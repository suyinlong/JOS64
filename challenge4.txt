List challenge problems completed as part of the lab 4 handin, as well
as the problem number.  If you worked any previous lab challenges and
submitted them with this lab, list them here, along with the lab number.

---------------------------------------------------------------------
Challenge 1 of Lab 4

Add glock
add console lock on cprintf()
need to do further work

---------------------------------------------------------------------
Challenge 2 of Lab 4

O(1) fixed-priority scheduler is added to JOS

DATA STRUCTURE

Two arrays (active, expired) of runqueues are added to JOS. These queues
are allocated in x64_vm_init(). Each array has 40 slots of queues.
Struct Env is also modified to add the priority and pri_link fields. The
priority field stores the fixed-priority of the environment. The pri_link
field is used in our runqueue to point to the next environment with same
priority. When initializing, those fields are set to 0 and NULL,
respectively.

CREATE AN ENVIRONMENT WITH PRIORITY

env_create() is modified with a new argument priority. The function now
sets the priority field of the environment structure then enqueue it into
the runqueue of expired array. The macro ENV_CREATE is also modified to
adapt to env_create(). The default priority (PRI_DEF) is 20.

FORK AN ENVIRONMENT WITH PRIORITY

By default, the child environment has the same priority of the parent
environment. At the end of sys_exofork() the new environment will enqueue
the runqueue of exipred array.

FREE AN ENVIRONMENT WITH PRIORITY

env_free() is modified to call function sched_free() to remove an
environment from the runqueue of expired array.

SCHEDULING WITH PRIORITY

The scheduler now scan the active array from the highest priority (=0) to
the lowest priority (=39). When the scheduler encounter an environment
with status ENV_RUNNABLE, it dequeue this environment and enqueue it into
the runqueue in expired array of the same priority then try to run it.
If the scheduler can not find any runnable environment in the active array,
it will swap the active array with expired array then try again. After the
second scan if it still fails, the scheduler will try to run current
environment (if possible) or call sched_halt().

TEST PROGRAM (user/printa.c printb.c printd.c)

To invoke the test program, type 'schedtest' in the monitor. The program
creates 3 environments (PRI_DEF = 20) then call scheduler:
    ENV_CREATE(user_printa, ENV_TYPE_USER, PRI_DEF);
    ENV_CREATE(user_printb, ENV_TYPE_USER, PRI_DEF - 10);
    ENV_CREATE(user_printd, ENV_TYPE_USER, PRI_DEF + 10);
The sequence should be 'BAD'.

---------------------------------------------------------------------
Challenge 3 of Lab 4

FPU Support:

* Modify the Trapframe structure in <inc/trap.h>, add 512 bytes FxRegs.

* Modify _alltraps in trapentry.S, use FXSAVE and FXRSTOR to save/restore
  x87 FPU, MMX Technology, and SSE State

* Modify env_pop_tf() in env.c, pop the trap frame correctly

Test program (user/fputest.c)

We wrote a user program to use FLDPI instruction to get PI from FPU. Since
JOS has poor support to floating-point numbers (none math functions provided,
any arguments or return values as float/double will cause error), we use
the conversion and arithmetic instructions of FPU to print out PI. The test
program is in 'user/fputest.c'. You can type command 'fputest' in the monitor
to invoke the program.

---------------------------------------------------------------------
Challenge 4 of Lab 4

Snapshot of child environment

DATA STRUCTURE

We define the struct EnvSnapshot in <inc/env.h>. This structure saves the Env
struct and stack page of the environment.

    struct EnvSnapshot {
        struct Env env;
        uint8_t stack[PGSIZE];
    };

The EnvSnapshot is over 4096 bytes, so we make our block malloc/free functions
of challenge 4 of lab 2 become system calls. See <inc/lib.h> <inc/syscall.h>
<kern/syscall.c> <lib/syscall.c> for more details.

SYSTEM CALLS

int sys_env_save(envid_t envid, struct EnvSnapshot *ess);

The sys_env_save() function use envid2env() and user_mem_check() to check the
validity of the environment id and the memory space of EnvSnapshot structure.
Then save the env structure and the content of stack page into 'ess'.

int sys_env_load(envid_t envid, struct EnvSnapshot *ess);

The sys_env_load() function use envid2env() and user_mem_check() to check the
validity of the environment id and the memory space of EnvSnapshot structure.
Then load the env structure and the content of stack page from 'ess'.

void *sys_b_malloc(size_t n);

This is the block malloc function in challege 4 of lab 2. We use it to malloc
the memory space to store struct EnvSnapShot.

void sys_b_free(void *va);

This is the block free function in challege 4 of lab 2. We use it to free
the memory space to store struct EnvSnapShot.

TEST PROGRAM (user/snapshottest.c)

We wrote a program to test the snapshot feature. To invoke the test program from
the monitor, type 'snapshottest' then press enter.
The program first read a number (0-9) from user input, then fork a child. The
parent process will run 10 loops, starting from 0. At the second loop it will
save the running state of the child process. And at the ninth loop it will load
the running state to the child process. The child process will run 25 loops
starting from the number given by user. You can see after the loading, the child
process just reverse back to previous state.

MISC

We only save the vital state of the environment. If we really want a full backup
of the environment, we may also need to save: the extra pages of the stack, the
global variables, the memory mappings (all page tables), and all the pages which
the environment is using. Then the time and space cost will be very expensive.

---------------------------------------------------------------------
Challenge 5 of Lab 4

User Exception Handler

We provide a new lib function to allow users to handle the exceptions by
themselves. The basic idea is same as user page fault handler.
In <lib/exception.c> we have the lib function:
    void set_exception_handler(int trapno, eHandler handler);
The assembly language exception entrypoints are defined in <lib/eentry.S>.

Test program (user/ehandlertest.c)

Type 'ehandlertest' in the monitor to invoke the test program. The program
registers three exception handlers on divide-by-zero, illegal opcode and
general protection fault.

---------------------------------------------------------------------
Challenge 6 of Lab 4

Shared-memory fork()

Implement sfork() in <lib/fork.c>. Now the child and the parent share all
their memory pages (map) except for pages in the stack area (COW).

---------------------------------------------------------------------
Challenge 7 of Lab 4

BENCHMARKING TEST PROGRAM (user/forktest.c)

We use RDTSC instruction to benchmark the performance of different approachs
of fork(). Type 'forktest' in the monitor to invoke the test program.
One test result is:
  [dumbfork: 9145800]    [fork: 7640176]    [sfork: 4278556]
Dumbfork takes a lot of ticks on switching between user mode and kernel mode.
Our fork() takes less time since its work is done in one switch. The shared-
memory fork() takes less time than fork() because it doesn't need to modify
the PTE_W / PTE_COW flags thus uses less calls.
Although the ticks do not show the actual clock cycles of running time, you
can get rough comparison result from the numbers.

---------------------------------------------------------------------
Challenge 8 of Lab 4

No loop ipc_send

The ipc_send() has to loop since the target environment may not be in the
mode of receiving. In order to send the message sucuessfully, the sender
use this loop to keep trying until the target receives the message (or some
fatal error occurs).

We have modifies the ipc lib calls and system calls so that the ipc_send()
does not need to loop. We were inspired by Liedtke's paper, 'Improving IPC
by Kernel Design', metioned in Challenge 11. In order to achieve that, we
need a queue to store the incoming send request per environment. Then the
sender only need to enqueue, sleep and wait for the receiver to wake it up.
Now we use sleep and wake-up instead of while-loop thus the ipc takes less
CPU time.

DATA STRUCTURE

To simplify, we use a fixed size arraylist in env structure as our 'queue'.
In real OS, it should be a real queue with large capacity. The 'queue'
stores all the id of envs that want to send a message to the target env.

FLOW

Note: When we say wake up here, it means set the (target) env state to
      ENV_RUNNABLE
      When we say sleep here, it means set the (current) env state to
      ENV_NOT_RUNNABLE and call sched_yield()

IPC_SEND (syscall)
Phase 1:
    1. Enqueue to the receiver's queue
    2. Check the receiver's state, if recving = 1, then wake up the receiver
    3. Set return value (rax) as 0, then sleep
Phase 2: [the receiver woke up the sender]
    1. Check the receiver's state, recving should be 2 (we set this as our
       two-phase ipc flag)
    2. Set the receiver's ipc value, id, va, etc.
    3. Wake up the receiver (again) and return.

IPC_RECV (syscall)
Phase 1:
    1. Set the recving flag to 1
    2. Check the queue. If there is some envs in the queue, try to dequeue
       one valid sender. If there is one, wake up the sender and set recving
       to 2.
    3. Set the return value (rax) as recving flag (we use this to check
       whether it has dequeued one env), then sleep
Phase 2: [the sender woke up the receiver]
    1. Nothing needs to be done, just return to ipc_recv at lib/ipc.c

As you can see here, IPC_SEND in syscall has two parts and we seperate them
with sleep (yield). This is because if we yield in kernel mode, it will fall
into user mode next time it is running, which is in ipc_send of lib/ipc.c.
So we divide the IPC_SEND as two system calls: sys_ipc_try_send and
sys_ipc_try_send_2. The phase 2 of IPC_RECV has nothing to do, so it doesn't
need two parts. But we really want the syscall dequeue one env properly so
we check this in ipc_recv of lib/ipc.c.

IPC_SEND (lib)
    1. Call phase 1 of IPC_SEND system call
    2. After waking up, check the return value (should be 0)
    3. Call phase 2 of IPC_SEND system call

IPC_RECV (lib)
    1. Call IPC_RECV system call
    2. After waking up, if it hasn't dequeued one env, then go to step 1
       try to dequeue one.
    3. Set env_store, pg, then return the value.

By doing this, we make sure the IPC calls are sleep & wake up procedure.
The scenario of multiple environments try to send to one env will not
cause conflicts since we check the recving flag at IPC_SEND (syscall)
step 2. When the receiver already has a excepted sender, other senders
won't wake it up since the flag becomes 2.
Another scenario is that when one or more senders are queued, the receiver
suddenly exits (intentionally or not). The old while-loop IPC will almost
immediately detect and return the error 'bad environment'. Meanwhile our
envs are sleeping. To fix that, we modify the env_destroy() in env.c to
wake up all the envs in the queue when the env is destroying.
We also modify the ipc_try_send's return value. Old function returns void
but we need to know if error occurs in the procedure rather than just
panic in the function.
We also add lock to the queue modfication operation to avoid race condition.

To test the new IPC functions, we provide a test program (user/ipctest.c).
Type 'ipctest' in kernel monitor to invoke it. The example program
forks 6 children and send a number to all of them, but only receives 3
return value. This example shows if our IPC functions can queue up sending
requests, wake up senders and handle teminated receiver correctly.

---------------------------------------------------------------------
Challenge 9 of Lab 4

Concurrent Matrix Multiplication

Calculate IN * A (user/matrix.c)
In the monitor, use command 'matrixtest' to invoke the test program.
We use our fork() to fork 12 child processes. Every node know its right and
bottom nodes. The parent node feeds three input nodes (1,0) (2,0) (3,0) the
value of matrix IN row by row. And nine center nodes accept the numbers passed
from their left and top. The final result is sent back to parent node.

 +---+    +---+    +---+    +---+    +---+
 | I | → |1,0| → |1,1| → |1,2| → |1,3|
 | N |    +---+    +---+    +---+    +---+
 | P |               ↓        ↓        ↓
 | U |    +---+    +---+    +---+    +---+
 | T | → |2,0| → |2,1| → |2,2| → |2,3|
 |   |    +---+    +---+    +---+    +---+
 | S |               ↓        ↓        ↓
 | T |    +---+    +---+    +---+    +---+
 | R | → |3,0| → |3,1| → |3,2| → |3,3|
 | E |    +---+    +---+    +---+    +---+
 | A |               ↓        ↓        ↓
 | M +-----------------------------------+
 | +           OUTPUT STREAM             |
 +---------------------------------------+

 NOTE:
   1.To simplify the program, we make matrix A as a constant matrix and every
   child can access it directly. It is almost the same as the parent node gets
   input from user then forks children and every child has matrix A. We just
   don't want to type the numbers every time the program runs.
   2.And the IN matrix is also a constant matrix (coz we are lazy...). But our
   child nodes only accept the numbers from IPC message.

COMMAND: (in kernel monitor)
  matrixtest

---------------------------------------------------------------------
Challenge 10 of Lab 4

Power series calculator

Calculate the power series of sin(x+x^3) (user/powerseries.c)

The program uses Doug McIlroy's methods to calculate the power series of
sin(x+x^3).

The forumla of multiply stream:
    P = F G
    P0 + xP' = F0G0 + x (F0G'+G0F') + x^2 F'G'
So solving P0 is easy (P0 = F0G0). The problem can be solved recursively.

The forumla of substitution stream:
  S = F (G)
  S0 + xS' = F0 + x G' F'(G)
  S0 = F0 + G0 * F'(G)[0]
Actually solving S0 is not easy. If G0 is not zero, then the S0 is the sum of
an infinite series.

Those streams fork lots of children thus are very expensive. It will overflow
the limitation of max environments of JOS very quick.
We also implement source-specified IPC to receive the value from desired
target. The code is in lib/sipc.c kern/syscall.c

COMMAND: (in kernel monitor)
  powerseriestest

---------------------------------------------------------------------
Challenge 11 of Lab 4

We use some techniques to help improve IPC performance.

1.  Reduce the system calls & Wakeups
    Entering and leaving kernel mode are expensive. Our implementation of
    two-phase sleep and wake-up ipc saves a lot of mode switches. The old
    design of ipc_send is a while loop that constantly enters and leaves
    system call if the sending is not done.

    After we changed the ipc functions, the switch numbers are:
    +==========+========+==============+
    | Function |    New    |    Old    |
    +==========+===========+===========+
    | ipc_send |     2     | 1, 2, ... |
    | ipc_recv |    1, 2   |     1     |
    +==========+===========+===========+

    Note: Our new ipc_recv may enter & leave several times. The scenarios
          are:
          One Time: When entering ipc_recv, the queue is not empty and we
                    dequeue one valid environment sucessfully.
                    * Usually happens when one process calls send first,
                    another calls recv later.
          Two Time: When entering ipc_recv, there is no env in the queue
                    or all the envs in queue are invalid (terminated maybe).
                    So we have to dequeue one properly.
                    * Usually happens when one process calls recv first,
                    then comes another process calls send.
          >2  Time: All the envs in receiver's queue are invalid but the
                    wake-up comes constantly.
                    * Very rare, happens when a bug or malicious program comes
                    into ipc_send of lib, crashes after first part of ipc_send

          In general, the switch number is still between 1 and 2.

2.  Pass short message via register
    Many IPC messages are very short. We can transfer the short messages via
    registers by carefully using them. We modify our source-specified IPC
    (which uses 64-bit as passing values rather than 32-bit of JOS' IPC) to
    use r15 register to pass the 8-byte message. The sender just modify the
    trapframe of the receiver at send phase two. Then the receiver reads the
    value from its r15 register. More bytes can be transferred if we carefully
    design the usage of registers.
