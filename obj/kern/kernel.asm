
obj/kern/kernel:     file format elf64-x86-64


Disassembly of section .bootstrap:

0000000000100000 <_head64>:
.text
.globl _head64
_head64:

# Save multiboot_info addr passed by bootloader
    movl $multiboot_info, %eax
  100000:	b8 00 70 10 00       	mov    $0x107000,%eax
    movl %ebx, (%eax)
  100005:	89 18                	mov    %ebx,(%rax)

	movw $0x1234,0x472			# warm boot
  100007:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472(%rip)        # 100482 <verify_cpu_no_longmode+0x36f>
  10000e:	34 12 
# Reset the stack pointer in case we didn't come from the loader
    movl $0x7c00,%esp
  100010:	bc 00 7c 00 00       	mov    $0x7c00,%esp

    call verify_cpu   #check if CPU supports long mode
  100015:	e8 cc 00 00 00       	callq  1000e6 <verify_cpu>
    movl $CR4_PAE,%eax
  10001a:	b8 20 00 00 00       	mov    $0x20,%eax
    movl %eax,%cr4
  10001f:	0f 22 e0             	mov    %rax,%cr4

# build an early boot pml4 at physical address pml4phys 

    #initializing the page tables
    movl $pml4,%edi
  100022:	bf 00 20 10 00       	mov    $0x102000,%edi
    xorl %eax,%eax
  100027:	31 c0                	xor    %eax,%eax
    movl $((4096/4)*5),%ecx  # moving these many words to the 6 pages with 4 second level pages + 1 3rd level + 1 4th level pages 
  100029:	b9 00 14 00 00       	mov    $0x1400,%ecx
    rep stosl
  10002e:	f3 ab                	rep stos %eax,%es:(%rdi)
    # creating a 4G boot page table
    # setting the 4th level page table only the second entry needed (PML4)
    movl $pml4,%eax
  100030:	b8 00 20 10 00       	mov    $0x102000,%eax
    movl $pdpt1, %ebx
  100035:	bb 00 30 10 00       	mov    $0x103000,%ebx
    orl $PTE_P,%ebx
  10003a:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10003d:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%eax)
  100040:	89 18                	mov    %ebx,(%rax)

    movl $pdpt2, %ebx
  100042:	bb 00 40 10 00       	mov    $0x104000,%ebx
    orl $PTE_P,%ebx
  100047:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10004a:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,0x8(%eax)
  10004d:	89 58 08             	mov    %ebx,0x8(%rax)

    # setting the 3rd level page table (PDPE)
    # 4 entries (counter in ecx), point to the next four physical pages (pgdirs)
    # pgdirs in 0xa0000--0xd000
    movl $pdpt1,%edi
  100050:	bf 00 30 10 00       	mov    $0x103000,%edi
    movl $pde1,%ebx
  100055:	bb 00 50 10 00       	mov    $0x105000,%ebx
    orl $PTE_P,%ebx
  10005a:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10005d:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%edi)
  100060:	89 1f                	mov    %ebx,(%rdi)

    movl $pdpt2,%edi
  100062:	bf 00 40 10 00       	mov    $0x104000,%edi
    movl $pde2,%ebx
  100067:	bb 00 60 10 00       	mov    $0x106000,%ebx
    orl $PTE_P,%ebx
  10006c:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10006f:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%edi)
  100072:	89 1f                	mov    %ebx,(%rdi)
    
    # setting the pgdir so that the LA=PA
    # mapping first 1G of mem at KERNBASE
    movl $128,%ecx
  100074:	b9 80 00 00 00       	mov    $0x80,%ecx
    # Start at the end and work backwards
    #leal (pml4 + 5*0x1000 - 0x8),%edi
    movl $pde1,%edi
  100079:	bf 00 50 10 00       	mov    $0x105000,%edi
    movl $pde2,%ebx
  10007e:	bb 00 60 10 00       	mov    $0x106000,%ebx
    #64th entry - 0x8004000000
    addl $256,%ebx 
  100083:	81 c3 00 01 00 00    	add    $0x100,%ebx
    # PTE_P|PTE_W|PTE_MBZ
    movl $0x00000183,%eax
  100089:	b8 83 01 00 00       	mov    $0x183,%eax
  1:
     movl %eax,(%edi)
  10008e:	89 07                	mov    %eax,(%rdi)
     movl %eax,(%ebx)
  100090:	89 03                	mov    %eax,(%rbx)
     addl $0x8,%edi
  100092:	83 c7 08             	add    $0x8,%edi
     addl $0x8,%ebx
  100095:	83 c3 08             	add    $0x8,%ebx
     addl $0x00200000,%eax
  100098:	05 00 00 20 00       	add    $0x200000,%eax
     subl $1,%ecx
  10009d:	83 e9 01             	sub    $0x1,%ecx
     cmp $0x0,%ecx
  1000a0:	83 f9 00             	cmp    $0x0,%ecx
     jne 1b
  1000a3:	75 e9                	jne    10008e <_head64+0x8e>
 /*    subl $1,%ecx */
 /*    cmp $0x0,%ecx */
 /*    jne 1b */

    # set the cr3 register
    movl $pml4,%eax
  1000a5:	b8 00 20 10 00       	mov    $0x102000,%eax
    movl %eax, %cr3
  1000aa:	0f 22 d8             	mov    %rax,%cr3

	
    # enable the long mode in MSR
    movl $EFER_MSR,%ecx
  1000ad:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
    rdmsr
  1000b2:	0f 32                	rdmsr  
    btsl $EFER_LME,%eax
  1000b4:	0f ba e8 08          	bts    $0x8,%eax
    wrmsr
  1000b8:	0f 30                	wrmsr  
    
    # enable paging 
    movl %cr0,%eax
  1000ba:	0f 20 c0             	mov    %cr0,%rax
    orl $CR0_PE,%eax
  1000bd:	83 c8 01             	or     $0x1,%eax
    orl $CR0_PG,%eax
  1000c0:	0d 00 00 00 80       	or     $0x80000000,%eax
    orl $CR0_AM,%eax
  1000c5:	0d 00 00 04 00       	or     $0x40000,%eax
    orl $CR0_WP,%eax
  1000ca:	0d 00 00 01 00       	or     $0x10000,%eax
    orl $CR0_MP,%eax
  1000cf:	83 c8 02             	or     $0x2,%eax
    movl %eax,%cr0
  1000d2:	0f 22 c0             	mov    %rax,%cr0
    #jump to long mode with CS=0 and

    movl $gdtdesc_64,%eax
  1000d5:	b8 18 10 10 00       	mov    $0x101018,%eax
    lgdt (%eax)
  1000da:	0f 01 10             	lgdt   (%rax)
    pushl $0x8
  1000dd:	6a 08                	pushq  $0x8
    movl $_start,%eax
  1000df:	b8 0c 00 20 00       	mov    $0x20000c,%eax
    pushl %eax
  1000e4:	50                   	push   %rax

00000000001000e5 <jumpto_longmode>:
    
    .globl jumpto_longmode
    .type jumpto_longmode,@function
jumpto_longmode:
    lret
  1000e5:	cb                   	lret   

00000000001000e6 <verify_cpu>:
/*     movabs $_back_from_head64, %rax */
/*     pushq %rax */
/*     lretq */

verify_cpu:
    pushfl                   # get eflags in eax -- standardard way to check for cpuid
  1000e6:	9c                   	pushfq 
    popl %eax
  1000e7:	58                   	pop    %rax
    movl %eax,%ecx
  1000e8:	89 c1                	mov    %eax,%ecx
    xorl $0x200000, %eax
  1000ea:	35 00 00 20 00       	xor    $0x200000,%eax
    pushl %eax
  1000ef:	50                   	push   %rax
    popfl
  1000f0:	9d                   	popfq  
    pushfl
  1000f1:	9c                   	pushfq 
    popl %eax
  1000f2:	58                   	pop    %rax
    cmpl %eax,%ebx
  1000f3:	39 c3                	cmp    %eax,%ebx
    jz verify_cpu_no_longmode   # no cpuid -- no long mode
  1000f5:	74 1c                	je     100113 <verify_cpu_no_longmode>

    movl $0x0,%eax              # see if cpuid 1 is implemented
  1000f7:	b8 00 00 00 00       	mov    $0x0,%eax
    cpuid
  1000fc:	0f a2                	cpuid  
    cmpl $0x1,%eax
  1000fe:	83 f8 01             	cmp    $0x1,%eax
    jb verify_cpu_no_longmode    # cpuid 1 is not implemented
  100101:	72 10                	jb     100113 <verify_cpu_no_longmode>


    mov $0x80000001, %eax
  100103:	b8 01 00 00 80       	mov    $0x80000001,%eax
    cpuid                 
  100108:	0f a2                	cpuid  
    test $(1 << 29),%edx                 #Test if the LM-bit, is set or not.
  10010a:	f7 c2 00 00 00 20    	test   $0x20000000,%edx
    jz verify_cpu_no_longmode
  100110:	74 01                	je     100113 <verify_cpu_no_longmode>

    ret
  100112:	c3                   	retq   

0000000000100113 <verify_cpu_no_longmode>:

verify_cpu_no_longmode:
    jmp verify_cpu_no_longmode
  100113:	eb fe                	jmp    100113 <verify_cpu_no_longmode>
  100115:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10011c:	00 00 00 
  10011f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100126:	00 00 00 
  100129:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100130:	00 00 00 
  100133:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10013a:	00 00 00 
  10013d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100144:	00 00 00 
  100147:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10014e:	00 00 00 
  100151:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100158:	00 00 00 
  10015b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100162:	00 00 00 
  100165:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10016c:	00 00 00 
  10016f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100176:	00 00 00 
  100179:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100180:	00 00 00 
  100183:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10018a:	00 00 00 
  10018d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100194:	00 00 00 
  100197:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10019e:	00 00 00 
  1001a1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001a8:	00 00 00 
  1001ab:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001b2:	00 00 00 
  1001b5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001bc:	00 00 00 
  1001bf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001c6:	00 00 00 
  1001c9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001d0:	00 00 00 
  1001d3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001da:	00 00 00 
  1001dd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001e4:	00 00 00 
  1001e7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001ee:	00 00 00 
  1001f1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001f8:	00 00 00 
  1001fb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100202:	00 00 00 
  100205:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10020c:	00 00 00 
  10020f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100216:	00 00 00 
  100219:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100220:	00 00 00 
  100223:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10022a:	00 00 00 
  10022d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100234:	00 00 00 
  100237:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10023e:	00 00 00 
  100241:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100248:	00 00 00 
  10024b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100252:	00 00 00 
  100255:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10025c:	00 00 00 
  10025f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100266:	00 00 00 
  100269:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100270:	00 00 00 
  100273:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10027a:	00 00 00 
  10027d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100284:	00 00 00 
  100287:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10028e:	00 00 00 
  100291:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100298:	00 00 00 
  10029b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002a2:	00 00 00 
  1002a5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002ac:	00 00 00 
  1002af:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002b6:	00 00 00 
  1002b9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002c0:	00 00 00 
  1002c3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002ca:	00 00 00 
  1002cd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002d4:	00 00 00 
  1002d7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002de:	00 00 00 
  1002e1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002e8:	00 00 00 
  1002eb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002f2:	00 00 00 
  1002f5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002fc:	00 00 00 
  1002ff:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100306:	00 00 00 
  100309:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100310:	00 00 00 
  100313:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10031a:	00 00 00 
  10031d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100324:	00 00 00 
  100327:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10032e:	00 00 00 
  100331:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100338:	00 00 00 
  10033b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100342:	00 00 00 
  100345:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10034c:	00 00 00 
  10034f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100356:	00 00 00 
  100359:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100360:	00 00 00 
  100363:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10036a:	00 00 00 
  10036d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100374:	00 00 00 
  100377:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10037e:	00 00 00 
  100381:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100388:	00 00 00 
  10038b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100392:	00 00 00 
  100395:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10039c:	00 00 00 
  10039f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003a6:	00 00 00 
  1003a9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003b0:	00 00 00 
  1003b3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003ba:	00 00 00 
  1003bd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003c4:	00 00 00 
  1003c7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003ce:	00 00 00 
  1003d1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003d8:	00 00 00 
  1003db:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003e2:	00 00 00 
  1003e5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003ec:	00 00 00 
  1003ef:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003f6:	00 00 00 
  1003f9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100400:	00 00 00 
  100403:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10040a:	00 00 00 
  10040d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100414:	00 00 00 
  100417:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10041e:	00 00 00 
  100421:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100428:	00 00 00 
  10042b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100432:	00 00 00 
  100435:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10043c:	00 00 00 
  10043f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100446:	00 00 00 
  100449:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100450:	00 00 00 
  100453:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10045a:	00 00 00 
  10045d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100464:	00 00 00 
  100467:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10046e:	00 00 00 
  100471:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100478:	00 00 00 
  10047b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100482:	00 00 00 
  100485:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10048c:	00 00 00 
  10048f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100496:	00 00 00 
  100499:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004a0:	00 00 00 
  1004a3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004aa:	00 00 00 
  1004ad:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004b4:	00 00 00 
  1004b7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004be:	00 00 00 
  1004c1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004c8:	00 00 00 
  1004cb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004d2:	00 00 00 
  1004d5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004dc:	00 00 00 
  1004df:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004e6:	00 00 00 
  1004e9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004f0:	00 00 00 
  1004f3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004fa:	00 00 00 
  1004fd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100504:	00 00 00 
  100507:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10050e:	00 00 00 
  100511:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100518:	00 00 00 
  10051b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100522:	00 00 00 
  100525:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10052c:	00 00 00 
  10052f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100536:	00 00 00 
  100539:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100540:	00 00 00 
  100543:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10054a:	00 00 00 
  10054d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100554:	00 00 00 
  100557:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10055e:	00 00 00 
  100561:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100568:	00 00 00 
  10056b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100572:	00 00 00 
  100575:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10057c:	00 00 00 
  10057f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100586:	00 00 00 
  100589:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100590:	00 00 00 
  100593:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10059a:	00 00 00 
  10059d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005a4:	00 00 00 
  1005a7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005ae:	00 00 00 
  1005b1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005b8:	00 00 00 
  1005bb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005c2:	00 00 00 
  1005c5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005cc:	00 00 00 
  1005cf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005d6:	00 00 00 
  1005d9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005e0:	00 00 00 
  1005e3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005ea:	00 00 00 
  1005ed:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005f4:	00 00 00 
  1005f7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005fe:	00 00 00 
  100601:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100608:	00 00 00 
  10060b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100612:	00 00 00 
  100615:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10061c:	00 00 00 
  10061f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100626:	00 00 00 
  100629:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100630:	00 00 00 
  100633:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10063a:	00 00 00 
  10063d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100644:	00 00 00 
  100647:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10064e:	00 00 00 
  100651:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100658:	00 00 00 
  10065b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100662:	00 00 00 
  100665:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10066c:	00 00 00 
  10066f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100676:	00 00 00 
  100679:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100680:	00 00 00 
  100683:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10068a:	00 00 00 
  10068d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100694:	00 00 00 
  100697:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10069e:	00 00 00 
  1006a1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006a8:	00 00 00 
  1006ab:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006b2:	00 00 00 
  1006b5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006bc:	00 00 00 
  1006bf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006c6:	00 00 00 
  1006c9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006d0:	00 00 00 
  1006d3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006da:	00 00 00 
  1006dd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006e4:	00 00 00 
  1006e7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006ee:	00 00 00 
  1006f1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006f8:	00 00 00 
  1006fb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100702:	00 00 00 
  100705:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10070c:	00 00 00 
  10070f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100716:	00 00 00 
  100719:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100720:	00 00 00 
  100723:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10072a:	00 00 00 
  10072d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100734:	00 00 00 
  100737:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10073e:	00 00 00 
  100741:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100748:	00 00 00 
  10074b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100752:	00 00 00 
  100755:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10075c:	00 00 00 
  10075f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100766:	00 00 00 
  100769:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100770:	00 00 00 
  100773:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10077a:	00 00 00 
  10077d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100784:	00 00 00 
  100787:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10078e:	00 00 00 
  100791:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100798:	00 00 00 
  10079b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007a2:	00 00 00 
  1007a5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007ac:	00 00 00 
  1007af:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007b6:	00 00 00 
  1007b9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007c0:	00 00 00 
  1007c3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007ca:	00 00 00 
  1007cd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007d4:	00 00 00 
  1007d7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007de:	00 00 00 
  1007e1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007e8:	00 00 00 
  1007eb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007f2:	00 00 00 
  1007f5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007fc:	00 00 00 
  1007ff:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100806:	00 00 00 
  100809:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100810:	00 00 00 
  100813:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10081a:	00 00 00 
  10081d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100824:	00 00 00 
  100827:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10082e:	00 00 00 
  100831:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100838:	00 00 00 
  10083b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100842:	00 00 00 
  100845:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10084c:	00 00 00 
  10084f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100856:	00 00 00 
  100859:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100860:	00 00 00 
  100863:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10086a:	00 00 00 
  10086d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100874:	00 00 00 
  100877:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10087e:	00 00 00 
  100881:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100888:	00 00 00 
  10088b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100892:	00 00 00 
  100895:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10089c:	00 00 00 
  10089f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008a6:	00 00 00 
  1008a9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008b0:	00 00 00 
  1008b3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008ba:	00 00 00 
  1008bd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008c4:	00 00 00 
  1008c7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008ce:	00 00 00 
  1008d1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008d8:	00 00 00 
  1008db:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008e2:	00 00 00 
  1008e5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008ec:	00 00 00 
  1008ef:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008f6:	00 00 00 
  1008f9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100900:	00 00 00 
  100903:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10090a:	00 00 00 
  10090d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100914:	00 00 00 
  100917:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10091e:	00 00 00 
  100921:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100928:	00 00 00 
  10092b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100932:	00 00 00 
  100935:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10093c:	00 00 00 
  10093f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100946:	00 00 00 
  100949:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100950:	00 00 00 
  100953:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10095a:	00 00 00 
  10095d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100964:	00 00 00 
  100967:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10096e:	00 00 00 
  100971:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100978:	00 00 00 
  10097b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100982:	00 00 00 
  100985:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10098c:	00 00 00 
  10098f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100996:	00 00 00 
  100999:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009a0:	00 00 00 
  1009a3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009aa:	00 00 00 
  1009ad:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009b4:	00 00 00 
  1009b7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009be:	00 00 00 
  1009c1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009c8:	00 00 00 
  1009cb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009d2:	00 00 00 
  1009d5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009dc:	00 00 00 
  1009df:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009e6:	00 00 00 
  1009e9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009f0:	00 00 00 
  1009f3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009fa:	00 00 00 
  1009fd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a04:	00 00 00 
  100a07:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a0e:	00 00 00 
  100a11:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a18:	00 00 00 
  100a1b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a22:	00 00 00 
  100a25:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a2c:	00 00 00 
  100a2f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a36:	00 00 00 
  100a39:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a40:	00 00 00 
  100a43:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a4a:	00 00 00 
  100a4d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a54:	00 00 00 
  100a57:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a5e:	00 00 00 
  100a61:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a68:	00 00 00 
  100a6b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a72:	00 00 00 
  100a75:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a7c:	00 00 00 
  100a7f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a86:	00 00 00 
  100a89:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a90:	00 00 00 
  100a93:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a9a:	00 00 00 
  100a9d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aa4:	00 00 00 
  100aa7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aae:	00 00 00 
  100ab1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ab8:	00 00 00 
  100abb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ac2:	00 00 00 
  100ac5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100acc:	00 00 00 
  100acf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ad6:	00 00 00 
  100ad9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ae0:	00 00 00 
  100ae3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aea:	00 00 00 
  100aed:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100af4:	00 00 00 
  100af7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100afe:	00 00 00 
  100b01:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b08:	00 00 00 
  100b0b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b12:	00 00 00 
  100b15:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b1c:	00 00 00 
  100b1f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b26:	00 00 00 
  100b29:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b30:	00 00 00 
  100b33:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b3a:	00 00 00 
  100b3d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b44:	00 00 00 
  100b47:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b4e:	00 00 00 
  100b51:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b58:	00 00 00 
  100b5b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b62:	00 00 00 
  100b65:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b6c:	00 00 00 
  100b6f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b76:	00 00 00 
  100b79:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b80:	00 00 00 
  100b83:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b8a:	00 00 00 
  100b8d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b94:	00 00 00 
  100b97:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b9e:	00 00 00 
  100ba1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ba8:	00 00 00 
  100bab:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bb2:	00 00 00 
  100bb5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bbc:	00 00 00 
  100bbf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bc6:	00 00 00 
  100bc9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bd0:	00 00 00 
  100bd3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bda:	00 00 00 
  100bdd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100be4:	00 00 00 
  100be7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bee:	00 00 00 
  100bf1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bf8:	00 00 00 
  100bfb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c02:	00 00 00 
  100c05:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c0c:	00 00 00 
  100c0f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c16:	00 00 00 
  100c19:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c20:	00 00 00 
  100c23:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c2a:	00 00 00 
  100c2d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c34:	00 00 00 
  100c37:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c3e:	00 00 00 
  100c41:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c48:	00 00 00 
  100c4b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c52:	00 00 00 
  100c55:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c5c:	00 00 00 
  100c5f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c66:	00 00 00 
  100c69:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c70:	00 00 00 
  100c73:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c7a:	00 00 00 
  100c7d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c84:	00 00 00 
  100c87:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c8e:	00 00 00 
  100c91:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c98:	00 00 00 
  100c9b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ca2:	00 00 00 
  100ca5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cac:	00 00 00 
  100caf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cb6:	00 00 00 
  100cb9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cc0:	00 00 00 
  100cc3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cca:	00 00 00 
  100ccd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cd4:	00 00 00 
  100cd7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cde:	00 00 00 
  100ce1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ce8:	00 00 00 
  100ceb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cf2:	00 00 00 
  100cf5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cfc:	00 00 00 
  100cff:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d06:	00 00 00 
  100d09:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d10:	00 00 00 
  100d13:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d1a:	00 00 00 
  100d1d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d24:	00 00 00 
  100d27:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d2e:	00 00 00 
  100d31:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d38:	00 00 00 
  100d3b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d42:	00 00 00 
  100d45:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d4c:	00 00 00 
  100d4f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d56:	00 00 00 
  100d59:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d60:	00 00 00 
  100d63:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d6a:	00 00 00 
  100d6d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d74:	00 00 00 
  100d77:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d7e:	00 00 00 
  100d81:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d88:	00 00 00 
  100d8b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d92:	00 00 00 
  100d95:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d9c:	00 00 00 
  100d9f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100da6:	00 00 00 
  100da9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100db0:	00 00 00 
  100db3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dba:	00 00 00 
  100dbd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dc4:	00 00 00 
  100dc7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dce:	00 00 00 
  100dd1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dd8:	00 00 00 
  100ddb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100de2:	00 00 00 
  100de5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dec:	00 00 00 
  100def:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100df6:	00 00 00 
  100df9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e00:	00 00 00 
  100e03:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e0a:	00 00 00 
  100e0d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e14:	00 00 00 
  100e17:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e1e:	00 00 00 
  100e21:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e28:	00 00 00 
  100e2b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e32:	00 00 00 
  100e35:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e3c:	00 00 00 
  100e3f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e46:	00 00 00 
  100e49:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e50:	00 00 00 
  100e53:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e5a:	00 00 00 
  100e5d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e64:	00 00 00 
  100e67:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e6e:	00 00 00 
  100e71:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e78:	00 00 00 
  100e7b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e82:	00 00 00 
  100e85:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e8c:	00 00 00 
  100e8f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e96:	00 00 00 
  100e99:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ea0:	00 00 00 
  100ea3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100eaa:	00 00 00 
  100ead:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100eb4:	00 00 00 
  100eb7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ebe:	00 00 00 
  100ec1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ec8:	00 00 00 
  100ecb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ed2:	00 00 00 
  100ed5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100edc:	00 00 00 
  100edf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ee6:	00 00 00 
  100ee9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ef0:	00 00 00 
  100ef3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100efa:	00 00 00 
  100efd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f04:	00 00 00 
  100f07:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f0e:	00 00 00 
  100f11:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f18:	00 00 00 
  100f1b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f22:	00 00 00 
  100f25:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f2c:	00 00 00 
  100f2f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f36:	00 00 00 
  100f39:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f40:	00 00 00 
  100f43:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f4a:	00 00 00 
  100f4d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f54:	00 00 00 
  100f57:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f5e:	00 00 00 
  100f61:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f68:	00 00 00 
  100f6b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f72:	00 00 00 
  100f75:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f7c:	00 00 00 
  100f7f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f86:	00 00 00 
  100f89:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f90:	00 00 00 
  100f93:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f9a:	00 00 00 
  100f9d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fa4:	00 00 00 
  100fa7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fae:	00 00 00 
  100fb1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fb8:	00 00 00 
  100fbb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fc2:	00 00 00 
  100fc5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fcc:	00 00 00 
  100fcf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fd6:	00 00 00 
  100fd9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fe0:	00 00 00 
  100fe3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fea:	00 00 00 
  100fed:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ff4:	00 00 00 
  100ff7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  100ffe:	00 00 

0000000000101000 <gdt_64>:
	...
  101008:	ff                   	(bad)  
  101009:	ff 00                	incl   (%rax)
  10100b:	00 00                	add    %al,(%rax)
  10100d:	9a                   	(bad)  
  10100e:	af                   	scas   %es:(%rdi),%eax
  10100f:	00 ff                	add    %bh,%bh
  101011:	ff 00                	incl   (%rax)
  101013:	00 00                	add    %al,(%rax)
  101015:	92                   	xchg   %eax,%edx
  101016:	cf                   	iret   
	...

0000000000101018 <gdtdesc_64>:
  101018:	17                   	(bad)  
  101019:	00 00                	add    %al,(%rax)
  10101b:	10 10                	adc    %dl,(%rax)
	...

0000000000102000 <pml4phys>:
	...

0000000000103000 <pdpt1>:
	...

0000000000104000 <pdpt2>:
	...

0000000000105000 <pde1>:
	...

0000000000106000 <pde2>:
	...

0000000000107000 <multiboot_info>:
  107000:	00 00                	add    %al,(%rax)
	...

Disassembly of section .text:

0000008004200000 <_start+0x8003fffff4>:
  8004200000:	02 b0 ad 1b 00 00    	add    0x1bad(%rax),%dh
  8004200006:	00 00                	add    %al,(%rax)
  8004200008:	fe 4f 52             	decb   0x52(%rdi)
  800420000b:	e4 48                	in     $0x48,%al

000000800420000c <entry>:
entry:

/* .globl _back_from_head64 */
/* _back_from_head64: */

    movabs   $gdtdesc_64,%rax
  800420000c:	48 b8 38 b0 22 04 80 	movabs $0x800422b038,%rax
  8004200013:	00 00 00 
    lgdt     (%rax)
  8004200016:	0f 01 10             	lgdt   (%rax)
    movw    $DATA_SEL,%ax
  8004200019:	66 b8 10 00          	mov    $0x10,%ax
    movw    %ax,%ds
  800420001d:	8e d8                	mov    %eax,%ds
    movw    %ax,%ss
  800420001f:	8e d0                	mov    %eax,%ss
    movw    %ax,%fs
  8004200021:	8e e0                	mov    %eax,%fs
    movw    %ax,%gs
  8004200023:	8e e8                	mov    %eax,%gs
    movw    %ax,%es
  8004200025:	8e c0                	mov    %eax,%es
    pushq   $CODE_SEL
  8004200027:	6a 08                	pushq  $0x8
    movabs  $relocated,%rax
  8004200029:	48 b8 36 00 20 04 80 	movabs $0x8004200036,%rax
  8004200030:	00 00 00 
    pushq   %rax
  8004200033:	50                   	push   %rax
    lretq
  8004200034:	48 cb                	lretq  

0000008004200036 <relocated>:
relocated:

	# Clear the frame pointer register (RBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movq	$0x0,%rbp			# nuke frame pointer
  8004200036:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp

	# Set the stack pointer
	movabs	$(bootstacktop),%rax
  800420003d:	48 b8 00 b0 22 04 80 	movabs $0x800422b000,%rax
  8004200044:	00 00 00 
	movq  %rax,%rsp
  8004200047:	48 89 c4             	mov    %rax,%rsp

	# now to C code
    movabs $i386_init, %rax
  800420004a:	48 b8 99 00 20 04 80 	movabs $0x8004200099,%rax
  8004200051:	00 00 00 
	call *%rax
  8004200054:	ff d0                	callq  *%rax

0000008004200056 <spin>:

	# Should never get here, but in case we do, just spin.
spin:	jmp	spin
  8004200056:	eb fe                	jmp    8004200056 <spin>

0000008004200058 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  8004200058:	55                   	push   %rbp
  8004200059:	48 89 e5             	mov    %rsp,%rbp
  800420005c:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004200060:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004200064:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  8004200067:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420006b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420006e:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004200072:	f0 87 02             	lock xchg %eax,(%rdx)
  8004200075:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  8004200078:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420007b:	c9                   	leaveq 
  800420007c:	c3                   	retq   

000000800420007d <lock_kernel>:

extern struct spinlock kernel_lock;

static inline void
lock_kernel(void)
{
  800420007d:	55                   	push   %rbp
  800420007e:	48 89 e5             	mov    %rsp,%rbp
	spin_lock(&kernel_lock);
  8004200081:	48 bf 80 b7 22 04 80 	movabs $0x800422b780,%rdi
  8004200088:	00 00 00 
  800420008b:	48 b8 18 5b 21 04 80 	movabs $0x8004215b18,%rax
  8004200092:	00 00 00 
  8004200095:	ff d0                	callq  *%rax
}
  8004200097:	5d                   	pop    %rbp
  8004200098:	c3                   	retq   

0000008004200099 <i386_init>:
static void boot_aps(void);


void
i386_init(void)
{
  8004200099:	55                   	push   %rbp
  800420009a:	48 89 e5             	mov    %rsp,%rbp
	extern char edata[], end[];

	// Before doing anything else, complete the ELF loading process.
	// Clear the uninitialized global data (BSS) section of our program.
	// This ensures that all static/global variables start out zero.
	memset(edata, 0, end - edata);
  800420009d:	48 ba 10 90 51 04 80 	movabs $0x8004519010,%rdx
  80042000a4:	00 00 00 
  80042000a7:	48 b8 b6 44 49 04 80 	movabs $0x80044944b6,%rax
  80042000ae:	00 00 00 
  80042000b1:	48 29 c2             	sub    %rax,%rdx
  80042000b4:	48 89 d0             	mov    %rdx,%rax
  80042000b7:	48 89 c2             	mov    %rax,%rdx
  80042000ba:	be 00 00 00 00       	mov    $0x0,%esi
  80042000bf:	48 bf b6 44 49 04 80 	movabs $0x80044944b6,%rdi
  80042000c6:	00 00 00 
  80042000c9:	48 b8 db e8 20 04 80 	movabs $0x800420e8db,%rax
  80042000d0:	00 00 00 
  80042000d3:	ff d0                	callq  *%rax

	// Initialize the console.
	// Can't call cprintf until after we do this!
	cons_init();
  80042000d5:	48 b8 a6 11 20 04 80 	movabs $0x80042011a6,%rax
  80042000dc:	00 00 00 
  80042000df:	ff d0                	callq  *%rax

	cprintf("6828 decimal is %o octal!\n", 6828);
  80042000e1:	be ac 1a 00 00       	mov    $0x1aac,%esi
  80042000e6:	48 bf 40 5e 21 04 80 	movabs $0x8004215e40,%rdi
  80042000ed:	00 00 00 
  80042000f0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042000f5:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  80042000fc:	00 00 00 
  80042000ff:	ff d2                	callq  *%rdx

	extern char end[];
	end_debug = read_section_headers((0x10000+KERNBASE), (uintptr_t)end); 
  8004200101:	48 b8 10 90 51 04 80 	movabs $0x8004519010,%rax
  8004200108:	00 00 00 
  800420010b:	48 89 c6             	mov    %rax,%rsi
  800420010e:	48 bf 00 00 01 04 80 	movabs $0x8004010000,%rdi
  8004200115:	00 00 00 
  8004200118:	48 b8 cb 42 21 04 80 	movabs $0x80042142cb,%rax
  800420011f:	00 00 00 
  8004200122:	ff d0                	callq  *%rax
  8004200124:	48 ba 88 67 49 04 80 	movabs $0x8004496788,%rdx
  800420012b:	00 00 00 
  800420012e:	48 89 02             	mov    %rax,(%rdx)

	// Lab 2 memory management initialization functions
	x64_vm_init();
  8004200131:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200136:	48 ba ff 23 20 04 80 	movabs $0x80042023ff,%rdx
  800420013d:	00 00 00 
  8004200140:	ff d2                	callq  *%rdx

	// Lab 3 user environment initialization functions
	env_init();
  8004200142:	48 b8 f0 74 20 04 80 	movabs $0x80042074f0,%rax
  8004200149:	00 00 00 
  800420014c:	ff d0                	callq  *%rax
	trap_init();
  800420014e:	48 b8 f2 8b 20 04 80 	movabs $0x8004208bf2,%rax
  8004200155:	00 00 00 
  8004200158:	ff d0                	callq  *%rax

	// Lab 4 multiprocessor initialization functions
	mp_init();
  800420015a:	48 b8 55 52 21 04 80 	movabs $0x8004215255,%rax
  8004200161:	00 00 00 
  8004200164:	ff d0                	callq  *%rax
	lapic_init();
  8004200166:	48 b8 96 55 21 04 80 	movabs $0x8004215596,%rax
  800420016d:	00 00 00 
  8004200170:	ff d0                	callq  *%rax

	// Lab 4 multitasking initialization functions
	pic_init();
  8004200172:	48 b8 aa 87 20 04 80 	movabs $0x80042087aa,%rax
  8004200179:	00 00 00 
  800420017c:	ff d0                	callq  *%rax

	// Acquire the big kernel lock before waking up APs
	// Your code here:
	lock_kernel();
  800420017e:	48 b8 7d 00 20 04 80 	movabs $0x800420007d,%rax
  8004200185:	00 00 00 
  8004200188:	ff d0                	callq  *%rax

	// Starting non-boot CPUs
	boot_aps();
  800420018a:	48 b8 e4 01 20 04 80 	movabs $0x80042001e4,%rax
  8004200191:	00 00 00 
  8004200194:	ff d0                	callq  *%rax

	// Start fs.
	ENV_CREATE(fs_fs, ENV_TYPE_FS);
  8004200196:	be 01 00 00 00       	mov    $0x1,%esi
  800420019b:	48 bf ef fb 3c 04 80 	movabs $0x80043cfbef,%rdi
  80042001a2:	00 00 00 
  80042001a5:	48 b8 b3 7d 20 04 80 	movabs $0x8004207db3,%rax
  80042001ac:	00 00 00 
  80042001af:	ff d0                	callq  *%rax

#if defined(TEST)
	// Don't touch -- used by grading script!
	ENV_CREATE(TEST, ENV_TYPE_USER);
  80042001b1:	be 00 00 00 00       	mov    $0x0,%esi
  80042001b6:	48 bf 48 83 45 04 80 	movabs $0x8004458348,%rdi
  80042001bd:	00 00 00 
  80042001c0:	48 b8 b3 7d 20 04 80 	movabs $0x8004207db3,%rax
  80042001c7:	00 00 00 
  80042001ca:	ff d0                	callq  *%rax
	//ENV_CREATE(user_testkbd, ENV_TYPE_USER);
	ENV_CREATE(user_icode, ENV_TYPE_USER);
#endif // TEST*

	// Should not be necessary - drains keyboard because interrupt has given up.
	kbd_intr();
  80042001cc:	48 b8 d8 0f 20 04 80 	movabs $0x8004200fd8,%rax
  80042001d3:	00 00 00 
  80042001d6:	ff d0                	callq  *%rax

	// Schedule and run the first user environment!
	sched_yield();
  80042001d8:	48 b8 fe ba 20 04 80 	movabs $0x800420bafe,%rax
  80042001df:	00 00 00 
  80042001e2:	ff d0                	callq  *%rax

00000080042001e4 <boot_aps>:
void *mpentry_kstack;

// Start the non-boot (AP) processors.
static void
boot_aps(void)
{
  80042001e4:	55                   	push   %rbp
  80042001e5:	48 89 e5             	mov    %rsp,%rbp
  80042001e8:	48 83 ec 30          	sub    $0x30,%rsp
	extern unsigned char mpentry_start[], mpentry_end[];
	void *code;
	struct CpuInfo *c;

	// Write entry code to unused memory at MPENTRY_PADDR
	code = KADDR(MPENTRY_PADDR);
  80042001ec:	48 c7 45 f0 00 70 00 	movq   $0x7000,-0x10(%rbp)
  80042001f3:	00 
  80042001f4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042001f8:	48 c1 e8 0c          	shr    $0xc,%rax
  80042001fc:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80042001ff:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004200202:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  8004200209:	00 00 00 
  800420020c:	48 8b 00             	mov    (%rax),%rax
  800420020f:	48 39 c2             	cmp    %rax,%rdx
  8004200212:	72 32                	jb     8004200246 <boot_aps+0x62>
  8004200214:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004200218:	48 89 c1             	mov    %rax,%rcx
  800420021b:	48 ba 60 5e 21 04 80 	movabs $0x8004215e60,%rdx
  8004200222:	00 00 00 
  8004200225:	be 8d 00 00 00       	mov    $0x8d,%esi
  800420022a:	48 bf 83 5e 21 04 80 	movabs $0x8004215e83,%rdi
  8004200231:	00 00 00 
  8004200234:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200239:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004200240:	00 00 00 
  8004200243:	41 ff d0             	callq  *%r8
  8004200246:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420024d:	00 00 00 
  8004200250:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004200254:	48 01 d0             	add    %rdx,%rax
  8004200257:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	memmove(code, mpentry_start, mpentry_end - mpentry_start);
  800420025b:	48 ba 7e 4d 21 04 80 	movabs $0x8004214d7e,%rdx
  8004200262:	00 00 00 
  8004200265:	48 b8 98 4c 21 04 80 	movabs $0x8004214c98,%rax
  800420026c:	00 00 00 
  800420026f:	48 29 c2             	sub    %rax,%rdx
  8004200272:	48 89 d0             	mov    %rdx,%rax
  8004200275:	48 89 c2             	mov    %rax,%rdx
  8004200278:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420027c:	48 be 98 4c 21 04 80 	movabs $0x8004214c98,%rsi
  8004200283:	00 00 00 
  8004200286:	48 89 c7             	mov    %rax,%rdi
  8004200289:	48 b8 66 e9 20 04 80 	movabs $0x800420e966,%rax
  8004200290:	00 00 00 
  8004200293:	ff d0                	callq  *%rax
	// Boot each AP one at a time
	for (c = cpus; c < cpus + ncpu; c++) {
  8004200295:	48 b8 20 80 49 04 80 	movabs $0x8004498020,%rax
  800420029c:	00 00 00 
  800420029f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042002a3:	e9 0b 01 00 00       	jmpq   80042003b3 <boot_aps+0x1cf>
		if (c == cpus + cpunum())  // We've started already.
  80042002a8:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  80042002af:	00 00 00 
  80042002b2:	ff d0                	callq  *%rax
  80042002b4:	48 98                	cltq   
  80042002b6:	48 c1 e0 03          	shl    $0x3,%rax
  80042002ba:	48 89 c2             	mov    %rax,%rdx
  80042002bd:	48 c1 e2 04          	shl    $0x4,%rdx
  80042002c1:	48 29 c2             	sub    %rax,%rdx
  80042002c4:	48 b8 20 80 49 04 80 	movabs $0x8004498020,%rax
  80042002cb:	00 00 00 
  80042002ce:	48 01 d0             	add    %rdx,%rax
  80042002d1:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042002d5:	75 05                	jne    80042002dc <boot_aps+0xf8>
			continue;
  80042002d7:	e9 d2 00 00 00       	jmpq   80042003ae <boot_aps+0x1ca>

		// Tell mpentry.S what stack to use 
		mpentry_kstack = percpu_kstacks[c - cpus] + KSTKSIZE;
  80042002dc:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042002e0:	48 b8 20 80 49 04 80 	movabs $0x8004498020,%rax
  80042002e7:	00 00 00 
  80042002ea:	48 29 c2             	sub    %rax,%rdx
  80042002ed:	48 89 d0             	mov    %rdx,%rax
  80042002f0:	48 c1 f8 03          	sar    $0x3,%rax
  80042002f4:	48 89 c2             	mov    %rax,%rdx
  80042002f7:	48 b8 ef ee ee ee ee 	movabs $0xeeeeeeeeeeeeeeef,%rax
  80042002fe:	ee ee ee 
  8004200301:	48 0f af c2          	imul   %rdx,%rax
  8004200305:	48 83 c0 01          	add    $0x1,%rax
  8004200309:	48 c1 e0 10          	shl    $0x10,%rax
  800420030d:	48 89 c2             	mov    %rax,%rdx
  8004200310:	48 b8 00 90 49 04 80 	movabs $0x8004499000,%rax
  8004200317:	00 00 00 
  800420031a:	48 01 c2             	add    %rax,%rdx
  800420031d:	48 b8 98 67 49 04 80 	movabs $0x8004496798,%rax
  8004200324:	00 00 00 
  8004200327:	48 89 10             	mov    %rdx,(%rax)
		// Start the CPU at mpentry_start
		lapic_startap(c->cpu_id, PADDR(code));
  800420032a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420032e:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004200332:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004200339:	00 00 00 
  800420033c:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  8004200340:	77 32                	ja     8004200374 <boot_aps+0x190>
  8004200342:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004200346:	48 89 c1             	mov    %rax,%rcx
  8004200349:	48 ba 90 5e 21 04 80 	movabs $0x8004215e90,%rdx
  8004200350:	00 00 00 
  8004200353:	be 97 00 00 00       	mov    $0x97,%esi
  8004200358:	48 bf 83 5e 21 04 80 	movabs $0x8004215e83,%rdi
  800420035f:	00 00 00 
  8004200362:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200367:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420036e:	00 00 00 
  8004200371:	41 ff d0             	callq  *%r8
  8004200374:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420037b:	ff ff ff 
  800420037e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004200382:	48 01 d0             	add    %rdx,%rax
  8004200385:	89 c2                	mov    %eax,%edx
  8004200387:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420038b:	0f b6 00             	movzbl (%rax),%eax
  800420038e:	0f b6 c0             	movzbl %al,%eax
  8004200391:	89 d6                	mov    %edx,%esi
  8004200393:	89 c7                	mov    %eax,%edi
  8004200395:	48 b8 fd 57 21 04 80 	movabs $0x80042157fd,%rax
  800420039c:	00 00 00 
  800420039f:	ff d0                	callq  *%rax
		// Wait for the CPU to finish some basic setup in mp_main()
		while (c->cpu_status != CPU_STARTED)
  80042003a1:	90                   	nop
  80042003a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042003a6:	8b 40 04             	mov    0x4(%rax),%eax
  80042003a9:	83 f8 01             	cmp    $0x1,%eax
  80042003ac:	75 f4                	jne    80042003a2 <boot_aps+0x1be>

	// Write entry code to unused memory at MPENTRY_PADDR
	code = KADDR(MPENTRY_PADDR);
	memmove(code, mpentry_start, mpentry_end - mpentry_start);
	// Boot each AP one at a time
	for (c = cpus; c < cpus + ncpu; c++) {
  80042003ae:	48 83 45 f8 78       	addq   $0x78,-0x8(%rbp)
  80042003b3:	48 b8 e8 83 49 04 80 	movabs $0x80044983e8,%rax
  80042003ba:	00 00 00 
  80042003bd:	8b 00                	mov    (%rax),%eax
  80042003bf:	48 98                	cltq   
  80042003c1:	48 c1 e0 03          	shl    $0x3,%rax
  80042003c5:	48 89 c2             	mov    %rax,%rdx
  80042003c8:	48 c1 e2 04          	shl    $0x4,%rdx
  80042003cc:	48 29 c2             	sub    %rax,%rdx
  80042003cf:	48 b8 20 80 49 04 80 	movabs $0x8004498020,%rax
  80042003d6:	00 00 00 
  80042003d9:	48 01 d0             	add    %rdx,%rax
  80042003dc:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042003e0:	0f 87 c2 fe ff ff    	ja     80042002a8 <boot_aps+0xc4>
		lapic_startap(c->cpu_id, PADDR(code));
		// Wait for the CPU to finish some basic setup in mp_main()
		while (c->cpu_status != CPU_STARTED)
			;
	}
}
  80042003e6:	c9                   	leaveq 
  80042003e7:	c3                   	retq   

00000080042003e8 <mp_main>:

// Setup code for APs
void
mp_main(void)
{
  80042003e8:	55                   	push   %rbp
  80042003e9:	48 89 e5             	mov    %rsp,%rbp
  80042003ec:	48 83 ec 10          	sub    $0x10,%rsp
	// We are in high EIP now, safe to switch to kern_pgdir 
	lcr3(boot_cr3);
  80042003f0:	48 b8 a0 67 49 04 80 	movabs $0x80044967a0,%rax
  80042003f7:	00 00 00 
  80042003fa:	48 8b 00             	mov    (%rax),%rax
  80042003fd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  8004200401:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200405:	0f 22 d8             	mov    %rax,%cr3
	cprintf("SMP: CPU %d starting\n", cpunum());
  8004200408:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420040f:	00 00 00 
  8004200412:	ff d0                	callq  *%rax
  8004200414:	89 c6                	mov    %eax,%esi
  8004200416:	48 bf b4 5e 21 04 80 	movabs $0x8004215eb4,%rdi
  800420041d:	00 00 00 
  8004200420:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200425:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  800420042c:	00 00 00 
  800420042f:	ff d2                	callq  *%rdx

	lapic_init();
  8004200431:	48 b8 96 55 21 04 80 	movabs $0x8004215596,%rax
  8004200438:	00 00 00 
  800420043b:	ff d0                	callq  *%rax
	env_init_percpu();
  800420043d:	48 b8 43 76 20 04 80 	movabs $0x8004207643,%rax
  8004200444:	00 00 00 
  8004200447:	ff d0                	callq  *%rax
	trap_init_percpu();
  8004200449:	48 b8 16 a7 20 04 80 	movabs $0x800420a716,%rax
  8004200450:	00 00 00 
  8004200453:	ff d0                	callq  *%rax
	xchg(&thiscpu->cpu_status, CPU_STARTED); // tell boot_aps() we're up
  8004200455:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420045c:	00 00 00 
  800420045f:	ff d0                	callq  *%rax
  8004200461:	48 98                	cltq   
  8004200463:	48 c1 e0 03          	shl    $0x3,%rax
  8004200467:	48 89 c2             	mov    %rax,%rdx
  800420046a:	48 c1 e2 04          	shl    $0x4,%rdx
  800420046e:	48 29 c2             	sub    %rax,%rdx
  8004200471:	48 b8 20 80 49 04 80 	movabs $0x8004498020,%rax
  8004200478:	00 00 00 
  800420047b:	48 01 d0             	add    %rdx,%rax
  800420047e:	48 83 c0 04          	add    $0x4,%rax
  8004200482:	be 01 00 00 00       	mov    $0x1,%esi
  8004200487:	48 89 c7             	mov    %rax,%rdi
  800420048a:	48 b8 58 00 20 04 80 	movabs $0x8004200058,%rax
  8004200491:	00 00 00 
  8004200494:	ff d0                	callq  *%rax
	// Now that we have finished some basic setup, call sched_yield()
	// to start running processes on this CPU.  But make sure that
	// only one CPU can enter the scheduler at a time!
	//
	// Your code here:
	lock_kernel();
  8004200496:	48 b8 7d 00 20 04 80 	movabs $0x800420007d,%rax
  800420049d:	00 00 00 
  80042004a0:	ff d0                	callq  *%rax
	sched_yield();
  80042004a2:	48 b8 fe ba 20 04 80 	movabs $0x800420bafe,%rax
  80042004a9:	00 00 00 
  80042004ac:	ff d0                	callq  *%rax

00000080042004ae <_panic>:
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", and then enters the kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt,...)
{
  80042004ae:	55                   	push   %rbp
  80042004af:	48 89 e5             	mov    %rsp,%rbp
  80042004b2:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  80042004b9:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  80042004c0:	89 b5 24 ff ff ff    	mov    %esi,-0xdc(%rbp)
  80042004c6:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  80042004cd:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  80042004d4:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  80042004db:	84 c0                	test   %al,%al
  80042004dd:	74 20                	je     80042004ff <_panic+0x51>
  80042004df:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  80042004e3:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  80042004e7:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  80042004eb:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  80042004ef:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  80042004f3:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  80042004f7:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  80042004fb:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  80042004ff:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	if (panicstr)
  8004200506:	48 b8 90 67 49 04 80 	movabs $0x8004496790,%rax
  800420050d:	00 00 00 
  8004200510:	48 8b 00             	mov    (%rax),%rax
  8004200513:	48 85 c0             	test   %rax,%rax
  8004200516:	74 05                	je     800420051d <_panic+0x6f>
		goto dead;
  8004200518:	e9 b5 00 00 00       	jmpq   80042005d2 <_panic+0x124>
	panicstr = fmt;
  800420051d:	48 b8 90 67 49 04 80 	movabs $0x8004496790,%rax
  8004200524:	00 00 00 
  8004200527:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  800420052e:	48 89 10             	mov    %rdx,(%rax)

	// Be extra sure that the machine is in as reasonable state
	__asm __volatile("cli; cld");
  8004200531:	fa                   	cli    
  8004200532:	fc                   	cld    

	va_start(ap, fmt);
  8004200533:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  800420053a:	00 00 00 
  800420053d:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  8004200544:	00 00 00 
  8004200547:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420054b:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  8004200552:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004200559:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	cprintf("kernel panic on CPU %d at %s:%d: ", cpunum(), file, line);
  8004200560:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  8004200567:	00 00 00 
  800420056a:	ff d0                	callq  *%rax
  800420056c:	8b 8d 24 ff ff ff    	mov    -0xdc(%rbp),%ecx
  8004200572:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  8004200579:	89 c6                	mov    %eax,%esi
  800420057b:	48 bf d0 5e 21 04 80 	movabs $0x8004215ed0,%rdi
  8004200582:	00 00 00 
  8004200585:	b8 00 00 00 00       	mov    $0x0,%eax
  800420058a:	49 b8 7a 8a 20 04 80 	movabs $0x8004208a7a,%r8
  8004200591:	00 00 00 
  8004200594:	41 ff d0             	callq  *%r8
	vcprintf(fmt, ap);
  8004200597:	48 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%rdx
  800420059e:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80042005a5:	48 89 d6             	mov    %rdx,%rsi
  80042005a8:	48 89 c7             	mov    %rax,%rdi
  80042005ab:	48 b8 1b 8a 20 04 80 	movabs $0x8004208a1b,%rax
  80042005b2:	00 00 00 
  80042005b5:	ff d0                	callq  *%rax
	cprintf("\n");
  80042005b7:	48 bf f2 5e 21 04 80 	movabs $0x8004215ef2,%rdi
  80042005be:	00 00 00 
  80042005c1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042005c6:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  80042005cd:	00 00 00 
  80042005d0:	ff d2                	callq  *%rdx
	va_end(ap);

dead:
	/* break into the kernel monitor */
	while (1)
		monitor(NULL);
  80042005d2:	bf 00 00 00 00       	mov    $0x0,%edi
  80042005d7:	48 b8 9a 18 20 04 80 	movabs $0x800420189a,%rax
  80042005de:	00 00 00 
  80042005e1:	ff d0                	callq  *%rax
  80042005e3:	eb ed                	jmp    80042005d2 <_panic+0x124>

00000080042005e5 <_warn>:
}

/* like panic, but don't */
void
_warn(const char *file, int line, const char *fmt,...)
{
  80042005e5:	55                   	push   %rbp
  80042005e6:	48 89 e5             	mov    %rsp,%rbp
  80042005e9:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  80042005f0:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  80042005f7:	89 b5 24 ff ff ff    	mov    %esi,-0xdc(%rbp)
  80042005fd:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  8004200604:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  800420060b:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  8004200612:	84 c0                	test   %al,%al
  8004200614:	74 20                	je     8004200636 <_warn+0x51>
  8004200616:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  800420061a:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420061e:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  8004200622:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  8004200626:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  800420062a:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420062e:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  8004200632:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  8004200636:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	va_start(ap, fmt);
  800420063d:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  8004200644:	00 00 00 
  8004200647:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  800420064e:	00 00 00 
  8004200651:	48 8d 45 10          	lea    0x10(%rbp),%rax
  8004200655:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  800420065c:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004200663:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	cprintf("kernel warning at %s:%d: ", file, line);
  800420066a:	8b 95 24 ff ff ff    	mov    -0xdc(%rbp),%edx
  8004200670:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004200677:	48 89 c6             	mov    %rax,%rsi
  800420067a:	48 bf f4 5e 21 04 80 	movabs $0x8004215ef4,%rdi
  8004200681:	00 00 00 
  8004200684:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200689:	48 b9 7a 8a 20 04 80 	movabs $0x8004208a7a,%rcx
  8004200690:	00 00 00 
  8004200693:	ff d1                	callq  *%rcx
	vcprintf(fmt, ap);
  8004200695:	48 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%rdx
  800420069c:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80042006a3:	48 89 d6             	mov    %rdx,%rsi
  80042006a6:	48 89 c7             	mov    %rax,%rdi
  80042006a9:	48 b8 1b 8a 20 04 80 	movabs $0x8004208a1b,%rax
  80042006b0:	00 00 00 
  80042006b3:	ff d0                	callq  *%rax
	cprintf("\n");
  80042006b5:	48 bf f2 5e 21 04 80 	movabs $0x8004215ef2,%rdi
  80042006bc:	00 00 00 
  80042006bf:	b8 00 00 00 00       	mov    $0x0,%eax
  80042006c4:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  80042006cb:	00 00 00 
  80042006ce:	ff d2                	callq  *%rdx
	va_end(ap);
}
  80042006d0:	c9                   	leaveq 
  80042006d1:	c3                   	retq   

00000080042006d2 <delay>:
static void cons_putc(int c);

// Stupid I/O delay routine necessitated by historical PC design flaws
static void
delay(void)
{
  80042006d2:	55                   	push   %rbp
  80042006d3:	48 89 e5             	mov    %rsp,%rbp
  80042006d6:	48 83 ec 20          	sub    $0x20,%rsp
  80042006da:	c7 45 fc 84 00 00 00 	movl   $0x84,-0x4(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042006e1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042006e4:	89 c2                	mov    %eax,%edx
  80042006e6:	ec                   	in     (%dx),%al
  80042006e7:	88 45 fb             	mov    %al,-0x5(%rbp)
  80042006ea:	c7 45 f4 84 00 00 00 	movl   $0x84,-0xc(%rbp)
  80042006f1:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042006f4:	89 c2                	mov    %eax,%edx
  80042006f6:	ec                   	in     (%dx),%al
  80042006f7:	88 45 f3             	mov    %al,-0xd(%rbp)
  80042006fa:	c7 45 ec 84 00 00 00 	movl   $0x84,-0x14(%rbp)
  8004200701:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004200704:	89 c2                	mov    %eax,%edx
  8004200706:	ec                   	in     (%dx),%al
  8004200707:	88 45 eb             	mov    %al,-0x15(%rbp)
  800420070a:	c7 45 e4 84 00 00 00 	movl   $0x84,-0x1c(%rbp)
  8004200711:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004200714:	89 c2                	mov    %eax,%edx
  8004200716:	ec                   	in     (%dx),%al
  8004200717:	88 45 e3             	mov    %al,-0x1d(%rbp)
	inb(0x84);
	inb(0x84);
	inb(0x84);
	inb(0x84);
}
  800420071a:	c9                   	leaveq 
  800420071b:	c3                   	retq   

000000800420071c <serial_proc_data>:

static bool serial_exists;

static int
serial_proc_data(void)
{
  800420071c:	55                   	push   %rbp
  800420071d:	48 89 e5             	mov    %rsp,%rbp
  8004200720:	48 83 ec 10          	sub    $0x10,%rsp
  8004200724:	c7 45 fc fd 03 00 00 	movl   $0x3fd,-0x4(%rbp)
  800420072b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420072e:	89 c2                	mov    %eax,%edx
  8004200730:	ec                   	in     (%dx),%al
  8004200731:	88 45 fb             	mov    %al,-0x5(%rbp)
	return data;
  8004200734:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
	if (!(inb(COM1+COM_LSR) & COM_LSR_DATA))
  8004200738:	0f b6 c0             	movzbl %al,%eax
  800420073b:	83 e0 01             	and    $0x1,%eax
  800420073e:	85 c0                	test   %eax,%eax
  8004200740:	75 07                	jne    8004200749 <serial_proc_data+0x2d>
		return -1;
  8004200742:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004200747:	eb 17                	jmp    8004200760 <serial_proc_data+0x44>
  8004200749:	c7 45 f4 f8 03 00 00 	movl   $0x3f8,-0xc(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200750:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004200753:	89 c2                	mov    %eax,%edx
  8004200755:	ec                   	in     (%dx),%al
  8004200756:	88 45 f3             	mov    %al,-0xd(%rbp)
	return data;
  8004200759:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
	return inb(COM1+COM_RX);
  800420075d:	0f b6 c0             	movzbl %al,%eax
}
  8004200760:	c9                   	leaveq 
  8004200761:	c3                   	retq   

0000008004200762 <serial_intr>:

void
serial_intr(void)
{
  8004200762:	55                   	push   %rbp
  8004200763:	48 89 e5             	mov    %rsp,%rbp
	if (serial_exists)
  8004200766:	48 b8 00 50 49 04 80 	movabs $0x8004495000,%rax
  800420076d:	00 00 00 
  8004200770:	0f b6 00             	movzbl (%rax),%eax
  8004200773:	84 c0                	test   %al,%al
  8004200775:	74 16                	je     800420078d <serial_intr+0x2b>
		cons_intr(serial_proc_data);
  8004200777:	48 bf 1c 07 20 04 80 	movabs $0x800420071c,%rdi
  800420077e:	00 00 00 
  8004200781:	48 b8 29 10 20 04 80 	movabs $0x8004201029,%rax
  8004200788:	00 00 00 
  800420078b:	ff d0                	callq  *%rax
}
  800420078d:	5d                   	pop    %rbp
  800420078e:	c3                   	retq   

000000800420078f <serial_putc>:

static void
serial_putc(int c)
{
  800420078f:	55                   	push   %rbp
  8004200790:	48 89 e5             	mov    %rsp,%rbp
  8004200793:	48 83 ec 28          	sub    $0x28,%rsp
  8004200797:	89 7d dc             	mov    %edi,-0x24(%rbp)
	int i;

	for (i = 0;
  800420079a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042007a1:	eb 10                	jmp    80042007b3 <serial_putc+0x24>
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
	     i++)
		delay();
  80042007a3:	48 b8 d2 06 20 04 80 	movabs $0x80042006d2,%rax
  80042007aa:	00 00 00 
  80042007ad:	ff d0                	callq  *%rax
{
	int i;

	for (i = 0;
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
	     i++)
  80042007af:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042007b3:	c7 45 f8 fd 03 00 00 	movl   $0x3fd,-0x8(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042007ba:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042007bd:	89 c2                	mov    %eax,%edx
  80042007bf:	ec                   	in     (%dx),%al
  80042007c0:	88 45 f7             	mov    %al,-0x9(%rbp)
	return data;
  80042007c3:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
serial_putc(int c)
{
	int i;

	for (i = 0;
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
  80042007c7:	0f b6 c0             	movzbl %al,%eax
  80042007ca:	83 e0 20             	and    $0x20,%eax
static void
serial_putc(int c)
{
	int i;

	for (i = 0;
  80042007cd:	85 c0                	test   %eax,%eax
  80042007cf:	75 09                	jne    80042007da <serial_putc+0x4b>
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
  80042007d1:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%rbp)
  80042007d8:	7e c9                	jle    80042007a3 <serial_putc+0x14>
	     i++)
		delay();

	outb(COM1 + COM_TX, c);
  80042007da:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80042007dd:	0f b6 c0             	movzbl %al,%eax
  80042007e0:	c7 45 f0 f8 03 00 00 	movl   $0x3f8,-0x10(%rbp)
  80042007e7:	88 45 ef             	mov    %al,-0x11(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  80042007ea:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  80042007ee:	8b 55 f0             	mov    -0x10(%rbp),%edx
  80042007f1:	ee                   	out    %al,(%dx)
}
  80042007f2:	c9                   	leaveq 
  80042007f3:	c3                   	retq   

00000080042007f4 <serial_init>:

static void
serial_init(void)
{
  80042007f4:	55                   	push   %rbp
  80042007f5:	48 89 e5             	mov    %rsp,%rbp
  80042007f8:	48 83 ec 50          	sub    $0x50,%rsp
  80042007fc:	c7 45 fc fa 03 00 00 	movl   $0x3fa,-0x4(%rbp)
  8004200803:	c6 45 fb 00          	movb   $0x0,-0x5(%rbp)
  8004200807:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  800420080b:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420080e:	ee                   	out    %al,(%dx)
  800420080f:	c7 45 f4 fb 03 00 00 	movl   $0x3fb,-0xc(%rbp)
  8004200816:	c6 45 f3 80          	movb   $0x80,-0xd(%rbp)
  800420081a:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  800420081e:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004200821:	ee                   	out    %al,(%dx)
  8004200822:	c7 45 ec f8 03 00 00 	movl   $0x3f8,-0x14(%rbp)
  8004200829:	c6 45 eb 0c          	movb   $0xc,-0x15(%rbp)
  800420082d:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004200831:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004200834:	ee                   	out    %al,(%dx)
  8004200835:	c7 45 e4 f9 03 00 00 	movl   $0x3f9,-0x1c(%rbp)
  800420083c:	c6 45 e3 00          	movb   $0x0,-0x1d(%rbp)
  8004200840:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004200844:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004200847:	ee                   	out    %al,(%dx)
  8004200848:	c7 45 dc fb 03 00 00 	movl   $0x3fb,-0x24(%rbp)
  800420084f:	c6 45 db 03          	movb   $0x3,-0x25(%rbp)
  8004200853:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004200857:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800420085a:	ee                   	out    %al,(%dx)
  800420085b:	c7 45 d4 fc 03 00 00 	movl   $0x3fc,-0x2c(%rbp)
  8004200862:	c6 45 d3 00          	movb   $0x0,-0x2d(%rbp)
  8004200866:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  800420086a:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  800420086d:	ee                   	out    %al,(%dx)
  800420086e:	c7 45 cc f9 03 00 00 	movl   $0x3f9,-0x34(%rbp)
  8004200875:	c6 45 cb 01          	movb   $0x1,-0x35(%rbp)
  8004200879:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  800420087d:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004200880:	ee                   	out    %al,(%dx)
  8004200881:	c7 45 c4 fd 03 00 00 	movl   $0x3fd,-0x3c(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200888:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800420088b:	89 c2                	mov    %eax,%edx
  800420088d:	ec                   	in     (%dx),%al
  800420088e:	88 45 c3             	mov    %al,-0x3d(%rbp)
	return data;
  8004200891:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
	// Enable rcv interrupts
	outb(COM1+COM_IER, COM_IER_RDI);

	// Clear any preexisting overrun indications and interrupts
	// Serial port doesn't exist if COM_LSR returns 0xFF
	serial_exists = (inb(COM1+COM_LSR) != 0xFF);
  8004200895:	3c ff                	cmp    $0xff,%al
  8004200897:	0f 95 c2             	setne  %dl
  800420089a:	48 b8 00 50 49 04 80 	movabs $0x8004495000,%rax
  80042008a1:	00 00 00 
  80042008a4:	88 10                	mov    %dl,(%rax)
  80042008a6:	c7 45 bc fa 03 00 00 	movl   $0x3fa,-0x44(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042008ad:	8b 45 bc             	mov    -0x44(%rbp),%eax
  80042008b0:	89 c2                	mov    %eax,%edx
  80042008b2:	ec                   	in     (%dx),%al
  80042008b3:	88 45 bb             	mov    %al,-0x45(%rbp)
  80042008b6:	c7 45 b4 f8 03 00 00 	movl   $0x3f8,-0x4c(%rbp)
  80042008bd:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  80042008c0:	89 c2                	mov    %eax,%edx
  80042008c2:	ec                   	in     (%dx),%al
  80042008c3:	88 45 b3             	mov    %al,-0x4d(%rbp)
	(void) inb(COM1+COM_IIR);
	(void) inb(COM1+COM_RX);

	// Enable serial interrupts
	if (serial_exists)
  80042008c6:	48 b8 00 50 49 04 80 	movabs $0x8004495000,%rax
  80042008cd:	00 00 00 
  80042008d0:	0f b6 00             	movzbl (%rax),%eax
  80042008d3:	84 c0                	test   %al,%al
  80042008d5:	74 23                	je     80042008fa <serial_init+0x106>
		irq_setmask_8259A(irq_mask_8259A & ~(1<<4));
  80042008d7:	48 b8 92 b6 22 04 80 	movabs $0x800422b692,%rax
  80042008de:	00 00 00 
  80042008e1:	0f b7 00             	movzwl (%rax),%eax
  80042008e4:	0f b7 c0             	movzwl %ax,%eax
  80042008e7:	25 ef ff 00 00       	and    $0xffef,%eax
  80042008ec:	89 c7                	mov    %eax,%edi
  80042008ee:	48 b8 fc 88 20 04 80 	movabs $0x80042088fc,%rax
  80042008f5:	00 00 00 
  80042008f8:	ff d0                	callq  *%rax
}
  80042008fa:	c9                   	leaveq 
  80042008fb:	c3                   	retq   

00000080042008fc <lpt_putc>:
// For information on PC parallel port programming, see the class References
// page.

static void
lpt_putc(int c)
{
  80042008fc:	55                   	push   %rbp
  80042008fd:	48 89 e5             	mov    %rsp,%rbp
  8004200900:	48 83 ec 38          	sub    $0x38,%rsp
  8004200904:	89 7d cc             	mov    %edi,-0x34(%rbp)
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 12800; i++)
  8004200907:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420090e:	eb 10                	jmp    8004200920 <lpt_putc+0x24>
		delay();
  8004200910:	48 b8 d2 06 20 04 80 	movabs $0x80042006d2,%rax
  8004200917:	00 00 00 
  800420091a:	ff d0                	callq  *%rax
static void
lpt_putc(int c)
{
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 12800; i++)
  800420091c:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004200920:	c7 45 f8 79 03 00 00 	movl   $0x379,-0x8(%rbp)
  8004200927:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420092a:	89 c2                	mov    %eax,%edx
  800420092c:	ec                   	in     (%dx),%al
  800420092d:	88 45 f7             	mov    %al,-0x9(%rbp)
	return data;
  8004200930:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  8004200934:	84 c0                	test   %al,%al
  8004200936:	78 09                	js     8004200941 <lpt_putc+0x45>
  8004200938:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%rbp)
  800420093f:	7e cf                	jle    8004200910 <lpt_putc+0x14>
		delay();
	outb(0x378+0, c);
  8004200941:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200944:	0f b6 c0             	movzbl %al,%eax
  8004200947:	c7 45 f0 78 03 00 00 	movl   $0x378,-0x10(%rbp)
  800420094e:	88 45 ef             	mov    %al,-0x11(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200951:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8004200955:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004200958:	ee                   	out    %al,(%dx)
  8004200959:	c7 45 e8 7a 03 00 00 	movl   $0x37a,-0x18(%rbp)
  8004200960:	c6 45 e7 0d          	movb   $0xd,-0x19(%rbp)
  8004200964:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004200968:	8b 55 e8             	mov    -0x18(%rbp),%edx
  800420096b:	ee                   	out    %al,(%dx)
  800420096c:	c7 45 e0 7a 03 00 00 	movl   $0x37a,-0x20(%rbp)
  8004200973:	c6 45 df 08          	movb   $0x8,-0x21(%rbp)
  8004200977:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  800420097b:	8b 55 e0             	mov    -0x20(%rbp),%edx
  800420097e:	ee                   	out    %al,(%dx)
	outb(0x378+2, 0x08|0x04|0x01);
	outb(0x378+2, 0x08);
}
  800420097f:	c9                   	leaveq 
  8004200980:	c3                   	retq   

0000008004200981 <cga_init>:
static uint16_t *crt_buf;
static uint16_t crt_pos;

static void
cga_init(void)
{
  8004200981:	55                   	push   %rbp
  8004200982:	48 89 e5             	mov    %rsp,%rbp
  8004200985:	48 83 ec 30          	sub    $0x30,%rsp
	volatile uint16_t *cp;
	uint16_t was;
	unsigned pos;

	cp = (uint16_t*) (KERNBASE + CGA_BUF);
  8004200989:	48 b8 00 80 0b 04 80 	movabs $0x80040b8000,%rax
  8004200990:	00 00 00 
  8004200993:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	was = *cp;
  8004200997:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420099b:	0f b7 00             	movzwl (%rax),%eax
  800420099e:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
	*cp = (uint16_t) 0xA55A;
  80042009a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042009a6:	66 c7 00 5a a5       	movw   $0xa55a,(%rax)
	if (*cp != 0xA55A) {
  80042009ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042009af:	0f b7 00             	movzwl (%rax),%eax
  80042009b2:	66 3d 5a a5          	cmp    $0xa55a,%ax
  80042009b6:	74 20                	je     80042009d8 <cga_init+0x57>
		cp = (uint16_t*) (KERNBASE + MONO_BUF);
  80042009b8:	48 b8 00 00 0b 04 80 	movabs $0x80040b0000,%rax
  80042009bf:	00 00 00 
  80042009c2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		addr_6845 = MONO_BASE;
  80042009c6:	48 b8 04 50 49 04 80 	movabs $0x8004495004,%rax
  80042009cd:	00 00 00 
  80042009d0:	c7 00 b4 03 00 00    	movl   $0x3b4,(%rax)
  80042009d6:	eb 1b                	jmp    80042009f3 <cga_init+0x72>
	} else {
		*cp = was;
  80042009d8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042009dc:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80042009e0:	66 89 10             	mov    %dx,(%rax)
		addr_6845 = CGA_BASE;
  80042009e3:	48 b8 04 50 49 04 80 	movabs $0x8004495004,%rax
  80042009ea:	00 00 00 
  80042009ed:	c7 00 d4 03 00 00    	movl   $0x3d4,(%rax)
	}

	/* Extract cursor location */
	outb(addr_6845, 14);
  80042009f3:	48 b8 04 50 49 04 80 	movabs $0x8004495004,%rax
  80042009fa:	00 00 00 
  80042009fd:	8b 00                	mov    (%rax),%eax
  80042009ff:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004200a02:	c6 45 eb 0e          	movb   $0xe,-0x15(%rbp)
  8004200a06:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004200a0a:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004200a0d:	ee                   	out    %al,(%dx)
	pos = inb(addr_6845 + 1) << 8;
  8004200a0e:	48 b8 04 50 49 04 80 	movabs $0x8004495004,%rax
  8004200a15:	00 00 00 
  8004200a18:	8b 00                	mov    (%rax),%eax
  8004200a1a:	83 c0 01             	add    $0x1,%eax
  8004200a1d:	89 45 e4             	mov    %eax,-0x1c(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200a20:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004200a23:	89 c2                	mov    %eax,%edx
  8004200a25:	ec                   	in     (%dx),%al
  8004200a26:	88 45 e3             	mov    %al,-0x1d(%rbp)
	return data;
  8004200a29:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004200a2d:	0f b6 c0             	movzbl %al,%eax
  8004200a30:	c1 e0 08             	shl    $0x8,%eax
  8004200a33:	89 45 f0             	mov    %eax,-0x10(%rbp)
	outb(addr_6845, 15);
  8004200a36:	48 b8 04 50 49 04 80 	movabs $0x8004495004,%rax
  8004200a3d:	00 00 00 
  8004200a40:	8b 00                	mov    (%rax),%eax
  8004200a42:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004200a45:	c6 45 db 0f          	movb   $0xf,-0x25(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200a49:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004200a4d:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004200a50:	ee                   	out    %al,(%dx)
	pos |= inb(addr_6845 + 1);
  8004200a51:	48 b8 04 50 49 04 80 	movabs $0x8004495004,%rax
  8004200a58:	00 00 00 
  8004200a5b:	8b 00                	mov    (%rax),%eax
  8004200a5d:	83 c0 01             	add    $0x1,%eax
  8004200a60:	89 45 d4             	mov    %eax,-0x2c(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200a63:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8004200a66:	89 c2                	mov    %eax,%edx
  8004200a68:	ec                   	in     (%dx),%al
  8004200a69:	88 45 d3             	mov    %al,-0x2d(%rbp)
	return data;
  8004200a6c:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004200a70:	0f b6 c0             	movzbl %al,%eax
  8004200a73:	09 45 f0             	or     %eax,-0x10(%rbp)

	crt_buf = (uint16_t*) cp;
  8004200a76:	48 b8 08 50 49 04 80 	movabs $0x8004495008,%rax
  8004200a7d:	00 00 00 
  8004200a80:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004200a84:	48 89 10             	mov    %rdx,(%rax)
	crt_pos = pos;
  8004200a87:	8b 45 f0             	mov    -0x10(%rbp),%eax
  8004200a8a:	89 c2                	mov    %eax,%edx
  8004200a8c:	48 b8 10 50 49 04 80 	movabs $0x8004495010,%rax
  8004200a93:	00 00 00 
  8004200a96:	66 89 10             	mov    %dx,(%rax)
}
  8004200a99:	c9                   	leaveq 
  8004200a9a:	c3                   	retq   

0000008004200a9b <cga_putc>:



static void
cga_putc(int c)
{
  8004200a9b:	55                   	push   %rbp
  8004200a9c:	48 89 e5             	mov    %rsp,%rbp
  8004200a9f:	48 83 ec 40          	sub    $0x40,%rsp
  8004200aa3:	89 7d cc             	mov    %edi,-0x34(%rbp)
	if (color_parsing)
  8004200aa6:	48 b8 18 63 49 04 80 	movabs $0x8004496318,%rax
  8004200aad:	00 00 00 
  8004200ab0:	8b 00                	mov    (%rax),%eax
  8004200ab2:	85 c0                	test   %eax,%eax
  8004200ab4:	74 05                	je     8004200abb <cga_putc+0x20>
		return;
  8004200ab6:	e9 ed 02 00 00       	jmpq   8004200da8 <cga_putc+0x30d>
	c |= (color_flag << 8);
  8004200abb:	48 b8 b0 b6 22 04 80 	movabs $0x800422b6b0,%rax
  8004200ac2:	00 00 00 
  8004200ac5:	8b 00                	mov    (%rax),%eax
  8004200ac7:	c1 e0 08             	shl    $0x8,%eax
  8004200aca:	09 45 cc             	or     %eax,-0x34(%rbp)
	// if no attribute given, then use black on white
	if (!(c & ~0xFF))
  8004200acd:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200ad0:	b0 00                	mov    $0x0,%al
  8004200ad2:	85 c0                	test   %eax,%eax
  8004200ad4:	75 07                	jne    8004200add <cga_putc+0x42>
		c |= 0x0700;
  8004200ad6:	81 4d cc 00 07 00 00 	orl    $0x700,-0x34(%rbp)

	switch (c & 0xff) {
  8004200add:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200ae0:	0f b6 c0             	movzbl %al,%eax
  8004200ae3:	83 f8 09             	cmp    $0x9,%eax
  8004200ae6:	0f 84 f6 00 00 00    	je     8004200be2 <cga_putc+0x147>
  8004200aec:	83 f8 09             	cmp    $0x9,%eax
  8004200aef:	7f 0a                	jg     8004200afb <cga_putc+0x60>
  8004200af1:	83 f8 08             	cmp    $0x8,%eax
  8004200af4:	74 18                	je     8004200b0e <cga_putc+0x73>
  8004200af6:	e9 3e 01 00 00       	jmpq   8004200c39 <cga_putc+0x19e>
  8004200afb:	83 f8 0a             	cmp    $0xa,%eax
  8004200afe:	74 75                	je     8004200b75 <cga_putc+0xda>
  8004200b00:	83 f8 0d             	cmp    $0xd,%eax
  8004200b03:	0f 84 89 00 00 00    	je     8004200b92 <cga_putc+0xf7>
  8004200b09:	e9 2b 01 00 00       	jmpq   8004200c39 <cga_putc+0x19e>
	case '\b':
		if (crt_pos > 0) {
  8004200b0e:	48 b8 10 50 49 04 80 	movabs $0x8004495010,%rax
  8004200b15:	00 00 00 
  8004200b18:	0f b7 00             	movzwl (%rax),%eax
  8004200b1b:	66 85 c0             	test   %ax,%ax
  8004200b1e:	74 50                	je     8004200b70 <cga_putc+0xd5>
			crt_pos--;
  8004200b20:	48 b8 10 50 49 04 80 	movabs $0x8004495010,%rax
  8004200b27:	00 00 00 
  8004200b2a:	0f b7 00             	movzwl (%rax),%eax
  8004200b2d:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004200b30:	48 b8 10 50 49 04 80 	movabs $0x8004495010,%rax
  8004200b37:	00 00 00 
  8004200b3a:	66 89 10             	mov    %dx,(%rax)
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
  8004200b3d:	48 b8 08 50 49 04 80 	movabs $0x8004495008,%rax
  8004200b44:	00 00 00 
  8004200b47:	48 8b 10             	mov    (%rax),%rdx
  8004200b4a:	48 b8 10 50 49 04 80 	movabs $0x8004495010,%rax
  8004200b51:	00 00 00 
  8004200b54:	0f b7 00             	movzwl (%rax),%eax
  8004200b57:	0f b7 c0             	movzwl %ax,%eax
  8004200b5a:	48 01 c0             	add    %rax,%rax
  8004200b5d:	48 01 c2             	add    %rax,%rdx
  8004200b60:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200b63:	b0 00                	mov    $0x0,%al
  8004200b65:	83 c8 20             	or     $0x20,%eax
  8004200b68:	66 89 02             	mov    %ax,(%rdx)
		}
		break;
  8004200b6b:	e9 04 01 00 00       	jmpq   8004200c74 <cga_putc+0x1d9>
  8004200b70:	e9 ff 00 00 00       	jmpq   8004200c74 <cga_putc+0x1d9>
	case '\n':
		crt_pos += CRT_COLS;
  8004200b75:	48 b8 10 50 49 04 80 	movabs $0x8004495010,%rax
  8004200b7c:	00 00 00 
  8004200b7f:	0f b7 00             	movzwl (%rax),%eax
  8004200b82:	8d 50 50             	lea    0x50(%rax),%edx
  8004200b85:	48 b8 10 50 49 04 80 	movabs $0x8004495010,%rax
  8004200b8c:	00 00 00 
  8004200b8f:	66 89 10             	mov    %dx,(%rax)
		/* fallthru */
	case '\r':
		crt_pos -= (crt_pos % CRT_COLS);
  8004200b92:	48 b8 10 50 49 04 80 	movabs $0x8004495010,%rax
  8004200b99:	00 00 00 
  8004200b9c:	0f b7 30             	movzwl (%rax),%esi
  8004200b9f:	48 b8 10 50 49 04 80 	movabs $0x8004495010,%rax
  8004200ba6:	00 00 00 
  8004200ba9:	0f b7 08             	movzwl (%rax),%ecx
  8004200bac:	0f b7 c1             	movzwl %cx,%eax
  8004200baf:	69 c0 cd cc 00 00    	imul   $0xcccd,%eax,%eax
  8004200bb5:	c1 e8 10             	shr    $0x10,%eax
  8004200bb8:	89 c2                	mov    %eax,%edx
  8004200bba:	66 c1 ea 06          	shr    $0x6,%dx
  8004200bbe:	89 d0                	mov    %edx,%eax
  8004200bc0:	c1 e0 02             	shl    $0x2,%eax
  8004200bc3:	01 d0                	add    %edx,%eax
  8004200bc5:	c1 e0 04             	shl    $0x4,%eax
  8004200bc8:	29 c1                	sub    %eax,%ecx
  8004200bca:	89 ca                	mov    %ecx,%edx
  8004200bcc:	29 d6                	sub    %edx,%esi
  8004200bce:	89 f2                	mov    %esi,%edx
  8004200bd0:	48 b8 10 50 49 04 80 	movabs $0x8004495010,%rax
  8004200bd7:	00 00 00 
  8004200bda:	66 89 10             	mov    %dx,(%rax)
		break;
  8004200bdd:	e9 92 00 00 00       	jmpq   8004200c74 <cga_putc+0x1d9>
	case '\t':
		cons_putc(' ');
  8004200be2:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200be7:	48 b8 66 11 20 04 80 	movabs $0x8004201166,%rax
  8004200bee:	00 00 00 
  8004200bf1:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200bf3:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200bf8:	48 b8 66 11 20 04 80 	movabs $0x8004201166,%rax
  8004200bff:	00 00 00 
  8004200c02:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200c04:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c09:	48 b8 66 11 20 04 80 	movabs $0x8004201166,%rax
  8004200c10:	00 00 00 
  8004200c13:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200c15:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c1a:	48 b8 66 11 20 04 80 	movabs $0x8004201166,%rax
  8004200c21:	00 00 00 
  8004200c24:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200c26:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c2b:	48 b8 66 11 20 04 80 	movabs $0x8004201166,%rax
  8004200c32:	00 00 00 
  8004200c35:	ff d0                	callq  *%rax
		break;
  8004200c37:	eb 3b                	jmp    8004200c74 <cga_putc+0x1d9>
	default:
		crt_buf[crt_pos++] = c;		/* write the character */
  8004200c39:	48 b8 08 50 49 04 80 	movabs $0x8004495008,%rax
  8004200c40:	00 00 00 
  8004200c43:	48 8b 30             	mov    (%rax),%rsi
  8004200c46:	48 b8 10 50 49 04 80 	movabs $0x8004495010,%rax
  8004200c4d:	00 00 00 
  8004200c50:	0f b7 00             	movzwl (%rax),%eax
  8004200c53:	8d 48 01             	lea    0x1(%rax),%ecx
  8004200c56:	48 ba 10 50 49 04 80 	movabs $0x8004495010,%rdx
  8004200c5d:	00 00 00 
  8004200c60:	66 89 0a             	mov    %cx,(%rdx)
  8004200c63:	0f b7 c0             	movzwl %ax,%eax
  8004200c66:	48 01 c0             	add    %rax,%rax
  8004200c69:	48 8d 14 06          	lea    (%rsi,%rax,1),%rdx
  8004200c6d:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200c70:	66 89 02             	mov    %ax,(%rdx)
		break;
  8004200c73:	90                   	nop
	}

	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
  8004200c74:	48 b8 10 50 49 04 80 	movabs $0x8004495010,%rax
  8004200c7b:	00 00 00 
  8004200c7e:	0f b7 00             	movzwl (%rax),%eax
  8004200c81:	66 3d cf 07          	cmp    $0x7cf,%ax
  8004200c85:	0f 86 89 00 00 00    	jbe    8004200d14 <cga_putc+0x279>
		int i;

		memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
  8004200c8b:	48 b8 08 50 49 04 80 	movabs $0x8004495008,%rax
  8004200c92:	00 00 00 
  8004200c95:	48 8b 00             	mov    (%rax),%rax
  8004200c98:	48 8d 88 a0 00 00 00 	lea    0xa0(%rax),%rcx
  8004200c9f:	48 b8 08 50 49 04 80 	movabs $0x8004495008,%rax
  8004200ca6:	00 00 00 
  8004200ca9:	48 8b 00             	mov    (%rax),%rax
  8004200cac:	ba 00 0f 00 00       	mov    $0xf00,%edx
  8004200cb1:	48 89 ce             	mov    %rcx,%rsi
  8004200cb4:	48 89 c7             	mov    %rax,%rdi
  8004200cb7:	48 b8 66 e9 20 04 80 	movabs $0x800420e966,%rax
  8004200cbe:	00 00 00 
  8004200cc1:	ff d0                	callq  *%rax
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
  8004200cc3:	c7 45 fc 80 07 00 00 	movl   $0x780,-0x4(%rbp)
  8004200cca:	eb 22                	jmp    8004200cee <cga_putc+0x253>
			crt_buf[i] = 0x0700 | ' ';
  8004200ccc:	48 b8 08 50 49 04 80 	movabs $0x8004495008,%rax
  8004200cd3:	00 00 00 
  8004200cd6:	48 8b 00             	mov    (%rax),%rax
  8004200cd9:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004200cdc:	48 63 d2             	movslq %edx,%rdx
  8004200cdf:	48 01 d2             	add    %rdx,%rdx
  8004200ce2:	48 01 d0             	add    %rdx,%rax
  8004200ce5:	66 c7 00 20 07       	movw   $0x720,(%rax)
	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
		int i;

		memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
  8004200cea:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004200cee:	81 7d fc cf 07 00 00 	cmpl   $0x7cf,-0x4(%rbp)
  8004200cf5:	7e d5                	jle    8004200ccc <cga_putc+0x231>
			crt_buf[i] = 0x0700 | ' ';
		crt_pos -= CRT_COLS;
  8004200cf7:	48 b8 10 50 49 04 80 	movabs $0x8004495010,%rax
  8004200cfe:	00 00 00 
  8004200d01:	0f b7 00             	movzwl (%rax),%eax
  8004200d04:	8d 50 b0             	lea    -0x50(%rax),%edx
  8004200d07:	48 b8 10 50 49 04 80 	movabs $0x8004495010,%rax
  8004200d0e:	00 00 00 
  8004200d11:	66 89 10             	mov    %dx,(%rax)
	}

	/* move that little blinky thing */
	outb(addr_6845, 14);
  8004200d14:	48 b8 04 50 49 04 80 	movabs $0x8004495004,%rax
  8004200d1b:	00 00 00 
  8004200d1e:	8b 00                	mov    (%rax),%eax
  8004200d20:	89 45 f8             	mov    %eax,-0x8(%rbp)
  8004200d23:	c6 45 f7 0e          	movb   $0xe,-0x9(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200d27:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  8004200d2b:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004200d2e:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos >> 8);
  8004200d2f:	48 b8 10 50 49 04 80 	movabs $0x8004495010,%rax
  8004200d36:	00 00 00 
  8004200d39:	0f b7 00             	movzwl (%rax),%eax
  8004200d3c:	66 c1 e8 08          	shr    $0x8,%ax
  8004200d40:	0f b6 c0             	movzbl %al,%eax
  8004200d43:	48 ba 04 50 49 04 80 	movabs $0x8004495004,%rdx
  8004200d4a:	00 00 00 
  8004200d4d:	8b 12                	mov    (%rdx),%edx
  8004200d4f:	83 c2 01             	add    $0x1,%edx
  8004200d52:	89 55 f0             	mov    %edx,-0x10(%rbp)
  8004200d55:	88 45 ef             	mov    %al,-0x11(%rbp)
  8004200d58:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8004200d5c:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004200d5f:	ee                   	out    %al,(%dx)
	outb(addr_6845, 15);
  8004200d60:	48 b8 04 50 49 04 80 	movabs $0x8004495004,%rax
  8004200d67:	00 00 00 
  8004200d6a:	8b 00                	mov    (%rax),%eax
  8004200d6c:	89 45 e8             	mov    %eax,-0x18(%rbp)
  8004200d6f:	c6 45 e7 0f          	movb   $0xf,-0x19(%rbp)
  8004200d73:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004200d77:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004200d7a:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos);
  8004200d7b:	48 b8 10 50 49 04 80 	movabs $0x8004495010,%rax
  8004200d82:	00 00 00 
  8004200d85:	0f b7 00             	movzwl (%rax),%eax
  8004200d88:	0f b6 c0             	movzbl %al,%eax
  8004200d8b:	48 ba 04 50 49 04 80 	movabs $0x8004495004,%rdx
  8004200d92:	00 00 00 
  8004200d95:	8b 12                	mov    (%rdx),%edx
  8004200d97:	83 c2 01             	add    $0x1,%edx
  8004200d9a:	89 55 e0             	mov    %edx,-0x20(%rbp)
  8004200d9d:	88 45 df             	mov    %al,-0x21(%rbp)
  8004200da0:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004200da4:	8b 55 e0             	mov    -0x20(%rbp),%edx
  8004200da7:	ee                   	out    %al,(%dx)
}
  8004200da8:	c9                   	leaveq 
  8004200da9:	c3                   	retq   

0000008004200daa <kbd_proc_data>:
 * Get data from the keyboard.  If we finish a character, return it.  Else 0.
 * Return -1 if no data.
 */
static int
kbd_proc_data(void)
{
  8004200daa:	55                   	push   %rbp
  8004200dab:	48 89 e5             	mov    %rsp,%rbp
  8004200dae:	48 83 ec 20          	sub    $0x20,%rsp
  8004200db2:	c7 45 f4 64 00 00 00 	movl   $0x64,-0xc(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200db9:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004200dbc:	89 c2                	mov    %eax,%edx
  8004200dbe:	ec                   	in     (%dx),%al
  8004200dbf:	88 45 f3             	mov    %al,-0xd(%rbp)
	return data;
  8004200dc2:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
	int c;
	uint8_t data;
	static uint32_t shift;

	if ((inb(KBSTATP) & KBS_DIB) == 0)
  8004200dc6:	0f b6 c0             	movzbl %al,%eax
  8004200dc9:	83 e0 01             	and    $0x1,%eax
  8004200dcc:	85 c0                	test   %eax,%eax
  8004200dce:	75 0a                	jne    8004200dda <kbd_proc_data+0x30>
		return -1;
  8004200dd0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004200dd5:	e9 fc 01 00 00       	jmpq   8004200fd6 <kbd_proc_data+0x22c>
  8004200dda:	c7 45 ec 60 00 00 00 	movl   $0x60,-0x14(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200de1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004200de4:	89 c2                	mov    %eax,%edx
  8004200de6:	ec                   	in     (%dx),%al
  8004200de7:	88 45 eb             	mov    %al,-0x15(%rbp)
	return data;
  8004200dea:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax

	data = inb(KBDATAP);
  8004200dee:	88 45 fb             	mov    %al,-0x5(%rbp)

	if (data == 0xE0) {
  8004200df1:	80 7d fb e0          	cmpb   $0xe0,-0x5(%rbp)
  8004200df5:	75 27                	jne    8004200e1e <kbd_proc_data+0x74>
		// E0 escape character
		shift |= E0ESC;
  8004200df7:	48 b8 28 52 49 04 80 	movabs $0x8004495228,%rax
  8004200dfe:	00 00 00 
  8004200e01:	8b 00                	mov    (%rax),%eax
  8004200e03:	83 c8 40             	or     $0x40,%eax
  8004200e06:	89 c2                	mov    %eax,%edx
  8004200e08:	48 b8 28 52 49 04 80 	movabs $0x8004495228,%rax
  8004200e0f:	00 00 00 
  8004200e12:	89 10                	mov    %edx,(%rax)
		return 0;
  8004200e14:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200e19:	e9 b8 01 00 00       	jmpq   8004200fd6 <kbd_proc_data+0x22c>
	} else if (data & 0x80) {
  8004200e1e:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200e22:	84 c0                	test   %al,%al
  8004200e24:	79 65                	jns    8004200e8b <kbd_proc_data+0xe1>
		// Key released
		data = (shift & E0ESC ? data : data & 0x7F);
  8004200e26:	48 b8 28 52 49 04 80 	movabs $0x8004495228,%rax
  8004200e2d:	00 00 00 
  8004200e30:	8b 00                	mov    (%rax),%eax
  8004200e32:	83 e0 40             	and    $0x40,%eax
  8004200e35:	85 c0                	test   %eax,%eax
  8004200e37:	75 09                	jne    8004200e42 <kbd_proc_data+0x98>
  8004200e39:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200e3d:	83 e0 7f             	and    $0x7f,%eax
  8004200e40:	eb 04                	jmp    8004200e46 <kbd_proc_data+0x9c>
  8004200e42:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200e46:	88 45 fb             	mov    %al,-0x5(%rbp)
		shift &= ~(shiftcode[data] | E0ESC);
  8004200e49:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200e4d:	48 ba 60 b0 22 04 80 	movabs $0x800422b060,%rdx
  8004200e54:	00 00 00 
  8004200e57:	48 98                	cltq   
  8004200e59:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200e5d:	83 c8 40             	or     $0x40,%eax
  8004200e60:	0f b6 c0             	movzbl %al,%eax
  8004200e63:	f7 d0                	not    %eax
  8004200e65:	89 c2                	mov    %eax,%edx
  8004200e67:	48 b8 28 52 49 04 80 	movabs $0x8004495228,%rax
  8004200e6e:	00 00 00 
  8004200e71:	8b 00                	mov    (%rax),%eax
  8004200e73:	21 c2                	and    %eax,%edx
  8004200e75:	48 b8 28 52 49 04 80 	movabs $0x8004495228,%rax
  8004200e7c:	00 00 00 
  8004200e7f:	89 10                	mov    %edx,(%rax)
		return 0;
  8004200e81:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200e86:	e9 4b 01 00 00       	jmpq   8004200fd6 <kbd_proc_data+0x22c>
	} else if (shift & E0ESC) {
  8004200e8b:	48 b8 28 52 49 04 80 	movabs $0x8004495228,%rax
  8004200e92:	00 00 00 
  8004200e95:	8b 00                	mov    (%rax),%eax
  8004200e97:	83 e0 40             	and    $0x40,%eax
  8004200e9a:	85 c0                	test   %eax,%eax
  8004200e9c:	74 21                	je     8004200ebf <kbd_proc_data+0x115>
		// Last character was an E0 escape; or with 0x80
		data |= 0x80;
  8004200e9e:	80 4d fb 80          	orb    $0x80,-0x5(%rbp)
		shift &= ~E0ESC;
  8004200ea2:	48 b8 28 52 49 04 80 	movabs $0x8004495228,%rax
  8004200ea9:	00 00 00 
  8004200eac:	8b 00                	mov    (%rax),%eax
  8004200eae:	83 e0 bf             	and    $0xffffffbf,%eax
  8004200eb1:	89 c2                	mov    %eax,%edx
  8004200eb3:	48 b8 28 52 49 04 80 	movabs $0x8004495228,%rax
  8004200eba:	00 00 00 
  8004200ebd:	89 10                	mov    %edx,(%rax)
	}

	shift |= shiftcode[data];
  8004200ebf:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200ec3:	48 ba 60 b0 22 04 80 	movabs $0x800422b060,%rdx
  8004200eca:	00 00 00 
  8004200ecd:	48 98                	cltq   
  8004200ecf:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200ed3:	0f b6 d0             	movzbl %al,%edx
  8004200ed6:	48 b8 28 52 49 04 80 	movabs $0x8004495228,%rax
  8004200edd:	00 00 00 
  8004200ee0:	8b 00                	mov    (%rax),%eax
  8004200ee2:	09 c2                	or     %eax,%edx
  8004200ee4:	48 b8 28 52 49 04 80 	movabs $0x8004495228,%rax
  8004200eeb:	00 00 00 
  8004200eee:	89 10                	mov    %edx,(%rax)
	shift ^= togglecode[data];
  8004200ef0:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200ef4:	48 ba 60 b1 22 04 80 	movabs $0x800422b160,%rdx
  8004200efb:	00 00 00 
  8004200efe:	48 98                	cltq   
  8004200f00:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200f04:	0f b6 d0             	movzbl %al,%edx
  8004200f07:	48 b8 28 52 49 04 80 	movabs $0x8004495228,%rax
  8004200f0e:	00 00 00 
  8004200f11:	8b 00                	mov    (%rax),%eax
  8004200f13:	31 c2                	xor    %eax,%edx
  8004200f15:	48 b8 28 52 49 04 80 	movabs $0x8004495228,%rax
  8004200f1c:	00 00 00 
  8004200f1f:	89 10                	mov    %edx,(%rax)

	c = charcode[shift & (CTL | SHIFT)][data];
  8004200f21:	48 b8 28 52 49 04 80 	movabs $0x8004495228,%rax
  8004200f28:	00 00 00 
  8004200f2b:	8b 00                	mov    (%rax),%eax
  8004200f2d:	83 e0 03             	and    $0x3,%eax
  8004200f30:	89 c2                	mov    %eax,%edx
  8004200f32:	48 b8 60 b5 22 04 80 	movabs $0x800422b560,%rax
  8004200f39:	00 00 00 
  8004200f3c:	89 d2                	mov    %edx,%edx
  8004200f3e:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  8004200f42:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200f46:	48 01 d0             	add    %rdx,%rax
  8004200f49:	0f b6 00             	movzbl (%rax),%eax
  8004200f4c:	0f b6 c0             	movzbl %al,%eax
  8004200f4f:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (shift & CAPSLOCK) {
  8004200f52:	48 b8 28 52 49 04 80 	movabs $0x8004495228,%rax
  8004200f59:	00 00 00 
  8004200f5c:	8b 00                	mov    (%rax),%eax
  8004200f5e:	83 e0 08             	and    $0x8,%eax
  8004200f61:	85 c0                	test   %eax,%eax
  8004200f63:	74 22                	je     8004200f87 <kbd_proc_data+0x1dd>
		if ('a' <= c && c <= 'z')
  8004200f65:	83 7d fc 60          	cmpl   $0x60,-0x4(%rbp)
  8004200f69:	7e 0c                	jle    8004200f77 <kbd_proc_data+0x1cd>
  8004200f6b:	83 7d fc 7a          	cmpl   $0x7a,-0x4(%rbp)
  8004200f6f:	7f 06                	jg     8004200f77 <kbd_proc_data+0x1cd>
			c += 'A' - 'a';
  8004200f71:	83 6d fc 20          	subl   $0x20,-0x4(%rbp)
  8004200f75:	eb 10                	jmp    8004200f87 <kbd_proc_data+0x1dd>
		else if ('A' <= c && c <= 'Z')
  8004200f77:	83 7d fc 40          	cmpl   $0x40,-0x4(%rbp)
  8004200f7b:	7e 0a                	jle    8004200f87 <kbd_proc_data+0x1dd>
  8004200f7d:	83 7d fc 5a          	cmpl   $0x5a,-0x4(%rbp)
  8004200f81:	7f 04                	jg     8004200f87 <kbd_proc_data+0x1dd>
			c += 'a' - 'A';
  8004200f83:	83 45 fc 20          	addl   $0x20,-0x4(%rbp)
	}

	// Process special keys
	// Ctrl-Alt-Del: reboot
	if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
  8004200f87:	48 b8 28 52 49 04 80 	movabs $0x8004495228,%rax
  8004200f8e:	00 00 00 
  8004200f91:	8b 00                	mov    (%rax),%eax
  8004200f93:	f7 d0                	not    %eax
  8004200f95:	83 e0 06             	and    $0x6,%eax
  8004200f98:	85 c0                	test   %eax,%eax
  8004200f9a:	75 37                	jne    8004200fd3 <kbd_proc_data+0x229>
  8004200f9c:	81 7d fc e9 00 00 00 	cmpl   $0xe9,-0x4(%rbp)
  8004200fa3:	75 2e                	jne    8004200fd3 <kbd_proc_data+0x229>
		cprintf("Rebooting!\n");
  8004200fa5:	48 bf 0e 5f 21 04 80 	movabs $0x8004215f0e,%rdi
  8004200fac:	00 00 00 
  8004200faf:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200fb4:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  8004200fbb:	00 00 00 
  8004200fbe:	ff d2                	callq  *%rdx
  8004200fc0:	c7 45 e4 92 00 00 00 	movl   $0x92,-0x1c(%rbp)
  8004200fc7:	c6 45 e3 03          	movb   $0x3,-0x1d(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200fcb:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004200fcf:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004200fd2:	ee                   	out    %al,(%dx)
		outb(0x92, 0x3); // courtesy of Chris Frost
	}

	return c;
  8004200fd3:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004200fd6:	c9                   	leaveq 
  8004200fd7:	c3                   	retq   

0000008004200fd8 <kbd_intr>:

void
kbd_intr(void)
{
  8004200fd8:	55                   	push   %rbp
  8004200fd9:	48 89 e5             	mov    %rsp,%rbp
	cons_intr(kbd_proc_data);
  8004200fdc:	48 bf aa 0d 20 04 80 	movabs $0x8004200daa,%rdi
  8004200fe3:	00 00 00 
  8004200fe6:	48 b8 29 10 20 04 80 	movabs $0x8004201029,%rax
  8004200fed:	00 00 00 
  8004200ff0:	ff d0                	callq  *%rax
}
  8004200ff2:	5d                   	pop    %rbp
  8004200ff3:	c3                   	retq   

0000008004200ff4 <kbd_init>:

static void
kbd_init(void)
{
  8004200ff4:	55                   	push   %rbp
  8004200ff5:	48 89 e5             	mov    %rsp,%rbp
	// Drain the kbd buffer so that Bochs generates interrupts.
	kbd_intr();
  8004200ff8:	48 b8 d8 0f 20 04 80 	movabs $0x8004200fd8,%rax
  8004200fff:	00 00 00 
  8004201002:	ff d0                	callq  *%rax
	irq_setmask_8259A(irq_mask_8259A & ~(1<<1));
  8004201004:	48 b8 92 b6 22 04 80 	movabs $0x800422b692,%rax
  800420100b:	00 00 00 
  800420100e:	0f b7 00             	movzwl (%rax),%eax
  8004201011:	0f b7 c0             	movzwl %ax,%eax
  8004201014:	25 fd ff 00 00       	and    $0xfffd,%eax
  8004201019:	89 c7                	mov    %eax,%edi
  800420101b:	48 b8 fc 88 20 04 80 	movabs $0x80042088fc,%rax
  8004201022:	00 00 00 
  8004201025:	ff d0                	callq  *%rax
}
  8004201027:	5d                   	pop    %rbp
  8004201028:	c3                   	retq   

0000008004201029 <cons_intr>:

// called by device interrupt routines to feed input characters
// into the circular console input buffer.
static void
cons_intr(int (*proc)(void))
{
  8004201029:	55                   	push   %rbp
  800420102a:	48 89 e5             	mov    %rsp,%rbp
  800420102d:	48 83 ec 20          	sub    $0x20,%rsp
  8004201031:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int c;

	while ((c = (*proc)()) != -1) {
  8004201035:	eb 6a                	jmp    80042010a1 <cons_intr+0x78>
		if (c == 0)
  8004201037:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420103b:	75 02                	jne    800420103f <cons_intr+0x16>
			continue;
  800420103d:	eb 62                	jmp    80042010a1 <cons_intr+0x78>
		cons.buf[cons.wpos++] = c;
  800420103f:	48 b8 20 50 49 04 80 	movabs $0x8004495020,%rax
  8004201046:	00 00 00 
  8004201049:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  800420104f:	8d 48 01             	lea    0x1(%rax),%ecx
  8004201052:	48 ba 20 50 49 04 80 	movabs $0x8004495020,%rdx
  8004201059:	00 00 00 
  800420105c:	89 8a 04 02 00 00    	mov    %ecx,0x204(%rdx)
  8004201062:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004201065:	89 d1                	mov    %edx,%ecx
  8004201067:	48 ba 20 50 49 04 80 	movabs $0x8004495020,%rdx
  800420106e:	00 00 00 
  8004201071:	89 c0                	mov    %eax,%eax
  8004201073:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
		if (cons.wpos == CONSBUFSIZE)
  8004201076:	48 b8 20 50 49 04 80 	movabs $0x8004495020,%rax
  800420107d:	00 00 00 
  8004201080:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  8004201086:	3d 00 02 00 00       	cmp    $0x200,%eax
  800420108b:	75 14                	jne    80042010a1 <cons_intr+0x78>
			cons.wpos = 0;
  800420108d:	48 b8 20 50 49 04 80 	movabs $0x8004495020,%rax
  8004201094:	00 00 00 
  8004201097:	c7 80 04 02 00 00 00 	movl   $0x0,0x204(%rax)
  800420109e:	00 00 00 
static void
cons_intr(int (*proc)(void))
{
	int c;

	while ((c = (*proc)()) != -1) {
  80042010a1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042010a5:	ff d0                	callq  *%rax
  80042010a7:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80042010aa:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  80042010ae:	75 87                	jne    8004201037 <cons_intr+0xe>
			continue;
		cons.buf[cons.wpos++] = c;
		if (cons.wpos == CONSBUFSIZE)
			cons.wpos = 0;
	}
}
  80042010b0:	c9                   	leaveq 
  80042010b1:	c3                   	retq   

00000080042010b2 <cons_getc>:

// return the next input character from the console, or 0 if none waiting
int
cons_getc(void)
{
  80042010b2:	55                   	push   %rbp
  80042010b3:	48 89 e5             	mov    %rsp,%rbp
  80042010b6:	48 83 ec 10          	sub    $0x10,%rsp
	int c;

	// poll for any pending input characters,
	// so that this function works even when interrupts are disabled
	// (e.g., when called from the kernel monitor).
	serial_intr();
  80042010ba:	48 b8 62 07 20 04 80 	movabs $0x8004200762,%rax
  80042010c1:	00 00 00 
  80042010c4:	ff d0                	callq  *%rax
	kbd_intr();
  80042010c6:	48 b8 d8 0f 20 04 80 	movabs $0x8004200fd8,%rax
  80042010cd:	00 00 00 
  80042010d0:	ff d0                	callq  *%rax

	// grab the next character from the input buffer.
	if (cons.rpos != cons.wpos) {
  80042010d2:	48 b8 20 50 49 04 80 	movabs $0x8004495020,%rax
  80042010d9:	00 00 00 
  80042010dc:	8b 90 00 02 00 00    	mov    0x200(%rax),%edx
  80042010e2:	48 b8 20 50 49 04 80 	movabs $0x8004495020,%rax
  80042010e9:	00 00 00 
  80042010ec:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  80042010f2:	39 c2                	cmp    %eax,%edx
  80042010f4:	74 69                	je     800420115f <cons_getc+0xad>
		c = cons.buf[cons.rpos++];
  80042010f6:	48 b8 20 50 49 04 80 	movabs $0x8004495020,%rax
  80042010fd:	00 00 00 
  8004201100:	8b 80 00 02 00 00    	mov    0x200(%rax),%eax
  8004201106:	8d 48 01             	lea    0x1(%rax),%ecx
  8004201109:	48 ba 20 50 49 04 80 	movabs $0x8004495020,%rdx
  8004201110:	00 00 00 
  8004201113:	89 8a 00 02 00 00    	mov    %ecx,0x200(%rdx)
  8004201119:	48 ba 20 50 49 04 80 	movabs $0x8004495020,%rdx
  8004201120:	00 00 00 
  8004201123:	89 c0                	mov    %eax,%eax
  8004201125:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004201129:	0f b6 c0             	movzbl %al,%eax
  800420112c:	89 45 fc             	mov    %eax,-0x4(%rbp)
		if (cons.rpos == CONSBUFSIZE)
  800420112f:	48 b8 20 50 49 04 80 	movabs $0x8004495020,%rax
  8004201136:	00 00 00 
  8004201139:	8b 80 00 02 00 00    	mov    0x200(%rax),%eax
  800420113f:	3d 00 02 00 00       	cmp    $0x200,%eax
  8004201144:	75 14                	jne    800420115a <cons_getc+0xa8>
			cons.rpos = 0;
  8004201146:	48 b8 20 50 49 04 80 	movabs $0x8004495020,%rax
  800420114d:	00 00 00 
  8004201150:	c7 80 00 02 00 00 00 	movl   $0x0,0x200(%rax)
  8004201157:	00 00 00 
		return c;
  800420115a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420115d:	eb 05                	jmp    8004201164 <cons_getc+0xb2>
	}
	return 0;
  800420115f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201164:	c9                   	leaveq 
  8004201165:	c3                   	retq   

0000008004201166 <cons_putc>:

// output a character to the console
static void
cons_putc(int c)
{
  8004201166:	55                   	push   %rbp
  8004201167:	48 89 e5             	mov    %rsp,%rbp
  800420116a:	48 83 ec 10          	sub    $0x10,%rsp
  800420116e:	89 7d fc             	mov    %edi,-0x4(%rbp)
	serial_putc(c);
  8004201171:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201174:	89 c7                	mov    %eax,%edi
  8004201176:	48 b8 8f 07 20 04 80 	movabs $0x800420078f,%rax
  800420117d:	00 00 00 
  8004201180:	ff d0                	callq  *%rax
	lpt_putc(c);
  8004201182:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201185:	89 c7                	mov    %eax,%edi
  8004201187:	48 b8 fc 08 20 04 80 	movabs $0x80042008fc,%rax
  800420118e:	00 00 00 
  8004201191:	ff d0                	callq  *%rax
	cga_putc(c);
  8004201193:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201196:	89 c7                	mov    %eax,%edi
  8004201198:	48 b8 9b 0a 20 04 80 	movabs $0x8004200a9b,%rax
  800420119f:	00 00 00 
  80042011a2:	ff d0                	callq  *%rax
}
  80042011a4:	c9                   	leaveq 
  80042011a5:	c3                   	retq   

00000080042011a6 <cons_init>:

// initialize the console devices
void
cons_init(void)
{
  80042011a6:	55                   	push   %rbp
  80042011a7:	48 89 e5             	mov    %rsp,%rbp
	cga_init();
  80042011aa:	48 b8 81 09 20 04 80 	movabs $0x8004200981,%rax
  80042011b1:	00 00 00 
  80042011b4:	ff d0                	callq  *%rax
	kbd_init();
  80042011b6:	48 b8 f4 0f 20 04 80 	movabs $0x8004200ff4,%rax
  80042011bd:	00 00 00 
  80042011c0:	ff d0                	callq  *%rax
	serial_init();
  80042011c2:	48 b8 f4 07 20 04 80 	movabs $0x80042007f4,%rax
  80042011c9:	00 00 00 
  80042011cc:	ff d0                	callq  *%rax

	if (!serial_exists)
  80042011ce:	48 b8 00 50 49 04 80 	movabs $0x8004495000,%rax
  80042011d5:	00 00 00 
  80042011d8:	0f b6 00             	movzbl (%rax),%eax
  80042011db:	83 f0 01             	xor    $0x1,%eax
  80042011de:	84 c0                	test   %al,%al
  80042011e0:	74 1b                	je     80042011fd <cons_init+0x57>
		cprintf("Serial port does not exist!\n");
  80042011e2:	48 bf 1a 5f 21 04 80 	movabs $0x8004215f1a,%rdi
  80042011e9:	00 00 00 
  80042011ec:	b8 00 00 00 00       	mov    $0x0,%eax
  80042011f1:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  80042011f8:	00 00 00 
  80042011fb:	ff d2                	callq  *%rdx
}
  80042011fd:	5d                   	pop    %rbp
  80042011fe:	c3                   	retq   

00000080042011ff <cputchar>:

// `High'-level console I/O.  Used by readline and cprintf.

void
cputchar(int c)
{
  80042011ff:	55                   	push   %rbp
  8004201200:	48 89 e5             	mov    %rsp,%rbp
  8004201203:	48 83 ec 10          	sub    $0x10,%rsp
  8004201207:	89 7d fc             	mov    %edi,-0x4(%rbp)
	cons_putc(c);
  800420120a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420120d:	89 c7                	mov    %eax,%edi
  800420120f:	48 b8 66 11 20 04 80 	movabs $0x8004201166,%rax
  8004201216:	00 00 00 
  8004201219:	ff d0                	callq  *%rax
}
  800420121b:	c9                   	leaveq 
  800420121c:	c3                   	retq   

000000800420121d <getchar>:

int
getchar(void)
{
  800420121d:	55                   	push   %rbp
  800420121e:	48 89 e5             	mov    %rsp,%rbp
  8004201221:	48 83 ec 10          	sub    $0x10,%rsp
	int c;

	while ((c = cons_getc()) == 0)
  8004201225:	48 b8 b2 10 20 04 80 	movabs $0x80042010b2,%rax
  800420122c:	00 00 00 
  800420122f:	ff d0                	callq  *%rax
  8004201231:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8004201234:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004201238:	74 eb                	je     8004201225 <getchar+0x8>
		/* do nothing */;
	return c;
  800420123a:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420123d:	c9                   	leaveq 
  800420123e:	c3                   	retq   

000000800420123f <iscons>:

int
iscons(int fdnum)
{
  800420123f:	55                   	push   %rbp
  8004201240:	48 89 e5             	mov    %rsp,%rbp
  8004201243:	48 83 ec 04          	sub    $0x4,%rsp
  8004201247:	89 7d fc             	mov    %edi,-0x4(%rbp)
	// used by readline
	return 1;
  800420124a:	b8 01 00 00 00       	mov    $0x1,%eax
}
  800420124f:	c9                   	leaveq 
  8004201250:	c3                   	retq   

0000008004201251 <mon_help>:

/***** Implementations of basic kernel monitor commands *****/

int
mon_help(int argc, char **argv, struct Trapframe *tf)
{
  8004201251:	55                   	push   %rbp
  8004201252:	48 89 e5             	mov    %rsp,%rbp
  8004201255:	48 83 ec 30          	sub    $0x30,%rsp
  8004201259:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420125c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004201260:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int i;

	for (i = 0; i < NCOMMANDS; i++)
  8004201264:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420126b:	eb 6c                	jmp    80042012d9 <mon_help+0x88>
		cprintf("%s - %s\n", commands[i].name, commands[i].desc);
  800420126d:	48 b9 80 b5 22 04 80 	movabs $0x800422b580,%rcx
  8004201274:	00 00 00 
  8004201277:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420127a:	48 63 d0             	movslq %eax,%rdx
  800420127d:	48 89 d0             	mov    %rdx,%rax
  8004201280:	48 01 c0             	add    %rax,%rax
  8004201283:	48 01 d0             	add    %rdx,%rax
  8004201286:	48 c1 e0 03          	shl    $0x3,%rax
  800420128a:	48 01 c8             	add    %rcx,%rax
  800420128d:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004201291:	48 be 80 b5 22 04 80 	movabs $0x800422b580,%rsi
  8004201298:	00 00 00 
  800420129b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420129e:	48 63 d0             	movslq %eax,%rdx
  80042012a1:	48 89 d0             	mov    %rdx,%rax
  80042012a4:	48 01 c0             	add    %rax,%rax
  80042012a7:	48 01 d0             	add    %rdx,%rax
  80042012aa:	48 c1 e0 03          	shl    $0x3,%rax
  80042012ae:	48 01 f0             	add    %rsi,%rax
  80042012b1:	48 8b 00             	mov    (%rax),%rax
  80042012b4:	48 89 ca             	mov    %rcx,%rdx
  80042012b7:	48 89 c6             	mov    %rax,%rsi
  80042012ba:	48 bf a1 5f 21 04 80 	movabs $0x8004215fa1,%rdi
  80042012c1:	00 00 00 
  80042012c4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042012c9:	48 b9 7a 8a 20 04 80 	movabs $0x8004208a7a,%rcx
  80042012d0:	00 00 00 
  80042012d3:	ff d1                	callq  *%rcx
int
mon_help(int argc, char **argv, struct Trapframe *tf)
{
	int i;

	for (i = 0; i < NCOMMANDS; i++)
  80042012d5:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042012d9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042012dc:	83 f8 02             	cmp    $0x2,%eax
  80042012df:	76 8c                	jbe    800420126d <mon_help+0x1c>
		cprintf("%s - %s\n", commands[i].name, commands[i].desc);
	return 0;
  80042012e1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042012e6:	c9                   	leaveq 
  80042012e7:	c3                   	retq   

00000080042012e8 <mon_kerninfo>:

int
mon_kerninfo(int argc, char **argv, struct Trapframe *tf)
{
  80042012e8:	55                   	push   %rbp
  80042012e9:	48 89 e5             	mov    %rsp,%rbp
  80042012ec:	48 83 ec 30          	sub    $0x30,%rsp
  80042012f0:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80042012f3:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042012f7:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	extern char _start[], entry[], etext[], edata[], end[];

	cprintf("Special kernel symbols:\n");
  80042012fb:	48 bf aa 5f 21 04 80 	movabs $0x8004215faa,%rdi
  8004201302:	00 00 00 
  8004201305:	b8 00 00 00 00       	mov    $0x0,%eax
  800420130a:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  8004201311:	00 00 00 
  8004201314:	ff d2                	callq  *%rdx
	cprintf("  _start                  %08x (phys)\n", _start);
  8004201316:	48 be 0c 00 20 00 00 	movabs $0x20000c,%rsi
  800420131d:	00 00 00 
  8004201320:	48 bf c8 5f 21 04 80 	movabs $0x8004215fc8,%rdi
  8004201327:	00 00 00 
  800420132a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420132f:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  8004201336:	00 00 00 
  8004201339:	ff d2                	callq  *%rdx
	cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
  800420133b:	48 ba 0c 00 20 00 00 	movabs $0x20000c,%rdx
  8004201342:	00 00 00 
  8004201345:	48 be 0c 00 20 04 80 	movabs $0x800420000c,%rsi
  800420134c:	00 00 00 
  800420134f:	48 bf f0 5f 21 04 80 	movabs $0x8004215ff0,%rdi
  8004201356:	00 00 00 
  8004201359:	b8 00 00 00 00       	mov    $0x0,%eax
  800420135e:	48 b9 7a 8a 20 04 80 	movabs $0x8004208a7a,%rcx
  8004201365:	00 00 00 
  8004201368:	ff d1                	callq  *%rcx
	cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
  800420136a:	48 ba 39 5e 21 00 00 	movabs $0x215e39,%rdx
  8004201371:	00 00 00 
  8004201374:	48 be 39 5e 21 04 80 	movabs $0x8004215e39,%rsi
  800420137b:	00 00 00 
  800420137e:	48 bf 18 60 21 04 80 	movabs $0x8004216018,%rdi
  8004201385:	00 00 00 
  8004201388:	b8 00 00 00 00       	mov    $0x0,%eax
  800420138d:	48 b9 7a 8a 20 04 80 	movabs $0x8004208a7a,%rcx
  8004201394:	00 00 00 
  8004201397:	ff d1                	callq  *%rcx
	cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
  8004201399:	48 ba b6 44 49 00 00 	movabs $0x4944b6,%rdx
  80042013a0:	00 00 00 
  80042013a3:	48 be b6 44 49 04 80 	movabs $0x80044944b6,%rsi
  80042013aa:	00 00 00 
  80042013ad:	48 bf 40 60 21 04 80 	movabs $0x8004216040,%rdi
  80042013b4:	00 00 00 
  80042013b7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042013bc:	48 b9 7a 8a 20 04 80 	movabs $0x8004208a7a,%rcx
  80042013c3:	00 00 00 
  80042013c6:	ff d1                	callq  *%rcx
	cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
  80042013c8:	48 ba 10 90 51 00 00 	movabs $0x519010,%rdx
  80042013cf:	00 00 00 
  80042013d2:	48 be 10 90 51 04 80 	movabs $0x8004519010,%rsi
  80042013d9:	00 00 00 
  80042013dc:	48 bf 68 60 21 04 80 	movabs $0x8004216068,%rdi
  80042013e3:	00 00 00 
  80042013e6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042013eb:	48 b9 7a 8a 20 04 80 	movabs $0x8004208a7a,%rcx
  80042013f2:	00 00 00 
  80042013f5:	ff d1                	callq  *%rcx
	cprintf("Kernel executable memory footprint: %dKB\n",
		ROUNDUP(end - entry, 1024) / 1024);
  80042013f7:	48 c7 45 f8 00 04 00 	movq   $0x400,-0x8(%rbp)
  80042013fe:	00 
  80042013ff:	48 b8 0c 00 20 04 80 	movabs $0x800420000c,%rax
  8004201406:	00 00 00 
  8004201409:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420140d:	48 29 c2             	sub    %rax,%rdx
  8004201410:	48 b8 10 90 51 04 80 	movabs $0x8004519010,%rax
  8004201417:	00 00 00 
  800420141a:	48 83 e8 01          	sub    $0x1,%rax
  800420141e:	48 01 d0             	add    %rdx,%rax
  8004201421:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004201425:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004201429:	ba 00 00 00 00       	mov    $0x0,%edx
  800420142e:	48 f7 75 f8          	divq   -0x8(%rbp)
  8004201432:	48 89 d0             	mov    %rdx,%rax
  8004201435:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004201439:	48 29 c2             	sub    %rax,%rdx
  800420143c:	48 89 d0             	mov    %rdx,%rax
	cprintf("  _start                  %08x (phys)\n", _start);
	cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
	cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
	cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
	cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
	cprintf("Kernel executable memory footprint: %dKB\n",
  800420143f:	48 8d 90 ff 03 00 00 	lea    0x3ff(%rax),%rdx
  8004201446:	48 85 c0             	test   %rax,%rax
  8004201449:	48 0f 48 c2          	cmovs  %rdx,%rax
  800420144d:	48 c1 f8 0a          	sar    $0xa,%rax
  8004201451:	48 89 c6             	mov    %rax,%rsi
  8004201454:	48 bf 90 60 21 04 80 	movabs $0x8004216090,%rdi
  800420145b:	00 00 00 
  800420145e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201463:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  800420146a:	00 00 00 
  800420146d:	ff d2                	callq  *%rdx
		ROUNDUP(end - entry, 1024) / 1024);
	return 0;
  800420146f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201474:	c9                   	leaveq 
  8004201475:	c3                   	retq   

0000008004201476 <mon_backtrace>:

int
mon_backtrace(int argc, char **argv, struct Trapframe *tf)
{
  8004201476:	55                   	push   %rbp
  8004201477:	48 89 e5             	mov    %rsp,%rbp
  800420147a:	48 81 ec 20 05 00 00 	sub    $0x520,%rsp
  8004201481:	89 bd fc fa ff ff    	mov    %edi,-0x504(%rbp)
  8004201487:	48 89 b5 f0 fa ff ff 	mov    %rsi,-0x510(%rbp)
  800420148e:	48 89 95 e8 fa ff ff 	mov    %rdx,-0x518(%rbp)
	int i;
	uint32_t arg;				// argument
	uint64_t rbp, rip;			// rbp and rip
	struct Ripdebuginfo info;	// backtrace info structure

	cprintf("\033[41;36mStack backtrace:\033[0m\n");
  8004201495:	48 bf ba 60 21 04 80 	movabs $0x80042160ba,%rdi
  800420149c:	00 00 00 
  800420149f:	b8 00 00 00 00       	mov    $0x0,%eax
  80042014a4:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  80042014ab:	00 00 00 
  80042014ae:	ff d2                	callq  *%rdx

static __inline uint64_t
read_rbp(void)
{
        uint64_t rbp;
        __asm __volatile("movq %%rbp,%0" : "=r" (rbp)::"cc","memory");
  80042014b0:	48 89 e8             	mov    %rbp,%rax
  80042014b3:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        return rbp;
  80042014b7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax

	// read rbp and rip from register
	// call debuginfo_rip to get backtrace information
	rbp = read_rbp();
  80042014bb:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	read_rip(rip);
  80042014bf:	48 8d 05 00 00 00 00 	lea    0x0(%rip),%rax        # 80042014c6 <mon_backtrace+0x50>
  80042014c6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	debuginfo_rip(rip, &info);
  80042014ca:	48 8d 95 00 fb ff ff 	lea    -0x500(%rbp),%rdx
  80042014d1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042014d5:	48 89 d6             	mov    %rdx,%rsi
  80042014d8:	48 89 c7             	mov    %rax,%rdi
  80042014db:	48 b8 50 d3 20 04 80 	movabs $0x800420d350,%rax
  80042014e2:	00 00 00 
  80042014e5:	ff d0                	callq  *%rax

	while (rbp != 0) {
  80042014e7:	e9 8b 01 00 00       	jmpq   8004201677 <mon_backtrace+0x201>
		// print stack and debug information
		cprintf("  rbp %016x  rip %016x\n", rbp, rip);
  80042014ec:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042014f0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042014f4:	48 89 c6             	mov    %rax,%rsi
  80042014f7:	48 bf d8 60 21 04 80 	movabs $0x80042160d8,%rdi
  80042014fe:	00 00 00 
  8004201501:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201506:	48 b9 7a 8a 20 04 80 	movabs $0x8004208a7a,%rcx
  800420150d:	00 00 00 
  8004201510:	ff d1                	callq  *%rcx
		cprintf("       %s:%d: ", info.rip_file, info.rip_line);
  8004201512:	8b 95 08 fb ff ff    	mov    -0x4f8(%rbp),%edx
  8004201518:	48 8b 85 00 fb ff ff 	mov    -0x500(%rbp),%rax
  800420151f:	48 89 c6             	mov    %rax,%rsi
  8004201522:	48 bf f0 60 21 04 80 	movabs $0x80042160f0,%rdi
  8004201529:	00 00 00 
  800420152c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201531:	48 b9 7a 8a 20 04 80 	movabs $0x8004208a7a,%rcx
  8004201538:	00 00 00 
  800420153b:	ff d1                	callq  *%rcx
		for (i = 0; i < info.rip_fn_namelen; i++)
  800420153d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004201544:	eb 36                	jmp    800420157c <mon_backtrace+0x106>
			cprintf("%c", info.rip_fn_name[i]);
  8004201546:	48 8b 95 10 fb ff ff 	mov    -0x4f0(%rbp),%rdx
  800420154d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201550:	48 98                	cltq   
  8004201552:	48 01 d0             	add    %rdx,%rax
  8004201555:	0f b6 00             	movzbl (%rax),%eax
  8004201558:	0f be c0             	movsbl %al,%eax
  800420155b:	89 c6                	mov    %eax,%esi
  800420155d:	48 bf ff 60 21 04 80 	movabs $0x80042160ff,%rdi
  8004201564:	00 00 00 
  8004201567:	b8 00 00 00 00       	mov    $0x0,%eax
  800420156c:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  8004201573:	00 00 00 
  8004201576:	ff d2                	callq  *%rdx

	while (rbp != 0) {
		// print stack and debug information
		cprintf("  rbp %016x  rip %016x\n", rbp, rip);
		cprintf("       %s:%d: ", info.rip_file, info.rip_line);
		for (i = 0; i < info.rip_fn_namelen; i++)
  8004201578:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420157c:	8b 85 18 fb ff ff    	mov    -0x4e8(%rbp),%eax
  8004201582:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8004201585:	7f bf                	jg     8004201546 <mon_backtrace+0xd0>
			cprintf("%c", info.rip_fn_name[i]);
		cprintf("+%016x", rip - info.rip_fn_addr);
  8004201587:	48 8b 85 20 fb ff ff 	mov    -0x4e0(%rbp),%rax
  800420158e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004201592:	48 29 c2             	sub    %rax,%rdx
  8004201595:	48 89 d0             	mov    %rdx,%rax
  8004201598:	48 89 c6             	mov    %rax,%rsi
  800420159b:	48 bf 02 61 21 04 80 	movabs $0x8004216102,%rdi
  80042015a2:	00 00 00 
  80042015a5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042015aa:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  80042015b1:	00 00 00 
  80042015b4:	ff d2                	callq  *%rdx
		cprintf("  args:%d ", info.rip_fn_narg);
  80042015b6:	8b 85 28 fb ff ff    	mov    -0x4d8(%rbp),%eax
  80042015bc:	89 c6                	mov    %eax,%esi
  80042015be:	48 bf 09 61 21 04 80 	movabs $0x8004216109,%rdi
  80042015c5:	00 00 00 
  80042015c8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042015cd:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  80042015d4:	00 00 00 
  80042015d7:	ff d2                	callq  *%rdx
		for (i = 0; i < info.rip_fn_narg; i++)
  80042015d9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042015e0:	eb 38                	jmp    800420161a <mon_backtrace+0x1a4>
			cprintf(" %016x", *((uint32_t *) (rbp - (i + 1) * 4)));
  80042015e2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042015e5:	83 c0 01             	add    $0x1,%eax
  80042015e8:	c1 e0 02             	shl    $0x2,%eax
  80042015eb:	48 98                	cltq   
  80042015ed:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042015f1:	48 29 c2             	sub    %rax,%rdx
  80042015f4:	48 89 d0             	mov    %rdx,%rax
  80042015f7:	8b 00                	mov    (%rax),%eax
  80042015f9:	89 c6                	mov    %eax,%esi
  80042015fb:	48 bf 14 61 21 04 80 	movabs $0x8004216114,%rdi
  8004201602:	00 00 00 
  8004201605:	b8 00 00 00 00       	mov    $0x0,%eax
  800420160a:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  8004201611:	00 00 00 
  8004201614:	ff d2                	callq  *%rdx
		cprintf("       %s:%d: ", info.rip_file, info.rip_line);
		for (i = 0; i < info.rip_fn_namelen; i++)
			cprintf("%c", info.rip_fn_name[i]);
		cprintf("+%016x", rip - info.rip_fn_addr);
		cprintf("  args:%d ", info.rip_fn_narg);
		for (i = 0; i < info.rip_fn_narg; i++)
  8004201616:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420161a:	8b 85 28 fb ff ff    	mov    -0x4d8(%rbp),%eax
  8004201620:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8004201623:	7f bd                	jg     80042015e2 <mon_backtrace+0x16c>
			cprintf(" %016x", *((uint32_t *) (rbp - (i + 1) * 4)));
		cprintf("\n");
  8004201625:	48 bf 1b 61 21 04 80 	movabs $0x800421611b,%rdi
  800420162c:	00 00 00 
  800420162f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201634:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  800420163b:	00 00 00 
  800420163e:	ff d2                	callq  *%rdx
		// backtrace to upper level
		rip = *((uint64_t *) (rbp + 8));
  8004201640:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004201644:	48 83 c0 08          	add    $0x8,%rax
  8004201648:	48 8b 00             	mov    (%rax),%rax
  800420164b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		rbp = *((uint64_t *) rbp);
  800420164f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004201653:	48 8b 00             	mov    (%rax),%rax
  8004201656:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		debuginfo_rip(rip, &info);
  800420165a:	48 8d 95 00 fb ff ff 	lea    -0x500(%rbp),%rdx
  8004201661:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201665:	48 89 d6             	mov    %rdx,%rsi
  8004201668:	48 89 c7             	mov    %rax,%rdi
  800420166b:	48 b8 50 d3 20 04 80 	movabs $0x800420d350,%rax
  8004201672:	00 00 00 
  8004201675:	ff d0                	callq  *%rax
	// call debuginfo_rip to get backtrace information
	rbp = read_rbp();
	read_rip(rip);
	debuginfo_rip(rip, &info);

	while (rbp != 0) {
  8004201677:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420167c:	0f 85 6a fe ff ff    	jne    80042014ec <mon_backtrace+0x76>
		rip = *((uint64_t *) (rbp + 8));
		rbp = *((uint64_t *) rbp);
		debuginfo_rip(rip, &info);
	}

	return 0;
  8004201682:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201687:	c9                   	leaveq 
  8004201688:	c3                   	retq   

0000008004201689 <runcmd>:
#define WHITESPACE "\t\r\n "
#define MAXARGS 16

static int
runcmd(char *buf, struct Trapframe *tf)
{
  8004201689:	55                   	push   %rbp
  800420168a:	48 89 e5             	mov    %rsp,%rbp
  800420168d:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  8004201694:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  800420169b:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
	int argc;
	char *argv[MAXARGS];
	int i;

	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
  80042016a2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	argv[argc] = 0;
  80042016a9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042016ac:	48 98                	cltq   
  80042016ae:	48 c7 84 c5 70 ff ff 	movq   $0x0,-0x90(%rbp,%rax,8)
  80042016b5:	ff 00 00 00 00 
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  80042016ba:	eb 15                	jmp    80042016d1 <runcmd+0x48>
			*buf++ = 0;
  80042016bc:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042016c3:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042016c7:	48 89 95 68 ff ff ff 	mov    %rdx,-0x98(%rbp)
  80042016ce:	c6 00 00             	movb   $0x0,(%rax)
	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
	argv[argc] = 0;
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  80042016d1:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042016d8:	0f b6 00             	movzbl (%rax),%eax
  80042016db:	84 c0                	test   %al,%al
  80042016dd:	74 2a                	je     8004201709 <runcmd+0x80>
  80042016df:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042016e6:	0f b6 00             	movzbl (%rax),%eax
  80042016e9:	0f be c0             	movsbl %al,%eax
  80042016ec:	89 c6                	mov    %eax,%esi
  80042016ee:	48 bf 1d 61 21 04 80 	movabs $0x800421611d,%rdi
  80042016f5:	00 00 00 
  80042016f8:	48 b8 68 e8 20 04 80 	movabs $0x800420e868,%rax
  80042016ff:	00 00 00 
  8004201702:	ff d0                	callq  *%rax
  8004201704:	48 85 c0             	test   %rax,%rax
  8004201707:	75 b3                	jne    80042016bc <runcmd+0x33>
			*buf++ = 0;
		if (*buf == 0)
  8004201709:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004201710:	0f b6 00             	movzbl (%rax),%eax
  8004201713:	84 c0                	test   %al,%al
  8004201715:	75 21                	jne    8004201738 <runcmd+0xaf>
			break;
  8004201717:	90                   	nop
		}
		argv[argc++] = buf;
		while (*buf && !strchr(WHITESPACE, *buf))
			buf++;
	}
	argv[argc] = 0;
  8004201718:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420171b:	48 98                	cltq   
  800420171d:	48 c7 84 c5 70 ff ff 	movq   $0x0,-0x90(%rbp,%rax,8)
  8004201724:	ff 00 00 00 00 

	// Lookup and invoke the command
	if (argc == 0)
  8004201729:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420172d:	0f 85 a1 00 00 00    	jne    80042017d4 <runcmd+0x14b>
  8004201733:	e9 92 00 00 00       	jmpq   80042017ca <runcmd+0x141>
			*buf++ = 0;
		if (*buf == 0)
			break;

		// save and scan past next arg
		if (argc == MAXARGS-1) {
  8004201738:	83 7d fc 0f          	cmpl   $0xf,-0x4(%rbp)
  800420173c:	75 2a                	jne    8004201768 <runcmd+0xdf>
			cprintf("Too many arguments (max %d)\n", MAXARGS);
  800420173e:	be 10 00 00 00       	mov    $0x10,%esi
  8004201743:	48 bf 22 61 21 04 80 	movabs $0x8004216122,%rdi
  800420174a:	00 00 00 
  800420174d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201752:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  8004201759:	00 00 00 
  800420175c:	ff d2                	callq  *%rdx
			return 0;
  800420175e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201763:	e9 30 01 00 00       	jmpq   8004201898 <runcmd+0x20f>
		}
		argv[argc++] = buf;
  8004201768:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420176b:	8d 50 01             	lea    0x1(%rax),%edx
  800420176e:	89 55 fc             	mov    %edx,-0x4(%rbp)
  8004201771:	48 98                	cltq   
  8004201773:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
  800420177a:	48 89 94 c5 70 ff ff 	mov    %rdx,-0x90(%rbp,%rax,8)
  8004201781:	ff 
		while (*buf && !strchr(WHITESPACE, *buf))
  8004201782:	eb 08                	jmp    800420178c <runcmd+0x103>
			buf++;
  8004201784:	48 83 85 68 ff ff ff 	addq   $0x1,-0x98(%rbp)
  800420178b:	01 
		if (argc == MAXARGS-1) {
			cprintf("Too many arguments (max %d)\n", MAXARGS);
			return 0;
		}
		argv[argc++] = buf;
		while (*buf && !strchr(WHITESPACE, *buf))
  800420178c:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004201793:	0f b6 00             	movzbl (%rax),%eax
  8004201796:	84 c0                	test   %al,%al
  8004201798:	74 2a                	je     80042017c4 <runcmd+0x13b>
  800420179a:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042017a1:	0f b6 00             	movzbl (%rax),%eax
  80042017a4:	0f be c0             	movsbl %al,%eax
  80042017a7:	89 c6                	mov    %eax,%esi
  80042017a9:	48 bf 1d 61 21 04 80 	movabs $0x800421611d,%rdi
  80042017b0:	00 00 00 
  80042017b3:	48 b8 68 e8 20 04 80 	movabs $0x800420e868,%rax
  80042017ba:	00 00 00 
  80042017bd:	ff d0                	callq  *%rax
  80042017bf:	48 85 c0             	test   %rax,%rax
  80042017c2:	74 c0                	je     8004201784 <runcmd+0xfb>
			buf++;
	}
  80042017c4:	90                   	nop
	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
	argv[argc] = 0;
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  80042017c5:	e9 07 ff ff ff       	jmpq   80042016d1 <runcmd+0x48>
	}
	argv[argc] = 0;

	// Lookup and invoke the command
	if (argc == 0)
		return 0;
  80042017ca:	b8 00 00 00 00       	mov    $0x0,%eax
  80042017cf:	e9 c4 00 00 00       	jmpq   8004201898 <runcmd+0x20f>
	for (i = 0; i < NCOMMANDS; i++) {
  80042017d4:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  80042017db:	e9 82 00 00 00       	jmpq   8004201862 <runcmd+0x1d9>
		if (strcmp(argv[0], commands[i].name) == 0)
  80042017e0:	48 b9 80 b5 22 04 80 	movabs $0x800422b580,%rcx
  80042017e7:	00 00 00 
  80042017ea:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042017ed:	48 63 d0             	movslq %eax,%rdx
  80042017f0:	48 89 d0             	mov    %rdx,%rax
  80042017f3:	48 01 c0             	add    %rax,%rax
  80042017f6:	48 01 d0             	add    %rdx,%rax
  80042017f9:	48 c1 e0 03          	shl    $0x3,%rax
  80042017fd:	48 01 c8             	add    %rcx,%rax
  8004201800:	48 8b 10             	mov    (%rax),%rdx
  8004201803:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  800420180a:	48 89 d6             	mov    %rdx,%rsi
  800420180d:	48 89 c7             	mov    %rax,%rdi
  8004201810:	48 b8 a4 e7 20 04 80 	movabs $0x800420e7a4,%rax
  8004201817:	00 00 00 
  800420181a:	ff d0                	callq  *%rax
  800420181c:	85 c0                	test   %eax,%eax
  800420181e:	75 3e                	jne    800420185e <runcmd+0x1d5>
			return commands[i].func(argc, argv, tf);
  8004201820:	48 b9 80 b5 22 04 80 	movabs $0x800422b580,%rcx
  8004201827:	00 00 00 
  800420182a:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420182d:	48 63 d0             	movslq %eax,%rdx
  8004201830:	48 89 d0             	mov    %rdx,%rax
  8004201833:	48 01 c0             	add    %rax,%rax
  8004201836:	48 01 d0             	add    %rdx,%rax
  8004201839:	48 c1 e0 03          	shl    $0x3,%rax
  800420183d:	48 01 c8             	add    %rcx,%rax
  8004201840:	48 83 c0 10          	add    $0x10,%rax
  8004201844:	48 8b 00             	mov    (%rax),%rax
  8004201847:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800420184e:	48 8d b5 70 ff ff ff 	lea    -0x90(%rbp),%rsi
  8004201855:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004201858:	89 cf                	mov    %ecx,%edi
  800420185a:	ff d0                	callq  *%rax
  800420185c:	eb 3a                	jmp    8004201898 <runcmd+0x20f>
	argv[argc] = 0;

	// Lookup and invoke the command
	if (argc == 0)
		return 0;
	for (i = 0; i < NCOMMANDS; i++) {
  800420185e:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  8004201862:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004201865:	83 f8 02             	cmp    $0x2,%eax
  8004201868:	0f 86 72 ff ff ff    	jbe    80042017e0 <runcmd+0x157>
		if (strcmp(argv[0], commands[i].name) == 0)
			return commands[i].func(argc, argv, tf);
	}
	cprintf("Unknown command '%s'\n", argv[0]);
  800420186e:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004201875:	48 89 c6             	mov    %rax,%rsi
  8004201878:	48 bf 3f 61 21 04 80 	movabs $0x800421613f,%rdi
  800420187f:	00 00 00 
  8004201882:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201887:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  800420188e:	00 00 00 
  8004201891:	ff d2                	callq  *%rdx
	return 0;
  8004201893:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201898:	c9                   	leaveq 
  8004201899:	c3                   	retq   

000000800420189a <monitor>:

void
monitor(struct Trapframe *tf)
{
  800420189a:	55                   	push   %rbp
  800420189b:	48 89 e5             	mov    %rsp,%rbp
  800420189e:	48 83 ec 20          	sub    $0x20,%rsp
  80042018a2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	char *buf;

	cprintf("Welcome to the JOS kernel monitor!\n");
  80042018a6:	48 bf 58 61 21 04 80 	movabs $0x8004216158,%rdi
  80042018ad:	00 00 00 
  80042018b0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042018b5:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  80042018bc:	00 00 00 
  80042018bf:	ff d2                	callq  *%rdx
	cprintf("Type 'help' for a list of commands.\n");
  80042018c1:	48 bf 80 61 21 04 80 	movabs $0x8004216180,%rdi
  80042018c8:	00 00 00 
  80042018cb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042018d0:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  80042018d7:	00 00 00 
  80042018da:	ff d2                	callq  *%rdx

	if (tf != NULL)
  80042018dc:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042018e1:	74 13                	je     80042018f6 <monitor+0x5c>
		print_trapframe(tf);
  80042018e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042018e7:	48 89 c7             	mov    %rax,%rdi
  80042018ea:	48 b8 e1 aa 20 04 80 	movabs $0x800420aae1,%rax
  80042018f1:	00 00 00 
  80042018f4:	ff d0                	callq  *%rax

	while (1) {
		buf = readline("K> ");
  80042018f6:	48 bf a5 61 21 04 80 	movabs $0x80042161a5,%rdi
  80042018fd:	00 00 00 
  8004201900:	48 b8 81 e4 20 04 80 	movabs $0x800420e481,%rax
  8004201907:	00 00 00 
  800420190a:	ff d0                	callq  *%rax
  800420190c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (buf != NULL)
  8004201910:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004201915:	74 20                	je     8004201937 <monitor+0x9d>
			if (runcmd(buf, tf) < 0)
  8004201917:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420191b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420191f:	48 89 d6             	mov    %rdx,%rsi
  8004201922:	48 89 c7             	mov    %rax,%rdi
  8004201925:	48 b8 89 16 20 04 80 	movabs $0x8004201689,%rax
  800420192c:	00 00 00 
  800420192f:	ff d0                	callq  *%rax
  8004201931:	85 c0                	test   %eax,%eax
  8004201933:	79 02                	jns    8004201937 <monitor+0x9d>
				break;
  8004201935:	eb 02                	jmp    8004201939 <monitor+0x9f>
	}
  8004201937:	eb bd                	jmp    80042018f6 <monitor+0x5c>
}
  8004201939:	c9                   	leaveq 
  800420193a:	c3                   	retq   

000000800420193b <page2ppn>:
int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);

static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  800420193b:	55                   	push   %rbp
  800420193c:	48 89 e5             	mov    %rsp,%rbp
  800420193f:	48 83 ec 08          	sub    $0x8,%rsp
  8004201943:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  8004201947:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420194b:	48 b8 b8 67 49 04 80 	movabs $0x80044967b8,%rax
  8004201952:	00 00 00 
  8004201955:	48 8b 00             	mov    (%rax),%rax
  8004201958:	48 29 c2             	sub    %rax,%rdx
  800420195b:	48 89 d0             	mov    %rdx,%rax
  800420195e:	48 c1 f8 04          	sar    $0x4,%rax
}
  8004201962:	c9                   	leaveq 
  8004201963:	c3                   	retq   

0000008004201964 <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  8004201964:	55                   	push   %rbp
  8004201965:	48 89 e5             	mov    %rsp,%rbp
  8004201968:	48 83 ec 08          	sub    $0x8,%rsp
  800420196c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  8004201970:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201974:	48 89 c7             	mov    %rax,%rdi
  8004201977:	48 b8 3b 19 20 04 80 	movabs $0x800420193b,%rax
  800420197e:	00 00 00 
  8004201981:	ff d0                	callq  *%rax
  8004201983:	48 c1 e0 0c          	shl    $0xc,%rax
}
  8004201987:	c9                   	leaveq 
  8004201988:	c3                   	retq   

0000008004201989 <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  8004201989:	55                   	push   %rbp
  800420198a:	48 89 e5             	mov    %rsp,%rbp
  800420198d:	48 83 ec 10          	sub    $0x10,%rsp
  8004201991:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  8004201995:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201999:	48 c1 e8 0c          	shr    $0xc,%rax
  800420199d:	48 89 c2             	mov    %rax,%rdx
  80042019a0:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  80042019a7:	00 00 00 
  80042019aa:	48 8b 00             	mov    (%rax),%rax
  80042019ad:	48 39 c2             	cmp    %rax,%rdx
  80042019b0:	72 2a                	jb     80042019dc <pa2page+0x53>
		panic("pa2page called with invalid pa");
  80042019b2:	48 ba b0 61 21 04 80 	movabs $0x80042161b0,%rdx
  80042019b9:	00 00 00 
  80042019bc:	be 54 00 00 00       	mov    $0x54,%esi
  80042019c1:	48 bf cf 61 21 04 80 	movabs $0x80042161cf,%rdi
  80042019c8:	00 00 00 
  80042019cb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042019d0:	48 b9 ae 04 20 04 80 	movabs $0x80042004ae,%rcx
  80042019d7:	00 00 00 
  80042019da:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  80042019dc:	48 b8 b8 67 49 04 80 	movabs $0x80044967b8,%rax
  80042019e3:	00 00 00 
  80042019e6:	48 8b 00             	mov    (%rax),%rax
  80042019e9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042019ed:	48 c1 ea 0c          	shr    $0xc,%rdx
  80042019f1:	48 c1 e2 04          	shl    $0x4,%rdx
  80042019f5:	48 01 d0             	add    %rdx,%rax
}
  80042019f8:	c9                   	leaveq 
  80042019f9:	c3                   	retq   

00000080042019fa <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  80042019fa:	55                   	push   %rbp
  80042019fb:	48 89 e5             	mov    %rsp,%rbp
  80042019fe:	48 83 ec 20          	sub    $0x20,%rsp
  8004201a02:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  8004201a06:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201a0a:	48 89 c7             	mov    %rax,%rdi
  8004201a0d:	48 b8 64 19 20 04 80 	movabs $0x8004201964,%rax
  8004201a14:	00 00 00 
  8004201a17:	ff d0                	callq  *%rax
  8004201a19:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004201a1d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201a21:	48 c1 e8 0c          	shr    $0xc,%rax
  8004201a25:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004201a28:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004201a2b:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  8004201a32:	00 00 00 
  8004201a35:	48 8b 00             	mov    (%rax),%rax
  8004201a38:	48 39 c2             	cmp    %rax,%rdx
  8004201a3b:	72 32                	jb     8004201a6f <page2kva+0x75>
  8004201a3d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201a41:	48 89 c1             	mov    %rax,%rcx
  8004201a44:	48 ba e0 61 21 04 80 	movabs $0x80042161e0,%rdx
  8004201a4b:	00 00 00 
  8004201a4e:	be 5b 00 00 00       	mov    $0x5b,%esi
  8004201a53:	48 bf cf 61 21 04 80 	movabs $0x80042161cf,%rdi
  8004201a5a:	00 00 00 
  8004201a5d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201a62:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004201a69:	00 00 00 
  8004201a6c:	41 ff d0             	callq  *%r8
  8004201a6f:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004201a76:	00 00 00 
  8004201a79:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201a7d:	48 01 d0             	add    %rdx,%rax
}
  8004201a80:	c9                   	leaveq 
  8004201a81:	c3                   	retq   

0000008004201a82 <restrictive_type>:
   uint32_t length_low;
   uint32_t length_high;
   uint32_t type;
 } memory_map_t;

uint32_t restrictive_type(uint32_t t1, uint32_t t2) {
  8004201a82:	55                   	push   %rbp
  8004201a83:	48 89 e5             	mov    %rsp,%rbp
  8004201a86:	48 83 ec 08          	sub    $0x8,%rsp
  8004201a8a:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8004201a8d:	89 75 f8             	mov    %esi,-0x8(%rbp)
  if (t1==MB_TYPE_BAD || t2==MB_TYPE_BAD)
  8004201a90:	83 7d fc 05          	cmpl   $0x5,-0x4(%rbp)
  8004201a94:	74 06                	je     8004201a9c <restrictive_type+0x1a>
  8004201a96:	83 7d f8 05          	cmpl   $0x5,-0x8(%rbp)
  8004201a9a:	75 07                	jne    8004201aa3 <restrictive_type+0x21>
    return MB_TYPE_BAD;
  8004201a9c:	b8 05 00 00 00       	mov    $0x5,%eax
  8004201aa1:	eb 3e                	jmp    8004201ae1 <restrictive_type+0x5f>
  else if (t1==MB_TYPE_ACPI_NVS || t2==MB_TYPE_ACPI_NVS)
  8004201aa3:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  8004201aa7:	74 06                	je     8004201aaf <restrictive_type+0x2d>
  8004201aa9:	83 7d f8 04          	cmpl   $0x4,-0x8(%rbp)
  8004201aad:	75 07                	jne    8004201ab6 <restrictive_type+0x34>
    return MB_TYPE_ACPI_NVS;
  8004201aaf:	b8 04 00 00 00       	mov    $0x4,%eax
  8004201ab4:	eb 2b                	jmp    8004201ae1 <restrictive_type+0x5f>
  else if (t1==MB_TYPE_RESERVED || t2==MB_TYPE_RESERVED)
  8004201ab6:	83 7d fc 02          	cmpl   $0x2,-0x4(%rbp)
  8004201aba:	74 06                	je     8004201ac2 <restrictive_type+0x40>
  8004201abc:	83 7d f8 02          	cmpl   $0x2,-0x8(%rbp)
  8004201ac0:	75 07                	jne    8004201ac9 <restrictive_type+0x47>
    return MB_TYPE_RESERVED;
  8004201ac2:	b8 02 00 00 00       	mov    $0x2,%eax
  8004201ac7:	eb 18                	jmp    8004201ae1 <restrictive_type+0x5f>
  else if (t1==MB_TYPE_ACPI_RECLM || t2==MB_TYPE_ACPI_RECLM)
  8004201ac9:	83 7d fc 03          	cmpl   $0x3,-0x4(%rbp)
  8004201acd:	74 06                	je     8004201ad5 <restrictive_type+0x53>
  8004201acf:	83 7d f8 03          	cmpl   $0x3,-0x8(%rbp)
  8004201ad3:	75 07                	jne    8004201adc <restrictive_type+0x5a>
    return MB_TYPE_ACPI_RECLM;
  8004201ad5:	b8 03 00 00 00       	mov    $0x3,%eax
  8004201ada:	eb 05                	jmp    8004201ae1 <restrictive_type+0x5f>

  return MB_TYPE_USABLE;
  8004201adc:	b8 01 00 00 00       	mov    $0x1,%eax
}
  8004201ae1:	c9                   	leaveq 
  8004201ae2:	c3                   	retq   

0000008004201ae3 <nvram_read>:
// Detect machine's physical memory setup.
// --------------------------------------------------------------

static int
nvram_read(int r)
{
  8004201ae3:	55                   	push   %rbp
  8004201ae4:	48 89 e5             	mov    %rsp,%rbp
  8004201ae7:	53                   	push   %rbx
  8004201ae8:	48 83 ec 18          	sub    $0x18,%rsp
  8004201aec:	89 7d ec             	mov    %edi,-0x14(%rbp)
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
  8004201aef:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201af2:	89 c7                	mov    %eax,%edi
  8004201af4:	48 b8 2e 87 20 04 80 	movabs $0x800420872e,%rax
  8004201afb:	00 00 00 
  8004201afe:	ff d0                	callq  *%rax
  8004201b00:	89 c3                	mov    %eax,%ebx
  8004201b02:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201b05:	83 c0 01             	add    $0x1,%eax
  8004201b08:	89 c7                	mov    %eax,%edi
  8004201b0a:	48 b8 2e 87 20 04 80 	movabs $0x800420872e,%rax
  8004201b11:	00 00 00 
  8004201b14:	ff d0                	callq  *%rax
  8004201b16:	c1 e0 08             	shl    $0x8,%eax
  8004201b19:	09 d8                	or     %ebx,%eax
}
  8004201b1b:	48 83 c4 18          	add    $0x18,%rsp
  8004201b1f:	5b                   	pop    %rbx
  8004201b20:	5d                   	pop    %rbp
  8004201b21:	c3                   	retq   

0000008004201b22 <multiboot_read>:

static void
multiboot_read(multiboot_info_t* mbinfo, size_t* basemem, size_t* extmem) {
  8004201b22:	55                   	push   %rbp
  8004201b23:	48 89 e5             	mov    %rsp,%rbp
  8004201b26:	41 54                	push   %r12
  8004201b28:	53                   	push   %rbx
  8004201b29:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  8004201b30:	48 89 bd 58 ff ff ff 	mov    %rdi,-0xa8(%rbp)
  8004201b37:	48 89 b5 50 ff ff ff 	mov    %rsi,-0xb0(%rbp)
  8004201b3e:	48 89 95 48 ff ff ff 	mov    %rdx,-0xb8(%rbp)
  8004201b45:	48 89 e0             	mov    %rsp,%rax
  8004201b48:	49 89 c4             	mov    %rax,%r12
	int i;

	memory_map_t* mmap_base = (memory_map_t*)(uintptr_t)mbinfo->mmap_addr;
  8004201b4b:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201b52:	8b 40 30             	mov    0x30(%rax),%eax
  8004201b55:	89 c0                	mov    %eax,%eax
  8004201b57:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
 	memory_map_t* mmap_list[mbinfo->mmap_length/ (sizeof(memory_map_t))];
  8004201b5b:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201b62:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004201b65:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004201b6a:	f7 e2                	mul    %edx
  8004201b6c:	89 d0                	mov    %edx,%eax
  8004201b6e:	c1 e8 04             	shr    $0x4,%eax
  8004201b71:	89 c0                	mov    %eax,%eax
  8004201b73:	48 89 c2             	mov    %rax,%rdx
  8004201b76:	48 83 ea 01          	sub    $0x1,%rdx
  8004201b7a:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  8004201b7e:	49 89 c0             	mov    %rax,%r8
  8004201b81:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8004201b87:	48 89 c1             	mov    %rax,%rcx
  8004201b8a:	bb 00 00 00 00       	mov    $0x0,%ebx
  8004201b8f:	48 c1 e0 03          	shl    $0x3,%rax
  8004201b93:	48 8d 50 07          	lea    0x7(%rax),%rdx
  8004201b97:	b8 10 00 00 00       	mov    $0x10,%eax
  8004201b9c:	48 83 e8 01          	sub    $0x1,%rax
  8004201ba0:	48 01 d0             	add    %rdx,%rax
  8004201ba3:	bb 10 00 00 00       	mov    $0x10,%ebx
  8004201ba8:	ba 00 00 00 00       	mov    $0x0,%edx
  8004201bad:	48 f7 f3             	div    %rbx
  8004201bb0:	48 6b c0 10          	imul   $0x10,%rax,%rax
  8004201bb4:	48 29 c4             	sub    %rax,%rsp
  8004201bb7:	48 89 e0             	mov    %rsp,%rax
  8004201bba:	48 83 c0 07          	add    $0x7,%rax
  8004201bbe:	48 c1 e8 03          	shr    $0x3,%rax
  8004201bc2:	48 c1 e0 03          	shl    $0x3,%rax
  8004201bc6:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	cprintf("\ne820 MEMORY MAP\n");
  8004201bca:	48 bf 03 62 21 04 80 	movabs $0x8004216203,%rdi
  8004201bd1:	00 00 00 
  8004201bd4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201bd9:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  8004201be0:	00 00 00 
  8004201be3:	ff d2                	callq  *%rdx
	for (i = 0; i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201be5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004201bec:	e9 6c 01 00 00       	jmpq   8004201d5d <multiboot_read+0x23b>
		memory_map_t* mmap = &mmap_base[i];
  8004201bf1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201bf4:	48 63 d0             	movslq %eax,%rdx
  8004201bf7:	48 89 d0             	mov    %rdx,%rax
  8004201bfa:	48 01 c0             	add    %rax,%rax
  8004201bfd:	48 01 d0             	add    %rdx,%rax
  8004201c00:	48 c1 e0 03          	shl    $0x3,%rax
  8004201c04:	48 89 c2             	mov    %rax,%rdx
  8004201c07:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004201c0b:	48 01 d0             	add    %rdx,%rax
  8004201c0e:	48 89 45 c0          	mov    %rax,-0x40(%rbp)

		uint64_t addr = APPEND_HILO(mmap->base_addr_high, mmap->base_addr_low);
  8004201c12:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201c16:	8b 40 08             	mov    0x8(%rax),%eax
  8004201c19:	89 c0                	mov    %eax,%eax
  8004201c1b:	48 c1 e0 20          	shl    $0x20,%rax
  8004201c1f:	48 89 c2             	mov    %rax,%rdx
  8004201c22:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201c26:	8b 40 04             	mov    0x4(%rax),%eax
  8004201c29:	89 c0                	mov    %eax,%eax
  8004201c2b:	48 01 d0             	add    %rdx,%rax
  8004201c2e:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		uint64_t len = APPEND_HILO(mmap->length_high, mmap->length_low);
  8004201c32:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201c36:	8b 40 10             	mov    0x10(%rax),%eax
  8004201c39:	89 c0                	mov    %eax,%eax
  8004201c3b:	48 c1 e0 20          	shl    $0x20,%rax
  8004201c3f:	48 89 c2             	mov    %rax,%rdx
  8004201c42:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201c46:	8b 40 0c             	mov    0xc(%rax),%eax
  8004201c49:	89 c0                	mov    %eax,%eax
  8004201c4b:	48 01 d0             	add    %rdx,%rax
  8004201c4e:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
        
		cprintf("size: %d, address: 0x%016x, length: 0x%016x, type: %x\n", mmap->size, 
  8004201c52:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201c56:	8b 70 14             	mov    0x14(%rax),%esi
  8004201c59:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201c5d:	8b 00                	mov    (%rax),%eax
  8004201c5f:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004201c63:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004201c67:	41 89 f0             	mov    %esi,%r8d
  8004201c6a:	89 c6                	mov    %eax,%esi
  8004201c6c:	48 bf 18 62 21 04 80 	movabs $0x8004216218,%rdi
  8004201c73:	00 00 00 
  8004201c76:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201c7b:	49 b9 7a 8a 20 04 80 	movabs $0x8004208a7a,%r9
  8004201c82:	00 00 00 
  8004201c85:	41 ff d1             	callq  *%r9
			addr, len, mmap->type);

		if (mmap->type > 5 || mmap->type < 1)
  8004201c88:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201c8c:	8b 40 14             	mov    0x14(%rax),%eax
  8004201c8f:	83 f8 05             	cmp    $0x5,%eax
  8004201c92:	77 0b                	ja     8004201c9f <multiboot_read+0x17d>
  8004201c94:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201c98:	8b 40 14             	mov    0x14(%rax),%eax
  8004201c9b:	85 c0                	test   %eax,%eax
  8004201c9d:	75 0b                	jne    8004201caa <multiboot_read+0x188>
			mmap->type = MB_TYPE_RESERVED;
  8004201c9f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201ca3:	c7 40 14 02 00 00 00 	movl   $0x2,0x14(%rax)
       
		//Insert into the sorted list
		int j = 0;
  8004201caa:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
		for ( ; j < i; j++) {
  8004201cb1:	e9 85 00 00 00       	jmpq   8004201d3b <multiboot_read+0x219>
			memory_map_t* this = mmap_list[j];
  8004201cb6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201cba:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004201cbd:	48 63 d2             	movslq %edx,%rdx
  8004201cc0:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004201cc4:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
  8004201cc8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004201ccc:	8b 40 08             	mov    0x8(%rax),%eax
  8004201ccf:	89 c0                	mov    %eax,%eax
  8004201cd1:	48 c1 e0 20          	shl    $0x20,%rax
  8004201cd5:	48 89 c2             	mov    %rax,%rdx
  8004201cd8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004201cdc:	8b 40 04             	mov    0x4(%rax),%eax
  8004201cdf:	89 c0                	mov    %eax,%eax
  8004201ce1:	48 01 d0             	add    %rdx,%rax
  8004201ce4:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			if (this_addr > addr) {
  8004201ce8:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004201cec:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004201cf0:	76 45                	jbe    8004201d37 <multiboot_read+0x215>
				int last = i+1;
  8004201cf2:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201cf5:	83 c0 01             	add    $0x1,%eax
  8004201cf8:	89 45 e4             	mov    %eax,-0x1c(%rbp)
				while (last != j) {
  8004201cfb:	eb 30                	jmp    8004201d2d <multiboot_read+0x20b>
					*(mmap_list + last) = *(mmap_list + last - 1);
  8004201cfd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201d01:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004201d04:	48 63 d2             	movslq %edx,%rdx
  8004201d07:	48 c1 e2 03          	shl    $0x3,%rdx
  8004201d0b:	48 01 c2             	add    %rax,%rdx
  8004201d0e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201d12:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  8004201d15:	48 63 c9             	movslq %ecx,%rcx
  8004201d18:	48 c1 e1 03          	shl    $0x3,%rcx
  8004201d1c:	48 83 e9 08          	sub    $0x8,%rcx
  8004201d20:	48 01 c8             	add    %rcx,%rax
  8004201d23:	48 8b 00             	mov    (%rax),%rax
  8004201d26:	48 89 02             	mov    %rax,(%rdx)
					last--;
  8004201d29:	83 6d e4 01          	subl   $0x1,-0x1c(%rbp)
		for ( ; j < i; j++) {
			memory_map_t* this = mmap_list[j];
			uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
			if (this_addr > addr) {
				int last = i+1;
				while (last != j) {
  8004201d2d:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004201d30:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  8004201d33:	75 c8                	jne    8004201cfd <multiboot_read+0x1db>
					*(mmap_list + last) = *(mmap_list + last - 1);
					last--;
				}
				break; 
  8004201d35:	eb 10                	jmp    8004201d47 <multiboot_read+0x225>
		if (mmap->type > 5 || mmap->type < 1)
			mmap->type = MB_TYPE_RESERVED;
       
		//Insert into the sorted list
		int j = 0;
		for ( ; j < i; j++) {
  8004201d37:	83 45 e8 01          	addl   $0x1,-0x18(%rbp)
  8004201d3b:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004201d3e:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004201d41:	0f 8c 6f ff ff ff    	jl     8004201cb6 <multiboot_read+0x194>
					last--;
				}
				break; 
			}
		}
		mmap_list[j] = mmap;  
  8004201d47:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201d4b:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004201d4e:	48 63 d2             	movslq %edx,%rdx
  8004201d51:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8004201d55:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)

	memory_map_t* mmap_base = (memory_map_t*)(uintptr_t)mbinfo->mmap_addr;
 	memory_map_t* mmap_list[mbinfo->mmap_length/ (sizeof(memory_map_t))];

	cprintf("\ne820 MEMORY MAP\n");
	for (i = 0; i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201d59:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004201d5d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201d60:	48 63 c8             	movslq %eax,%rcx
  8004201d63:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201d6a:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004201d6d:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004201d72:	f7 e2                	mul    %edx
  8004201d74:	89 d0                	mov    %edx,%eax
  8004201d76:	c1 e8 04             	shr    $0x4,%eax
  8004201d79:	89 c0                	mov    %eax,%eax
  8004201d7b:	48 39 c1             	cmp    %rax,%rcx
  8004201d7e:	0f 82 6d fe ff ff    	jb     8004201bf1 <multiboot_read+0xcf>
				break; 
			}
		}
		mmap_list[j] = mmap;  
	}
	cprintf("\n");
  8004201d84:	48 bf 4f 62 21 04 80 	movabs $0x800421624f,%rdi
  8004201d8b:	00 00 00 
  8004201d8e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201d93:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  8004201d9a:	00 00 00 
  8004201d9d:	ff d2                	callq  *%rdx
    
	// Sanitize the list
	for (i = 1; i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201d9f:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%rbp)
  8004201da6:	e9 93 01 00 00       	jmpq   8004201f3e <multiboot_read+0x41c>
		memory_map_t* prev = mmap_list[i-1];
  8004201dab:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201dae:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004201db1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201db5:	48 63 d2             	movslq %edx,%rdx
  8004201db8:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004201dbc:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		memory_map_t* this = mmap_list[i];
  8004201dc0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201dc4:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004201dc7:	48 63 d2             	movslq %edx,%rdx
  8004201dca:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004201dce:	48 89 45 90          	mov    %rax,-0x70(%rbp)

		uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
  8004201dd2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201dd6:	8b 40 08             	mov    0x8(%rax),%eax
  8004201dd9:	89 c0                	mov    %eax,%eax
  8004201ddb:	48 c1 e0 20          	shl    $0x20,%rax
  8004201ddf:	48 89 c2             	mov    %rax,%rdx
  8004201de2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201de6:	8b 40 04             	mov    0x4(%rax),%eax
  8004201de9:	89 c0                	mov    %eax,%eax
  8004201deb:	48 01 d0             	add    %rdx,%rax
  8004201dee:	48 89 45 88          	mov    %rax,-0x78(%rbp)
		uint64_t prev_addr = APPEND_HILO(prev->base_addr_high, prev->base_addr_low);
  8004201df2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201df6:	8b 40 08             	mov    0x8(%rax),%eax
  8004201df9:	89 c0                	mov    %eax,%eax
  8004201dfb:	48 c1 e0 20          	shl    $0x20,%rax
  8004201dff:	48 89 c2             	mov    %rax,%rdx
  8004201e02:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201e06:	8b 40 04             	mov    0x4(%rax),%eax
  8004201e09:	89 c0                	mov    %eax,%eax
  8004201e0b:	48 01 d0             	add    %rdx,%rax
  8004201e0e:	48 89 45 80          	mov    %rax,-0x80(%rbp)
		uint64_t prev_length = APPEND_HILO(prev->length_high, prev->length_low);
  8004201e12:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201e16:	8b 40 10             	mov    0x10(%rax),%eax
  8004201e19:	89 c0                	mov    %eax,%eax
  8004201e1b:	48 c1 e0 20          	shl    $0x20,%rax
  8004201e1f:	48 89 c2             	mov    %rax,%rdx
  8004201e22:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201e26:	8b 40 0c             	mov    0xc(%rax),%eax
  8004201e29:	89 c0                	mov    %eax,%eax
  8004201e2b:	48 01 d0             	add    %rdx,%rax
  8004201e2e:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
		uint64_t this_length = APPEND_HILO(this->length_high, this->length_low);
  8004201e35:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201e39:	8b 40 10             	mov    0x10(%rax),%eax
  8004201e3c:	89 c0                	mov    %eax,%eax
  8004201e3e:	48 c1 e0 20          	shl    $0x20,%rax
  8004201e42:	48 89 c2             	mov    %rax,%rdx
  8004201e45:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201e49:	8b 40 0c             	mov    0xc(%rax),%eax
  8004201e4c:	89 c0                	mov    %eax,%eax
  8004201e4e:	48 01 d0             	add    %rdx,%rax
  8004201e51:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)

		// Merge adjacent regions with same type
		if (prev_addr + prev_length == this_addr && prev->type == this->type) {
  8004201e58:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004201e5f:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004201e63:	48 01 d0             	add    %rdx,%rax
  8004201e66:	48 3b 45 88          	cmp    -0x78(%rbp),%rax
  8004201e6a:	75 7c                	jne    8004201ee8 <multiboot_read+0x3c6>
  8004201e6c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201e70:	8b 50 14             	mov    0x14(%rax),%edx
  8004201e73:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201e77:	8b 40 14             	mov    0x14(%rax),%eax
  8004201e7a:	39 c2                	cmp    %eax,%edx
  8004201e7c:	75 6a                	jne    8004201ee8 <multiboot_read+0x3c6>
			this->length_low = (uint32_t)prev_length + this_length;
  8004201e7e:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004201e85:	89 c2                	mov    %eax,%edx
  8004201e87:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004201e8e:	01 c2                	add    %eax,%edx
  8004201e90:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201e94:	89 50 0c             	mov    %edx,0xc(%rax)
			this->length_high = (uint32_t)((prev_length + this_length)>>32);
  8004201e97:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004201e9e:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  8004201ea5:	48 01 d0             	add    %rdx,%rax
  8004201ea8:	48 c1 e8 20          	shr    $0x20,%rax
  8004201eac:	89 c2                	mov    %eax,%edx
  8004201eae:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201eb2:	89 50 10             	mov    %edx,0x10(%rax)
			this->base_addr_low = prev->base_addr_low;
  8004201eb5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201eb9:	8b 50 04             	mov    0x4(%rax),%edx
  8004201ebc:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201ec0:	89 50 04             	mov    %edx,0x4(%rax)
			this->base_addr_high = prev->base_addr_high;
  8004201ec3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201ec7:	8b 50 08             	mov    0x8(%rax),%edx
  8004201eca:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201ece:	89 50 08             	mov    %edx,0x8(%rax)
			mmap_list[i-1] = NULL;
  8004201ed1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201ed4:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004201ed7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201edb:	48 63 d2             	movslq %edx,%rdx
  8004201ede:	48 c7 04 d0 00 00 00 	movq   $0x0,(%rax,%rdx,8)
  8004201ee5:	00 
  8004201ee6:	eb 52                	jmp    8004201f3a <multiboot_read+0x418>
		} else if (prev_addr + prev_length > this_addr) {
  8004201ee8:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004201eef:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004201ef3:	48 01 d0             	add    %rdx,%rax
  8004201ef6:	48 3b 45 88          	cmp    -0x78(%rbp),%rax
  8004201efa:	76 3e                	jbe    8004201f3a <multiboot_read+0x418>
			//Overlapping regions
			uint32_t type = restrictive_type(prev->type, this->type);
  8004201efc:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201f00:	8b 50 14             	mov    0x14(%rax),%edx
  8004201f03:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201f07:	8b 40 14             	mov    0x14(%rax),%eax
  8004201f0a:	89 d6                	mov    %edx,%esi
  8004201f0c:	89 c7                	mov    %eax,%edi
  8004201f0e:	48 b8 82 1a 20 04 80 	movabs $0x8004201a82,%rax
  8004201f15:	00 00 00 
  8004201f18:	ff d0                	callq  *%rax
  8004201f1a:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
			prev->type = type;
  8004201f20:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201f24:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
  8004201f2a:	89 50 14             	mov    %edx,0x14(%rax)
			this->type = type;
  8004201f2d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201f31:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
  8004201f37:	89 50 14             	mov    %edx,0x14(%rax)
		mmap_list[j] = mmap;  
	}
	cprintf("\n");
    
	// Sanitize the list
	for (i = 1; i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201f3a:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004201f3e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201f41:	48 63 c8             	movslq %eax,%rcx
  8004201f44:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201f4b:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004201f4e:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004201f53:	f7 e2                	mul    %edx
  8004201f55:	89 d0                	mov    %edx,%eax
  8004201f57:	c1 e8 04             	shr    $0x4,%eax
  8004201f5a:	89 c0                	mov    %eax,%eax
  8004201f5c:	48 39 c1             	cmp    %rax,%rcx
  8004201f5f:	0f 82 46 fe ff ff    	jb     8004201dab <multiboot_read+0x289>
			prev->type = type;
			this->type = type;
		}
	}

	for (i = 0; i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201f65:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004201f6c:	e9 dc 00 00 00       	jmpq   800420204d <multiboot_read+0x52b>
		memory_map_t* mmap = mmap_list[i];
  8004201f71:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201f75:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004201f78:	48 63 d2             	movslq %edx,%rdx
  8004201f7b:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004201f7f:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
		if (mmap) {
  8004201f86:	48 83 bd 60 ff ff ff 	cmpq   $0x0,-0xa0(%rbp)
  8004201f8d:	00 
  8004201f8e:	0f 84 b5 00 00 00    	je     8004202049 <multiboot_read+0x527>
			if (mmap->type == MB_TYPE_USABLE || mmap->type == MB_TYPE_ACPI_RECLM) {
  8004201f94:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004201f9b:	8b 40 14             	mov    0x14(%rax),%eax
  8004201f9e:	83 f8 01             	cmp    $0x1,%eax
  8004201fa1:	74 13                	je     8004201fb6 <multiboot_read+0x494>
  8004201fa3:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004201faa:	8b 40 14             	mov    0x14(%rax),%eax
  8004201fad:	83 f8 03             	cmp    $0x3,%eax
  8004201fb0:	0f 85 93 00 00 00    	jne    8004202049 <multiboot_read+0x527>
				if (mmap->base_addr_low < 0x100000 && mmap->base_addr_high == 0)
  8004201fb6:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004201fbd:	8b 40 04             	mov    0x4(%rax),%eax
  8004201fc0:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
  8004201fc5:	77 49                	ja     8004202010 <multiboot_read+0x4ee>
  8004201fc7:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004201fce:	8b 40 08             	mov    0x8(%rax),%eax
  8004201fd1:	85 c0                	test   %eax,%eax
  8004201fd3:	75 3b                	jne    8004202010 <multiboot_read+0x4ee>
					*basemem += APPEND_HILO(mmap->length_high, mmap->length_low);
  8004201fd5:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004201fdc:	48 8b 10             	mov    (%rax),%rdx
  8004201fdf:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004201fe6:	8b 40 10             	mov    0x10(%rax),%eax
  8004201fe9:	89 c0                	mov    %eax,%eax
  8004201feb:	48 c1 e0 20          	shl    $0x20,%rax
  8004201fef:	48 89 c1             	mov    %rax,%rcx
  8004201ff2:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004201ff9:	8b 40 0c             	mov    0xc(%rax),%eax
  8004201ffc:	89 c0                	mov    %eax,%eax
  8004201ffe:	48 01 c8             	add    %rcx,%rax
  8004202001:	48 01 c2             	add    %rax,%rdx
  8004202004:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  800420200b:	48 89 10             	mov    %rdx,(%rax)
  800420200e:	eb 39                	jmp    8004202049 <multiboot_read+0x527>
				else
					*extmem += APPEND_HILO(mmap->length_high, mmap->length_low);
  8004202010:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004202017:	48 8b 10             	mov    (%rax),%rdx
  800420201a:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004202021:	8b 40 10             	mov    0x10(%rax),%eax
  8004202024:	89 c0                	mov    %eax,%eax
  8004202026:	48 c1 e0 20          	shl    $0x20,%rax
  800420202a:	48 89 c1             	mov    %rax,%rcx
  800420202d:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004202034:	8b 40 0c             	mov    0xc(%rax),%eax
  8004202037:	89 c0                	mov    %eax,%eax
  8004202039:	48 01 c8             	add    %rcx,%rax
  800420203c:	48 01 c2             	add    %rax,%rdx
  800420203f:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004202046:	48 89 10             	mov    %rdx,(%rax)
			prev->type = type;
			this->type = type;
		}
	}

	for (i = 0; i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004202049:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  800420204d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202050:	48 63 c8             	movslq %eax,%rcx
  8004202053:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800420205a:	8b 40 2c             	mov    0x2c(%rax),%eax
  800420205d:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004202062:	f7 e2                	mul    %edx
  8004202064:	89 d0                	mov    %edx,%eax
  8004202066:	c1 e8 04             	shr    $0x4,%eax
  8004202069:	89 c0                	mov    %eax,%eax
  800420206b:	48 39 c1             	cmp    %rax,%rcx
  800420206e:	0f 82 fd fe ff ff    	jb     8004201f71 <multiboot_read+0x44f>
  8004202074:	4c 89 e4             	mov    %r12,%rsp
				else
					*extmem += APPEND_HILO(mmap->length_high, mmap->length_low);
			}
		}
	}
}
  8004202077:	48 8d 65 f0          	lea    -0x10(%rbp),%rsp
  800420207b:	5b                   	pop    %rbx
  800420207c:	41 5c                	pop    %r12
  800420207e:	5d                   	pop    %rbp
  800420207f:	c3                   	retq   

0000008004202080 <i386_detect_memory>:

static void
i386_detect_memory(void)
{
  8004202080:	55                   	push   %rbp
  8004202081:	48 89 e5             	mov    %rsp,%rbp
  8004202084:	48 83 ec 50          	sub    $0x50,%rsp
	size_t npages_extmem;
	size_t basemem = 0;
  8004202088:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  800420208f:	00 
	size_t extmem = 0;
  8004202090:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  8004202097:	00 

	// Check if the bootloader passed us a multiboot structure
	extern char multiboot_info[];
	uintptr_t* mbp = (uintptr_t*)multiboot_info;
  8004202098:	48 b8 00 70 10 00 00 	movabs $0x107000,%rax
  800420209f:	00 00 00 
  80042020a2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	multiboot_info_t * mbinfo = (multiboot_info_t*)*mbp;
  80042020a6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042020aa:	48 8b 00             	mov    (%rax),%rax
  80042020ad:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	
	if (mbinfo && (mbinfo->flags & MB_FLAG_MMAP)) {
  80042020b1:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042020b6:	74 2d                	je     80042020e5 <i386_detect_memory+0x65>
  80042020b8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042020bc:	8b 00                	mov    (%rax),%eax
  80042020be:	83 e0 40             	and    $0x40,%eax
  80042020c1:	85 c0                	test   %eax,%eax
  80042020c3:	74 20                	je     80042020e5 <i386_detect_memory+0x65>
		multiboot_read(mbinfo, &basemem, &extmem);
  80042020c5:	48 8d 55 b8          	lea    -0x48(%rbp),%rdx
  80042020c9:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  80042020cd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042020d1:	48 89 ce             	mov    %rcx,%rsi
  80042020d4:	48 89 c7             	mov    %rax,%rdi
  80042020d7:	48 b8 22 1b 20 04 80 	movabs $0x8004201b22,%rax
  80042020de:	00 00 00 
  80042020e1:	ff d0                	callq  *%rax
  80042020e3:	eb 34                	jmp    8004202119 <i386_detect_memory+0x99>
	} else {
		basemem = (nvram_read(NVRAM_BASELO) * 1024);
  80042020e5:	bf 15 00 00 00       	mov    $0x15,%edi
  80042020ea:	48 b8 e3 1a 20 04 80 	movabs $0x8004201ae3,%rax
  80042020f1:	00 00 00 
  80042020f4:	ff d0                	callq  *%rax
  80042020f6:	c1 e0 0a             	shl    $0xa,%eax
  80042020f9:	48 98                	cltq   
  80042020fb:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
		extmem = (nvram_read(NVRAM_EXTLO) * 1024);
  80042020ff:	bf 17 00 00 00       	mov    $0x17,%edi
  8004202104:	48 b8 e3 1a 20 04 80 	movabs $0x8004201ae3,%rax
  800420210b:	00 00 00 
  800420210e:	ff d0                	callq  *%rax
  8004202110:	c1 e0 0a             	shl    $0xa,%eax
  8004202113:	48 98                	cltq   
  8004202115:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	}
    
	assert(basemem);
  8004202119:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420211d:	48 85 c0             	test   %rax,%rax
  8004202120:	75 35                	jne    8004202157 <i386_detect_memory+0xd7>
  8004202122:	48 b9 51 62 21 04 80 	movabs $0x8004216251,%rcx
  8004202129:	00 00 00 
  800420212c:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004202133:	00 00 00 
  8004202136:	be 86 00 00 00       	mov    $0x86,%esi
  800420213b:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004202142:	00 00 00 
  8004202145:	b8 00 00 00 00       	mov    $0x0,%eax
  800420214a:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004202151:	00 00 00 
  8004202154:	41 ff d0             	callq  *%r8

	npages_basemem = basemem / PGSIZE;
  8004202157:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420215b:	48 c1 e8 0c          	shr    $0xc,%rax
  800420215f:	48 89 c2             	mov    %rax,%rdx
  8004202162:	48 b8 30 52 49 04 80 	movabs $0x8004495230,%rax
  8004202169:	00 00 00 
  800420216c:	48 89 10             	mov    %rdx,(%rax)
	npages_extmem = extmem / PGSIZE;
  800420216f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202173:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202177:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	
	if (nvram_read(NVRAM_EXTLO) == 0xffff) {
  800420217b:	bf 17 00 00 00       	mov    $0x17,%edi
  8004202180:	48 b8 e3 1a 20 04 80 	movabs $0x8004201ae3,%rax
  8004202187:	00 00 00 
  800420218a:	ff d0                	callq  *%rax
  800420218c:	3d ff ff 00 00       	cmp    $0xffff,%eax
  8004202191:	75 2c                	jne    80042021bf <i386_detect_memory+0x13f>
		// EXTMEM > 16M in blocks of 64k
		size_t pextmem = nvram_read(NVRAM_EXTGT16LO) * (64 * 1024);
  8004202193:	bf 34 00 00 00       	mov    $0x34,%edi
  8004202198:	48 b8 e3 1a 20 04 80 	movabs $0x8004201ae3,%rax
  800420219f:	00 00 00 
  80042021a2:	ff d0                	callq  *%rax
  80042021a4:	c1 e0 10             	shl    $0x10,%eax
  80042021a7:	48 98                	cltq   
  80042021a9:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		npages_extmem = ((16 * 1024 * 1024) + pextmem - (1 * 1024 * 1024)) / PGSIZE;
  80042021ad:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042021b1:	48 05 00 00 f0 00    	add    $0xf00000,%rax
  80042021b7:	48 c1 e8 0c          	shr    $0xc,%rax
  80042021bb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	}
	
	// Calculate the number of physical pages available in both base
	// and extended memory.
	if (npages_extmem)
  80042021bf:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042021c4:	74 1a                	je     80042021e0 <i386_detect_memory+0x160>
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
  80042021c6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042021ca:	48 8d 90 00 01 00 00 	lea    0x100(%rax),%rdx
  80042021d1:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  80042021d8:	00 00 00 
  80042021db:	48 89 10             	mov    %rdx,(%rax)
  80042021de:	eb 1a                	jmp    80042021fa <i386_detect_memory+0x17a>
	else
		npages = npages_basemem;
  80042021e0:	48 b8 30 52 49 04 80 	movabs $0x8004495230,%rax
  80042021e7:	00 00 00 
  80042021ea:	48 8b 10             	mov    (%rax),%rdx
  80042021ed:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  80042021f4:	00 00 00 
  80042021f7:	48 89 10             	mov    %rdx,(%rax)

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  80042021fa:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  8004202201:	00 00 00 
  8004202204:	48 8b 30             	mov    (%rax),%rsi
		npages * PGSIZE / (1024 * 1024),
		npages_basemem * PGSIZE / 1024,
		npages_extmem * PGSIZE / 1024,
  8004202207:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420220b:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  800420220f:	48 c1 e8 0a          	shr    $0xa,%rax
  8004202213:	48 89 c1             	mov    %rax,%rcx
		npages * PGSIZE / (1024 * 1024),
		npages_basemem * PGSIZE / 1024,
  8004202216:	48 b8 30 52 49 04 80 	movabs $0x8004495230,%rax
  800420221d:	00 00 00 
  8004202220:	48 8b 00             	mov    (%rax),%rax
  8004202223:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  8004202227:	48 c1 e8 0a          	shr    $0xa,%rax
  800420222b:	48 89 c2             	mov    %rax,%rdx
		npages * PGSIZE / (1024 * 1024),
  800420222e:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  8004202235:	00 00 00 
  8004202238:	48 8b 00             	mov    (%rax),%rax
  800420223b:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  800420223f:	48 c1 e8 14          	shr    $0x14,%rax
  8004202243:	49 89 f0             	mov    %rsi,%r8
  8004202246:	48 89 c6             	mov    %rax,%rsi
  8004202249:	48 bf 80 62 21 04 80 	movabs $0x8004216280,%rdi
  8004202250:	00 00 00 
  8004202253:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202258:	49 b9 7a 8a 20 04 80 	movabs $0x8004208a7a,%r9
  800420225f:	00 00 00 
  8004202262:	41 ff d1             	callq  *%r9
	//JOS 64 pages are limited by the size of both the UPAGES
	//  virtual address space, and the range from KERNBASE to UVPT.
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to 
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
  8004202265:	48 c7 45 d8 00 00 32 	movq   $0x320000,-0x28(%rbp)
  800420226c:	00 
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
  800420226d:	48 c7 45 d0 00 c0 ff 	movq   $0x7ffc000,-0x30(%rbp)
  8004202274:	07 
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n", 
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
		kern_mem_max, kern_mem_max * PGSIZE / (1024 * 1024));
  8004202275:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004202279:	48 c1 e0 0c          	shl    $0xc,%rax
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to 
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n", 
  800420227d:	48 c1 e8 14          	shr    $0x14,%rax
  8004202281:	48 89 c1             	mov    %rax,%rcx
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
  8004202284:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202288:	48 c1 e0 0c          	shl    $0xc,%rax
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to 
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n", 
  800420228c:	48 c1 e8 14          	shr    $0x14,%rax
  8004202290:	48 89 c6             	mov    %rax,%rsi
  8004202293:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004202297:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420229b:	49 89 c8             	mov    %rcx,%r8
  800420229e:	48 89 d1             	mov    %rdx,%rcx
  80042022a1:	48 89 f2             	mov    %rsi,%rdx
  80042022a4:	48 89 c6             	mov    %rax,%rsi
  80042022a7:	48 bf d0 62 21 04 80 	movabs $0x80042162d0,%rdi
  80042022ae:	00 00 00 
  80042022b1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042022b6:	49 b9 7a 8a 20 04 80 	movabs $0x8004208a7a,%r9
  80042022bd:	00 00 00 
  80042022c0:	41 ff d1             	callq  *%r9
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
		kern_mem_max, kern_mem_max * PGSIZE / (1024 * 1024));
	uint64_t max_npages = upages_max < kern_mem_max ? upages_max : kern_mem_max;
  80042022c3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042022c7:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  80042022cb:	48 0f 46 45 d0       	cmovbe -0x30(%rbp),%rax
  80042022d0:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	if (npages > max_npages) {
  80042022d4:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  80042022db:	00 00 00 
  80042022de:	48 8b 00             	mov    (%rax),%rax
  80042022e1:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  80042022e5:	76 3a                	jbe    8004202321 <i386_detect_memory+0x2a1>
		npages = max_npages - 1024;
  80042022e7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042022eb:	48 8d 90 00 fc ff ff 	lea    -0x400(%rax),%rdx
  80042022f2:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  80042022f9:	00 00 00 
  80042022fc:	48 89 10             	mov    %rdx,(%rax)
		cprintf("Using only %uK of the available memory.\n", max_npages);
  80042022ff:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202303:	48 89 c6             	mov    %rax,%rsi
  8004202306:	48 bf 38 63 21 04 80 	movabs $0x8004216338,%rdi
  800420230d:	00 00 00 
  8004202310:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202315:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  800420231c:	00 00 00 
  800420231f:	ff d2                	callq  *%rdx
	}
}
  8004202321:	c9                   	leaveq 
  8004202322:	c3                   	retq   

0000008004202323 <boot_alloc>:
// If we're out of memory, boot_alloc should panic.
// This function may ONLY be used during initialization,
// before the page_free_list list has been set up.
static void *
boot_alloc(uint32_t n)
{
  8004202323:	55                   	push   %rbp
  8004202324:	48 89 e5             	mov    %rsp,%rbp
  8004202327:	48 83 ec 34          	sub    $0x34,%rsp
  800420232b:	89 7d cc             	mov    %edi,-0x34(%rbp)
	// Initialize nextfree if this is the first time.
	// 'end' is a magic symbol automatically generated by the linker,
	// which points to the end of the kernel's bss segment:
	// the first virtual address that the linker did *not* assign
	// to any kernel code or global variables.
	if (!nextfree) {
  800420232e:	48 b8 48 52 49 04 80 	movabs $0x8004495248,%rax
  8004202335:	00 00 00 
  8004202338:	48 8b 00             	mov    (%rax),%rax
  800420233b:	48 85 c0             	test   %rax,%rax
  800420233e:	75 4e                	jne    800420238e <boot_alloc+0x6b>
		extern uintptr_t end_debug;
		nextfree = ROUNDUP((char *) end_debug, PGSIZE);
  8004202340:	48 c7 45 f8 00 10 00 	movq   $0x1000,-0x8(%rbp)
  8004202347:	00 
  8004202348:	48 b8 88 67 49 04 80 	movabs $0x8004496788,%rax
  800420234f:	00 00 00 
  8004202352:	48 8b 10             	mov    (%rax),%rdx
  8004202355:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202359:	48 01 d0             	add    %rdx,%rax
  800420235c:	48 83 e8 01          	sub    $0x1,%rax
  8004202360:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004202364:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202368:	ba 00 00 00 00       	mov    $0x0,%edx
  800420236d:	48 f7 75 f8          	divq   -0x8(%rbp)
  8004202371:	48 89 d0             	mov    %rdx,%rax
  8004202374:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004202378:	48 29 c2             	sub    %rax,%rdx
  800420237b:	48 89 d0             	mov    %rdx,%rax
  800420237e:	48 89 c2             	mov    %rax,%rdx
  8004202381:	48 b8 48 52 49 04 80 	movabs $0x8004495248,%rax
  8004202388:	00 00 00 
  800420238b:	48 89 10             	mov    %rdx,(%rax)
	// Allocate a chunk large enough to hold 'n' bytes, then update
	// nextfree.  Make sure nextfree is kept aligned
	// to a multiple of PGSIZE.
	//
	// LAB 2: Your code here.
	result = nextfree;
  800420238e:	48 b8 48 52 49 04 80 	movabs $0x8004495248,%rax
  8004202395:	00 00 00 
  8004202398:	48 8b 00             	mov    (%rax),%rax
  800420239b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (n > 0) {
  800420239f:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  80042023a3:	74 54                	je     80042023f9 <boot_alloc+0xd6>
		nextfree += ROUNDUP(n, PGSIZE);
  80042023a5:	48 b8 48 52 49 04 80 	movabs $0x8004495248,%rax
  80042023ac:	00 00 00 
  80042023af:	48 8b 08             	mov    (%rax),%rcx
  80042023b2:	48 c7 45 e0 00 10 00 	movq   $0x1000,-0x20(%rbp)
  80042023b9:	00 
  80042023ba:	8b 55 cc             	mov    -0x34(%rbp),%edx
  80042023bd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042023c1:	48 01 d0             	add    %rdx,%rax
  80042023c4:	48 83 e8 01          	sub    $0x1,%rax
  80042023c8:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042023cc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042023d0:	ba 00 00 00 00       	mov    $0x0,%edx
  80042023d5:	48 f7 75 e0          	divq   -0x20(%rbp)
  80042023d9:	48 89 d0             	mov    %rdx,%rax
  80042023dc:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042023e0:	48 29 c2             	sub    %rax,%rdx
  80042023e3:	48 89 d0             	mov    %rdx,%rax
  80042023e6:	89 c0                	mov    %eax,%eax
  80042023e8:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042023ec:	48 b8 48 52 49 04 80 	movabs $0x8004495248,%rax
  80042023f3:	00 00 00 
  80042023f6:	48 89 10             	mov    %rdx,(%rax)
	}

	return result;
  80042023f9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  80042023fd:	c9                   	leaveq 
  80042023fe:	c3                   	retq   

00000080042023ff <x64_vm_init>:
//
// From UTOP to ULIM, the user is allowed to read but not write.
// Above ULIM the user cannot read or write.
void
x64_vm_init(void)
{
  80042023ff:	55                   	push   %rbp
  8004202400:	48 89 e5             	mov    %rsp,%rbp
  8004202403:	48 83 ec 60          	sub    $0x60,%rsp
	pml4e_t* pml4e;
	uint32_t cr0;
	uint64_t n;
	int r;
	struct Env *env;
	i386_detect_memory();
  8004202407:	48 b8 80 20 20 04 80 	movabs $0x8004202080,%rax
  800420240e:	00 00 00 
  8004202411:	ff d0                	callq  *%rax
	//panic("i386_vm_init: This function is not finished\n");
	//////////////////////////////////////////////////////////////////////
	// create initial page directory.
	//panic("x64_vm_init: this function is not finished\n");
	pml4e = boot_alloc(PGSIZE);
  8004202413:	bf 00 10 00 00       	mov    $0x1000,%edi
  8004202418:	48 b8 23 23 20 04 80 	movabs $0x8004202323,%rax
  800420241f:	00 00 00 
  8004202422:	ff d0                	callq  *%rax
  8004202424:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	memset(pml4e, 0, PGSIZE);
  8004202428:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420242c:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004202431:	be 00 00 00 00       	mov    $0x0,%esi
  8004202436:	48 89 c7             	mov    %rax,%rdi
  8004202439:	48 b8 db e8 20 04 80 	movabs $0x800420e8db,%rax
  8004202440:	00 00 00 
  8004202443:	ff d0                	callq  *%rax
	boot_pml4e = pml4e;
  8004202445:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  800420244c:	00 00 00 
  800420244f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202453:	48 89 10             	mov    %rdx,(%rax)
	boot_cr3 = PADDR(pml4e);
  8004202456:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420245a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420245e:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202465:	00 00 00 
  8004202468:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  800420246c:	77 32                	ja     80042024a0 <x64_vm_init+0xa1>
  800420246e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202472:	48 89 c1             	mov    %rax,%rcx
  8004202475:	48 ba 68 63 21 04 80 	movabs $0x8004216368,%rdx
  800420247c:	00 00 00 
  800420247f:	be ff 00 00 00       	mov    $0xff,%esi
  8004202484:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  800420248b:	00 00 00 
  800420248e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202493:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420249a:	00 00 00 
  800420249d:	41 ff d0             	callq  *%r8
  80042024a0:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  80042024a7:	ff ff ff 
  80042024aa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042024ae:	48 01 c2             	add    %rax,%rdx
  80042024b1:	48 b8 a0 67 49 04 80 	movabs $0x80044967a0,%rax
  80042024b8:	00 00 00 
  80042024bb:	48 89 10             	mov    %rdx,(%rax)
	// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.
	// The kernel uses this array to keep track of physical pages: for
	// each physical page, there is a corresponding struct PageInfo in this
	// array.  'npages' is the number of physical pages in memory.
	// Your code goes here:
	pages = boot_alloc(npages * sizeof(struct PageInfo));
  80042024be:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  80042024c5:	00 00 00 
  80042024c8:	48 8b 00             	mov    (%rax),%rax
  80042024cb:	c1 e0 04             	shl    $0x4,%eax
  80042024ce:	89 c7                	mov    %eax,%edi
  80042024d0:	48 b8 23 23 20 04 80 	movabs $0x8004202323,%rax
  80042024d7:	00 00 00 
  80042024da:	ff d0                	callq  *%rax
  80042024dc:	48 ba b8 67 49 04 80 	movabs $0x80044967b8,%rdx
  80042024e3:	00 00 00 
  80042024e6:	48 89 02             	mov    %rax,(%rdx)

	//////////////////////////////////////////////////////////////////////
	// Make 'envs' point to an array of size 'NENV' of 'struct Env'.
	// LAB 3: Your code here.
	envs = boot_alloc(NENV * sizeof(struct Env));
  80042024e9:	bf 00 80 04 00       	mov    $0x48000,%edi
  80042024ee:	48 b8 23 23 20 04 80 	movabs $0x8004202323,%rax
  80042024f5:	00 00 00 
  80042024f8:	ff d0                	callq  *%rax
  80042024fa:	48 ba 50 52 49 04 80 	movabs $0x8004495250,%rdx
  8004202501:	00 00 00 
  8004202504:	48 89 02             	mov    %rax,(%rdx)
	//////////////////////////////////////////////////////////////////////
	// Now that we've allocated the initial kernel data structures, we set
	// up the list of free physical pages. Once we've done so, all further
	// memory management will go through the page_* functions. In
	// particular, we can now map memory using boot_map_region or page_insert
	page_init();
  8004202507:	48 b8 67 29 20 04 80 	movabs $0x8004202967,%rax
  800420250e:	00 00 00 
  8004202511:	ff d0                	callq  *%rax
	// Permissions:
	//    - the new image at UPAGES -- kernel R, us/er R
	//      (ie. perm = PTE_U | PTE_P)
	//    - pages itself -- kernel RW, user NONE
	// Your code goes here:
	boot_map_region(boot_pml4e, UPAGES, PTSIZE, PADDR(pages), PTE_P | PTE_U);
  8004202513:	48 b8 b8 67 49 04 80 	movabs $0x80044967b8,%rax
  800420251a:	00 00 00 
  800420251d:	48 8b 00             	mov    (%rax),%rax
  8004202520:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004202524:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420252b:	00 00 00 
  800420252e:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  8004202532:	77 32                	ja     8004202566 <x64_vm_init+0x167>
  8004202534:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202538:	48 89 c1             	mov    %rax,%rcx
  800420253b:	48 ba 68 63 21 04 80 	movabs $0x8004216368,%rdx
  8004202542:	00 00 00 
  8004202545:	be 1e 01 00 00       	mov    $0x11e,%esi
  800420254a:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004202551:	00 00 00 
  8004202554:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202559:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004202560:	00 00 00 
  8004202563:	41 ff d0             	callq  *%r8
  8004202566:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420256d:	ff ff ff 
  8004202570:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202574:	48 01 c2             	add    %rax,%rdx
  8004202577:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  800420257e:	00 00 00 
  8004202581:	48 8b 00             	mov    (%rax),%rax
  8004202584:	41 b8 05 00 00 00    	mov    $0x5,%r8d
  800420258a:	48 89 d1             	mov    %rdx,%rcx
  800420258d:	ba 00 00 20 00       	mov    $0x200000,%edx
  8004202592:	48 be 00 00 a0 00 80 	movabs $0x8000a00000,%rsi
  8004202599:	00 00 00 
  800420259c:	48 89 c7             	mov    %rax,%rdi
  800420259f:	48 b8 40 32 20 04 80 	movabs $0x8004203240,%rax
  80042025a6:	00 00 00 
  80042025a9:	ff d0                	callq  *%rax
	// (ie. perm = PTE_U | PTE_P).
	// Permissions:
	//    - the new image at UENVS  -- kernel R, user R
	//    - envs itself -- kernel RW, user NONE
	// LAB 3: Your code here.
	boot_map_region(boot_pml4e, UENVS, PTSIZE, PADDR(envs), PTE_P | PTE_U);
  80042025ab:	48 b8 50 52 49 04 80 	movabs $0x8004495250,%rax
  80042025b2:	00 00 00 
  80042025b5:	48 8b 00             	mov    (%rax),%rax
  80042025b8:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042025bc:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042025c3:	00 00 00 
  80042025c6:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  80042025ca:	77 32                	ja     80042025fe <x64_vm_init+0x1ff>
  80042025cc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042025d0:	48 89 c1             	mov    %rax,%rcx
  80042025d3:	48 ba 68 63 21 04 80 	movabs $0x8004216368,%rdx
  80042025da:	00 00 00 
  80042025dd:	be 27 01 00 00       	mov    $0x127,%esi
  80042025e2:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  80042025e9:	00 00 00 
  80042025ec:	b8 00 00 00 00       	mov    $0x0,%eax
  80042025f1:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042025f8:	00 00 00 
  80042025fb:	41 ff d0             	callq  *%r8
  80042025fe:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202605:	ff ff ff 
  8004202608:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420260c:	48 01 c2             	add    %rax,%rdx
  800420260f:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  8004202616:	00 00 00 
  8004202619:	48 8b 00             	mov    (%rax),%rax
  800420261c:	41 b8 05 00 00 00    	mov    $0x5,%r8d
  8004202622:	48 89 d1             	mov    %rdx,%rcx
  8004202625:	ba 00 00 20 00       	mov    $0x200000,%edx
  800420262a:	48 be 00 00 80 00 80 	movabs $0x8000800000,%rsi
  8004202631:	00 00 00 
  8004202634:	48 89 c7             	mov    %rax,%rdi
  8004202637:	48 b8 40 32 20 04 80 	movabs $0x8004203240,%rax
  800420263e:	00 00 00 
  8004202641:	ff d0                	callq  *%rax
	//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if
	//       the kernel overflows its stack, it will fault rather than
	//       overwrite memory.  Known as a "guard page".
	//     Permissions: kernel RW, user NONE
	// Your code goes here:
	boot_map_region(boot_pml4e, KSTACKTOP - KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_P | PTE_W);
  8004202643:	48 b8 00 b0 21 04 80 	movabs $0x800421b000,%rax
  800420264a:	00 00 00 
  800420264d:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004202651:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202658:	00 00 00 
  800420265b:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  800420265f:	77 32                	ja     8004202693 <x64_vm_init+0x294>
  8004202661:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202665:	48 89 c1             	mov    %rax,%rcx
  8004202668:	48 ba 68 63 21 04 80 	movabs $0x8004216368,%rdx
  800420266f:	00 00 00 
  8004202672:	be 34 01 00 00       	mov    $0x134,%esi
  8004202677:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  800420267e:	00 00 00 
  8004202681:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202686:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420268d:	00 00 00 
  8004202690:	41 ff d0             	callq  *%r8
  8004202693:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420269a:	ff ff ff 
  800420269d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042026a1:	48 01 c2             	add    %rax,%rdx
  80042026a4:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  80042026ab:	00 00 00 
  80042026ae:	48 8b 00             	mov    (%rax),%rax
  80042026b1:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  80042026b7:	48 89 d1             	mov    %rdx,%rcx
  80042026ba:	ba 00 00 01 00       	mov    $0x10000,%edx
  80042026bf:	48 be 00 00 ff 03 80 	movabs $0x8003ff0000,%rsi
  80042026c6:	00 00 00 
  80042026c9:	48 89 c7             	mov    %rax,%rdi
  80042026cc:	48 b8 40 32 20 04 80 	movabs $0x8004203240,%rax
  80042026d3:	00 00 00 
  80042026d6:	ff d0                	callq  *%rax
	// of physical pages to be npages.
	// Ie.  the VA range [KERNBASE, npages*PGSIZE) should map to
	//      the PA range [0, npages*PGSIZE)
	// Permissions: kernel RW, user NONE
	// Your code goes here: 
	boot_map_region(boot_pml4e, KERNBASE, npages * PGSIZE, 0, PTE_P | PTE_W);
  80042026d8:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  80042026df:	00 00 00 
  80042026e2:	48 8b 00             	mov    (%rax),%rax
  80042026e5:	48 c1 e0 0c          	shl    $0xc,%rax
  80042026e9:	48 89 c2             	mov    %rax,%rdx
  80042026ec:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  80042026f3:	00 00 00 
  80042026f6:	48 8b 00             	mov    (%rax),%rax
  80042026f9:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  80042026ff:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004202704:	48 be 00 00 00 04 80 	movabs $0x8004000000,%rsi
  800420270b:	00 00 00 
  800420270e:	48 89 c7             	mov    %rax,%rdi
  8004202711:	48 b8 40 32 20 04 80 	movabs $0x8004203240,%rax
  8004202718:	00 00 00 
  800420271b:	ff d0                	callq  *%rax

	// Check that the initial page directory has been set up correctly.
	// Initialize the SMP-related parts of the memory map
	mem_init_mp();
  800420271d:	48 b8 8d 28 20 04 80 	movabs $0x800420288d,%rax
  8004202724:	00 00 00 
  8004202727:	ff d0                	callq  *%rax

	check_boot_pml4e(boot_pml4e);
  8004202729:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  8004202730:	00 00 00 
  8004202733:	48 8b 00             	mov    (%rax),%rax
  8004202736:	48 89 c7             	mov    %rax,%rdi
  8004202739:	48 b8 fd 47 20 04 80 	movabs $0x80042047fd,%rax
  8004202740:	00 00 00 
  8004202743:	ff d0                	callq  *%rax

	//////////////////////////////////////////////////////////////////////
	// Permissions: kernel RW, user NONE
	pdpe_t *pdpe = KADDR(PTE_ADDR(pml4e[1]));
  8004202745:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202749:	48 83 c0 08          	add    $0x8,%rax
  800420274d:	48 8b 00             	mov    (%rax),%rax
  8004202750:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004202756:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  800420275a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420275e:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202762:	89 45 cc             	mov    %eax,-0x34(%rbp)
  8004202765:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004202768:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  800420276f:	00 00 00 
  8004202772:	48 8b 00             	mov    (%rax),%rax
  8004202775:	48 39 c2             	cmp    %rax,%rdx
  8004202778:	72 32                	jb     80042027ac <x64_vm_init+0x3ad>
  800420277a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420277e:	48 89 c1             	mov    %rax,%rcx
  8004202781:	48 ba e0 61 21 04 80 	movabs $0x80042161e0,%rdx
  8004202788:	00 00 00 
  800420278b:	be 4c 01 00 00       	mov    $0x14c,%esi
  8004202790:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004202797:	00 00 00 
  800420279a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420279f:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042027a6:	00 00 00 
  80042027a9:	41 ff d0             	callq  *%r8
  80042027ac:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042027b3:	00 00 00 
  80042027b6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042027ba:	48 01 d0             	add    %rdx,%rax
  80042027bd:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
	pde_t *pgdir = KADDR(PTE_ADDR(pdpe[0]));
  80042027c1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042027c5:	48 8b 00             	mov    (%rax),%rax
  80042027c8:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042027ce:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  80042027d2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042027d6:	48 c1 e8 0c          	shr    $0xc,%rax
  80042027da:	89 45 b4             	mov    %eax,-0x4c(%rbp)
  80042027dd:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  80042027e0:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  80042027e7:	00 00 00 
  80042027ea:	48 8b 00             	mov    (%rax),%rax
  80042027ed:	48 39 c2             	cmp    %rax,%rdx
  80042027f0:	72 32                	jb     8004202824 <x64_vm_init+0x425>
  80042027f2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042027f6:	48 89 c1             	mov    %rax,%rcx
  80042027f9:	48 ba e0 61 21 04 80 	movabs $0x80042161e0,%rdx
  8004202800:	00 00 00 
  8004202803:	be 4d 01 00 00       	mov    $0x14d,%esi
  8004202808:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  800420280f:	00 00 00 
  8004202812:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202817:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420281e:	00 00 00 
  8004202821:	41 ff d0             	callq  *%r8
  8004202824:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420282b:	00 00 00 
  800420282e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202832:	48 01 d0             	add    %rdx,%rax
  8004202835:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	lcr3(boot_cr3);
  8004202839:	48 b8 a0 67 49 04 80 	movabs $0x80044967a0,%rax
  8004202840:	00 00 00 
  8004202843:	48 8b 00             	mov    (%rax),%rax
  8004202846:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  800420284a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420284e:	0f 22 d8             	mov    %rax,%cr3

	check_page_free_list(1);
  8004202851:	bf 01 00 00 00       	mov    $0x1,%edi
  8004202856:	48 b8 e4 38 20 04 80 	movabs $0x80042038e4,%rax
  800420285d:	00 00 00 
  8004202860:	ff d0                	callq  *%rax
	check_page_alloc();
  8004202862:	48 b8 11 3e 20 04 80 	movabs $0x8004203e11,%rax
  8004202869:	00 00 00 
  800420286c:	ff d0                	callq  *%rax
	page_check();
  800420286e:	48 b8 c5 51 20 04 80 	movabs $0x80042051c5,%rax
  8004202875:	00 00 00 
  8004202878:	ff d0                	callq  *%rax
	check_page_free_list(0);
  800420287a:	bf 00 00 00 00       	mov    $0x0,%edi
  800420287f:	48 b8 e4 38 20 04 80 	movabs $0x80042038e4,%rax
  8004202886:	00 00 00 
  8004202889:	ff d0                	callq  *%rax
}
  800420288b:	c9                   	leaveq 
  800420288c:	c3                   	retq   

000000800420288d <mem_init_mp>:
// Modify mappings in boot_pml4e to support SMP
//   - Map the per-CPU stacks in the region [KSTACKTOP-PTSIZE, KSTACKTOP)
//
static void
mem_init_mp(void)
{
  800420288d:	55                   	push   %rbp
  800420288e:	48 89 e5             	mov    %rsp,%rbp
  8004202891:	48 83 ec 20          	sub    $0x20,%rsp
	//             Known as a "guard page".
	//     Permissions: kernel RW, user NONE
	//
	// LAB 4: Your code here:
	size_t i;
	uintptr_t la = KSTACKTOP - KSTKSIZE;
  8004202895:	48 b8 00 00 ff 03 80 	movabs $0x8003ff0000,%rax
  800420289c:	00 00 00 
  800420289f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	for (i = 0; i < NCPU; i++) {
  80042028a3:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042028aa:	00 
  80042028ab:	e9 aa 00 00 00       	jmpq   800420295a <mem_init_mp+0xcd>
		boot_map_region(boot_pml4e, la, KSTKSIZE, PADDR(percpu_kstacks[i]), PTE_P | PTE_W);
  80042028b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042028b4:	48 c1 e0 10          	shl    $0x10,%rax
  80042028b8:	48 89 c2             	mov    %rax,%rdx
  80042028bb:	48 b8 00 90 49 04 80 	movabs $0x8004499000,%rax
  80042028c2:	00 00 00 
  80042028c5:	48 01 d0             	add    %rdx,%rax
  80042028c8:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  80042028cc:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042028d3:	00 00 00 
  80042028d6:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80042028da:	77 32                	ja     800420290e <mem_init_mp+0x81>
  80042028dc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042028e0:	48 89 c1             	mov    %rax,%rcx
  80042028e3:	48 ba 68 63 21 04 80 	movabs $0x8004216368,%rdx
  80042028ea:	00 00 00 
  80042028ed:	be 71 01 00 00       	mov    $0x171,%esi
  80042028f2:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  80042028f9:	00 00 00 
  80042028fc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202901:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004202908:	00 00 00 
  800420290b:	41 ff d0             	callq  *%r8
  800420290e:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202915:	ff ff ff 
  8004202918:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420291c:	48 01 c2             	add    %rax,%rdx
  800420291f:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  8004202926:	00 00 00 
  8004202929:	48 8b 00             	mov    (%rax),%rax
  800420292c:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8004202930:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  8004202936:	48 89 d1             	mov    %rdx,%rcx
  8004202939:	ba 00 00 01 00       	mov    $0x10000,%edx
  800420293e:	48 89 c7             	mov    %rax,%rdi
  8004202941:	48 b8 40 32 20 04 80 	movabs $0x8004203240,%rax
  8004202948:	00 00 00 
  800420294b:	ff d0                	callq  *%rax
		la -= KSTKSIZE + KSTKGAP;
  800420294d:	48 81 6d f0 00 80 01 	subq   $0x18000,-0x10(%rbp)
  8004202954:	00 
	//
	// LAB 4: Your code here:
	size_t i;
	uintptr_t la = KSTACKTOP - KSTKSIZE;

	for (i = 0; i < NCPU; i++) {
  8004202955:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420295a:	48 83 7d f8 07       	cmpq   $0x7,-0x8(%rbp)
  800420295f:	0f 86 4b ff ff ff    	jbe    80042028b0 <mem_init_mp+0x23>
		boot_map_region(boot_pml4e, la, KSTKSIZE, PADDR(percpu_kstacks[i]), PTE_P | PTE_W);
		la -= KSTKSIZE + KSTKGAP;
	}
}
  8004202965:	c9                   	leaveq 
  8004202966:	c3                   	retq   

0000008004202967 <page_init>:
// allocator functions below to allocate and deallocate physical
// memory via the page_free_list.
//
void
page_init(void)
{
  8004202967:	55                   	push   %rbp
  8004202968:	48 89 e5             	mov    %rsp,%rbp
  800420296b:	53                   	push   %rbx
  800420296c:	48 83 ec 28          	sub    $0x28,%rsp
	// NB: Make sure you preserve the direction in which your page_free_list 
	// is constructed
	// NB: Remember to mark the memory used for initial boot page table i.e (va>=BOOT_PAGE_TABLE_START && va < BOOT_PAGE_TABLE_END) as in-use (not free)
	size_t i;
	uint64_t kva;
	struct PageInfo* last = NULL;
  8004202970:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  8004202977:	00 

	for (i = npages - 1; i > 0; i--) {
  8004202978:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  800420297f:	00 00 00 
  8004202982:	48 8b 00             	mov    (%rax),%rax
  8004202985:	48 83 e8 01          	sub    $0x1,%rax
  8004202989:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420298d:	e9 ce 01 00 00       	jmpq   8004202b60 <page_init+0x1f9>
		if (page2pa(&pages[i]) >= PADDR(KERNBASE + IOPHYSMEM) && page2pa(&pages[i]) < PADDR(boot_alloc(0)))
  8004202992:	48 b8 b8 67 49 04 80 	movabs $0x80044967b8,%rax
  8004202999:	00 00 00 
  800420299c:	48 8b 00             	mov    (%rax),%rax
  800420299f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042029a3:	48 c1 e2 04          	shl    $0x4,%rdx
  80042029a7:	48 01 d0             	add    %rdx,%rax
  80042029aa:	48 89 c7             	mov    %rax,%rdi
  80042029ad:	48 b8 64 19 20 04 80 	movabs $0x8004201964,%rax
  80042029b4:	00 00 00 
  80042029b7:	ff d0                	callq  *%rax
  80042029b9:	48 be 00 00 0a 04 80 	movabs $0x80040a0000,%rsi
  80042029c0:	00 00 00 
  80042029c3:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
  80042029c7:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  80042029ce:	00 00 00 
  80042029d1:	48 39 55 d8          	cmp    %rdx,-0x28(%rbp)
  80042029d5:	77 32                	ja     8004202a09 <page_init+0xa2>
  80042029d7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042029db:	48 89 c1             	mov    %rax,%rcx
  80042029de:	48 ba 68 63 21 04 80 	movabs $0x8004216368,%rdx
  80042029e5:	00 00 00 
  80042029e8:	be a2 01 00 00       	mov    $0x1a2,%esi
  80042029ed:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  80042029f4:	00 00 00 
  80042029f7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042029fc:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004202a03:	00 00 00 
  8004202a06:	41 ff d0             	callq  *%r8
  8004202a09:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  8004202a10:	ff ff ff 
  8004202a13:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004202a17:	48 01 ca             	add    %rcx,%rdx
  8004202a1a:	48 39 d0             	cmp    %rdx,%rax
  8004202a1d:	0f 82 9c 00 00 00    	jb     8004202abf <page_init+0x158>
  8004202a23:	48 b8 b8 67 49 04 80 	movabs $0x80044967b8,%rax
  8004202a2a:	00 00 00 
  8004202a2d:	48 8b 00             	mov    (%rax),%rax
  8004202a30:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004202a34:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202a38:	48 01 d0             	add    %rdx,%rax
  8004202a3b:	48 89 c7             	mov    %rax,%rdi
  8004202a3e:	48 b8 64 19 20 04 80 	movabs $0x8004201964,%rax
  8004202a45:	00 00 00 
  8004202a48:	ff d0                	callq  *%rax
  8004202a4a:	48 89 c3             	mov    %rax,%rbx
  8004202a4d:	bf 00 00 00 00       	mov    $0x0,%edi
  8004202a52:	48 b8 23 23 20 04 80 	movabs $0x8004202323,%rax
  8004202a59:	00 00 00 
  8004202a5c:	ff d0                	callq  *%rax
  8004202a5e:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004202a62:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202a69:	00 00 00 
  8004202a6c:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  8004202a70:	77 32                	ja     8004202aa4 <page_init+0x13d>
  8004202a72:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004202a76:	48 89 c1             	mov    %rax,%rcx
  8004202a79:	48 ba 68 63 21 04 80 	movabs $0x8004216368,%rdx
  8004202a80:	00 00 00 
  8004202a83:	be a2 01 00 00       	mov    $0x1a2,%esi
  8004202a88:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004202a8f:	00 00 00 
  8004202a92:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202a97:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004202a9e:	00 00 00 
  8004202aa1:	41 ff d0             	callq  *%r8
  8004202aa4:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202aab:	ff ff ff 
  8004202aae:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004202ab2:	48 01 d0             	add    %rdx,%rax
  8004202ab5:	48 39 c3             	cmp    %rax,%rbx
  8004202ab8:	73 05                	jae    8004202abf <page_init+0x158>
			continue;
  8004202aba:	e9 9c 00 00 00       	jmpq   8004202b5b <page_init+0x1f4>
		if (page2pa(&pages[i]) == MPENTRY_PADDR)
  8004202abf:	48 b8 b8 67 49 04 80 	movabs $0x80044967b8,%rax
  8004202ac6:	00 00 00 
  8004202ac9:	48 8b 00             	mov    (%rax),%rax
  8004202acc:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004202ad0:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202ad4:	48 01 d0             	add    %rdx,%rax
  8004202ad7:	48 89 c7             	mov    %rax,%rdi
  8004202ada:	48 b8 64 19 20 04 80 	movabs $0x8004201964,%rax
  8004202ae1:	00 00 00 
  8004202ae4:	ff d0                	callq  *%rax
  8004202ae6:	48 3d 00 70 00 00    	cmp    $0x7000,%rax
  8004202aec:	75 02                	jne    8004202af0 <page_init+0x189>
			continue;
  8004202aee:	eb 6b                	jmp    8004202b5b <page_init+0x1f4>
		pages[i].pp_ref = 0;
  8004202af0:	48 b8 b8 67 49 04 80 	movabs $0x80044967b8,%rax
  8004202af7:	00 00 00 
  8004202afa:	48 8b 00             	mov    (%rax),%rax
  8004202afd:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004202b01:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202b05:	48 01 d0             	add    %rdx,%rax
  8004202b08:	66 c7 40 08 00 00    	movw   $0x0,0x8(%rax)
		pages[i].pp_link = page_free_list;
  8004202b0e:	48 b8 b8 67 49 04 80 	movabs $0x80044967b8,%rax
  8004202b15:	00 00 00 
  8004202b18:	48 8b 00             	mov    (%rax),%rax
  8004202b1b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004202b1f:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202b23:	48 01 c2             	add    %rax,%rdx
  8004202b26:	48 b8 38 52 49 04 80 	movabs $0x8004495238,%rax
  8004202b2d:	00 00 00 
  8004202b30:	48 8b 00             	mov    (%rax),%rax
  8004202b33:	48 89 02             	mov    %rax,(%rdx)
		page_free_list = &pages[i];
  8004202b36:	48 b8 b8 67 49 04 80 	movabs $0x80044967b8,%rax
  8004202b3d:	00 00 00 
  8004202b40:	48 8b 00             	mov    (%rax),%rax
  8004202b43:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004202b47:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202b4b:	48 01 c2             	add    %rax,%rdx
  8004202b4e:	48 b8 38 52 49 04 80 	movabs $0x8004495238,%rax
  8004202b55:	00 00 00 
  8004202b58:	48 89 10             	mov    %rdx,(%rax)
	// NB: Remember to mark the memory used for initial boot page table i.e (va>=BOOT_PAGE_TABLE_START && va < BOOT_PAGE_TABLE_END) as in-use (not free)
	size_t i;
	uint64_t kva;
	struct PageInfo* last = NULL;

	for (i = npages - 1; i > 0; i--) {
  8004202b5b:	48 83 6d e8 01       	subq   $0x1,-0x18(%rbp)
  8004202b60:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004202b65:	0f 85 27 fe ff ff    	jne    8004202992 <page_init+0x2b>
			continue;
		pages[i].pp_ref = 0;
		pages[i].pp_link = page_free_list;
		page_free_list = &pages[i];
	}
}
  8004202b6b:	48 83 c4 28          	add    $0x28,%rsp
  8004202b6f:	5b                   	pop    %rbx
  8004202b70:	5d                   	pop    %rbp
  8004202b71:	c3                   	retq   

0000008004202b72 <page_alloc>:
// Returns NULL if out of free memory.
//
// Hint: use page2kva and memset
struct PageInfo *
page_alloc(int alloc_flags)
{
  8004202b72:	55                   	push   %rbp
  8004202b73:	48 89 e5             	mov    %rsp,%rbp
  8004202b76:	48 83 ec 20          	sub    $0x20,%rsp
  8004202b7a:	89 7d ec             	mov    %edi,-0x14(%rbp)
	// Fill this function in
	struct PageInfo *pp = page_free_list;
  8004202b7d:	48 b8 38 52 49 04 80 	movabs $0x8004495238,%rax
  8004202b84:	00 00 00 
  8004202b87:	48 8b 00             	mov    (%rax),%rax
  8004202b8a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (pp) {
  8004202b8e:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004202b93:	74 4b                	je     8004202be0 <page_alloc+0x6e>
		page_free_list = pp->pp_link;
  8004202b95:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202b99:	48 8b 10             	mov    (%rax),%rdx
  8004202b9c:	48 b8 38 52 49 04 80 	movabs $0x8004495238,%rax
  8004202ba3:	00 00 00 
  8004202ba6:	48 89 10             	mov    %rdx,(%rax)
		pp->pp_link = NULL;
  8004202ba9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202bad:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		memset(page2kva(pp), 0, PGSIZE);
  8004202bb4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202bb8:	48 89 c7             	mov    %rax,%rdi
  8004202bbb:	48 b8 fa 19 20 04 80 	movabs $0x80042019fa,%rax
  8004202bc2:	00 00 00 
  8004202bc5:	ff d0                	callq  *%rax
  8004202bc7:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004202bcc:	be 00 00 00 00       	mov    $0x0,%esi
  8004202bd1:	48 89 c7             	mov    %rax,%rdi
  8004202bd4:	48 b8 db e8 20 04 80 	movabs $0x800420e8db,%rax
  8004202bdb:	00 00 00 
  8004202bde:	ff d0                	callq  *%rax
	}

	return pp;
  8004202be0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004202be4:	c9                   	leaveq 
  8004202be5:	c3                   	retq   

0000008004202be6 <page_initpp>:
// The result has null links and 0 refcount.
// Note that the corresponding physical page is NOT initialized!
//
static void
page_initpp(struct PageInfo *pp)
{
  8004202be6:	55                   	push   %rbp
  8004202be7:	48 89 e5             	mov    %rsp,%rbp
  8004202bea:	48 83 ec 10          	sub    $0x10,%rsp
  8004202bee:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	memset(pp, 0, sizeof(*pp));
  8004202bf2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202bf6:	ba 10 00 00 00       	mov    $0x10,%edx
  8004202bfb:	be 00 00 00 00       	mov    $0x0,%esi
  8004202c00:	48 89 c7             	mov    %rax,%rdi
  8004202c03:	48 b8 db e8 20 04 80 	movabs $0x800420e8db,%rax
  8004202c0a:	00 00 00 
  8004202c0d:	ff d0                	callq  *%rax
}
  8004202c0f:	c9                   	leaveq 
  8004202c10:	c3                   	retq   

0000008004202c11 <page_free>:
// Return a page to the free list.
// (This function should only be called when pp->pp_ref reaches 0.)
//
void
page_free(struct PageInfo *pp)
{
  8004202c11:	55                   	push   %rbp
  8004202c12:	48 89 e5             	mov    %rsp,%rbp
  8004202c15:	48 83 ec 10          	sub    $0x10,%rsp
  8004202c19:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// Fill this function in
	// Hint: You may want to panic if pp->pp_ref is nonzero or
	// pp->pp_link is not NULL.
	if (pp) {
  8004202c1d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004202c22:	74 57                	je     8004202c7b <page_free+0x6a>
		if (pp->pp_ref || pp->pp_link)
  8004202c24:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202c28:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004202c2c:	66 85 c0             	test   %ax,%ax
  8004202c2f:	75 0c                	jne    8004202c3d <page_free+0x2c>
  8004202c31:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202c35:	48 8b 00             	mov    (%rax),%rax
  8004202c38:	48 85 c0             	test   %rax,%rax
  8004202c3b:	74 2a                	je     8004202c67 <page_free+0x56>
			panic("page still in use");
  8004202c3d:	48 ba 8c 63 21 04 80 	movabs $0x800421638c,%rdx
  8004202c44:	00 00 00 
  8004202c47:	be dc 01 00 00       	mov    $0x1dc,%esi
  8004202c4c:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004202c53:	00 00 00 
  8004202c56:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202c5b:	48 b9 ae 04 20 04 80 	movabs $0x80042004ae,%rcx
  8004202c62:	00 00 00 
  8004202c65:	ff d1                	callq  *%rcx
		pp->pp_link = page_free_list;
  8004202c67:	48 b8 38 52 49 04 80 	movabs $0x8004495238,%rax
  8004202c6e:	00 00 00 
  8004202c71:	48 8b 10             	mov    (%rax),%rdx
  8004202c74:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202c78:	48 89 10             	mov    %rdx,(%rax)
	}
	page_free_list = pp;
  8004202c7b:	48 b8 38 52 49 04 80 	movabs $0x8004495238,%rax
  8004202c82:	00 00 00 
  8004202c85:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202c89:	48 89 10             	mov    %rdx,(%rax)
}
  8004202c8c:	c9                   	leaveq 
  8004202c8d:	c3                   	retq   

0000008004202c8e <page_decref>:
// Decrement the reference count on a page,
// freeing it if there are no more refs.
//
void
page_decref(struct PageInfo* pp)
{
  8004202c8e:	55                   	push   %rbp
  8004202c8f:	48 89 e5             	mov    %rsp,%rbp
  8004202c92:	48 83 ec 10          	sub    $0x10,%rsp
  8004202c96:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (--pp->pp_ref == 0)
  8004202c9a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202c9e:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004202ca2:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004202ca5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202ca9:	66 89 50 08          	mov    %dx,0x8(%rax)
  8004202cad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202cb1:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004202cb5:	66 85 c0             	test   %ax,%ax
  8004202cb8:	75 13                	jne    8004202ccd <page_decref+0x3f>
		page_free(pp);
  8004202cba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202cbe:	48 89 c7             	mov    %rax,%rdi
  8004202cc1:	48 b8 11 2c 20 04 80 	movabs $0x8004202c11,%rax
  8004202cc8:	00 00 00 
  8004202ccb:	ff d0                	callq  *%rax
}
  8004202ccd:	c9                   	leaveq 
  8004202cce:	c3                   	retq   

0000008004202ccf <pml4e_walk>:
// table, page directory,page directory pointer and pml4 entries.
//

pte_t *
pml4e_walk(pml4e_t *pml4e, const void *va, int create)
{
  8004202ccf:	55                   	push   %rbp
  8004202cd0:	48 89 e5             	mov    %rsp,%rbp
  8004202cd3:	48 83 ec 50          	sub    $0x50,%rsp
  8004202cd7:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004202cdb:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004202cdf:	89 55 bc             	mov    %edx,-0x44(%rbp)
	pte_t *ptep = NULL;
  8004202ce2:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004202ce9:	00 
	pml4e_t *pml4ep = NULL;
  8004202cea:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004202cf1:	00 
	pml4ep = pml4e + PML4(va);
  8004202cf2:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202cf6:	48 c1 e8 27          	shr    $0x27,%rax
  8004202cfa:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004202cff:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004202d06:	00 
  8004202d07:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202d0b:	48 01 d0             	add    %rdx,%rax
  8004202d0e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (!(*pml4ep & PTE_P)) {
  8004202d12:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202d16:	48 8b 00             	mov    (%rax),%rax
  8004202d19:	83 e0 01             	and    $0x1,%eax
  8004202d1c:	48 85 c0             	test   %rax,%rax
  8004202d1f:	0f 85 20 01 00 00    	jne    8004202e45 <pml4e_walk+0x176>
		if (!create)
  8004202d25:	83 7d bc 00          	cmpl   $0x0,-0x44(%rbp)
  8004202d29:	75 0a                	jne    8004202d35 <pml4e_walk+0x66>
			return NULL;
  8004202d2b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202d30:	e9 a5 01 00 00       	jmpq   8004202eda <pml4e_walk+0x20b>
		struct PageInfo *pp = page_alloc(ALLOC_ZERO);
  8004202d35:	bf 01 00 00 00       	mov    $0x1,%edi
  8004202d3a:	48 b8 72 2b 20 04 80 	movabs $0x8004202b72,%rax
  8004202d41:	00 00 00 
  8004202d44:	ff d0                	callq  *%rax
  8004202d46:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		if (pp == NULL)
  8004202d4a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004202d4f:	75 0a                	jne    8004202d5b <pml4e_walk+0x8c>
			return NULL;
  8004202d51:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202d56:	e9 7f 01 00 00       	jmpq   8004202eda <pml4e_walk+0x20b>
		pp->pp_ref++;
  8004202d5b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202d5f:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004202d63:	8d 50 01             	lea    0x1(%rax),%edx
  8004202d66:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202d6a:	66 89 50 08          	mov    %dx,0x8(%rax)
		*pml4ep = PADDR(page2kva(pp)) | PTE_P | PTE_W | PTE_U;
  8004202d6e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202d72:	48 89 c7             	mov    %rax,%rdi
  8004202d75:	48 b8 fa 19 20 04 80 	movabs $0x80042019fa,%rax
  8004202d7c:	00 00 00 
  8004202d7f:	ff d0                	callq  *%rax
  8004202d81:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004202d85:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202d8c:	00 00 00 
  8004202d8f:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  8004202d93:	77 32                	ja     8004202dc7 <pml4e_walk+0xf8>
  8004202d95:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202d99:	48 89 c1             	mov    %rax,%rcx
  8004202d9c:	48 ba 68 63 21 04 80 	movabs $0x8004216368,%rdx
  8004202da3:	00 00 00 
  8004202da6:	be 13 02 00 00       	mov    $0x213,%esi
  8004202dab:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004202db2:	00 00 00 
  8004202db5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202dba:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004202dc1:	00 00 00 
  8004202dc4:	41 ff d0             	callq  *%r8
  8004202dc7:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202dce:	ff ff ff 
  8004202dd1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202dd5:	48 01 d0             	add    %rdx,%rax
  8004202dd8:	48 83 c8 07          	or     $0x7,%rax
  8004202ddc:	48 89 c2             	mov    %rax,%rdx
  8004202ddf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202de3:	48 89 10             	mov    %rdx,(%rax)
		ptep = pdpe_walk((pdpe_t *)page2kva(pp), va, create);
  8004202de6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202dea:	48 89 c7             	mov    %rax,%rdi
  8004202ded:	48 b8 fa 19 20 04 80 	movabs $0x80042019fa,%rax
  8004202df4:	00 00 00 
  8004202df7:	ff d0                	callq  *%rax
  8004202df9:	8b 55 bc             	mov    -0x44(%rbp),%edx
  8004202dfc:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8004202e00:	48 89 ce             	mov    %rcx,%rsi
  8004202e03:	48 89 c7             	mov    %rax,%rdi
  8004202e06:	48 b8 dc 2e 20 04 80 	movabs $0x8004202edc,%rax
  8004202e0d:	00 00 00 
  8004202e10:	ff d0                	callq  *%rax
  8004202e12:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (ptep == NULL) {
  8004202e16:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004202e1b:	75 23                	jne    8004202e40 <pml4e_walk+0x171>
			page_decref(pp);
  8004202e1d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202e21:	48 89 c7             	mov    %rax,%rdi
  8004202e24:	48 b8 8e 2c 20 04 80 	movabs $0x8004202c8e,%rax
  8004202e2b:	00 00 00 
  8004202e2e:	ff d0                	callq  *%rax
			*pml4ep = 0;
  8004202e30:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202e34:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  8004202e3b:	e9 96 00 00 00       	jmpq   8004202ed6 <pml4e_walk+0x207>
  8004202e40:	e9 91 00 00 00       	jmpq   8004202ed6 <pml4e_walk+0x207>
		}
	} else {
		ptep = pdpe_walk((pdpe_t *)KADDR(PTE_ADDR(*pml4ep)), va, create);
  8004202e45:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202e49:	48 8b 00             	mov    (%rax),%rax
  8004202e4c:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004202e52:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004202e56:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202e5a:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202e5e:	89 45 d4             	mov    %eax,-0x2c(%rbp)
  8004202e61:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004202e64:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  8004202e6b:	00 00 00 
  8004202e6e:	48 8b 00             	mov    (%rax),%rax
  8004202e71:	48 39 c2             	cmp    %rax,%rdx
  8004202e74:	72 32                	jb     8004202ea8 <pml4e_walk+0x1d9>
  8004202e76:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202e7a:	48 89 c1             	mov    %rax,%rcx
  8004202e7d:	48 ba e0 61 21 04 80 	movabs $0x80042161e0,%rdx
  8004202e84:	00 00 00 
  8004202e87:	be 1a 02 00 00       	mov    $0x21a,%esi
  8004202e8c:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004202e93:	00 00 00 
  8004202e96:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202e9b:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004202ea2:	00 00 00 
  8004202ea5:	41 ff d0             	callq  *%r8
  8004202ea8:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202eaf:	00 00 00 
  8004202eb2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202eb6:	48 01 d0             	add    %rdx,%rax
  8004202eb9:	8b 55 bc             	mov    -0x44(%rbp),%edx
  8004202ebc:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8004202ec0:	48 89 ce             	mov    %rcx,%rsi
  8004202ec3:	48 89 c7             	mov    %rax,%rdi
  8004202ec6:	48 b8 dc 2e 20 04 80 	movabs $0x8004202edc,%rax
  8004202ecd:	00 00 00 
  8004202ed0:	ff d0                	callq  *%rax
  8004202ed2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	}

	return ptep;
  8004202ed6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004202eda:	c9                   	leaveq 
  8004202edb:	c3                   	retq   

0000008004202edc <pdpe_walk>:
// The programming logic in this function is similar to pml4e_walk.
// It calls the pgdir_walk which returns the page_table entry pointer.
// Hints are the same as in pml4e_walk
pte_t *
pdpe_walk(pdpe_t *pdpe,const void *va,int create)
{
  8004202edc:	55                   	push   %rbp
  8004202edd:	48 89 e5             	mov    %rsp,%rbp
  8004202ee0:	48 83 ec 50          	sub    $0x50,%rsp
  8004202ee4:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004202ee8:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004202eec:	89 55 bc             	mov    %edx,-0x44(%rbp)
	pte_t *ptep = NULL;
  8004202eef:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004202ef6:	00 
	pdpe_t *pdpep = NULL;
  8004202ef7:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004202efe:	00 
	pdpep = pdpe + PDPE(va);
  8004202eff:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202f03:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004202f07:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004202f0c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004202f13:	00 
  8004202f14:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202f18:	48 01 d0             	add    %rdx,%rax
  8004202f1b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (!(*pdpep & PTE_P)) {
  8004202f1f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202f23:	48 8b 00             	mov    (%rax),%rax
  8004202f26:	83 e0 01             	and    $0x1,%eax
  8004202f29:	48 85 c0             	test   %rax,%rax
  8004202f2c:	0f 85 20 01 00 00    	jne    8004203052 <pdpe_walk+0x176>
		if (!create)
  8004202f32:	83 7d bc 00          	cmpl   $0x0,-0x44(%rbp)
  8004202f36:	75 0a                	jne    8004202f42 <pdpe_walk+0x66>
			return NULL;
  8004202f38:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202f3d:	e9 a5 01 00 00       	jmpq   80042030e7 <pdpe_walk+0x20b>
		struct PageInfo *pp = page_alloc(ALLOC_ZERO);
  8004202f42:	bf 01 00 00 00       	mov    $0x1,%edi
  8004202f47:	48 b8 72 2b 20 04 80 	movabs $0x8004202b72,%rax
  8004202f4e:	00 00 00 
  8004202f51:	ff d0                	callq  *%rax
  8004202f53:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		if (pp == NULL)
  8004202f57:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004202f5c:	75 0a                	jne    8004202f68 <pdpe_walk+0x8c>
			return NULL;
  8004202f5e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202f63:	e9 7f 01 00 00       	jmpq   80042030e7 <pdpe_walk+0x20b>
		pp->pp_ref++;
  8004202f68:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202f6c:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004202f70:	8d 50 01             	lea    0x1(%rax),%edx
  8004202f73:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202f77:	66 89 50 08          	mov    %dx,0x8(%rax)
		*pdpep = PADDR(page2kva(pp)) | PTE_P | PTE_W | PTE_U;
  8004202f7b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202f7f:	48 89 c7             	mov    %rax,%rdi
  8004202f82:	48 b8 fa 19 20 04 80 	movabs $0x80042019fa,%rax
  8004202f89:	00 00 00 
  8004202f8c:	ff d0                	callq  *%rax
  8004202f8e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004202f92:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202f99:	00 00 00 
  8004202f9c:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  8004202fa0:	77 32                	ja     8004202fd4 <pdpe_walk+0xf8>
  8004202fa2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202fa6:	48 89 c1             	mov    %rax,%rcx
  8004202fa9:	48 ba 68 63 21 04 80 	movabs $0x8004216368,%rdx
  8004202fb0:	00 00 00 
  8004202fb3:	be 32 02 00 00       	mov    $0x232,%esi
  8004202fb8:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004202fbf:	00 00 00 
  8004202fc2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202fc7:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004202fce:	00 00 00 
  8004202fd1:	41 ff d0             	callq  *%r8
  8004202fd4:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202fdb:	ff ff ff 
  8004202fde:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202fe2:	48 01 d0             	add    %rdx,%rax
  8004202fe5:	48 83 c8 07          	or     $0x7,%rax
  8004202fe9:	48 89 c2             	mov    %rax,%rdx
  8004202fec:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202ff0:	48 89 10             	mov    %rdx,(%rax)
		ptep = pgdir_walk((pde_t *)page2kva(pp), va, create);
  8004202ff3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202ff7:	48 89 c7             	mov    %rax,%rdi
  8004202ffa:	48 b8 fa 19 20 04 80 	movabs $0x80042019fa,%rax
  8004203001:	00 00 00 
  8004203004:	ff d0                	callq  *%rax
  8004203006:	8b 55 bc             	mov    -0x44(%rbp),%edx
  8004203009:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  800420300d:	48 89 ce             	mov    %rcx,%rsi
  8004203010:	48 89 c7             	mov    %rax,%rdi
  8004203013:	48 b8 e9 30 20 04 80 	movabs $0x80042030e9,%rax
  800420301a:	00 00 00 
  800420301d:	ff d0                	callq  *%rax
  800420301f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (ptep == NULL) {
  8004203023:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203028:	75 23                	jne    800420304d <pdpe_walk+0x171>
			page_decref(pp);
  800420302a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420302e:	48 89 c7             	mov    %rax,%rdi
  8004203031:	48 b8 8e 2c 20 04 80 	movabs $0x8004202c8e,%rax
  8004203038:	00 00 00 
  800420303b:	ff d0                	callq  *%rax
			*pdpep = 0;
  800420303d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203041:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  8004203048:	e9 96 00 00 00       	jmpq   80042030e3 <pdpe_walk+0x207>
  800420304d:	e9 91 00 00 00       	jmpq   80042030e3 <pdpe_walk+0x207>
		}
	} else {
		ptep = pgdir_walk((pde_t *)KADDR(PTE_ADDR(*pdpep)), va, create);
  8004203052:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203056:	48 8b 00             	mov    (%rax),%rax
  8004203059:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420305f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004203063:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203067:	48 c1 e8 0c          	shr    $0xc,%rax
  800420306b:	89 45 d4             	mov    %eax,-0x2c(%rbp)
  800420306e:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004203071:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  8004203078:	00 00 00 
  800420307b:	48 8b 00             	mov    (%rax),%rax
  800420307e:	48 39 c2             	cmp    %rax,%rdx
  8004203081:	72 32                	jb     80042030b5 <pdpe_walk+0x1d9>
  8004203083:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203087:	48 89 c1             	mov    %rax,%rcx
  800420308a:	48 ba e0 61 21 04 80 	movabs $0x80042161e0,%rdx
  8004203091:	00 00 00 
  8004203094:	be 39 02 00 00       	mov    $0x239,%esi
  8004203099:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  80042030a0:	00 00 00 
  80042030a3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042030a8:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042030af:	00 00 00 
  80042030b2:	41 ff d0             	callq  *%r8
  80042030b5:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042030bc:	00 00 00 
  80042030bf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042030c3:	48 01 d0             	add    %rdx,%rax
  80042030c6:	8b 55 bc             	mov    -0x44(%rbp),%edx
  80042030c9:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  80042030cd:	48 89 ce             	mov    %rcx,%rsi
  80042030d0:	48 89 c7             	mov    %rax,%rdi
  80042030d3:	48 b8 e9 30 20 04 80 	movabs $0x80042030e9,%rax
  80042030da:	00 00 00 
  80042030dd:	ff d0                	callq  *%rax
  80042030df:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	}

	return ptep;
  80042030e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80042030e7:	c9                   	leaveq 
  80042030e8:	c3                   	retq   

00000080042030e9 <pgdir_walk>:
// The programming logic and the hints are the same as pml4e_walk
// and pdpe_walk.

pte_t *
pgdir_walk(pde_t *pgdir, const void *va, int create)
{
  80042030e9:	55                   	push   %rbp
  80042030ea:	48 89 e5             	mov    %rsp,%rbp
  80042030ed:	48 83 ec 50          	sub    $0x50,%rsp
  80042030f1:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80042030f5:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  80042030f9:	89 55 bc             	mov    %edx,-0x44(%rbp)
	// Fill this function in
	pte_t *ptep = NULL;
  80042030fc:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004203103:	00 
	pde_t *pgdirp = NULL;
  8004203104:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420310b:	00 
	pgdirp = pgdir + PDX(va);
  800420310c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203110:	48 c1 e8 15          	shr    $0x15,%rax
  8004203114:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203119:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203120:	00 
  8004203121:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203125:	48 01 d0             	add    %rdx,%rax
  8004203128:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (!(*pgdirp & PTE_P)) {
  800420312c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203130:	48 8b 00             	mov    (%rax),%rax
  8004203133:	83 e0 01             	and    $0x1,%eax
  8004203136:	48 85 c0             	test   %rax,%rax
  8004203139:	75 72                	jne    80042031ad <pgdir_walk+0xc4>
		if (!create)
  800420313b:	83 7d bc 00          	cmpl   $0x0,-0x44(%rbp)
  800420313f:	75 0a                	jne    800420314b <pgdir_walk+0x62>
			return NULL;
  8004203141:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203146:	e9 f3 00 00 00       	jmpq   800420323e <pgdir_walk+0x155>
		struct PageInfo *pp = page_alloc(ALLOC_ZERO);
  800420314b:	bf 01 00 00 00       	mov    $0x1,%edi
  8004203150:	48 b8 72 2b 20 04 80 	movabs $0x8004202b72,%rax
  8004203157:	00 00 00 
  800420315a:	ff d0                	callq  *%rax
  800420315c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		if (pp == NULL)
  8004203160:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203165:	75 0a                	jne    8004203171 <pgdir_walk+0x88>
			return NULL;
  8004203167:	b8 00 00 00 00       	mov    $0x0,%eax
  800420316c:	e9 cd 00 00 00       	jmpq   800420323e <pgdir_walk+0x155>
		pp->pp_ref++;
  8004203171:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203175:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203179:	8d 50 01             	lea    0x1(%rax),%edx
  800420317c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203180:	66 89 50 08          	mov    %dx,0x8(%rax)
		physaddr_t pa = page2pa(pp);
  8004203184:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203188:	48 89 c7             	mov    %rax,%rdi
  800420318b:	48 b8 64 19 20 04 80 	movabs $0x8004201964,%rax
  8004203192:	00 00 00 
  8004203195:	ff d0                	callq  *%rax
  8004203197:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		*pgdirp = pa | PTE_P | PTE_W | PTE_U;
  800420319b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420319f:	48 83 c8 07          	or     $0x7,%rax
  80042031a3:	48 89 c2             	mov    %rax,%rdx
  80042031a6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042031aa:	48 89 10             	mov    %rdx,(%rax)
	}

	ptep = &((pte_t *)KADDR(PTE_ADDR(*pgdirp)))[PTX(va)];
  80042031ad:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042031b1:	48 8b 00             	mov    (%rax),%rax
  80042031b4:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042031ba:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042031be:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042031c2:	48 c1 e8 0c          	shr    $0xc,%rax
  80042031c6:	89 45 d4             	mov    %eax,-0x2c(%rbp)
  80042031c9:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  80042031cc:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  80042031d3:	00 00 00 
  80042031d6:	48 8b 00             	mov    (%rax),%rax
  80042031d9:	48 39 c2             	cmp    %rax,%rdx
  80042031dc:	72 32                	jb     8004203210 <pgdir_walk+0x127>
  80042031de:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042031e2:	48 89 c1             	mov    %rax,%rcx
  80042031e5:	48 ba e0 61 21 04 80 	movabs $0x80042161e0,%rdx
  80042031ec:	00 00 00 
  80042031ef:	be 55 02 00 00       	mov    $0x255,%esi
  80042031f4:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  80042031fb:	00 00 00 
  80042031fe:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203203:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420320a:	00 00 00 
  800420320d:	41 ff d0             	callq  *%r8
  8004203210:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004203217:	00 00 00 
  800420321a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420321e:	48 01 d0             	add    %rdx,%rax
  8004203221:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004203225:	48 c1 ea 0c          	shr    $0xc,%rdx
  8004203229:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  800420322f:	48 c1 e2 03          	shl    $0x3,%rdx
  8004203233:	48 01 d0             	add    %rdx,%rax
  8004203236:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return ptep;
  800420323a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420323e:	c9                   	leaveq 
  800420323f:	c3                   	retq   

0000008004203240 <boot_map_region>:
// mapped pages.
//
// Hint: the TA solution uses pml4e_walk
static void
boot_map_region(pml4e_t *pml4e, uintptr_t la, size_t size, physaddr_t pa, int perm)
{
  8004203240:	55                   	push   %rbp
  8004203241:	48 89 e5             	mov    %rsp,%rbp
  8004203244:	48 83 ec 40          	sub    $0x40,%rsp
  8004203248:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420324c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004203250:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004203254:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  8004203258:	44 89 45 cc          	mov    %r8d,-0x34(%rbp)
	// Fill this function in
	size_t i;
	pte_t * ptep;
	for (i = 0; i < size; i += PGSIZE) {
  800420325c:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004203263:	00 
  8004203264:	eb 5f                	jmp    80042032c5 <boot_map_region+0x85>
		ptep = pml4e_walk(pml4e, (void *)(la + i), 1);
  8004203266:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420326a:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420326e:	48 01 d0             	add    %rdx,%rax
  8004203271:	48 89 c1             	mov    %rax,%rcx
  8004203274:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203278:	ba 01 00 00 00       	mov    $0x1,%edx
  800420327d:	48 89 ce             	mov    %rcx,%rsi
  8004203280:	48 89 c7             	mov    %rax,%rdi
  8004203283:	48 b8 cf 2c 20 04 80 	movabs $0x8004202ccf,%rax
  800420328a:	00 00 00 
  800420328d:	ff d0                	callq  *%rax
  800420328f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		*ptep = PTE_ADDR(pa + i) | perm | PTE_P;
  8004203293:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203297:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420329b:	48 01 d0             	add    %rdx,%rax
  800420329e:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042032a4:	48 89 c2             	mov    %rax,%rdx
  80042032a7:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80042032aa:	48 98                	cltq   
  80042032ac:	48 09 d0             	or     %rdx,%rax
  80042032af:	48 83 c8 01          	or     $0x1,%rax
  80042032b3:	48 89 c2             	mov    %rax,%rdx
  80042032b6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042032ba:	48 89 10             	mov    %rdx,(%rax)
boot_map_region(pml4e_t *pml4e, uintptr_t la, size_t size, physaddr_t pa, int perm)
{
	// Fill this function in
	size_t i;
	pte_t * ptep;
	for (i = 0; i < size; i += PGSIZE) {
  80042032bd:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  80042032c4:	00 
  80042032c5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042032c9:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  80042032cd:	72 97                	jb     8004203266 <boot_map_region+0x26>
		ptep = pml4e_walk(pml4e, (void *)(la + i), 1);
		*ptep = PTE_ADDR(pa + i) | perm | PTE_P;
	}
}
  80042032cf:	c9                   	leaveq 
  80042032d0:	c3                   	retq   

00000080042032d1 <page_insert>:
// Hint: The TA solution is implemented using pml4e_walk, page_remove,
// and page2pa.
//
int
page_insert(pml4e_t *pml4e, struct PageInfo *pp, void *va, int perm)
{
  80042032d1:	55                   	push   %rbp
  80042032d2:	48 89 e5             	mov    %rsp,%rbp
  80042032d5:	48 83 ec 30          	sub    $0x30,%rsp
  80042032d9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042032dd:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042032e1:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  80042032e5:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
	// Fill this function in
	// note: modified in lab5, if the correct page is already mapped, reset perm & update tlb only
	// inspired by Yinlong Su @ April 5th, 2016
	pte_t *ptep = pml4e_walk(pml4e, va, 0);
  80042032e8:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042032ec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042032f0:	ba 00 00 00 00       	mov    $0x0,%edx
  80042032f5:	48 89 ce             	mov    %rcx,%rsi
  80042032f8:	48 89 c7             	mov    %rax,%rdi
  80042032fb:	48 b8 cf 2c 20 04 80 	movabs $0x8004202ccf,%rax
  8004203302:	00 00 00 
  8004203305:	ff d0                	callq  *%rax
  8004203307:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (ptep && page2pa(pp) == PTE_ADDR(*ptep)) {
  800420330b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203310:	74 70                	je     8004203382 <page_insert+0xb1>
  8004203312:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203316:	48 89 c7             	mov    %rax,%rdi
  8004203319:	48 b8 64 19 20 04 80 	movabs $0x8004201964,%rax
  8004203320:	00 00 00 
  8004203323:	ff d0                	callq  *%rax
  8004203325:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203329:	48 8b 12             	mov    (%rdx),%rdx
  800420332c:	48 81 e2 00 f0 ff ff 	and    $0xfffffffffffff000,%rdx
  8004203333:	48 39 d0             	cmp    %rdx,%rax
  8004203336:	75 4a                	jne    8004203382 <page_insert+0xb1>
		*ptep = PTE_ADDR(*ptep) | perm | PTE_P;
  8004203338:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420333c:	48 8b 00             	mov    (%rax),%rax
  800420333f:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203345:	48 89 c2             	mov    %rax,%rdx
  8004203348:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800420334b:	48 98                	cltq   
  800420334d:	48 09 d0             	or     %rdx,%rax
  8004203350:	48 83 c8 01          	or     $0x1,%rax
  8004203354:	48 89 c2             	mov    %rax,%rdx
  8004203357:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420335b:	48 89 10             	mov    %rdx,(%rax)
		tlb_invalidate(pml4e, va);
  800420335e:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004203362:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203366:	48 89 d6             	mov    %rdx,%rsi
  8004203369:	48 89 c7             	mov    %rax,%rdi
  800420336c:	48 b8 02 35 20 04 80 	movabs $0x8004203502,%rax
  8004203373:	00 00 00 
  8004203376:	ff d0                	callq  *%rax
		return 0;
  8004203378:	b8 00 00 00 00       	mov    $0x0,%eax
  800420337d:	e9 96 00 00 00       	jmpq   8004203418 <page_insert+0x147>
	}

	page_remove(pml4e, va);
  8004203382:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004203386:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420338a:	48 89 d6             	mov    %rdx,%rsi
  800420338d:	48 89 c7             	mov    %rax,%rdi
  8004203390:	48 b8 8f 34 20 04 80 	movabs $0x800420348f,%rax
  8004203397:	00 00 00 
  800420339a:	ff d0                	callq  *%rax
	ptep = pml4e_walk(pml4e, va, 1);
  800420339c:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042033a0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042033a4:	ba 01 00 00 00       	mov    $0x1,%edx
  80042033a9:	48 89 ce             	mov    %rcx,%rsi
  80042033ac:	48 89 c7             	mov    %rax,%rdi
  80042033af:	48 b8 cf 2c 20 04 80 	movabs $0x8004202ccf,%rax
  80042033b6:	00 00 00 
  80042033b9:	ff d0                	callq  *%rax
  80042033bb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (ptep == NULL)
  80042033bf:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042033c4:	75 07                	jne    80042033cd <page_insert+0xfc>
		return -E_NO_MEM;
  80042033c6:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80042033cb:	eb 4b                	jmp    8004203418 <page_insert+0x147>
	*ptep = page2pa(pp);
  80042033cd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042033d1:	48 89 c7             	mov    %rax,%rdi
  80042033d4:	48 b8 64 19 20 04 80 	movabs $0x8004201964,%rax
  80042033db:	00 00 00 
  80042033de:	ff d0                	callq  *%rax
  80042033e0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042033e4:	48 89 02             	mov    %rax,(%rdx)
	*ptep |= perm | PTE_P;
  80042033e7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042033eb:	48 8b 10             	mov    (%rax),%rdx
  80042033ee:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80042033f1:	83 c8 01             	or     $0x1,%eax
  80042033f4:	48 98                	cltq   
  80042033f6:	48 09 c2             	or     %rax,%rdx
  80042033f9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042033fd:	48 89 10             	mov    %rdx,(%rax)
	pp->pp_ref++;
  8004203400:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203404:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203408:	8d 50 01             	lea    0x1(%rax),%edx
  800420340b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420340f:	66 89 50 08          	mov    %dx,0x8(%rax)
	return 0;
  8004203413:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004203418:	c9                   	leaveq 
  8004203419:	c3                   	retq   

000000800420341a <page_lookup>:
//
// Hint: the TA solution uses pml4e_walk and pa2page.
//
struct PageInfo *
page_lookup(pml4e_t *pml4e, void *va, pte_t **pte_store)
{
  800420341a:	55                   	push   %rbp
  800420341b:	48 89 e5             	mov    %rsp,%rbp
  800420341e:	48 83 ec 30          	sub    $0x30,%rsp
  8004203422:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004203426:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420342a:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	// Fill this function in
	pte_t *ptep = pml4e_walk(pml4e, va, 0);
  800420342e:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  8004203432:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203436:	ba 00 00 00 00       	mov    $0x0,%edx
  800420343b:	48 89 ce             	mov    %rcx,%rsi
  800420343e:	48 89 c7             	mov    %rax,%rdi
  8004203441:	48 b8 cf 2c 20 04 80 	movabs $0x8004202ccf,%rax
  8004203448:	00 00 00 
  800420344b:	ff d0                	callq  *%rax
  800420344d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (ptep == NULL)
  8004203451:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203456:	75 07                	jne    800420345f <page_lookup+0x45>
		return NULL;
  8004203458:	b8 00 00 00 00       	mov    $0x0,%eax
  800420345d:	eb 2e                	jmp    800420348d <page_lookup+0x73>
	if (pte_store)
  800420345f:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004203464:	74 0b                	je     8004203471 <page_lookup+0x57>
		*pte_store = ptep;
  8004203466:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420346a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420346e:	48 89 10             	mov    %rdx,(%rax)
	return pa2page(PTE_ADDR(*ptep));
  8004203471:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203475:	48 8b 00             	mov    (%rax),%rax
  8004203478:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420347e:	48 89 c7             	mov    %rax,%rdi
  8004203481:	48 b8 89 19 20 04 80 	movabs $0x8004201989,%rax
  8004203488:	00 00 00 
  800420348b:	ff d0                	callq  *%rax
}
  800420348d:	c9                   	leaveq 
  800420348e:	c3                   	retq   

000000800420348f <page_remove>:
// Hint: The TA solution is implemented using page_lookup,
// 	tlb_invalidate, and page_decref.
//
void
page_remove(pml4e_t *pml4e, void *va)
{
  800420348f:	55                   	push   %rbp
  8004203490:	48 89 e5             	mov    %rsp,%rbp
  8004203493:	48 83 ec 20          	sub    $0x20,%rsp
  8004203497:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420349b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Fill this function in
	pte_t *ptep;
	struct PageInfo *pp = page_lookup(pml4e, va, &ptep);
  800420349f:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  80042034a3:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  80042034a7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042034ab:	48 89 ce             	mov    %rcx,%rsi
  80042034ae:	48 89 c7             	mov    %rax,%rdi
  80042034b1:	48 b8 1a 34 20 04 80 	movabs $0x800420341a,%rax
  80042034b8:	00 00 00 
  80042034bb:	ff d0                	callq  *%rax
  80042034bd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (pp) {
  80042034c1:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042034c6:	74 38                	je     8004203500 <page_remove+0x71>
		page_decref(pp);
  80042034c8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042034cc:	48 89 c7             	mov    %rax,%rdi
  80042034cf:	48 b8 8e 2c 20 04 80 	movabs $0x8004202c8e,%rax
  80042034d6:	00 00 00 
  80042034d9:	ff d0                	callq  *%rax
		*ptep = 0;
  80042034db:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042034df:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		tlb_invalidate(pml4e, va);
  80042034e6:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042034ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042034ee:	48 89 d6             	mov    %rdx,%rsi
  80042034f1:	48 89 c7             	mov    %rax,%rdi
  80042034f4:	48 b8 02 35 20 04 80 	movabs $0x8004203502,%rax
  80042034fb:	00 00 00 
  80042034fe:	ff d0                	callq  *%rax
	}
}
  8004203500:	c9                   	leaveq 
  8004203501:	c3                   	retq   

0000008004203502 <tlb_invalidate>:
// Invalidate a TLB entry, but only if the page tables being
// edited are the ones currently in use by the processor.
//
void
tlb_invalidate(pml4e_t *pml4e, void *va)
{
  8004203502:	55                   	push   %rbp
  8004203503:	48 89 e5             	mov    %rsp,%rbp
  8004203506:	48 83 ec 20          	sub    $0x20,%rsp
  800420350a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420350e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Flush the entry only if we're modifying the current address space.
	assert(pml4e!=NULL);
  8004203512:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203517:	75 35                	jne    800420354e <tlb_invalidate+0x4c>
  8004203519:	48 b9 9e 63 21 04 80 	movabs $0x800421639e,%rcx
  8004203520:	00 00 00 
  8004203523:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  800420352a:	00 00 00 
  800420352d:	be da 02 00 00       	mov    $0x2da,%esi
  8004203532:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004203539:	00 00 00 
  800420353c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203541:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004203548:	00 00 00 
  800420354b:	41 ff d0             	callq  *%r8
	if (!curenv || curenv->env_pml4e == pml4e)
  800420354e:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  8004203555:	00 00 00 
  8004203558:	ff d0                	callq  *%rax
  800420355a:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  8004203561:	00 00 00 
  8004203564:	48 98                	cltq   
  8004203566:	48 c1 e0 03          	shl    $0x3,%rax
  800420356a:	48 89 c2             	mov    %rax,%rdx
  800420356d:	48 c1 e2 04          	shl    $0x4,%rdx
  8004203571:	48 29 c2             	sub    %rax,%rdx
  8004203574:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004203578:	48 83 c0 08          	add    $0x8,%rax
  800420357c:	48 8b 00             	mov    (%rax),%rax
  800420357f:	48 85 c0             	test   %rax,%rax
  8004203582:	74 3e                	je     80042035c2 <tlb_invalidate+0xc0>
  8004203584:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420358b:	00 00 00 
  800420358e:	ff d0                	callq  *%rax
  8004203590:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  8004203597:	00 00 00 
  800420359a:	48 98                	cltq   
  800420359c:	48 c1 e0 03          	shl    $0x3,%rax
  80042035a0:	48 89 c2             	mov    %rax,%rdx
  80042035a3:	48 c1 e2 04          	shl    $0x4,%rdx
  80042035a7:	48 29 c2             	sub    %rax,%rdx
  80042035aa:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042035ae:	48 83 c0 08          	add    $0x8,%rax
  80042035b2:	48 8b 00             	mov    (%rax),%rax
  80042035b5:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042035bc:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80042035c0:	75 0f                	jne    80042035d1 <tlb_invalidate+0xcf>
  80042035c2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042035c6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}

static __inline void 
invlpg(void *addr)
{ 
	__asm __volatile("invlpg (%0)" : : "r" (addr) : "memory");
  80042035ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042035ce:	0f 01 38             	invlpg (%rax)
		invlpg(va);
}
  80042035d1:	c9                   	leaveq 
  80042035d2:	c3                   	retq   

00000080042035d3 <mmio_map_region>:
// location.  Return the base of the reserved region.  size does *not*
// have to be multiple of PGSIZE.
//
void *
mmio_map_region(physaddr_t pa, size_t size)
{
  80042035d3:	55                   	push   %rbp
  80042035d4:	48 89 e5             	mov    %rsp,%rbp
  80042035d7:	48 83 ec 30          	sub    $0x30,%rsp
  80042035db:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80042035df:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	// okay to simply panic if this happens).
	//
	// Hint: The staff solution uses boot_map_region.
	//
	// Your code here:
	uintptr_t region_base = base;
  80042035e3:	48 b8 c8 b5 22 04 80 	movabs $0x800422b5c8,%rax
  80042035ea:	00 00 00 
  80042035ed:	48 8b 00             	mov    (%rax),%rax
  80042035f0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	size = ROUNDUP(size, PGSIZE);
  80042035f4:	48 c7 45 f0 00 10 00 	movq   $0x1000,-0x10(%rbp)
  80042035fb:	00 
  80042035fc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203600:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004203604:	48 01 d0             	add    %rdx,%rax
  8004203607:	48 83 e8 01          	sub    $0x1,%rax
  800420360b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420360f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203613:	ba 00 00 00 00       	mov    $0x0,%edx
  8004203618:	48 f7 75 f0          	divq   -0x10(%rbp)
  800420361c:	48 89 d0             	mov    %rdx,%rax
  800420361f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004203623:	48 29 c2             	sub    %rax,%rdx
  8004203626:	48 89 d0             	mov    %rdx,%rax
  8004203629:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	if (base + size > MMIOLIM) {
  800420362d:	48 b8 c8 b5 22 04 80 	movabs $0x800422b5c8,%rax
  8004203634:	00 00 00 
  8004203637:	48 8b 10             	mov    (%rax),%rdx
  800420363a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420363e:	48 01 c2             	add    %rax,%rdx
  8004203641:	48 b8 00 00 e0 03 80 	movabs $0x8003e00000,%rax
  8004203648:	00 00 00 
  800420364b:	48 39 c2             	cmp    %rax,%rdx
  800420364e:	76 2a                	jbe    800420367a <mmio_map_region+0xa7>
		panic("mmio_map_region(): memory overflow");
  8004203650:	48 ba b0 63 21 04 80 	movabs $0x80042163b0,%rdx
  8004203657:	00 00 00 
  800420365a:	be 03 03 00 00       	mov    $0x303,%esi
  800420365f:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004203666:	00 00 00 
  8004203669:	b8 00 00 00 00       	mov    $0x0,%eax
  800420366e:	48 b9 ae 04 20 04 80 	movabs $0x80042004ae,%rcx
  8004203675:	00 00 00 
  8004203678:	ff d1                	callq  *%rcx
	}
	boot_map_region(boot_pml4e, base, size, pa, PTE_W | PTE_PCD | PTE_PWT);
  800420367a:	48 b8 c8 b5 22 04 80 	movabs $0x800422b5c8,%rax
  8004203681:	00 00 00 
  8004203684:	48 8b 30             	mov    (%rax),%rsi
  8004203687:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  800420368e:	00 00 00 
  8004203691:	48 8b 00             	mov    (%rax),%rax
  8004203694:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004203698:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420369c:	41 b8 1a 00 00 00    	mov    $0x1a,%r8d
  80042036a2:	48 89 c7             	mov    %rax,%rdi
  80042036a5:	48 b8 40 32 20 04 80 	movabs $0x8004203240,%rax
  80042036ac:	00 00 00 
  80042036af:	ff d0                	callq  *%rax
	base += size;
  80042036b1:	48 b8 c8 b5 22 04 80 	movabs $0x800422b5c8,%rax
  80042036b8:	00 00 00 
  80042036bb:	48 8b 10             	mov    (%rax),%rdx
  80042036be:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042036c2:	48 01 c2             	add    %rax,%rdx
  80042036c5:	48 b8 c8 b5 22 04 80 	movabs $0x800422b5c8,%rax
  80042036cc:	00 00 00 
  80042036cf:	48 89 10             	mov    %rdx,(%rax)

	return (void *)region_base;
  80042036d2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
	//panic("mmio_map_region not implemented");
}
  80042036d6:	c9                   	leaveq 
  80042036d7:	c3                   	retq   

00000080042036d8 <user_mem_check>:
// Returns 0 if the user program can access this range of addresses,
// and -E_FAULT otherwise.
//
int
user_mem_check(struct Env *env, const void *va, size_t len, int perm)
{
  80042036d8:	55                   	push   %rbp
  80042036d9:	48 89 e5             	mov    %rsp,%rbp
  80042036dc:	48 83 ec 60          	sub    $0x60,%rsp
  80042036e0:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  80042036e4:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  80042036e8:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  80042036ec:	89 4d a4             	mov    %ecx,-0x5c(%rbp)
	// LAB 3: Your code here.
	void *bva;
	pte_t *ptep;
	struct PageInfo *pp;
	perm |= PTE_P;
  80042036ef:	83 4d a4 01          	orl    $0x1,-0x5c(%rbp)

	for (bva = (void *)va; bva < ROUNDUP(va + len, PGSIZE); bva = ROUNDDOWN(bva, PGSIZE) + PGSIZE) {
  80042036f3:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042036f7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042036fb:	e9 0d 01 00 00       	jmpq   800420380d <user_mem_check+0x135>
		if ((uintptr_t)ROUNDDOWN(bva, PGSIZE) > ULIM) {
  8004203700:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203704:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004203708:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420370c:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203712:	48 89 c2             	mov    %rax,%rdx
  8004203715:	48 b8 00 00 c0 03 80 	movabs $0x8003c00000,%rax
  800420371c:	00 00 00 
  800420371f:	48 39 c2             	cmp    %rax,%rdx
  8004203722:	76 1b                	jbe    800420373f <user_mem_check+0x67>
			user_mem_check_addr = (uintptr_t)bva;
  8004203724:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203728:	48 b8 40 52 49 04 80 	movabs $0x8004495240,%rax
  800420372f:	00 00 00 
  8004203732:	48 89 10             	mov    %rdx,(%rax)
			return -E_FAULT;
  8004203735:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  800420373a:	e9 1c 01 00 00       	jmpq   800420385b <user_mem_check+0x183>
		}

		pp = page_lookup(env->env_pml4e, bva, &ptep);
  800420373f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203743:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420374a:	48 8d 55 c8          	lea    -0x38(%rbp),%rdx
  800420374e:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  8004203752:	48 89 ce             	mov    %rcx,%rsi
  8004203755:	48 89 c7             	mov    %rax,%rdi
  8004203758:	48 b8 1a 34 20 04 80 	movabs $0x800420341a,%rax
  800420375f:	00 00 00 
  8004203762:	ff d0                	callq  *%rax
  8004203764:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		if (pp == NULL || (*ptep & perm) != perm) {
  8004203768:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420376d:	74 19                	je     8004203788 <user_mem_check+0xb0>
  800420376f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203773:	48 8b 10             	mov    (%rax),%rdx
  8004203776:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  8004203779:	48 98                	cltq   
  800420377b:	48 21 c2             	and    %rax,%rdx
  800420377e:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  8004203781:	48 98                	cltq   
  8004203783:	48 39 c2             	cmp    %rax,%rdx
  8004203786:	74 1b                	je     80042037a3 <user_mem_check+0xcb>
			user_mem_check_addr = (uintptr_t)bva;
  8004203788:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420378c:	48 b8 40 52 49 04 80 	movabs $0x8004495240,%rax
  8004203793:	00 00 00 
  8004203796:	48 89 10             	mov    %rdx,(%rax)
			return -E_FAULT;
  8004203799:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  800420379e:	e9 b8 00 00 00       	jmpq   800420385b <user_mem_check+0x183>
		}

		if (!(*pml4e_walk(env->env_pml4e, bva, 0) & perm)) {
  80042037a3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042037a7:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042037ae:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80042037b2:	ba 00 00 00 00       	mov    $0x0,%edx
  80042037b7:	48 89 ce             	mov    %rcx,%rsi
  80042037ba:	48 89 c7             	mov    %rax,%rdi
  80042037bd:	48 b8 cf 2c 20 04 80 	movabs $0x8004202ccf,%rax
  80042037c4:	00 00 00 
  80042037c7:	ff d0                	callq  *%rax
  80042037c9:	48 8b 10             	mov    (%rax),%rdx
  80042037cc:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  80042037cf:	48 98                	cltq   
  80042037d1:	48 21 d0             	and    %rdx,%rax
  80042037d4:	48 85 c0             	test   %rax,%rax
  80042037d7:	75 18                	jne    80042037f1 <user_mem_check+0x119>
			user_mem_check_addr = (uintptr_t)bva;
  80042037d9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042037dd:	48 b8 40 52 49 04 80 	movabs $0x8004495240,%rax
  80042037e4:	00 00 00 
  80042037e7:	48 89 10             	mov    %rdx,(%rax)
			return -E_FAULT;
  80042037ea:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  80042037ef:	eb 6a                	jmp    800420385b <user_mem_check+0x183>
	void *bva;
	pte_t *ptep;
	struct PageInfo *pp;
	perm |= PTE_P;

	for (bva = (void *)va; bva < ROUNDUP(va + len, PGSIZE); bva = ROUNDDOWN(bva, PGSIZE) + PGSIZE) {
  80042037f1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042037f5:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  80042037f9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042037fd:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203803:	48 05 00 10 00 00    	add    $0x1000,%rax
  8004203809:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420380d:	48 c7 45 f0 00 10 00 	movq   $0x1000,-0x10(%rbp)
  8004203814:	00 
  8004203815:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203819:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420381d:	48 01 d0             	add    %rdx,%rax
  8004203820:	48 89 c2             	mov    %rax,%rdx
  8004203823:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203827:	48 01 d0             	add    %rdx,%rax
  800420382a:	48 83 e8 01          	sub    $0x1,%rax
  800420382e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004203832:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203836:	ba 00 00 00 00       	mov    $0x0,%edx
  800420383b:	48 f7 75 f0          	divq   -0x10(%rbp)
  800420383f:	48 89 d0             	mov    %rdx,%rax
  8004203842:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004203846:	48 29 c2             	sub    %rax,%rdx
  8004203849:	48 89 d0             	mov    %rdx,%rax
  800420384c:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004203850:	0f 87 aa fe ff ff    	ja     8004203700 <user_mem_check+0x28>
			user_mem_check_addr = (uintptr_t)bva;
			return -E_FAULT;
		}
	}

	return 0;
  8004203856:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420385b:	c9                   	leaveq 
  800420385c:	c3                   	retq   

000000800420385d <user_mem_assert>:
// If it cannot, 'env' is destroyed and, if env is the current
// environment, this function will not return.
//
void
user_mem_assert(struct Env *env, const void *va, size_t len, int perm)
{
  800420385d:	55                   	push   %rbp
  800420385e:	48 89 e5             	mov    %rsp,%rbp
  8004203861:	48 83 ec 20          	sub    $0x20,%rsp
  8004203865:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004203869:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420386d:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004203871:	89 4d e4             	mov    %ecx,-0x1c(%rbp)
	if (user_mem_check(env, va, len, perm | PTE_U) < 0) {
  8004203874:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203877:	83 c8 04             	or     $0x4,%eax
  800420387a:	89 c1                	mov    %eax,%ecx
  800420387c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004203880:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8004203884:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203888:	48 89 c7             	mov    %rax,%rdi
  800420388b:	48 b8 d8 36 20 04 80 	movabs $0x80042036d8,%rax
  8004203892:	00 00 00 
  8004203895:	ff d0                	callq  *%rax
  8004203897:	85 c0                	test   %eax,%eax
  8004203899:	79 47                	jns    80042038e2 <user_mem_assert+0x85>
		cprintf("[%08x] user_mem_check assertion failure for "
  800420389b:	48 b8 40 52 49 04 80 	movabs $0x8004495240,%rax
  80042038a2:	00 00 00 
  80042038a5:	48 8b 10             	mov    (%rax),%rdx
  80042038a8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042038ac:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  80042038b2:	89 c6                	mov    %eax,%esi
  80042038b4:	48 bf d8 63 21 04 80 	movabs $0x80042163d8,%rdi
  80042038bb:	00 00 00 
  80042038be:	b8 00 00 00 00       	mov    $0x0,%eax
  80042038c3:	48 b9 7a 8a 20 04 80 	movabs $0x8004208a7a,%rcx
  80042038ca:	00 00 00 
  80042038cd:	ff d1                	callq  *%rcx
			"va %08x\n", env->env_id, user_mem_check_addr);
		env_destroy(env);	// may not return
  80042038cf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042038d3:	48 89 c7             	mov    %rax,%rdi
  80042038d6:	48 b8 67 83 20 04 80 	movabs $0x8004208367,%rax
  80042038dd:	00 00 00 
  80042038e0:	ff d0                	callq  *%rax
	}
}
  80042038e2:	c9                   	leaveq 
  80042038e3:	c3                   	retq   

00000080042038e4 <check_page_free_list>:
// Check that the pages on the page_free_list are reasonable.
//

static void
check_page_free_list(bool only_low_memory)
{
  80042038e4:	55                   	push   %rbp
  80042038e5:	48 89 e5             	mov    %rsp,%rbp
  80042038e8:	48 83 ec 60          	sub    $0x60,%rsp
  80042038ec:	89 f8                	mov    %edi,%eax
  80042038ee:	88 45 ac             	mov    %al,-0x54(%rbp)
	struct PageInfo *pp;
	unsigned pdx_limit = only_low_memory ? 1 : NPDENTRIES;
  80042038f1:	80 7d ac 00          	cmpb   $0x0,-0x54(%rbp)
  80042038f5:	74 07                	je     80042038fe <check_page_free_list+0x1a>
  80042038f7:	b8 01 00 00 00       	mov    $0x1,%eax
  80042038fc:	eb 05                	jmp    8004203903 <check_page_free_list+0x1f>
  80042038fe:	b8 00 02 00 00       	mov    $0x200,%eax
  8004203903:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	uint64_t nfree_basemem = 0, nfree_extmem = 0;
  8004203906:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420390d:	00 
  800420390e:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004203915:	00 
	char *first_free_page;

	if (!page_free_list)
  8004203916:	48 b8 38 52 49 04 80 	movabs $0x8004495238,%rax
  800420391d:	00 00 00 
  8004203920:	48 8b 00             	mov    (%rax),%rax
  8004203923:	48 85 c0             	test   %rax,%rax
  8004203926:	75 2a                	jne    8004203952 <check_page_free_list+0x6e>
		panic("'page_free_list' is a null pointer!");
  8004203928:	48 ba 10 64 21 04 80 	movabs $0x8004216410,%rdx
  800420392f:	00 00 00 
  8004203932:	be 61 03 00 00       	mov    $0x361,%esi
  8004203937:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  800420393e:	00 00 00 
  8004203941:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203946:	48 b9 ae 04 20 04 80 	movabs $0x80042004ae,%rcx
  800420394d:	00 00 00 
  8004203950:	ff d1                	callq  *%rcx

	if (only_low_memory) {
  8004203952:	80 7d ac 00          	cmpb   $0x0,-0x54(%rbp)
  8004203956:	0f 84 a9 00 00 00    	je     8004203a05 <check_page_free_list+0x121>
		// Move pages with lower addresses first in the free
		// list, since entry_pgdir does not map all pages.
		struct PageInfo *pp1, *pp2;
		struct PageInfo **tp[2] = { &pp1, &pp2 };
  800420395c:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  8004203960:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  8004203964:	48 8d 45 c8          	lea    -0x38(%rbp),%rax
  8004203968:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		for (pp = page_free_list; pp; pp = pp->pp_link) {
  800420396c:	48 b8 38 52 49 04 80 	movabs $0x8004495238,%rax
  8004203973:	00 00 00 
  8004203976:	48 8b 00             	mov    (%rax),%rax
  8004203979:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420397d:	eb 58                	jmp    80042039d7 <check_page_free_list+0xf3>
			int pagetype = PDX(page2pa(pp)) >= pdx_limit;
  800420397f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203983:	48 89 c7             	mov    %rax,%rdi
  8004203986:	48 b8 64 19 20 04 80 	movabs $0x8004201964,%rax
  800420398d:	00 00 00 
  8004203990:	ff d0                	callq  *%rax
  8004203992:	48 c1 e8 15          	shr    $0x15,%rax
  8004203996:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420399b:	48 89 c2             	mov    %rax,%rdx
  800420399e:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042039a1:	48 39 c2             	cmp    %rax,%rdx
  80042039a4:	0f 93 c0             	setae  %al
  80042039a7:	0f b6 c0             	movzbl %al,%eax
  80042039aa:	89 45 e0             	mov    %eax,-0x20(%rbp)
			*tp[pagetype] = pp;
  80042039ad:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80042039b0:	48 98                	cltq   
  80042039b2:	48 8b 44 c5 b0       	mov    -0x50(%rbp,%rax,8),%rax
  80042039b7:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042039bb:	48 89 10             	mov    %rdx,(%rax)
			tp[pagetype] = &pp->pp_link;
  80042039be:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042039c2:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80042039c5:	48 98                	cltq   
  80042039c7:	48 89 54 c5 b0       	mov    %rdx,-0x50(%rbp,%rax,8)
	if (only_low_memory) {
		// Move pages with lower addresses first in the free
		// list, since entry_pgdir does not map all pages.
		struct PageInfo *pp1, *pp2;
		struct PageInfo **tp[2] = { &pp1, &pp2 };
		for (pp = page_free_list; pp; pp = pp->pp_link) {
  80042039cc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042039d0:	48 8b 00             	mov    (%rax),%rax
  80042039d3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042039d7:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042039dc:	75 a1                	jne    800420397f <check_page_free_list+0x9b>
			int pagetype = PDX(page2pa(pp)) >= pdx_limit;
			*tp[pagetype] = pp;
			tp[pagetype] = &pp->pp_link;
		}
		*tp[1] = 0;
  80042039de:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042039e2:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		*tp[0] = pp2;
  80042039e9:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042039ed:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042039f1:	48 89 10             	mov    %rdx,(%rax)
		page_free_list = pp1;
  80042039f4:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042039f8:	48 b8 38 52 49 04 80 	movabs $0x8004495238,%rax
  80042039ff:	00 00 00 
  8004203a02:	48 89 10             	mov    %rdx,(%rax)
	}

	// if there's a page that shouldn't be on the free list,
	// try to make sure it eventually causes trouble.
	for (pp = page_free_list; pp; pp = pp->pp_link)
  8004203a05:	48 b8 38 52 49 04 80 	movabs $0x8004495238,%rax
  8004203a0c:	00 00 00 
  8004203a0f:	48 8b 00             	mov    (%rax),%rax
  8004203a12:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203a16:	eb 5e                	jmp    8004203a76 <check_page_free_list+0x192>
		if (PDX(page2pa(pp)) < pdx_limit)
  8004203a18:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203a1c:	48 89 c7             	mov    %rax,%rdi
  8004203a1f:	48 b8 64 19 20 04 80 	movabs $0x8004201964,%rax
  8004203a26:	00 00 00 
  8004203a29:	ff d0                	callq  *%rax
  8004203a2b:	48 c1 e8 15          	shr    $0x15,%rax
  8004203a2f:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203a34:	48 89 c2             	mov    %rax,%rdx
  8004203a37:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203a3a:	48 39 c2             	cmp    %rax,%rdx
  8004203a3d:	73 2c                	jae    8004203a6b <check_page_free_list+0x187>
			memset(page2kva(pp), 0x97, 128);
  8004203a3f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203a43:	48 89 c7             	mov    %rax,%rdi
  8004203a46:	48 b8 fa 19 20 04 80 	movabs $0x80042019fa,%rax
  8004203a4d:	00 00 00 
  8004203a50:	ff d0                	callq  *%rax
  8004203a52:	ba 80 00 00 00       	mov    $0x80,%edx
  8004203a57:	be 97 00 00 00       	mov    $0x97,%esi
  8004203a5c:	48 89 c7             	mov    %rax,%rdi
  8004203a5f:	48 b8 db e8 20 04 80 	movabs $0x800420e8db,%rax
  8004203a66:	00 00 00 
  8004203a69:	ff d0                	callq  *%rax
		page_free_list = pp1;
	}

	// if there's a page that shouldn't be on the free list,
	// try to make sure it eventually causes trouble.
	for (pp = page_free_list; pp; pp = pp->pp_link)
  8004203a6b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203a6f:	48 8b 00             	mov    (%rax),%rax
  8004203a72:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203a76:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203a7b:	75 9b                	jne    8004203a18 <check_page_free_list+0x134>
		if (PDX(page2pa(pp)) < pdx_limit)
			memset(page2kva(pp), 0x97, 128);

	first_free_page = (char *) boot_alloc(0);
  8004203a7d:	bf 00 00 00 00       	mov    $0x0,%edi
  8004203a82:	48 b8 23 23 20 04 80 	movabs $0x8004202323,%rax
  8004203a89:	00 00 00 
  8004203a8c:	ff d0                	callq  *%rax
  8004203a8e:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	for (pp = page_free_list; pp; pp = pp->pp_link) {
  8004203a92:	48 b8 38 52 49 04 80 	movabs $0x8004495238,%rax
  8004203a99:	00 00 00 
  8004203a9c:	48 8b 00             	mov    (%rax),%rax
  8004203a9f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203aa3:	e9 20 03 00 00       	jmpq   8004203dc8 <check_page_free_list+0x4e4>
		// check that we didn't corrupt the free list itself
		assert(pp >= pages);
  8004203aa8:	48 b8 b8 67 49 04 80 	movabs $0x80044967b8,%rax
  8004203aaf:	00 00 00 
  8004203ab2:	48 8b 00             	mov    (%rax),%rax
  8004203ab5:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004203ab9:	73 35                	jae    8004203af0 <check_page_free_list+0x20c>
  8004203abb:	48 b9 34 64 21 04 80 	movabs $0x8004216434,%rcx
  8004203ac2:	00 00 00 
  8004203ac5:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004203acc:	00 00 00 
  8004203acf:	be 7b 03 00 00       	mov    $0x37b,%esi
  8004203ad4:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004203adb:	00 00 00 
  8004203ade:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203ae3:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004203aea:	00 00 00 
  8004203aed:	41 ff d0             	callq  *%r8
		assert(pp < pages + npages);
  8004203af0:	48 b8 b8 67 49 04 80 	movabs $0x80044967b8,%rax
  8004203af7:	00 00 00 
  8004203afa:	48 8b 10             	mov    (%rax),%rdx
  8004203afd:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  8004203b04:	00 00 00 
  8004203b07:	48 8b 00             	mov    (%rax),%rax
  8004203b0a:	48 c1 e0 04          	shl    $0x4,%rax
  8004203b0e:	48 01 d0             	add    %rdx,%rax
  8004203b11:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004203b15:	77 35                	ja     8004203b4c <check_page_free_list+0x268>
  8004203b17:	48 b9 40 64 21 04 80 	movabs $0x8004216440,%rcx
  8004203b1e:	00 00 00 
  8004203b21:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004203b28:	00 00 00 
  8004203b2b:	be 7c 03 00 00       	mov    $0x37c,%esi
  8004203b30:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004203b37:	00 00 00 
  8004203b3a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203b3f:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004203b46:	00 00 00 
  8004203b49:	41 ff d0             	callq  *%r8
		assert(((char *) pp - (char *) pages) % sizeof(*pp) == 0);
  8004203b4c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203b50:	48 b8 b8 67 49 04 80 	movabs $0x80044967b8,%rax
  8004203b57:	00 00 00 
  8004203b5a:	48 8b 00             	mov    (%rax),%rax
  8004203b5d:	48 29 c2             	sub    %rax,%rdx
  8004203b60:	48 89 d0             	mov    %rdx,%rax
  8004203b63:	83 e0 0f             	and    $0xf,%eax
  8004203b66:	48 85 c0             	test   %rax,%rax
  8004203b69:	74 35                	je     8004203ba0 <check_page_free_list+0x2bc>
  8004203b6b:	48 b9 58 64 21 04 80 	movabs $0x8004216458,%rcx
  8004203b72:	00 00 00 
  8004203b75:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004203b7c:	00 00 00 
  8004203b7f:	be 7d 03 00 00       	mov    $0x37d,%esi
  8004203b84:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004203b8b:	00 00 00 
  8004203b8e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203b93:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004203b9a:	00 00 00 
  8004203b9d:	41 ff d0             	callq  *%r8

		// check a few pages that shouldn't be on the free list
		assert(page2pa(pp) != 0);
  8004203ba0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203ba4:	48 89 c7             	mov    %rax,%rdi
  8004203ba7:	48 b8 64 19 20 04 80 	movabs $0x8004201964,%rax
  8004203bae:	00 00 00 
  8004203bb1:	ff d0                	callq  *%rax
  8004203bb3:	48 85 c0             	test   %rax,%rax
  8004203bb6:	75 35                	jne    8004203bed <check_page_free_list+0x309>
  8004203bb8:	48 b9 8a 64 21 04 80 	movabs $0x800421648a,%rcx
  8004203bbf:	00 00 00 
  8004203bc2:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004203bc9:	00 00 00 
  8004203bcc:	be 80 03 00 00       	mov    $0x380,%esi
  8004203bd1:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004203bd8:	00 00 00 
  8004203bdb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203be0:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004203be7:	00 00 00 
  8004203bea:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != IOPHYSMEM);
  8004203bed:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203bf1:	48 89 c7             	mov    %rax,%rdi
  8004203bf4:	48 b8 64 19 20 04 80 	movabs $0x8004201964,%rax
  8004203bfb:	00 00 00 
  8004203bfe:	ff d0                	callq  *%rax
  8004203c00:	48 3d 00 00 0a 00    	cmp    $0xa0000,%rax
  8004203c06:	75 35                	jne    8004203c3d <check_page_free_list+0x359>
  8004203c08:	48 b9 9b 64 21 04 80 	movabs $0x800421649b,%rcx
  8004203c0f:	00 00 00 
  8004203c12:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004203c19:	00 00 00 
  8004203c1c:	be 81 03 00 00       	mov    $0x381,%esi
  8004203c21:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004203c28:	00 00 00 
  8004203c2b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203c30:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004203c37:	00 00 00 
  8004203c3a:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != EXTPHYSMEM - PGSIZE);
  8004203c3d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203c41:	48 89 c7             	mov    %rax,%rdi
  8004203c44:	48 b8 64 19 20 04 80 	movabs $0x8004201964,%rax
  8004203c4b:	00 00 00 
  8004203c4e:	ff d0                	callq  *%rax
  8004203c50:	48 3d 00 f0 0f 00    	cmp    $0xff000,%rax
  8004203c56:	75 35                	jne    8004203c8d <check_page_free_list+0x3a9>
  8004203c58:	48 b9 b8 64 21 04 80 	movabs $0x80042164b8,%rcx
  8004203c5f:	00 00 00 
  8004203c62:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004203c69:	00 00 00 
  8004203c6c:	be 82 03 00 00       	mov    $0x382,%esi
  8004203c71:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004203c78:	00 00 00 
  8004203c7b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203c80:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004203c87:	00 00 00 
  8004203c8a:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != EXTPHYSMEM);
  8004203c8d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203c91:	48 89 c7             	mov    %rax,%rdi
  8004203c94:	48 b8 64 19 20 04 80 	movabs $0x8004201964,%rax
  8004203c9b:	00 00 00 
  8004203c9e:	ff d0                	callq  *%rax
  8004203ca0:	48 3d 00 00 10 00    	cmp    $0x100000,%rax
  8004203ca6:	75 35                	jne    8004203cdd <check_page_free_list+0x3f9>
  8004203ca8:	48 b9 db 64 21 04 80 	movabs $0x80042164db,%rcx
  8004203caf:	00 00 00 
  8004203cb2:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004203cb9:	00 00 00 
  8004203cbc:	be 83 03 00 00       	mov    $0x383,%esi
  8004203cc1:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004203cc8:	00 00 00 
  8004203ccb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203cd0:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004203cd7:	00 00 00 
  8004203cda:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) < EXTPHYSMEM || (char *) page2kva(pp) >= first_free_page);
  8004203cdd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203ce1:	48 89 c7             	mov    %rax,%rdi
  8004203ce4:	48 b8 64 19 20 04 80 	movabs $0x8004201964,%rax
  8004203ceb:	00 00 00 
  8004203cee:	ff d0                	callq  *%rax
  8004203cf0:	48 3d ff ff 0f 00    	cmp    $0xfffff,%rax
  8004203cf6:	76 4e                	jbe    8004203d46 <check_page_free_list+0x462>
  8004203cf8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203cfc:	48 89 c7             	mov    %rax,%rdi
  8004203cff:	48 b8 fa 19 20 04 80 	movabs $0x80042019fa,%rax
  8004203d06:	00 00 00 
  8004203d09:	ff d0                	callq  *%rax
  8004203d0b:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004203d0f:	73 35                	jae    8004203d46 <check_page_free_list+0x462>
  8004203d11:	48 b9 f8 64 21 04 80 	movabs $0x80042164f8,%rcx
  8004203d18:	00 00 00 
  8004203d1b:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004203d22:	00 00 00 
  8004203d25:	be 84 03 00 00       	mov    $0x384,%esi
  8004203d2a:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004203d31:	00 00 00 
  8004203d34:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203d39:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004203d40:	00 00 00 
  8004203d43:	41 ff d0             	callq  *%r8
		// (new test for lab 4)
		assert(page2pa(pp) != MPENTRY_PADDR);
  8004203d46:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203d4a:	48 89 c7             	mov    %rax,%rdi
  8004203d4d:	48 b8 64 19 20 04 80 	movabs $0x8004201964,%rax
  8004203d54:	00 00 00 
  8004203d57:	ff d0                	callq  *%rax
  8004203d59:	48 3d 00 70 00 00    	cmp    $0x7000,%rax
  8004203d5f:	75 35                	jne    8004203d96 <check_page_free_list+0x4b2>
  8004203d61:	48 b9 3d 65 21 04 80 	movabs $0x800421653d,%rcx
  8004203d68:	00 00 00 
  8004203d6b:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004203d72:	00 00 00 
  8004203d75:	be 86 03 00 00       	mov    $0x386,%esi
  8004203d7a:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004203d81:	00 00 00 
  8004203d84:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203d89:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004203d90:	00 00 00 
  8004203d93:	41 ff d0             	callq  *%r8

		if (page2pa(pp) < EXTPHYSMEM)
  8004203d96:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203d9a:	48 89 c7             	mov    %rax,%rdi
  8004203d9d:	48 b8 64 19 20 04 80 	movabs $0x8004201964,%rax
  8004203da4:	00 00 00 
  8004203da7:	ff d0                	callq  *%rax
  8004203da9:	48 3d ff ff 0f 00    	cmp    $0xfffff,%rax
  8004203daf:	77 07                	ja     8004203db8 <check_page_free_list+0x4d4>
			++nfree_basemem;
  8004203db1:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  8004203db6:	eb 05                	jmp    8004203dbd <check_page_free_list+0x4d9>
		else
			++nfree_extmem;
  8004203db8:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
	for (pp = page_free_list; pp; pp = pp->pp_link)
		if (PDX(page2pa(pp)) < pdx_limit)
			memset(page2kva(pp), 0x97, 128);

	first_free_page = (char *) boot_alloc(0);
	for (pp = page_free_list; pp; pp = pp->pp_link) {
  8004203dbd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203dc1:	48 8b 00             	mov    (%rax),%rax
  8004203dc4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203dc8:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203dcd:	0f 85 d5 fc ff ff    	jne    8004203aa8 <check_page_free_list+0x1c4>
			++nfree_basemem;
		else
			++nfree_extmem;
	}

	assert(nfree_extmem > 0);
  8004203dd3:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203dd8:	75 35                	jne    8004203e0f <check_page_free_list+0x52b>
  8004203dda:	48 b9 5a 65 21 04 80 	movabs $0x800421655a,%rcx
  8004203de1:	00 00 00 
  8004203de4:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004203deb:	00 00 00 
  8004203dee:	be 8e 03 00 00       	mov    $0x38e,%esi
  8004203df3:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004203dfa:	00 00 00 
  8004203dfd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203e02:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004203e09:	00 00 00 
  8004203e0c:	41 ff d0             	callq  *%r8
}
  8004203e0f:	c9                   	leaveq 
  8004203e10:	c3                   	retq   

0000008004203e11 <check_page_alloc>:
// Check the physical page allocator (page_alloc(), page_free(),
// and page_init()).
//
static void
check_page_alloc(void)
{
  8004203e11:	55                   	push   %rbp
  8004203e12:	48 89 e5             	mov    %rsp,%rbp
  8004203e15:	48 83 ec 40          	sub    $0x40,%rsp
	int i;

	// if there's a page that shouldn't be on
	// the free list, try to make sure it
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004203e19:	48 b8 38 52 49 04 80 	movabs $0x8004495238,%rax
  8004203e20:	00 00 00 
  8004203e23:	48 8b 00             	mov    (%rax),%rax
  8004203e26:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203e2a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  8004203e31:	eb 37                	jmp    8004203e6a <check_page_alloc+0x59>
		memset(page2kva(pp0), 0x97, PGSIZE);
  8004203e33:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203e37:	48 89 c7             	mov    %rax,%rdi
  8004203e3a:	48 b8 fa 19 20 04 80 	movabs $0x80042019fa,%rax
  8004203e41:	00 00 00 
  8004203e44:	ff d0                	callq  *%rax
  8004203e46:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004203e4b:	be 97 00 00 00       	mov    $0x97,%esi
  8004203e50:	48 89 c7             	mov    %rax,%rdi
  8004203e53:	48 b8 db e8 20 04 80 	movabs $0x800420e8db,%rax
  8004203e5a:	00 00 00 
  8004203e5d:	ff d0                	callq  *%rax
	int i;

	// if there's a page that shouldn't be on
	// the free list, try to make sure it
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004203e5f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203e63:	48 8b 00             	mov    (%rax),%rax
  8004203e66:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203e6a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203e6f:	75 c2                	jne    8004203e33 <check_page_alloc+0x22>
		memset(page2kva(pp0), 0x97, PGSIZE);
	}

	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004203e71:	48 b8 38 52 49 04 80 	movabs $0x8004495238,%rax
  8004203e78:	00 00 00 
  8004203e7b:	48 8b 00             	mov    (%rax),%rax
  8004203e7e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203e82:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  8004203e89:	e9 ec 01 00 00       	jmpq   800420407a <check_page_alloc+0x269>
		// check that we didn't corrupt the free list itself
		assert(pp0 >= pages);
  8004203e8e:	48 b8 b8 67 49 04 80 	movabs $0x80044967b8,%rax
  8004203e95:	00 00 00 
  8004203e98:	48 8b 00             	mov    (%rax),%rax
  8004203e9b:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004203e9f:	73 35                	jae    8004203ed6 <check_page_alloc+0xc5>
  8004203ea1:	48 b9 6b 65 21 04 80 	movabs $0x800421656b,%rcx
  8004203ea8:	00 00 00 
  8004203eab:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004203eb2:	00 00 00 
  8004203eb5:	be a8 03 00 00       	mov    $0x3a8,%esi
  8004203eba:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004203ec1:	00 00 00 
  8004203ec4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203ec9:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004203ed0:	00 00 00 
  8004203ed3:	41 ff d0             	callq  *%r8
		assert(pp0 < pages + npages);
  8004203ed6:	48 b8 b8 67 49 04 80 	movabs $0x80044967b8,%rax
  8004203edd:	00 00 00 
  8004203ee0:	48 8b 10             	mov    (%rax),%rdx
  8004203ee3:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  8004203eea:	00 00 00 
  8004203eed:	48 8b 00             	mov    (%rax),%rax
  8004203ef0:	48 c1 e0 04          	shl    $0x4,%rax
  8004203ef4:	48 01 d0             	add    %rdx,%rax
  8004203ef7:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004203efb:	77 35                	ja     8004203f32 <check_page_alloc+0x121>
  8004203efd:	48 b9 78 65 21 04 80 	movabs $0x8004216578,%rcx
  8004203f04:	00 00 00 
  8004203f07:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004203f0e:	00 00 00 
  8004203f11:	be a9 03 00 00       	mov    $0x3a9,%esi
  8004203f16:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004203f1d:	00 00 00 
  8004203f20:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203f25:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004203f2c:	00 00 00 
  8004203f2f:	41 ff d0             	callq  *%r8

		// check a few pages that shouldn't be on the free list
		assert(page2pa(pp0) != 0);
  8004203f32:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203f36:	48 89 c7             	mov    %rax,%rdi
  8004203f39:	48 b8 64 19 20 04 80 	movabs $0x8004201964,%rax
  8004203f40:	00 00 00 
  8004203f43:	ff d0                	callq  *%rax
  8004203f45:	48 85 c0             	test   %rax,%rax
  8004203f48:	75 35                	jne    8004203f7f <check_page_alloc+0x16e>
  8004203f4a:	48 b9 8d 65 21 04 80 	movabs $0x800421658d,%rcx
  8004203f51:	00 00 00 
  8004203f54:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004203f5b:	00 00 00 
  8004203f5e:	be ac 03 00 00       	mov    $0x3ac,%esi
  8004203f63:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004203f6a:	00 00 00 
  8004203f6d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203f72:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004203f79:	00 00 00 
  8004203f7c:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != IOPHYSMEM);
  8004203f7f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203f83:	48 89 c7             	mov    %rax,%rdi
  8004203f86:	48 b8 64 19 20 04 80 	movabs $0x8004201964,%rax
  8004203f8d:	00 00 00 
  8004203f90:	ff d0                	callq  *%rax
  8004203f92:	48 3d 00 00 0a 00    	cmp    $0xa0000,%rax
  8004203f98:	75 35                	jne    8004203fcf <check_page_alloc+0x1be>
  8004203f9a:	48 b9 9f 65 21 04 80 	movabs $0x800421659f,%rcx
  8004203fa1:	00 00 00 
  8004203fa4:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004203fab:	00 00 00 
  8004203fae:	be ad 03 00 00       	mov    $0x3ad,%esi
  8004203fb3:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004203fba:	00 00 00 
  8004203fbd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203fc2:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004203fc9:	00 00 00 
  8004203fcc:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != EXTPHYSMEM - PGSIZE);
  8004203fcf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203fd3:	48 89 c7             	mov    %rax,%rdi
  8004203fd6:	48 b8 64 19 20 04 80 	movabs $0x8004201964,%rax
  8004203fdd:	00 00 00 
  8004203fe0:	ff d0                	callq  *%rax
  8004203fe2:	48 3d 00 f0 0f 00    	cmp    $0xff000,%rax
  8004203fe8:	75 35                	jne    800420401f <check_page_alloc+0x20e>
  8004203fea:	48 b9 c0 65 21 04 80 	movabs $0x80042165c0,%rcx
  8004203ff1:	00 00 00 
  8004203ff4:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004203ffb:	00 00 00 
  8004203ffe:	be ae 03 00 00       	mov    $0x3ae,%esi
  8004204003:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  800420400a:	00 00 00 
  800420400d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204012:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204019:	00 00 00 
  800420401c:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != EXTPHYSMEM);
  800420401f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204023:	48 89 c7             	mov    %rax,%rdi
  8004204026:	48 b8 64 19 20 04 80 	movabs $0x8004201964,%rax
  800420402d:	00 00 00 
  8004204030:	ff d0                	callq  *%rax
  8004204032:	48 3d 00 00 10 00    	cmp    $0x100000,%rax
  8004204038:	75 35                	jne    800420406f <check_page_alloc+0x25e>
  800420403a:	48 b9 e4 65 21 04 80 	movabs $0x80042165e4,%rcx
  8004204041:	00 00 00 
  8004204044:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  800420404b:	00 00 00 
  800420404e:	be af 03 00 00       	mov    $0x3af,%esi
  8004204053:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  800420405a:	00 00 00 
  800420405d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204062:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204069:	00 00 00 
  800420406c:	41 ff d0             	callq  *%r8
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
		memset(page2kva(pp0), 0x97, PGSIZE);
	}

	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  800420406f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204073:	48 8b 00             	mov    (%rax),%rax
  8004204076:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420407a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420407f:	0f 85 09 fe ff ff    	jne    8004203e8e <check_page_alloc+0x7d>
		assert(page2pa(pp0) != IOPHYSMEM);
		assert(page2pa(pp0) != EXTPHYSMEM - PGSIZE);
		assert(page2pa(pp0) != EXTPHYSMEM);
	}
	// should be able to allocate three pages
	pp0 = pp1 = pp2 = 0;
  8004204085:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  800420408c:	00 
  800420408d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204091:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204095:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204099:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert((pp0 = page_alloc(0)));
  800420409d:	bf 00 00 00 00       	mov    $0x0,%edi
  80042040a2:	48 b8 72 2b 20 04 80 	movabs $0x8004202b72,%rax
  80042040a9:	00 00 00 
  80042040ac:	ff d0                	callq  *%rax
  80042040ae:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042040b2:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042040b7:	75 35                	jne    80042040ee <check_page_alloc+0x2dd>
  80042040b9:	48 b9 ff 65 21 04 80 	movabs $0x80042165ff,%rcx
  80042040c0:	00 00 00 
  80042040c3:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  80042040ca:	00 00 00 
  80042040cd:	be b3 03 00 00       	mov    $0x3b3,%esi
  80042040d2:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  80042040d9:	00 00 00 
  80042040dc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042040e1:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042040e8:	00 00 00 
  80042040eb:	41 ff d0             	callq  *%r8
	assert((pp1 = page_alloc(0)));
  80042040ee:	bf 00 00 00 00       	mov    $0x0,%edi
  80042040f3:	48 b8 72 2b 20 04 80 	movabs $0x8004202b72,%rax
  80042040fa:	00 00 00 
  80042040fd:	ff d0                	callq  *%rax
  80042040ff:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204103:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204108:	75 35                	jne    800420413f <check_page_alloc+0x32e>
  800420410a:	48 b9 15 66 21 04 80 	movabs $0x8004216615,%rcx
  8004204111:	00 00 00 
  8004204114:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  800420411b:	00 00 00 
  800420411e:	be b4 03 00 00       	mov    $0x3b4,%esi
  8004204123:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  800420412a:	00 00 00 
  800420412d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204132:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204139:	00 00 00 
  800420413c:	41 ff d0             	callq  *%r8
	assert((pp2 = page_alloc(0)));
  800420413f:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204144:	48 b8 72 2b 20 04 80 	movabs $0x8004202b72,%rax
  800420414b:	00 00 00 
  800420414e:	ff d0                	callq  *%rax
  8004204150:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004204154:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204159:	75 35                	jne    8004204190 <check_page_alloc+0x37f>
  800420415b:	48 b9 2b 66 21 04 80 	movabs $0x800421662b,%rcx
  8004204162:	00 00 00 
  8004204165:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  800420416c:	00 00 00 
  800420416f:	be b5 03 00 00       	mov    $0x3b5,%esi
  8004204174:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  800420417b:	00 00 00 
  800420417e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204183:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420418a:	00 00 00 
  800420418d:	41 ff d0             	callq  *%r8
	assert(pp0);
  8004204190:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204195:	75 35                	jne    80042041cc <check_page_alloc+0x3bb>
  8004204197:	48 b9 41 66 21 04 80 	movabs $0x8004216641,%rcx
  800420419e:	00 00 00 
  80042041a1:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  80042041a8:	00 00 00 
  80042041ab:	be b6 03 00 00       	mov    $0x3b6,%esi
  80042041b0:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  80042041b7:	00 00 00 
  80042041ba:	b8 00 00 00 00       	mov    $0x0,%eax
  80042041bf:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042041c6:	00 00 00 
  80042041c9:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  80042041cc:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042041d1:	74 0a                	je     80042041dd <check_page_alloc+0x3cc>
  80042041d3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042041d7:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042041db:	75 35                	jne    8004204212 <check_page_alloc+0x401>
  80042041dd:	48 b9 45 66 21 04 80 	movabs $0x8004216645,%rcx
  80042041e4:	00 00 00 
  80042041e7:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  80042041ee:	00 00 00 
  80042041f1:	be b7 03 00 00       	mov    $0x3b7,%esi
  80042041f6:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  80042041fd:	00 00 00 
  8004204200:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204205:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420420c:	00 00 00 
  800420420f:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  8004204212:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204217:	74 14                	je     800420422d <check_page_alloc+0x41c>
  8004204219:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420421d:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004204221:	74 0a                	je     800420422d <check_page_alloc+0x41c>
  8004204223:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204227:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420422b:	75 35                	jne    8004204262 <check_page_alloc+0x451>
  800420422d:	48 b9 58 66 21 04 80 	movabs $0x8004216658,%rcx
  8004204234:	00 00 00 
  8004204237:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  800420423e:	00 00 00 
  8004204241:	be b8 03 00 00       	mov    $0x3b8,%esi
  8004204246:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  800420424d:	00 00 00 
  8004204250:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204255:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420425c:	00 00 00 
  800420425f:	41 ff d0             	callq  *%r8
	assert(page2pa(pp0) < npages*PGSIZE);
  8004204262:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204266:	48 89 c7             	mov    %rax,%rdi
  8004204269:	48 b8 64 19 20 04 80 	movabs $0x8004201964,%rax
  8004204270:	00 00 00 
  8004204273:	ff d0                	callq  *%rax
  8004204275:	48 ba b0 67 49 04 80 	movabs $0x80044967b0,%rdx
  800420427c:	00 00 00 
  800420427f:	48 8b 12             	mov    (%rdx),%rdx
  8004204282:	48 c1 e2 0c          	shl    $0xc,%rdx
  8004204286:	48 39 d0             	cmp    %rdx,%rax
  8004204289:	72 35                	jb     80042042c0 <check_page_alloc+0x4af>
  800420428b:	48 b9 78 66 21 04 80 	movabs $0x8004216678,%rcx
  8004204292:	00 00 00 
  8004204295:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  800420429c:	00 00 00 
  800420429f:	be b9 03 00 00       	mov    $0x3b9,%esi
  80042042a4:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  80042042ab:	00 00 00 
  80042042ae:	b8 00 00 00 00       	mov    $0x0,%eax
  80042042b3:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042042ba:	00 00 00 
  80042042bd:	41 ff d0             	callq  *%r8
	assert(page2pa(pp1) < npages*PGSIZE);
  80042042c0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042042c4:	48 89 c7             	mov    %rax,%rdi
  80042042c7:	48 b8 64 19 20 04 80 	movabs $0x8004201964,%rax
  80042042ce:	00 00 00 
  80042042d1:	ff d0                	callq  *%rax
  80042042d3:	48 ba b0 67 49 04 80 	movabs $0x80044967b0,%rdx
  80042042da:	00 00 00 
  80042042dd:	48 8b 12             	mov    (%rdx),%rdx
  80042042e0:	48 c1 e2 0c          	shl    $0xc,%rdx
  80042042e4:	48 39 d0             	cmp    %rdx,%rax
  80042042e7:	72 35                	jb     800420431e <check_page_alloc+0x50d>
  80042042e9:	48 b9 95 66 21 04 80 	movabs $0x8004216695,%rcx
  80042042f0:	00 00 00 
  80042042f3:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  80042042fa:	00 00 00 
  80042042fd:	be ba 03 00 00       	mov    $0x3ba,%esi
  8004204302:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004204309:	00 00 00 
  800420430c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204311:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204318:	00 00 00 
  800420431b:	41 ff d0             	callq  *%r8
	assert(page2pa(pp2) < npages*PGSIZE);
  800420431e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204322:	48 89 c7             	mov    %rax,%rdi
  8004204325:	48 b8 64 19 20 04 80 	movabs $0x8004201964,%rax
  800420432c:	00 00 00 
  800420432f:	ff d0                	callq  *%rax
  8004204331:	48 ba b0 67 49 04 80 	movabs $0x80044967b0,%rdx
  8004204338:	00 00 00 
  800420433b:	48 8b 12             	mov    (%rdx),%rdx
  800420433e:	48 c1 e2 0c          	shl    $0xc,%rdx
  8004204342:	48 39 d0             	cmp    %rdx,%rax
  8004204345:	72 35                	jb     800420437c <check_page_alloc+0x56b>
  8004204347:	48 b9 b2 66 21 04 80 	movabs $0x80042166b2,%rcx
  800420434e:	00 00 00 
  8004204351:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004204358:	00 00 00 
  800420435b:	be bb 03 00 00       	mov    $0x3bb,%esi
  8004204360:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004204367:	00 00 00 
  800420436a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420436f:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204376:	00 00 00 
  8004204379:	41 ff d0             	callq  *%r8

	// temporarily steal the rest of the free pages
	fl = page_free_list;
  800420437c:	48 b8 38 52 49 04 80 	movabs $0x8004495238,%rax
  8004204383:	00 00 00 
  8004204386:	48 8b 00             	mov    (%rax),%rax
  8004204389:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	page_free_list = 0;
  800420438d:	48 b8 38 52 49 04 80 	movabs $0x8004495238,%rax
  8004204394:	00 00 00 
  8004204397:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// should be no free memory
	assert(!page_alloc(0));
  800420439e:	bf 00 00 00 00       	mov    $0x0,%edi
  80042043a3:	48 b8 72 2b 20 04 80 	movabs $0x8004202b72,%rax
  80042043aa:	00 00 00 
  80042043ad:	ff d0                	callq  *%rax
  80042043af:	48 85 c0             	test   %rax,%rax
  80042043b2:	74 35                	je     80042043e9 <check_page_alloc+0x5d8>
  80042043b4:	48 b9 cf 66 21 04 80 	movabs $0x80042166cf,%rcx
  80042043bb:	00 00 00 
  80042043be:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  80042043c5:	00 00 00 
  80042043c8:	be c2 03 00 00       	mov    $0x3c2,%esi
  80042043cd:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  80042043d4:	00 00 00 
  80042043d7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042043dc:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042043e3:	00 00 00 
  80042043e6:	41 ff d0             	callq  *%r8

	// free and re-allocate?
	page_free(pp0);
  80042043e9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042043ed:	48 89 c7             	mov    %rax,%rdi
  80042043f0:	48 b8 11 2c 20 04 80 	movabs $0x8004202c11,%rax
  80042043f7:	00 00 00 
  80042043fa:	ff d0                	callq  *%rax
	page_free(pp1);
  80042043fc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204400:	48 89 c7             	mov    %rax,%rdi
  8004204403:	48 b8 11 2c 20 04 80 	movabs $0x8004202c11,%rax
  800420440a:	00 00 00 
  800420440d:	ff d0                	callq  *%rax
	page_free(pp2);
  800420440f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204413:	48 89 c7             	mov    %rax,%rdi
  8004204416:	48 b8 11 2c 20 04 80 	movabs $0x8004202c11,%rax
  800420441d:	00 00 00 
  8004204420:	ff d0                	callq  *%rax
	pp0 = pp1 = pp2 = 0;
  8004204422:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004204429:	00 
  800420442a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420442e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204432:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204436:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert((pp0 = page_alloc(0)));
  800420443a:	bf 00 00 00 00       	mov    $0x0,%edi
  800420443f:	48 b8 72 2b 20 04 80 	movabs $0x8004202b72,%rax
  8004204446:	00 00 00 
  8004204449:	ff d0                	callq  *%rax
  800420444b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420444f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204454:	75 35                	jne    800420448b <check_page_alloc+0x67a>
  8004204456:	48 b9 ff 65 21 04 80 	movabs $0x80042165ff,%rcx
  800420445d:	00 00 00 
  8004204460:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004204467:	00 00 00 
  800420446a:	be c9 03 00 00       	mov    $0x3c9,%esi
  800420446f:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004204476:	00 00 00 
  8004204479:	b8 00 00 00 00       	mov    $0x0,%eax
  800420447e:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204485:	00 00 00 
  8004204488:	41 ff d0             	callq  *%r8
	assert((pp1 = page_alloc(0)));
  800420448b:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204490:	48 b8 72 2b 20 04 80 	movabs $0x8004202b72,%rax
  8004204497:	00 00 00 
  800420449a:	ff d0                	callq  *%rax
  800420449c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042044a0:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042044a5:	75 35                	jne    80042044dc <check_page_alloc+0x6cb>
  80042044a7:	48 b9 15 66 21 04 80 	movabs $0x8004216615,%rcx
  80042044ae:	00 00 00 
  80042044b1:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  80042044b8:	00 00 00 
  80042044bb:	be ca 03 00 00       	mov    $0x3ca,%esi
  80042044c0:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  80042044c7:	00 00 00 
  80042044ca:	b8 00 00 00 00       	mov    $0x0,%eax
  80042044cf:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042044d6:	00 00 00 
  80042044d9:	41 ff d0             	callq  *%r8
	assert((pp2 = page_alloc(0)));
  80042044dc:	bf 00 00 00 00       	mov    $0x0,%edi
  80042044e1:	48 b8 72 2b 20 04 80 	movabs $0x8004202b72,%rax
  80042044e8:	00 00 00 
  80042044eb:	ff d0                	callq  *%rax
  80042044ed:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  80042044f1:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042044f6:	75 35                	jne    800420452d <check_page_alloc+0x71c>
  80042044f8:	48 b9 2b 66 21 04 80 	movabs $0x800421662b,%rcx
  80042044ff:	00 00 00 
  8004204502:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004204509:	00 00 00 
  800420450c:	be cb 03 00 00       	mov    $0x3cb,%esi
  8004204511:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004204518:	00 00 00 
  800420451b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204520:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204527:	00 00 00 
  800420452a:	41 ff d0             	callq  *%r8
	assert(pp0);
  800420452d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204532:	75 35                	jne    8004204569 <check_page_alloc+0x758>
  8004204534:	48 b9 41 66 21 04 80 	movabs $0x8004216641,%rcx
  800420453b:	00 00 00 
  800420453e:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004204545:	00 00 00 
  8004204548:	be cc 03 00 00       	mov    $0x3cc,%esi
  800420454d:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004204554:	00 00 00 
  8004204557:	b8 00 00 00 00       	mov    $0x0,%eax
  800420455c:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204563:	00 00 00 
  8004204566:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  8004204569:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420456e:	74 0a                	je     800420457a <check_page_alloc+0x769>
  8004204570:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204574:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204578:	75 35                	jne    80042045af <check_page_alloc+0x79e>
  800420457a:	48 b9 45 66 21 04 80 	movabs $0x8004216645,%rcx
  8004204581:	00 00 00 
  8004204584:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  800420458b:	00 00 00 
  800420458e:	be cd 03 00 00       	mov    $0x3cd,%esi
  8004204593:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  800420459a:	00 00 00 
  800420459d:	b8 00 00 00 00       	mov    $0x0,%eax
  80042045a2:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042045a9:	00 00 00 
  80042045ac:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  80042045af:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042045b4:	74 14                	je     80042045ca <check_page_alloc+0x7b9>
  80042045b6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042045ba:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  80042045be:	74 0a                	je     80042045ca <check_page_alloc+0x7b9>
  80042045c0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042045c4:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042045c8:	75 35                	jne    80042045ff <check_page_alloc+0x7ee>
  80042045ca:	48 b9 58 66 21 04 80 	movabs $0x8004216658,%rcx
  80042045d1:	00 00 00 
  80042045d4:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  80042045db:	00 00 00 
  80042045de:	be ce 03 00 00       	mov    $0x3ce,%esi
  80042045e3:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  80042045ea:	00 00 00 
  80042045ed:	b8 00 00 00 00       	mov    $0x0,%eax
  80042045f2:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042045f9:	00 00 00 
  80042045fc:	41 ff d0             	callq  *%r8
	assert(!page_alloc(0));
  80042045ff:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204604:	48 b8 72 2b 20 04 80 	movabs $0x8004202b72,%rax
  800420460b:	00 00 00 
  800420460e:	ff d0                	callq  *%rax
  8004204610:	48 85 c0             	test   %rax,%rax
  8004204613:	74 35                	je     800420464a <check_page_alloc+0x839>
  8004204615:	48 b9 cf 66 21 04 80 	movabs $0x80042166cf,%rcx
  800420461c:	00 00 00 
  800420461f:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004204626:	00 00 00 
  8004204629:	be cf 03 00 00       	mov    $0x3cf,%esi
  800420462e:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004204635:	00 00 00 
  8004204638:	b8 00 00 00 00       	mov    $0x0,%eax
  800420463d:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204644:	00 00 00 
  8004204647:	41 ff d0             	callq  *%r8

	// test flags
	memset(page2kva(pp0), 1, PGSIZE);
  800420464a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420464e:	48 89 c7             	mov    %rax,%rdi
  8004204651:	48 b8 fa 19 20 04 80 	movabs $0x80042019fa,%rax
  8004204658:	00 00 00 
  800420465b:	ff d0                	callq  *%rax
  800420465d:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004204662:	be 01 00 00 00       	mov    $0x1,%esi
  8004204667:	48 89 c7             	mov    %rax,%rdi
  800420466a:	48 b8 db e8 20 04 80 	movabs $0x800420e8db,%rax
  8004204671:	00 00 00 
  8004204674:	ff d0                	callq  *%rax
	page_free(pp0);
  8004204676:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420467a:	48 89 c7             	mov    %rax,%rdi
  800420467d:	48 b8 11 2c 20 04 80 	movabs $0x8004202c11,%rax
  8004204684:	00 00 00 
  8004204687:	ff d0                	callq  *%rax
	assert((pp = page_alloc(ALLOC_ZERO)));
  8004204689:	bf 01 00 00 00       	mov    $0x1,%edi
  800420468e:	48 b8 72 2b 20 04 80 	movabs $0x8004202b72,%rax
  8004204695:	00 00 00 
  8004204698:	ff d0                	callq  *%rax
  800420469a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  800420469e:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80042046a3:	75 35                	jne    80042046da <check_page_alloc+0x8c9>
  80042046a5:	48 b9 de 66 21 04 80 	movabs $0x80042166de,%rcx
  80042046ac:	00 00 00 
  80042046af:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  80042046b6:	00 00 00 
  80042046b9:	be d4 03 00 00       	mov    $0x3d4,%esi
  80042046be:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  80042046c5:	00 00 00 
  80042046c8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042046cd:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042046d4:	00 00 00 
  80042046d7:	41 ff d0             	callq  *%r8
	assert(pp && pp0 == pp);
  80042046da:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80042046df:	74 0a                	je     80042046eb <check_page_alloc+0x8da>
  80042046e1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042046e5:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042046e9:	74 35                	je     8004204720 <check_page_alloc+0x90f>
  80042046eb:	48 b9 fc 66 21 04 80 	movabs $0x80042166fc,%rcx
  80042046f2:	00 00 00 
  80042046f5:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  80042046fc:	00 00 00 
  80042046ff:	be d5 03 00 00       	mov    $0x3d5,%esi
  8004204704:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  800420470b:	00 00 00 
  800420470e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204713:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420471a:	00 00 00 
  800420471d:	41 ff d0             	callq  *%r8
	c = page2kva(pp);
  8004204720:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004204724:	48 89 c7             	mov    %rax,%rdi
  8004204727:	48 b8 fa 19 20 04 80 	movabs $0x80042019fa,%rax
  800420472e:	00 00 00 
  8004204731:	ff d0                	callq  *%rax
  8004204733:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	for (i = 0; i < PGSIZE; i++)
  8004204737:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  800420473e:	eb 4d                	jmp    800420478d <check_page_alloc+0x97c>
		assert(c[i] == 0);
  8004204740:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004204743:	48 63 d0             	movslq %eax,%rdx
  8004204746:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420474a:	48 01 d0             	add    %rdx,%rax
  800420474d:	0f b6 00             	movzbl (%rax),%eax
  8004204750:	84 c0                	test   %al,%al
  8004204752:	74 35                	je     8004204789 <check_page_alloc+0x978>
  8004204754:	48 b9 0c 67 21 04 80 	movabs $0x800421670c,%rcx
  800420475b:	00 00 00 
  800420475e:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004204765:	00 00 00 
  8004204768:	be d8 03 00 00       	mov    $0x3d8,%esi
  800420476d:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004204774:	00 00 00 
  8004204777:	b8 00 00 00 00       	mov    $0x0,%eax
  800420477c:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204783:	00 00 00 
  8004204786:	41 ff d0             	callq  *%r8
	memset(page2kva(pp0), 1, PGSIZE);
	page_free(pp0);
	assert((pp = page_alloc(ALLOC_ZERO)));
	assert(pp && pp0 == pp);
	c = page2kva(pp);
	for (i = 0; i < PGSIZE; i++)
  8004204789:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  800420478d:	81 7d f4 ff 0f 00 00 	cmpl   $0xfff,-0xc(%rbp)
  8004204794:	7e aa                	jle    8004204740 <check_page_alloc+0x92f>
		assert(c[i] == 0);

	// give free list back
	page_free_list = fl;
  8004204796:	48 b8 38 52 49 04 80 	movabs $0x8004495238,%rax
  800420479d:	00 00 00 
  80042047a0:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042047a4:	48 89 10             	mov    %rdx,(%rax)

	// free the pages we took
	page_free(pp0);
  80042047a7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042047ab:	48 89 c7             	mov    %rax,%rdi
  80042047ae:	48 b8 11 2c 20 04 80 	movabs $0x8004202c11,%rax
  80042047b5:	00 00 00 
  80042047b8:	ff d0                	callq  *%rax
	page_free(pp1);
  80042047ba:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042047be:	48 89 c7             	mov    %rax,%rdi
  80042047c1:	48 b8 11 2c 20 04 80 	movabs $0x8004202c11,%rax
  80042047c8:	00 00 00 
  80042047cb:	ff d0                	callq  *%rax
	page_free(pp2);
  80042047cd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042047d1:	48 89 c7             	mov    %rax,%rdi
  80042047d4:	48 b8 11 2c 20 04 80 	movabs $0x8004202c11,%rax
  80042047db:	00 00 00 
  80042047de:	ff d0                	callq  *%rax

	cprintf("check_page_alloc() succeeded!\n");
  80042047e0:	48 bf 18 67 21 04 80 	movabs $0x8004216718,%rdi
  80042047e7:	00 00 00 
  80042047ea:	b8 00 00 00 00       	mov    $0x0,%eax
  80042047ef:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  80042047f6:	00 00 00 
  80042047f9:	ff d2                	callq  *%rdx
}
  80042047fb:	c9                   	leaveq 
  80042047fc:	c3                   	retq   

00000080042047fd <check_boot_pml4e>:
// but it is a pretty good sanity check.
//

static void
check_boot_pml4e(pml4e_t *pml4e)
{
  80042047fd:	55                   	push   %rbp
  80042047fe:	48 89 e5             	mov    %rsp,%rbp
  8004204801:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  8004204808:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
	uint64_t i, n;

	pml4e = boot_pml4e;
  800420480f:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  8004204816:	00 00 00 
  8004204819:	48 8b 00             	mov    (%rax),%rax
  800420481c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	// check pages array
	n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
  8004204820:	48 c7 45 e0 00 10 00 	movq   $0x1000,-0x20(%rbp)
  8004204827:	00 
  8004204828:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  800420482f:	00 00 00 
  8004204832:	48 8b 00             	mov    (%rax),%rax
  8004204835:	48 c1 e0 04          	shl    $0x4,%rax
  8004204839:	48 89 c2             	mov    %rax,%rdx
  800420483c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204840:	48 01 d0             	add    %rdx,%rax
  8004204843:	48 83 e8 01          	sub    $0x1,%rax
  8004204847:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800420484b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420484f:	ba 00 00 00 00       	mov    $0x0,%edx
  8004204854:	48 f7 75 e0          	divq   -0x20(%rbp)
  8004204858:	48 89 d0             	mov    %rdx,%rax
  800420485b:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420485f:	48 29 c2             	sub    %rax,%rdx
  8004204862:	48 89 d0             	mov    %rdx,%rax
  8004204865:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < n; i += PGSIZE) {
  8004204869:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004204870:	00 
  8004204871:	e9 d4 00 00 00       	jmpq   800420494a <check_boot_pml4e+0x14d>
		// cprintf("%x %x %x\n",i,check_va2pa(pml4e, UPAGES + i), PADDR(pages) + i);
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
  8004204876:	48 ba 00 00 a0 00 80 	movabs $0x8000a00000,%rdx
  800420487d:	00 00 00 
  8004204880:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204884:	48 01 c2             	add    %rax,%rdx
  8004204887:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420488b:	48 89 d6             	mov    %rdx,%rsi
  800420488e:	48 89 c7             	mov    %rax,%rdi
  8004204891:	48 b8 4b 4f 20 04 80 	movabs $0x8004204f4b,%rax
  8004204898:	00 00 00 
  800420489b:	ff d0                	callq  *%rax
  800420489d:	48 ba b8 67 49 04 80 	movabs $0x80044967b8,%rdx
  80042048a4:	00 00 00 
  80042048a7:	48 8b 12             	mov    (%rdx),%rdx
  80042048aa:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  80042048ae:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  80042048b5:	00 00 00 
  80042048b8:	48 39 55 d0          	cmp    %rdx,-0x30(%rbp)
  80042048bc:	77 32                	ja     80042048f0 <check_boot_pml4e+0xf3>
  80042048be:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042048c2:	48 89 c1             	mov    %rax,%rcx
  80042048c5:	48 ba 68 63 21 04 80 	movabs $0x8004216368,%rdx
  80042048cc:	00 00 00 
  80042048cf:	be f8 03 00 00       	mov    $0x3f8,%esi
  80042048d4:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  80042048db:	00 00 00 
  80042048de:	b8 00 00 00 00       	mov    $0x0,%eax
  80042048e3:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042048ea:	00 00 00 
  80042048ed:	41 ff d0             	callq  *%r8
  80042048f0:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  80042048f7:	ff ff ff 
  80042048fa:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042048fe:	48 01 d1             	add    %rdx,%rcx
  8004204901:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004204905:	48 01 ca             	add    %rcx,%rdx
  8004204908:	48 39 d0             	cmp    %rdx,%rax
  800420490b:	74 35                	je     8004204942 <check_boot_pml4e+0x145>
  800420490d:	48 b9 38 67 21 04 80 	movabs $0x8004216738,%rcx
  8004204914:	00 00 00 
  8004204917:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  800420491e:	00 00 00 
  8004204921:	be f8 03 00 00       	mov    $0x3f8,%esi
  8004204926:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  800420492d:	00 00 00 
  8004204930:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204935:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420493c:	00 00 00 
  800420493f:	41 ff d0             	callq  *%r8

	pml4e = boot_pml4e;

	// check pages array
	n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
	for (i = 0; i < n; i += PGSIZE) {
  8004204942:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004204949:	00 
  800420494a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420494e:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8004204952:	0f 82 1e ff ff ff    	jb     8004204876 <check_boot_pml4e+0x79>
		// cprintf("%x %x %x\n",i,check_va2pa(pml4e, UPAGES + i), PADDR(pages) + i);
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
	}

	// check envs array (new test for lab 3)
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
  8004204958:	48 c7 45 c8 00 10 00 	movq   $0x1000,-0x38(%rbp)
  800420495f:	00 
  8004204960:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004204964:	48 05 ff 7f 04 00    	add    $0x47fff,%rax
  800420496a:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  800420496e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004204972:	ba 00 00 00 00       	mov    $0x0,%edx
  8004204977:	48 f7 75 c8          	divq   -0x38(%rbp)
  800420497b:	48 89 d0             	mov    %rdx,%rax
  800420497e:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004204982:	48 29 c2             	sub    %rax,%rdx
  8004204985:	48 89 d0             	mov    %rdx,%rax
  8004204988:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < n; i += PGSIZE)
  800420498c:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004204993:	00 
  8004204994:	e9 d4 00 00 00       	jmpq   8004204a6d <check_boot_pml4e+0x270>
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);
  8004204999:	48 ba 00 00 80 00 80 	movabs $0x8000800000,%rdx
  80042049a0:	00 00 00 
  80042049a3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042049a7:	48 01 c2             	add    %rax,%rdx
  80042049aa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042049ae:	48 89 d6             	mov    %rdx,%rsi
  80042049b1:	48 89 c7             	mov    %rax,%rdi
  80042049b4:	48 b8 4b 4f 20 04 80 	movabs $0x8004204f4b,%rax
  80042049bb:	00 00 00 
  80042049be:	ff d0                	callq  *%rax
  80042049c0:	48 ba 50 52 49 04 80 	movabs $0x8004495250,%rdx
  80042049c7:	00 00 00 
  80042049ca:	48 8b 12             	mov    (%rdx),%rdx
  80042049cd:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  80042049d1:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  80042049d8:	00 00 00 
  80042049db:	48 39 55 b8          	cmp    %rdx,-0x48(%rbp)
  80042049df:	77 32                	ja     8004204a13 <check_boot_pml4e+0x216>
  80042049e1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042049e5:	48 89 c1             	mov    %rax,%rcx
  80042049e8:	48 ba 68 63 21 04 80 	movabs $0x8004216368,%rdx
  80042049ef:	00 00 00 
  80042049f2:	be fe 03 00 00       	mov    $0x3fe,%esi
  80042049f7:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  80042049fe:	00 00 00 
  8004204a01:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204a06:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204a0d:	00 00 00 
  8004204a10:	41 ff d0             	callq  *%r8
  8004204a13:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  8004204a1a:	ff ff ff 
  8004204a1d:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004204a21:	48 01 d1             	add    %rdx,%rcx
  8004204a24:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004204a28:	48 01 ca             	add    %rcx,%rdx
  8004204a2b:	48 39 d0             	cmp    %rdx,%rax
  8004204a2e:	74 35                	je     8004204a65 <check_boot_pml4e+0x268>
  8004204a30:	48 b9 70 67 21 04 80 	movabs $0x8004216770,%rcx
  8004204a37:	00 00 00 
  8004204a3a:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004204a41:	00 00 00 
  8004204a44:	be fe 03 00 00       	mov    $0x3fe,%esi
  8004204a49:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004204a50:	00 00 00 
  8004204a53:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204a58:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204a5f:	00 00 00 
  8004204a62:	41 ff d0             	callq  *%r8
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
	}

	// check envs array (new test for lab 3)
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
	for (i = 0; i < n; i += PGSIZE)
  8004204a65:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004204a6c:	00 
  8004204a6d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204a71:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8004204a75:	0f 82 1e ff ff ff    	jb     8004204999 <check_boot_pml4e+0x19c>
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);

	// check phys mem
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
  8004204a7b:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004204a82:	00 
  8004204a83:	eb 6a                	jmp    8004204aef <check_boot_pml4e+0x2f2>
		assert(check_va2pa(pml4e, KERNBASE + i) == i);
  8004204a85:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004204a8c:	00 00 00 
  8004204a8f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204a93:	48 01 c2             	add    %rax,%rdx
  8004204a96:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204a9a:	48 89 d6             	mov    %rdx,%rsi
  8004204a9d:	48 89 c7             	mov    %rax,%rdi
  8004204aa0:	48 b8 4b 4f 20 04 80 	movabs $0x8004204f4b,%rax
  8004204aa7:	00 00 00 
  8004204aaa:	ff d0                	callq  *%rax
  8004204aac:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204ab0:	74 35                	je     8004204ae7 <check_boot_pml4e+0x2ea>
  8004204ab2:	48 b9 a8 67 21 04 80 	movabs $0x80042167a8,%rcx
  8004204ab9:	00 00 00 
  8004204abc:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004204ac3:	00 00 00 
  8004204ac6:	be 02 04 00 00       	mov    $0x402,%esi
  8004204acb:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004204ad2:	00 00 00 
  8004204ad5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204ada:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204ae1:	00 00 00 
  8004204ae4:	41 ff d0             	callq  *%r8
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
	for (i = 0; i < n; i += PGSIZE)
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);

	// check phys mem
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
  8004204ae7:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004204aee:	00 
  8004204aef:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  8004204af6:	00 00 00 
  8004204af9:	48 8b 00             	mov    (%rax),%rax
  8004204afc:	48 c1 e0 0c          	shl    $0xc,%rax
  8004204b00:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204b04:	0f 87 7b ff ff ff    	ja     8004204a85 <check_boot_pml4e+0x288>
		assert(check_va2pa(pml4e, KERNBASE + i) == i);

	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
  8004204b0a:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004204b11:	00 
  8004204b12:	e9 a1 01 00 00       	jmpq   8004204cb8 <check_boot_pml4e+0x4bb>
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
  8004204b17:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004204b1b:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004204b1f:	48 89 d0             	mov    %rdx,%rax
  8004204b22:	48 01 c0             	add    %rax,%rax
  8004204b25:	48 01 d0             	add    %rdx,%rax
  8004204b28:	48 c1 e0 0f          	shl    $0xf,%rax
  8004204b2c:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004204b33:	00 00 00 
  8004204b36:	48 29 c2             	sub    %rax,%rdx
  8004204b39:	48 89 d0             	mov    %rdx,%rax
  8004204b3c:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
  8004204b40:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004204b47:	00 
  8004204b48:	e9 e0 00 00 00       	jmpq   8004204c2d <check_boot_pml4e+0x430>
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
  8004204b4d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204b51:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004204b55:	48 01 d0             	add    %rdx,%rax
  8004204b58:	48 8d 90 00 80 00 00 	lea    0x8000(%rax),%rdx
  8004204b5f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204b63:	48 89 d6             	mov    %rdx,%rsi
  8004204b66:	48 89 c7             	mov    %rax,%rdi
  8004204b69:	48 b8 4b 4f 20 04 80 	movabs $0x8004204f4b,%rax
  8004204b70:	00 00 00 
  8004204b73:	ff d0                	callq  *%rax
  8004204b75:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004204b79:	48 89 d1             	mov    %rdx,%rcx
  8004204b7c:	48 c1 e1 10          	shl    $0x10,%rcx
  8004204b80:	48 ba 00 90 49 04 80 	movabs $0x8004499000,%rdx
  8004204b87:	00 00 00 
  8004204b8a:	48 01 ca             	add    %rcx,%rdx
  8004204b8d:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  8004204b91:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  8004204b98:	00 00 00 
  8004204b9b:	48 39 55 a8          	cmp    %rdx,-0x58(%rbp)
  8004204b9f:	77 32                	ja     8004204bd3 <check_boot_pml4e+0x3d6>
  8004204ba1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004204ba5:	48 89 c1             	mov    %rax,%rcx
  8004204ba8:	48 ba 68 63 21 04 80 	movabs $0x8004216368,%rdx
  8004204baf:	00 00 00 
  8004204bb2:	be 0a 04 00 00       	mov    $0x40a,%esi
  8004204bb7:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004204bbe:	00 00 00 
  8004204bc1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204bc6:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204bcd:	00 00 00 
  8004204bd0:	41 ff d0             	callq  *%r8
  8004204bd3:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  8004204bda:	ff ff ff 
  8004204bdd:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004204be1:	48 01 d1             	add    %rdx,%rcx
  8004204be4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004204be8:	48 01 ca             	add    %rcx,%rdx
  8004204beb:	48 39 d0             	cmp    %rdx,%rax
  8004204bee:	74 35                	je     8004204c25 <check_boot_pml4e+0x428>
  8004204bf0:	48 b9 d0 67 21 04 80 	movabs $0x80042167d0,%rcx
  8004204bf7:	00 00 00 
  8004204bfa:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004204c01:	00 00 00 
  8004204c04:	be 0a 04 00 00       	mov    $0x40a,%esi
  8004204c09:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004204c10:	00 00 00 
  8004204c13:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204c18:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204c1f:	00 00 00 
  8004204c22:	41 ff d0             	callq  *%r8

	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
  8004204c25:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004204c2c:	00 
  8004204c2d:	48 81 7d f8 ff ff 00 	cmpq   $0xffff,-0x8(%rbp)
  8004204c34:	00 
  8004204c35:	0f 86 12 ff ff ff    	jbe    8004204b4d <check_boot_pml4e+0x350>
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
  8004204c3b:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004204c42:	00 
  8004204c43:	eb 64                	jmp    8004204ca9 <check_boot_pml4e+0x4ac>
			assert(check_va2pa(pml4e, base + i) == ~0);
  8004204c45:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204c49:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004204c4d:	48 01 c2             	add    %rax,%rdx
  8004204c50:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204c54:	48 89 d6             	mov    %rdx,%rsi
  8004204c57:	48 89 c7             	mov    %rax,%rdi
  8004204c5a:	48 b8 4b 4f 20 04 80 	movabs $0x8004204f4b,%rax
  8004204c61:	00 00 00 
  8004204c64:	ff d0                	callq  *%rax
  8004204c66:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004204c6a:	74 35                	je     8004204ca1 <check_boot_pml4e+0x4a4>
  8004204c6c:	48 b9 18 68 21 04 80 	movabs $0x8004216818,%rcx
  8004204c73:	00 00 00 
  8004204c76:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004204c7d:	00 00 00 
  8004204c80:	be 0c 04 00 00       	mov    $0x40c,%esi
  8004204c85:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004204c8c:	00 00 00 
  8004204c8f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204c94:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204c9b:	00 00 00 
  8004204c9e:	41 ff d0             	callq  *%r8
	for (n = 0; n < NCPU; n++) {
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
  8004204ca1:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004204ca8:	00 
  8004204ca9:	48 81 7d f8 ff 7f 00 	cmpq   $0x7fff,-0x8(%rbp)
  8004204cb0:	00 
  8004204cb1:	76 92                	jbe    8004204c45 <check_boot_pml4e+0x448>
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
		assert(check_va2pa(pml4e, KERNBASE + i) == i);

	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
  8004204cb3:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  8004204cb8:	48 83 7d f0 07       	cmpq   $0x7,-0x10(%rbp)
  8004204cbd:	0f 86 54 fe ff ff    	jbe    8004204b17 <check_boot_pml4e+0x31a>
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
			assert(check_va2pa(pml4e, base + i) == ~0);
	}

	pdpe_t *pdpe = KADDR(PTE_ADDR(boot_pml4e[1]));
  8004204cc3:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  8004204cca:	00 00 00 
  8004204ccd:	48 8b 00             	mov    (%rax),%rax
  8004204cd0:	48 83 c0 08          	add    $0x8,%rax
  8004204cd4:	48 8b 00             	mov    (%rax),%rax
  8004204cd7:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004204cdd:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  8004204ce1:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004204ce5:	48 c1 e8 0c          	shr    $0xc,%rax
  8004204ce9:	89 45 9c             	mov    %eax,-0x64(%rbp)
  8004204cec:	8b 55 9c             	mov    -0x64(%rbp),%edx
  8004204cef:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  8004204cf6:	00 00 00 
  8004204cf9:	48 8b 00             	mov    (%rax),%rax
  8004204cfc:	48 39 c2             	cmp    %rax,%rdx
  8004204cff:	72 32                	jb     8004204d33 <check_boot_pml4e+0x536>
  8004204d01:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004204d05:	48 89 c1             	mov    %rax,%rcx
  8004204d08:	48 ba e0 61 21 04 80 	movabs $0x80042161e0,%rdx
  8004204d0f:	00 00 00 
  8004204d12:	be 0f 04 00 00       	mov    $0x40f,%esi
  8004204d17:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004204d1e:	00 00 00 
  8004204d21:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204d26:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204d2d:	00 00 00 
  8004204d30:	41 ff d0             	callq  *%r8
  8004204d33:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004204d3a:	00 00 00 
  8004204d3d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004204d41:	48 01 d0             	add    %rdx,%rax
  8004204d44:	48 89 45 90          	mov    %rax,-0x70(%rbp)
	pde_t  *pgdir = KADDR(PTE_ADDR(pdpe[0]));
  8004204d48:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004204d4c:	48 8b 00             	mov    (%rax),%rax
  8004204d4f:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004204d55:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  8004204d59:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004204d5d:	48 c1 e8 0c          	shr    $0xc,%rax
  8004204d61:	89 45 84             	mov    %eax,-0x7c(%rbp)
  8004204d64:	8b 55 84             	mov    -0x7c(%rbp),%edx
  8004204d67:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  8004204d6e:	00 00 00 
  8004204d71:	48 8b 00             	mov    (%rax),%rax
  8004204d74:	48 39 c2             	cmp    %rax,%rdx
  8004204d77:	72 32                	jb     8004204dab <check_boot_pml4e+0x5ae>
  8004204d79:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004204d7d:	48 89 c1             	mov    %rax,%rcx
  8004204d80:	48 ba e0 61 21 04 80 	movabs $0x80042161e0,%rdx
  8004204d87:	00 00 00 
  8004204d8a:	be 10 04 00 00       	mov    $0x410,%esi
  8004204d8f:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004204d96:	00 00 00 
  8004204d99:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204d9e:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204da5:	00 00 00 
  8004204da8:	41 ff d0             	callq  *%r8
  8004204dab:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004204db2:	00 00 00 
  8004204db5:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004204db9:	48 01 d0             	add    %rdx,%rax
  8004204dbc:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
	// check PDE permissions
	for (i = 0; i < NPDENTRIES; i++) {
  8004204dc3:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004204dca:	00 
  8004204dcb:	e9 50 01 00 00       	jmpq   8004204f20 <check_boot_pml4e+0x723>
		switch (i) {
  8004204dd0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204dd4:	48 83 f8 04          	cmp    $0x4,%rax
  8004204dd8:	72 67                	jb     8004204e41 <check_boot_pml4e+0x644>
  8004204dda:	48 83 f8 05          	cmp    $0x5,%rax
  8004204dde:	76 06                	jbe    8004204de6 <check_boot_pml4e+0x5e9>
  8004204de0:	48 83 f8 1f          	cmp    $0x1f,%rax
  8004204de4:	75 5b                	jne    8004204e41 <check_boot_pml4e+0x644>
			//case PDX(UVPT):
		case PDX(KSTACKTOP - 1):
		case PDX(UPAGES):
		case PDX(UENVS):
			assert(pgdir[i] & PTE_P);
  8004204de6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204dea:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004204df1:	00 
  8004204df2:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004204df9:	48 01 d0             	add    %rdx,%rax
  8004204dfc:	48 8b 00             	mov    (%rax),%rax
  8004204dff:	83 e0 01             	and    $0x1,%eax
  8004204e02:	48 85 c0             	test   %rax,%rax
  8004204e05:	75 35                	jne    8004204e3c <check_boot_pml4e+0x63f>
  8004204e07:	48 b9 3b 68 21 04 80 	movabs $0x800421683b,%rcx
  8004204e0e:	00 00 00 
  8004204e11:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004204e18:	00 00 00 
  8004204e1b:	be 18 04 00 00       	mov    $0x418,%esi
  8004204e20:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004204e27:	00 00 00 
  8004204e2a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204e2f:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204e36:	00 00 00 
  8004204e39:	41 ff d0             	callq  *%r8
			break;
  8004204e3c:	e9 da 00 00 00       	jmpq   8004204f1b <check_boot_pml4e+0x71e>
		default:
			if (i >= PDX(KERNBASE)) {
  8004204e41:	48 83 7d f8 1f       	cmpq   $0x1f,-0x8(%rbp)
  8004204e46:	0f 86 ce 00 00 00    	jbe    8004204f1a <check_boot_pml4e+0x71d>
				if (pgdir[i] & PTE_P)
  8004204e4c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204e50:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004204e57:	00 
  8004204e58:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004204e5f:	48 01 d0             	add    %rdx,%rax
  8004204e62:	48 8b 00             	mov    (%rax),%rax
  8004204e65:	83 e0 01             	and    $0x1,%eax
  8004204e68:	48 85 c0             	test   %rax,%rax
  8004204e6b:	74 5a                	je     8004204ec7 <check_boot_pml4e+0x6ca>
					assert(pgdir[i] & PTE_W);
  8004204e6d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204e71:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004204e78:	00 
  8004204e79:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004204e80:	48 01 d0             	add    %rdx,%rax
  8004204e83:	48 8b 00             	mov    (%rax),%rax
  8004204e86:	83 e0 02             	and    $0x2,%eax
  8004204e89:	48 85 c0             	test   %rax,%rax
  8004204e8c:	0f 85 88 00 00 00    	jne    8004204f1a <check_boot_pml4e+0x71d>
  8004204e92:	48 b9 4c 68 21 04 80 	movabs $0x800421684c,%rcx
  8004204e99:	00 00 00 
  8004204e9c:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004204ea3:	00 00 00 
  8004204ea6:	be 1d 04 00 00       	mov    $0x41d,%esi
  8004204eab:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004204eb2:	00 00 00 
  8004204eb5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204eba:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204ec1:	00 00 00 
  8004204ec4:	41 ff d0             	callq  *%r8
				else
					assert(pgdir[i] == 0);
  8004204ec7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204ecb:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004204ed2:	00 
  8004204ed3:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004204eda:	48 01 d0             	add    %rdx,%rax
  8004204edd:	48 8b 00             	mov    (%rax),%rax
  8004204ee0:	48 85 c0             	test   %rax,%rax
  8004204ee3:	74 35                	je     8004204f1a <check_boot_pml4e+0x71d>
  8004204ee5:	48 b9 5d 68 21 04 80 	movabs $0x800421685d,%rcx
  8004204eec:	00 00 00 
  8004204eef:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004204ef6:	00 00 00 
  8004204ef9:	be 1f 04 00 00       	mov    $0x41f,%esi
  8004204efe:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004204f05:	00 00 00 
  8004204f08:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204f0d:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204f14:	00 00 00 
  8004204f17:	41 ff d0             	callq  *%r8
			} 
			break;
  8004204f1a:	90                   	nop
	}

	pdpe_t *pdpe = KADDR(PTE_ADDR(boot_pml4e[1]));
	pde_t  *pgdir = KADDR(PTE_ADDR(pdpe[0]));
	// check PDE permissions
	for (i = 0; i < NPDENTRIES; i++) {
  8004204f1b:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004204f20:	48 81 7d f8 ff 01 00 	cmpq   $0x1ff,-0x8(%rbp)
  8004204f27:	00 
  8004204f28:	0f 86 a2 fe ff ff    	jbe    8004204dd0 <check_boot_pml4e+0x5d3>
					assert(pgdir[i] == 0);
			} 
			break;
		}
	}
	cprintf("check_boot_pml4e() succeeded!\n");
  8004204f2e:	48 bf 70 68 21 04 80 	movabs $0x8004216870,%rdi
  8004204f35:	00 00 00 
  8004204f38:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204f3d:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  8004204f44:	00 00 00 
  8004204f47:	ff d2                	callq  *%rdx
}
  8004204f49:	c9                   	leaveq 
  8004204f4a:	c3                   	retq   

0000008004204f4b <check_va2pa>:
// this functionality for us!  We define our own version to help check
// the check_boot_pml4e() function; it shouldn't be used elsewhere.

static physaddr_t
check_va2pa(pml4e_t *pml4e, uintptr_t va)
{
  8004204f4b:	55                   	push   %rbp
  8004204f4c:	48 89 e5             	mov    %rsp,%rbp
  8004204f4f:	48 83 ec 60          	sub    $0x60,%rsp
  8004204f53:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8004204f57:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
	pte_t *pte;
	pdpe_t *pdpe;
	pde_t *pde;
	// cprintf("%x", va);
	pml4e = &pml4e[PML4(va)];
  8004204f5b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004204f5f:	48 c1 e8 27          	shr    $0x27,%rax
  8004204f63:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004204f68:	48 c1 e0 03          	shl    $0x3,%rax
  8004204f6c:	48 01 45 a8          	add    %rax,-0x58(%rbp)
	// cprintf(" %x %x " , PML4(va), *pml4e);
	if (!(*pml4e & PTE_P))
  8004204f70:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004204f74:	48 8b 00             	mov    (%rax),%rax
  8004204f77:	83 e0 01             	and    $0x1,%eax
  8004204f7a:	48 85 c0             	test   %rax,%rax
  8004204f7d:	75 0c                	jne    8004204f8b <check_va2pa+0x40>
		return ~0;
  8004204f7f:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8004204f86:	e9 38 02 00 00       	jmpq   80042051c3 <check_va2pa+0x278>
	pdpe = (pdpe_t *) KADDR(PTE_ADDR(*pml4e));
  8004204f8b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004204f8f:	48 8b 00             	mov    (%rax),%rax
  8004204f92:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004204f98:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204f9c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204fa0:	48 c1 e8 0c          	shr    $0xc,%rax
  8004204fa4:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004204fa7:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004204faa:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  8004204fb1:	00 00 00 
  8004204fb4:	48 8b 00             	mov    (%rax),%rax
  8004204fb7:	48 39 c2             	cmp    %rax,%rdx
  8004204fba:	72 32                	jb     8004204fee <check_va2pa+0xa3>
  8004204fbc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204fc0:	48 89 c1             	mov    %rax,%rcx
  8004204fc3:	48 ba e0 61 21 04 80 	movabs $0x80042161e0,%rdx
  8004204fca:	00 00 00 
  8004204fcd:	be 37 04 00 00       	mov    $0x437,%esi
  8004204fd2:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004204fd9:	00 00 00 
  8004204fdc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204fe1:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204fe8:	00 00 00 
  8004204feb:	41 ff d0             	callq  *%r8
  8004204fee:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004204ff5:	00 00 00 
  8004204ff8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204ffc:	48 01 d0             	add    %rdx,%rax
  8004204fff:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	// cprintf(" %x %x " , pdpe, *pdpe);
	if (!(pdpe[PDPE(va)] & PTE_P))
  8004205003:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205007:	48 c1 e8 1e          	shr    $0x1e,%rax
  800420500b:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205010:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205017:	00 
  8004205018:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420501c:	48 01 d0             	add    %rdx,%rax
  800420501f:	48 8b 00             	mov    (%rax),%rax
  8004205022:	83 e0 01             	and    $0x1,%eax
  8004205025:	48 85 c0             	test   %rax,%rax
  8004205028:	75 0c                	jne    8004205036 <check_va2pa+0xeb>
		return ~0;
  800420502a:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8004205031:	e9 8d 01 00 00       	jmpq   80042051c3 <check_va2pa+0x278>
	pde = (pde_t *) KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  8004205036:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420503a:	48 c1 e8 1e          	shr    $0x1e,%rax
  800420503e:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205043:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420504a:	00 
  800420504b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420504f:	48 01 d0             	add    %rdx,%rax
  8004205052:	48 8b 00             	mov    (%rax),%rax
  8004205055:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420505b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420505f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205063:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205067:	89 45 dc             	mov    %eax,-0x24(%rbp)
  800420506a:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800420506d:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  8004205074:	00 00 00 
  8004205077:	48 8b 00             	mov    (%rax),%rax
  800420507a:	48 39 c2             	cmp    %rax,%rdx
  800420507d:	72 32                	jb     80042050b1 <check_va2pa+0x166>
  800420507f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205083:	48 89 c1             	mov    %rax,%rcx
  8004205086:	48 ba e0 61 21 04 80 	movabs $0x80042161e0,%rdx
  800420508d:	00 00 00 
  8004205090:	be 3b 04 00 00       	mov    $0x43b,%esi
  8004205095:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  800420509c:	00 00 00 
  800420509f:	b8 00 00 00 00       	mov    $0x0,%eax
  80042050a4:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042050ab:	00 00 00 
  80042050ae:	41 ff d0             	callq  *%r8
  80042050b1:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042050b8:	00 00 00 
  80042050bb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042050bf:	48 01 d0             	add    %rdx,%rax
  80042050c2:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	// cprintf(" %x %x " , pde, *pde);
	pde = &pde[PDX(va)];
  80042050c6:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042050ca:	48 c1 e8 15          	shr    $0x15,%rax
  80042050ce:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042050d3:	48 c1 e0 03          	shl    $0x3,%rax
  80042050d7:	48 01 45 d0          	add    %rax,-0x30(%rbp)
	if (!(*pde & PTE_P))
  80042050db:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042050df:	48 8b 00             	mov    (%rax),%rax
  80042050e2:	83 e0 01             	and    $0x1,%eax
  80042050e5:	48 85 c0             	test   %rax,%rax
  80042050e8:	75 0c                	jne    80042050f6 <check_va2pa+0x1ab>
		return ~0;
  80042050ea:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  80042050f1:	e9 cd 00 00 00       	jmpq   80042051c3 <check_va2pa+0x278>
	pte = (pte_t*) KADDR(PTE_ADDR(*pde));
  80042050f6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042050fa:	48 8b 00             	mov    (%rax),%rax
  80042050fd:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205103:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004205107:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420510b:	48 c1 e8 0c          	shr    $0xc,%rax
  800420510f:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  8004205112:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004205115:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  800420511c:	00 00 00 
  800420511f:	48 8b 00             	mov    (%rax),%rax
  8004205122:	48 39 c2             	cmp    %rax,%rdx
  8004205125:	72 32                	jb     8004205159 <check_va2pa+0x20e>
  8004205127:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420512b:	48 89 c1             	mov    %rax,%rcx
  800420512e:	48 ba e0 61 21 04 80 	movabs $0x80042161e0,%rdx
  8004205135:	00 00 00 
  8004205138:	be 40 04 00 00       	mov    $0x440,%esi
  800420513d:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004205144:	00 00 00 
  8004205147:	b8 00 00 00 00       	mov    $0x0,%eax
  800420514c:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205153:	00 00 00 
  8004205156:	41 ff d0             	callq  *%r8
  8004205159:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205160:	00 00 00 
  8004205163:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205167:	48 01 d0             	add    %rdx,%rax
  800420516a:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	// cprintf(" %x %x " , pte, *pte);
	if (!(pte[PTX(va)] & PTE_P))
  800420516e:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205172:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205176:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420517b:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205182:	00 
  8004205183:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205187:	48 01 d0             	add    %rdx,%rax
  800420518a:	48 8b 00             	mov    (%rax),%rax
  800420518d:	83 e0 01             	and    $0x1,%eax
  8004205190:	48 85 c0             	test   %rax,%rax
  8004205193:	75 09                	jne    800420519e <check_va2pa+0x253>
		return ~0;
  8004205195:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  800420519c:	eb 25                	jmp    80042051c3 <check_va2pa+0x278>
	// cprintf(" %x %x\n" , PTX(va),  PTE_ADDR(pte[PTX(va)]));
	return PTE_ADDR(pte[PTX(va)]);
  800420519e:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042051a2:	48 c1 e8 0c          	shr    $0xc,%rax
  80042051a6:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042051ab:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042051b2:	00 
  80042051b3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042051b7:	48 01 d0             	add    %rdx,%rax
  80042051ba:	48 8b 00             	mov    (%rax),%rax
  80042051bd:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
}
  80042051c3:	c9                   	leaveq 
  80042051c4:	c3                   	retq   

00000080042051c5 <page_check>:


// check page_insert, page_remove, &c
static void
page_check(void)
{
  80042051c5:	55                   	push   %rbp
  80042051c6:	48 89 e5             	mov    %rsp,%rbp
  80042051c9:	53                   	push   %rbx
  80042051ca:	48 81 ec 18 01 00 00 	sub    $0x118,%rsp
	pdpe_t *pdpe;
	pde_t *pde;
	void *va;
	int i;
	uintptr_t mm1, mm2;
	pp0 = pp1 = pp2 = pp3 = pp4 = pp5 =0;
  80042051d1:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  80042051d8:	00 
  80042051d9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042051dd:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042051e1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042051e5:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  80042051e9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042051ed:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  80042051f1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042051f5:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  80042051f9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042051fd:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	assert(pp0 = page_alloc(0));
  8004205201:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205206:	48 b8 72 2b 20 04 80 	movabs $0x8004202b72,%rax
  800420520d:	00 00 00 
  8004205210:	ff d0                	callq  *%rax
  8004205212:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  8004205216:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  800420521b:	75 35                	jne    8004205252 <page_check+0x8d>
  800420521d:	48 b9 8f 68 21 04 80 	movabs $0x800421688f,%rcx
  8004205224:	00 00 00 
  8004205227:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  800420522e:	00 00 00 
  8004205231:	be 56 04 00 00       	mov    $0x456,%esi
  8004205236:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  800420523d:	00 00 00 
  8004205240:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205245:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420524c:	00 00 00 
  800420524f:	41 ff d0             	callq  *%r8
	assert(pp1 = page_alloc(0));
  8004205252:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205257:	48 b8 72 2b 20 04 80 	movabs $0x8004202b72,%rax
  800420525e:	00 00 00 
  8004205261:	ff d0                	callq  *%rax
  8004205263:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004205267:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  800420526c:	75 35                	jne    80042052a3 <page_check+0xde>
  800420526e:	48 b9 a3 68 21 04 80 	movabs $0x80042168a3,%rcx
  8004205275:	00 00 00 
  8004205278:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  800420527f:	00 00 00 
  8004205282:	be 57 04 00 00       	mov    $0x457,%esi
  8004205287:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  800420528e:	00 00 00 
  8004205291:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205296:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420529d:	00 00 00 
  80042052a0:	41 ff d0             	callq  *%r8
	assert(pp2 = page_alloc(0));
  80042052a3:	bf 00 00 00 00       	mov    $0x0,%edi
  80042052a8:	48 b8 72 2b 20 04 80 	movabs $0x8004202b72,%rax
  80042052af:	00 00 00 
  80042052b2:	ff d0                	callq  *%rax
  80042052b4:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  80042052b8:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  80042052bd:	75 35                	jne    80042052f4 <page_check+0x12f>
  80042052bf:	48 b9 b7 68 21 04 80 	movabs $0x80042168b7,%rcx
  80042052c6:	00 00 00 
  80042052c9:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  80042052d0:	00 00 00 
  80042052d3:	be 58 04 00 00       	mov    $0x458,%esi
  80042052d8:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  80042052df:	00 00 00 
  80042052e2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042052e7:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042052ee:	00 00 00 
  80042052f1:	41 ff d0             	callq  *%r8
	assert(pp3 = page_alloc(0));
  80042052f4:	bf 00 00 00 00       	mov    $0x0,%edi
  80042052f9:	48 b8 72 2b 20 04 80 	movabs $0x8004202b72,%rax
  8004205300:	00 00 00 
  8004205303:	ff d0                	callq  *%rax
  8004205305:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004205309:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420530e:	75 35                	jne    8004205345 <page_check+0x180>
  8004205310:	48 b9 cb 68 21 04 80 	movabs $0x80042168cb,%rcx
  8004205317:	00 00 00 
  800420531a:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004205321:	00 00 00 
  8004205324:	be 59 04 00 00       	mov    $0x459,%esi
  8004205329:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004205330:	00 00 00 
  8004205333:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205338:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420533f:	00 00 00 
  8004205342:	41 ff d0             	callq  *%r8
	assert(pp4 = page_alloc(0));
  8004205345:	bf 00 00 00 00       	mov    $0x0,%edi
  800420534a:	48 b8 72 2b 20 04 80 	movabs $0x8004202b72,%rax
  8004205351:	00 00 00 
  8004205354:	ff d0                	callq  *%rax
  8004205356:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800420535a:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420535f:	75 35                	jne    8004205396 <page_check+0x1d1>
  8004205361:	48 b9 df 68 21 04 80 	movabs $0x80042168df,%rcx
  8004205368:	00 00 00 
  800420536b:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004205372:	00 00 00 
  8004205375:	be 5a 04 00 00       	mov    $0x45a,%esi
  800420537a:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004205381:	00 00 00 
  8004205384:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205389:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205390:	00 00 00 
  8004205393:	41 ff d0             	callq  *%r8
	assert(pp5 = page_alloc(0));
  8004205396:	bf 00 00 00 00       	mov    $0x0,%edi
  800420539b:	48 b8 72 2b 20 04 80 	movabs $0x8004202b72,%rax
  80042053a2:	00 00 00 
  80042053a5:	ff d0                	callq  *%rax
  80042053a7:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042053ab:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042053b0:	75 35                	jne    80042053e7 <page_check+0x222>
  80042053b2:	48 b9 f3 68 21 04 80 	movabs $0x80042168f3,%rcx
  80042053b9:	00 00 00 
  80042053bc:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  80042053c3:	00 00 00 
  80042053c6:	be 5b 04 00 00       	mov    $0x45b,%esi
  80042053cb:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  80042053d2:	00 00 00 
  80042053d5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042053da:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042053e1:	00 00 00 
  80042053e4:	41 ff d0             	callq  *%r8

	assert(pp0);
  80042053e7:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  80042053ec:	75 35                	jne    8004205423 <page_check+0x25e>
  80042053ee:	48 b9 41 66 21 04 80 	movabs $0x8004216641,%rcx
  80042053f5:	00 00 00 
  80042053f8:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  80042053ff:	00 00 00 
  8004205402:	be 5d 04 00 00       	mov    $0x45d,%esi
  8004205407:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  800420540e:	00 00 00 
  8004205411:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205416:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420541d:	00 00 00 
  8004205420:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  8004205423:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004205428:	74 0a                	je     8004205434 <page_check+0x26f>
  800420542a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420542e:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205432:	75 35                	jne    8004205469 <page_check+0x2a4>
  8004205434:	48 b9 45 66 21 04 80 	movabs $0x8004216645,%rcx
  800420543b:	00 00 00 
  800420543e:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004205445:	00 00 00 
  8004205448:	be 5e 04 00 00       	mov    $0x45e,%esi
  800420544d:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004205454:	00 00 00 
  8004205457:	b8 00 00 00 00       	mov    $0x0,%eax
  800420545c:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205463:	00 00 00 
  8004205466:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  8004205469:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420546e:	74 14                	je     8004205484 <page_check+0x2bf>
  8004205470:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205474:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205478:	74 0a                	je     8004205484 <page_check+0x2bf>
  800420547a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420547e:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205482:	75 35                	jne    80042054b9 <page_check+0x2f4>
  8004205484:	48 b9 58 66 21 04 80 	movabs $0x8004216658,%rcx
  800420548b:	00 00 00 
  800420548e:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004205495:	00 00 00 
  8004205498:	be 5f 04 00 00       	mov    $0x45f,%esi
  800420549d:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  80042054a4:	00 00 00 
  80042054a7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042054ac:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042054b3:	00 00 00 
  80042054b6:	41 ff d0             	callq  *%r8
	assert(pp3 && pp3 != pp2 && pp3 != pp1 && pp3 != pp0);
  80042054b9:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80042054be:	74 1e                	je     80042054de <page_check+0x319>
  80042054c0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042054c4:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  80042054c8:	74 14                	je     80042054de <page_check+0x319>
  80042054ca:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042054ce:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  80042054d2:	74 0a                	je     80042054de <page_check+0x319>
  80042054d4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042054d8:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  80042054dc:	75 35                	jne    8004205513 <page_check+0x34e>
  80042054de:	48 b9 08 69 21 04 80 	movabs $0x8004216908,%rcx
  80042054e5:	00 00 00 
  80042054e8:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  80042054ef:	00 00 00 
  80042054f2:	be 60 04 00 00       	mov    $0x460,%esi
  80042054f7:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  80042054fe:	00 00 00 
  8004205501:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205506:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420550d:	00 00 00 
  8004205510:	41 ff d0             	callq  *%r8
	assert(pp4 && pp4 != pp3 && pp4 != pp2 && pp4 != pp1 && pp4 != pp0);
  8004205513:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004205518:	74 28                	je     8004205542 <page_check+0x37d>
  800420551a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420551e:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004205522:	74 1e                	je     8004205542 <page_check+0x37d>
  8004205524:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205528:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  800420552c:	74 14                	je     8004205542 <page_check+0x37d>
  800420552e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205532:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205536:	74 0a                	je     8004205542 <page_check+0x37d>
  8004205538:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420553c:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205540:	75 35                	jne    8004205577 <page_check+0x3b2>
  8004205542:	48 b9 38 69 21 04 80 	movabs $0x8004216938,%rcx
  8004205549:	00 00 00 
  800420554c:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004205553:	00 00 00 
  8004205556:	be 61 04 00 00       	mov    $0x461,%esi
  800420555b:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004205562:	00 00 00 
  8004205565:	b8 00 00 00 00       	mov    $0x0,%eax
  800420556a:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205571:	00 00 00 
  8004205574:	41 ff d0             	callq  *%r8
	assert(pp5 && pp5 != pp4 && pp5 != pp3 && pp5 != pp2 && pp5 != pp1 && pp5 != pp0);
  8004205577:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420557c:	74 32                	je     80042055b0 <page_check+0x3eb>
  800420557e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205582:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004205586:	74 28                	je     80042055b0 <page_check+0x3eb>
  8004205588:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420558c:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004205590:	74 1e                	je     80042055b0 <page_check+0x3eb>
  8004205592:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205596:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  800420559a:	74 14                	je     80042055b0 <page_check+0x3eb>
  800420559c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042055a0:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  80042055a4:	74 0a                	je     80042055b0 <page_check+0x3eb>
  80042055a6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042055aa:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  80042055ae:	75 35                	jne    80042055e5 <page_check+0x420>
  80042055b0:	48 b9 78 69 21 04 80 	movabs $0x8004216978,%rcx
  80042055b7:	00 00 00 
  80042055ba:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  80042055c1:	00 00 00 
  80042055c4:	be 62 04 00 00       	mov    $0x462,%esi
  80042055c9:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  80042055d0:	00 00 00 
  80042055d3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042055d8:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042055df:	00 00 00 
  80042055e2:	41 ff d0             	callq  *%r8

	// temporarily steal the rest of the free pages
	fl = page_free_list;
  80042055e5:	48 b8 38 52 49 04 80 	movabs $0x8004495238,%rax
  80042055ec:	00 00 00 
  80042055ef:	48 8b 00             	mov    (%rax),%rax
  80042055f2:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	page_free_list = NULL;
  80042055f6:	48 b8 38 52 49 04 80 	movabs $0x8004495238,%rax
  80042055fd:	00 00 00 
  8004205600:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// should be no free memory
	assert(!page_alloc(0));
  8004205607:	bf 00 00 00 00       	mov    $0x0,%edi
  800420560c:	48 b8 72 2b 20 04 80 	movabs $0x8004202b72,%rax
  8004205613:	00 00 00 
  8004205616:	ff d0                	callq  *%rax
  8004205618:	48 85 c0             	test   %rax,%rax
  800420561b:	74 35                	je     8004205652 <page_check+0x48d>
  800420561d:	48 b9 cf 66 21 04 80 	movabs $0x80042166cf,%rcx
  8004205624:	00 00 00 
  8004205627:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  800420562e:	00 00 00 
  8004205631:	be 69 04 00 00       	mov    $0x469,%esi
  8004205636:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  800420563d:	00 00 00 
  8004205640:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205645:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420564c:	00 00 00 
  800420564f:	41 ff d0             	callq  *%r8

	// there is no page allocated at address 0
	assert(page_lookup(boot_pml4e, (void *) 0x0, &ptep) == NULL);
  8004205652:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  8004205659:	00 00 00 
  800420565c:	48 8b 00             	mov    (%rax),%rax
  800420565f:	48 8d 95 e8 fe ff ff 	lea    -0x118(%rbp),%rdx
  8004205666:	be 00 00 00 00       	mov    $0x0,%esi
  800420566b:	48 89 c7             	mov    %rax,%rdi
  800420566e:	48 b8 1a 34 20 04 80 	movabs $0x800420341a,%rax
  8004205675:	00 00 00 
  8004205678:	ff d0                	callq  *%rax
  800420567a:	48 85 c0             	test   %rax,%rax
  800420567d:	74 35                	je     80042056b4 <page_check+0x4ef>
  800420567f:	48 b9 c8 69 21 04 80 	movabs $0x80042169c8,%rcx
  8004205686:	00 00 00 
  8004205689:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004205690:	00 00 00 
  8004205693:	be 6c 04 00 00       	mov    $0x46c,%esi
  8004205698:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  800420569f:	00 00 00 
  80042056a2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042056a7:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042056ae:	00 00 00 
  80042056b1:	41 ff d0             	callq  *%r8

	// there is no free memory, so we can't allocate a page table 
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) < 0);
  80042056b4:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  80042056bb:	00 00 00 
  80042056be:	48 8b 00             	mov    (%rax),%rax
  80042056c1:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  80042056c5:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042056ca:	ba 00 00 00 00       	mov    $0x0,%edx
  80042056cf:	48 89 c7             	mov    %rax,%rdi
  80042056d2:	48 b8 d1 32 20 04 80 	movabs $0x80042032d1,%rax
  80042056d9:	00 00 00 
  80042056dc:	ff d0                	callq  *%rax
  80042056de:	85 c0                	test   %eax,%eax
  80042056e0:	78 35                	js     8004205717 <page_check+0x552>
  80042056e2:	48 b9 00 6a 21 04 80 	movabs $0x8004216a00,%rcx
  80042056e9:	00 00 00 
  80042056ec:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  80042056f3:	00 00 00 
  80042056f6:	be 6f 04 00 00       	mov    $0x46f,%esi
  80042056fb:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004205702:	00 00 00 
  8004205705:	b8 00 00 00 00       	mov    $0x0,%eax
  800420570a:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205711:	00 00 00 
  8004205714:	41 ff d0             	callq  *%r8

	// free pp0 and try again: pp0 should be used for page table
	page_free(pp0);
  8004205717:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420571b:	48 89 c7             	mov    %rax,%rdi
  800420571e:	48 b8 11 2c 20 04 80 	movabs $0x8004202c11,%rax
  8004205725:	00 00 00 
  8004205728:	ff d0                	callq  *%rax
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) < 0);
  800420572a:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  8004205731:	00 00 00 
  8004205734:	48 8b 00             	mov    (%rax),%rax
  8004205737:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420573b:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205740:	ba 00 00 00 00       	mov    $0x0,%edx
  8004205745:	48 89 c7             	mov    %rax,%rdi
  8004205748:	48 b8 d1 32 20 04 80 	movabs $0x80042032d1,%rax
  800420574f:	00 00 00 
  8004205752:	ff d0                	callq  *%rax
  8004205754:	85 c0                	test   %eax,%eax
  8004205756:	78 35                	js     800420578d <page_check+0x5c8>
  8004205758:	48 b9 00 6a 21 04 80 	movabs $0x8004216a00,%rcx
  800420575f:	00 00 00 
  8004205762:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004205769:	00 00 00 
  800420576c:	be 73 04 00 00       	mov    $0x473,%esi
  8004205771:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004205778:	00 00 00 
  800420577b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205780:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205787:	00 00 00 
  800420578a:	41 ff d0             	callq  *%r8
	page_free(pp2);
  800420578d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205791:	48 89 c7             	mov    %rax,%rdi
  8004205794:	48 b8 11 2c 20 04 80 	movabs $0x8004202c11,%rax
  800420579b:	00 00 00 
  800420579e:	ff d0                	callq  *%rax
	page_free(pp3);
  80042057a0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042057a4:	48 89 c7             	mov    %rax,%rdi
  80042057a7:	48 b8 11 2c 20 04 80 	movabs $0x8004202c11,%rax
  80042057ae:	00 00 00 
  80042057b1:	ff d0                	callq  *%rax
	//cprintf("pp1 ref count = %d\n",pp1->pp_ref);
	//cprintf("pp0 ref count = %d\n",pp0->pp_ref);
	//cprintf("pp2 ref count = %d\n",pp2->pp_ref);
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) == 0);
  80042057b3:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  80042057ba:	00 00 00 
  80042057bd:	48 8b 00             	mov    (%rax),%rax
  80042057c0:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  80042057c4:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042057c9:	ba 00 00 00 00       	mov    $0x0,%edx
  80042057ce:	48 89 c7             	mov    %rax,%rdi
  80042057d1:	48 b8 d1 32 20 04 80 	movabs $0x80042032d1,%rax
  80042057d8:	00 00 00 
  80042057db:	ff d0                	callq  *%rax
  80042057dd:	85 c0                	test   %eax,%eax
  80042057df:	74 35                	je     8004205816 <page_check+0x651>
  80042057e1:	48 b9 30 6a 21 04 80 	movabs $0x8004216a30,%rcx
  80042057e8:	00 00 00 
  80042057eb:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  80042057f2:	00 00 00 
  80042057f5:	be 79 04 00 00       	mov    $0x479,%esi
  80042057fa:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004205801:	00 00 00 
  8004205804:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205809:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205810:	00 00 00 
  8004205813:	41 ff d0             	callq  *%r8
	assert((PTE_ADDR(boot_pml4e[0]) == page2pa(pp0) || PTE_ADDR(boot_pml4e[0]) == page2pa(pp2) || PTE_ADDR(boot_pml4e[0]) == page2pa(pp3) ));
  8004205816:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  800420581d:	00 00 00 
  8004205820:	48 8b 00             	mov    (%rax),%rax
  8004205823:	48 8b 00             	mov    (%rax),%rax
  8004205826:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420582c:	48 89 c3             	mov    %rax,%rbx
  800420582f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205833:	48 89 c7             	mov    %rax,%rdi
  8004205836:	48 b8 64 19 20 04 80 	movabs $0x8004201964,%rax
  800420583d:	00 00 00 
  8004205840:	ff d0                	callq  *%rax
  8004205842:	48 39 c3             	cmp    %rax,%rbx
  8004205845:	0f 84 97 00 00 00    	je     80042058e2 <page_check+0x71d>
  800420584b:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  8004205852:	00 00 00 
  8004205855:	48 8b 00             	mov    (%rax),%rax
  8004205858:	48 8b 00             	mov    (%rax),%rax
  800420585b:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205861:	48 89 c3             	mov    %rax,%rbx
  8004205864:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205868:	48 89 c7             	mov    %rax,%rdi
  800420586b:	48 b8 64 19 20 04 80 	movabs $0x8004201964,%rax
  8004205872:	00 00 00 
  8004205875:	ff d0                	callq  *%rax
  8004205877:	48 39 c3             	cmp    %rax,%rbx
  800420587a:	74 66                	je     80042058e2 <page_check+0x71d>
  800420587c:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  8004205883:	00 00 00 
  8004205886:	48 8b 00             	mov    (%rax),%rax
  8004205889:	48 8b 00             	mov    (%rax),%rax
  800420588c:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205892:	48 89 c3             	mov    %rax,%rbx
  8004205895:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205899:	48 89 c7             	mov    %rax,%rdi
  800420589c:	48 b8 64 19 20 04 80 	movabs $0x8004201964,%rax
  80042058a3:	00 00 00 
  80042058a6:	ff d0                	callq  *%rax
  80042058a8:	48 39 c3             	cmp    %rax,%rbx
  80042058ab:	74 35                	je     80042058e2 <page_check+0x71d>
  80042058ad:	48 b9 60 6a 21 04 80 	movabs $0x8004216a60,%rcx
  80042058b4:	00 00 00 
  80042058b7:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  80042058be:	00 00 00 
  80042058c1:	be 7a 04 00 00       	mov    $0x47a,%esi
  80042058c6:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  80042058cd:	00 00 00 
  80042058d0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042058d5:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042058dc:	00 00 00 
  80042058df:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, 0x0) == page2pa(pp1));
  80042058e2:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  80042058e9:	00 00 00 
  80042058ec:	48 8b 00             	mov    (%rax),%rax
  80042058ef:	be 00 00 00 00       	mov    $0x0,%esi
  80042058f4:	48 89 c7             	mov    %rax,%rdi
  80042058f7:	48 b8 4b 4f 20 04 80 	movabs $0x8004204f4b,%rax
  80042058fe:	00 00 00 
  8004205901:	ff d0                	callq  *%rax
  8004205903:	48 89 c3             	mov    %rax,%rbx
  8004205906:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420590a:	48 89 c7             	mov    %rax,%rdi
  800420590d:	48 b8 64 19 20 04 80 	movabs $0x8004201964,%rax
  8004205914:	00 00 00 
  8004205917:	ff d0                	callq  *%rax
  8004205919:	48 39 c3             	cmp    %rax,%rbx
  800420591c:	74 35                	je     8004205953 <page_check+0x78e>
  800420591e:	48 b9 e8 6a 21 04 80 	movabs $0x8004216ae8,%rcx
  8004205925:	00 00 00 
  8004205928:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  800420592f:	00 00 00 
  8004205932:	be 7b 04 00 00       	mov    $0x47b,%esi
  8004205937:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  800420593e:	00 00 00 
  8004205941:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205946:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420594d:	00 00 00 
  8004205950:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 1);
  8004205953:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205957:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420595b:	66 83 f8 01          	cmp    $0x1,%ax
  800420595f:	74 35                	je     8004205996 <page_check+0x7d1>
  8004205961:	48 b9 15 6b 21 04 80 	movabs $0x8004216b15,%rcx
  8004205968:	00 00 00 
  800420596b:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004205972:	00 00 00 
  8004205975:	be 7c 04 00 00       	mov    $0x47c,%esi
  800420597a:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004205981:	00 00 00 
  8004205984:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205989:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205990:	00 00 00 
  8004205993:	41 ff d0             	callq  *%r8
	assert(pp0->pp_ref == 1);
  8004205996:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420599a:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420599e:	66 83 f8 01          	cmp    $0x1,%ax
  80042059a2:	74 35                	je     80042059d9 <page_check+0x814>
  80042059a4:	48 b9 26 6b 21 04 80 	movabs $0x8004216b26,%rcx
  80042059ab:	00 00 00 
  80042059ae:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  80042059b5:	00 00 00 
  80042059b8:	be 7d 04 00 00       	mov    $0x47d,%esi
  80042059bd:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  80042059c4:	00 00 00 
  80042059c7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042059cc:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042059d3:	00 00 00 
  80042059d6:	41 ff d0             	callq  *%r8
	assert(pp2->pp_ref == 1);
  80042059d9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042059dd:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042059e1:	66 83 f8 01          	cmp    $0x1,%ax
  80042059e5:	74 35                	je     8004205a1c <page_check+0x857>
  80042059e7:	48 b9 37 6b 21 04 80 	movabs $0x8004216b37,%rcx
  80042059ee:	00 00 00 
  80042059f1:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  80042059f8:	00 00 00 
  80042059fb:	be 7e 04 00 00       	mov    $0x47e,%esi
  8004205a00:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004205a07:	00 00 00 
  8004205a0a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205a0f:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205a16:	00 00 00 
  8004205a19:	41 ff d0             	callq  *%r8
	//should be able to map pp3 at PGSIZE because pp0 is already allocated for page table
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, 0) == 0);
  8004205a1c:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  8004205a23:	00 00 00 
  8004205a26:	48 8b 00             	mov    (%rax),%rax
  8004205a29:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004205a2d:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205a32:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004205a37:	48 89 c7             	mov    %rax,%rdi
  8004205a3a:	48 b8 d1 32 20 04 80 	movabs $0x80042032d1,%rax
  8004205a41:	00 00 00 
  8004205a44:	ff d0                	callq  *%rax
  8004205a46:	85 c0                	test   %eax,%eax
  8004205a48:	74 35                	je     8004205a7f <page_check+0x8ba>
  8004205a4a:	48 b9 48 6b 21 04 80 	movabs $0x8004216b48,%rcx
  8004205a51:	00 00 00 
  8004205a54:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004205a5b:	00 00 00 
  8004205a5e:	be 80 04 00 00       	mov    $0x480,%esi
  8004205a63:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004205a6a:	00 00 00 
  8004205a6d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205a72:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205a79:	00 00 00 
  8004205a7c:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  8004205a7f:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  8004205a86:	00 00 00 
  8004205a89:	48 8b 00             	mov    (%rax),%rax
  8004205a8c:	be 00 10 00 00       	mov    $0x1000,%esi
  8004205a91:	48 89 c7             	mov    %rax,%rdi
  8004205a94:	48 b8 4b 4f 20 04 80 	movabs $0x8004204f4b,%rax
  8004205a9b:	00 00 00 
  8004205a9e:	ff d0                	callq  *%rax
  8004205aa0:	48 89 c3             	mov    %rax,%rbx
  8004205aa3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205aa7:	48 89 c7             	mov    %rax,%rdi
  8004205aaa:	48 b8 64 19 20 04 80 	movabs $0x8004201964,%rax
  8004205ab1:	00 00 00 
  8004205ab4:	ff d0                	callq  *%rax
  8004205ab6:	48 39 c3             	cmp    %rax,%rbx
  8004205ab9:	74 35                	je     8004205af0 <page_check+0x92b>
  8004205abb:	48 b9 80 6b 21 04 80 	movabs $0x8004216b80,%rcx
  8004205ac2:	00 00 00 
  8004205ac5:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004205acc:	00 00 00 
  8004205acf:	be 81 04 00 00       	mov    $0x481,%esi
  8004205ad4:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004205adb:	00 00 00 
  8004205ade:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205ae3:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205aea:	00 00 00 
  8004205aed:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  8004205af0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205af4:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205af8:	66 83 f8 02          	cmp    $0x2,%ax
  8004205afc:	74 35                	je     8004205b33 <page_check+0x96e>
  8004205afe:	48 b9 b0 6b 21 04 80 	movabs $0x8004216bb0,%rcx
  8004205b05:	00 00 00 
  8004205b08:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004205b0f:	00 00 00 
  8004205b12:	be 82 04 00 00       	mov    $0x482,%esi
  8004205b17:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004205b1e:	00 00 00 
  8004205b21:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205b26:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205b2d:	00 00 00 
  8004205b30:	41 ff d0             	callq  *%r8

	// should be no free memory
	assert(!page_alloc(0));
  8004205b33:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205b38:	48 b8 72 2b 20 04 80 	movabs $0x8004202b72,%rax
  8004205b3f:	00 00 00 
  8004205b42:	ff d0                	callq  *%rax
  8004205b44:	48 85 c0             	test   %rax,%rax
  8004205b47:	74 35                	je     8004205b7e <page_check+0x9b9>
  8004205b49:	48 b9 cf 66 21 04 80 	movabs $0x80042166cf,%rcx
  8004205b50:	00 00 00 
  8004205b53:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004205b5a:	00 00 00 
  8004205b5d:	be 85 04 00 00       	mov    $0x485,%esi
  8004205b62:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004205b69:	00 00 00 
  8004205b6c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205b71:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205b78:	00 00 00 
  8004205b7b:	41 ff d0             	callq  *%r8

	// should be able to map pp3 at PGSIZE because it's already there
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, 0) == 0);
  8004205b7e:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  8004205b85:	00 00 00 
  8004205b88:	48 8b 00             	mov    (%rax),%rax
  8004205b8b:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004205b8f:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205b94:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004205b99:	48 89 c7             	mov    %rax,%rdi
  8004205b9c:	48 b8 d1 32 20 04 80 	movabs $0x80042032d1,%rax
  8004205ba3:	00 00 00 
  8004205ba6:	ff d0                	callq  *%rax
  8004205ba8:	85 c0                	test   %eax,%eax
  8004205baa:	74 35                	je     8004205be1 <page_check+0xa1c>
  8004205bac:	48 b9 48 6b 21 04 80 	movabs $0x8004216b48,%rcx
  8004205bb3:	00 00 00 
  8004205bb6:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004205bbd:	00 00 00 
  8004205bc0:	be 88 04 00 00       	mov    $0x488,%esi
  8004205bc5:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004205bcc:	00 00 00 
  8004205bcf:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205bd4:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205bdb:	00 00 00 
  8004205bde:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  8004205be1:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  8004205be8:	00 00 00 
  8004205beb:	48 8b 00             	mov    (%rax),%rax
  8004205bee:	be 00 10 00 00       	mov    $0x1000,%esi
  8004205bf3:	48 89 c7             	mov    %rax,%rdi
  8004205bf6:	48 b8 4b 4f 20 04 80 	movabs $0x8004204f4b,%rax
  8004205bfd:	00 00 00 
  8004205c00:	ff d0                	callq  *%rax
  8004205c02:	48 89 c3             	mov    %rax,%rbx
  8004205c05:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205c09:	48 89 c7             	mov    %rax,%rdi
  8004205c0c:	48 b8 64 19 20 04 80 	movabs $0x8004201964,%rax
  8004205c13:	00 00 00 
  8004205c16:	ff d0                	callq  *%rax
  8004205c18:	48 39 c3             	cmp    %rax,%rbx
  8004205c1b:	74 35                	je     8004205c52 <page_check+0xa8d>
  8004205c1d:	48 b9 80 6b 21 04 80 	movabs $0x8004216b80,%rcx
  8004205c24:	00 00 00 
  8004205c27:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004205c2e:	00 00 00 
  8004205c31:	be 89 04 00 00       	mov    $0x489,%esi
  8004205c36:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004205c3d:	00 00 00 
  8004205c40:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205c45:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205c4c:	00 00 00 
  8004205c4f:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  8004205c52:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205c56:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205c5a:	66 83 f8 02          	cmp    $0x2,%ax
  8004205c5e:	74 35                	je     8004205c95 <page_check+0xad0>
  8004205c60:	48 b9 b0 6b 21 04 80 	movabs $0x8004216bb0,%rcx
  8004205c67:	00 00 00 
  8004205c6a:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004205c71:	00 00 00 
  8004205c74:	be 8a 04 00 00       	mov    $0x48a,%esi
  8004205c79:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004205c80:	00 00 00 
  8004205c83:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205c88:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205c8f:	00 00 00 
  8004205c92:	41 ff d0             	callq  *%r8

	// pp3 should NOT be on the free list
	// could happen in ref counts are handled sloppily in page_insert
	assert(!page_alloc(0));
  8004205c95:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205c9a:	48 b8 72 2b 20 04 80 	movabs $0x8004202b72,%rax
  8004205ca1:	00 00 00 
  8004205ca4:	ff d0                	callq  *%rax
  8004205ca6:	48 85 c0             	test   %rax,%rax
  8004205ca9:	74 35                	je     8004205ce0 <page_check+0xb1b>
  8004205cab:	48 b9 cf 66 21 04 80 	movabs $0x80042166cf,%rcx
  8004205cb2:	00 00 00 
  8004205cb5:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004205cbc:	00 00 00 
  8004205cbf:	be 8e 04 00 00       	mov    $0x48e,%esi
  8004205cc4:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004205ccb:	00 00 00 
  8004205cce:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205cd3:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205cda:	00 00 00 
  8004205cdd:	41 ff d0             	callq  *%r8
	// check that pgdir_walk returns a pointer to the pte
	pdpe = KADDR(PTE_ADDR(boot_pml4e[PML4(PGSIZE)]));
  8004205ce0:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  8004205ce7:	00 00 00 
  8004205cea:	48 8b 00             	mov    (%rax),%rax
  8004205ced:	48 8b 00             	mov    (%rax),%rax
  8004205cf0:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205cf6:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  8004205cfa:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004205cfe:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205d02:	89 45 a4             	mov    %eax,-0x5c(%rbp)
  8004205d05:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  8004205d08:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  8004205d0f:	00 00 00 
  8004205d12:	48 8b 00             	mov    (%rax),%rax
  8004205d15:	48 39 c2             	cmp    %rax,%rdx
  8004205d18:	72 32                	jb     8004205d4c <page_check+0xb87>
  8004205d1a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004205d1e:	48 89 c1             	mov    %rax,%rcx
  8004205d21:	48 ba e0 61 21 04 80 	movabs $0x80042161e0,%rdx
  8004205d28:	00 00 00 
  8004205d2b:	be 90 04 00 00       	mov    $0x490,%esi
  8004205d30:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004205d37:	00 00 00 
  8004205d3a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205d3f:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205d46:	00 00 00 
  8004205d49:	41 ff d0             	callq  *%r8
  8004205d4c:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205d53:	00 00 00 
  8004205d56:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004205d5a:	48 01 d0             	add    %rdx,%rax
  8004205d5d:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde = KADDR(PTE_ADDR(pdpe[PDPE(PGSIZE)]));
  8004205d61:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004205d65:	48 8b 00             	mov    (%rax),%rax
  8004205d68:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205d6e:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  8004205d72:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004205d76:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205d7a:	89 45 8c             	mov    %eax,-0x74(%rbp)
  8004205d7d:	8b 55 8c             	mov    -0x74(%rbp),%edx
  8004205d80:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  8004205d87:	00 00 00 
  8004205d8a:	48 8b 00             	mov    (%rax),%rax
  8004205d8d:	48 39 c2             	cmp    %rax,%rdx
  8004205d90:	72 32                	jb     8004205dc4 <page_check+0xbff>
  8004205d92:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004205d96:	48 89 c1             	mov    %rax,%rcx
  8004205d99:	48 ba e0 61 21 04 80 	movabs $0x80042161e0,%rdx
  8004205da0:	00 00 00 
  8004205da3:	be 91 04 00 00       	mov    $0x491,%esi
  8004205da8:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004205daf:	00 00 00 
  8004205db2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205db7:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205dbe:	00 00 00 
  8004205dc1:	41 ff d0             	callq  *%r8
  8004205dc4:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205dcb:	00 00 00 
  8004205dce:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004205dd2:	48 01 d0             	add    %rdx,%rax
  8004205dd5:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep = KADDR(PTE_ADDR(pde[PDX(PGSIZE)]));
  8004205dd9:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004205ddd:	48 8b 00             	mov    (%rax),%rax
  8004205de0:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205de6:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  8004205ded:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004205df4:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205df8:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%rbp)
  8004205dfe:	8b 95 74 ff ff ff    	mov    -0x8c(%rbp),%edx
  8004205e04:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  8004205e0b:	00 00 00 
  8004205e0e:	48 8b 00             	mov    (%rax),%rax
  8004205e11:	48 39 c2             	cmp    %rax,%rdx
  8004205e14:	72 35                	jb     8004205e4b <page_check+0xc86>
  8004205e16:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004205e1d:	48 89 c1             	mov    %rax,%rcx
  8004205e20:	48 ba e0 61 21 04 80 	movabs $0x80042161e0,%rdx
  8004205e27:	00 00 00 
  8004205e2a:	be 92 04 00 00       	mov    $0x492,%esi
  8004205e2f:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004205e36:	00 00 00 
  8004205e39:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205e3e:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205e45:	00 00 00 
  8004205e48:	41 ff d0             	callq  *%r8
  8004205e4b:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205e52:	00 00 00 
  8004205e55:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004205e5c:	48 01 d0             	add    %rdx,%rax
  8004205e5f:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
	assert(pml4e_walk(boot_pml4e, (void*)PGSIZE, 0) == ptep+PTX(PGSIZE));
  8004205e66:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  8004205e6d:	00 00 00 
  8004205e70:	48 8b 00             	mov    (%rax),%rax
  8004205e73:	ba 00 00 00 00       	mov    $0x0,%edx
  8004205e78:	be 00 10 00 00       	mov    $0x1000,%esi
  8004205e7d:	48 89 c7             	mov    %rax,%rdi
  8004205e80:	48 b8 cf 2c 20 04 80 	movabs $0x8004202ccf,%rax
  8004205e87:	00 00 00 
  8004205e8a:	ff d0                	callq  *%rax
  8004205e8c:	48 8b 95 e8 fe ff ff 	mov    -0x118(%rbp),%rdx
  8004205e93:	48 83 c2 08          	add    $0x8,%rdx
  8004205e97:	48 39 d0             	cmp    %rdx,%rax
  8004205e9a:	74 35                	je     8004205ed1 <page_check+0xd0c>
  8004205e9c:	48 b9 c8 6b 21 04 80 	movabs $0x8004216bc8,%rcx
  8004205ea3:	00 00 00 
  8004205ea6:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004205ead:	00 00 00 
  8004205eb0:	be 93 04 00 00       	mov    $0x493,%esi
  8004205eb5:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004205ebc:	00 00 00 
  8004205ebf:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205ec4:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205ecb:	00 00 00 
  8004205ece:	41 ff d0             	callq  *%r8

	// should be able to change permissions too.
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, PTE_U) == 0);
  8004205ed1:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  8004205ed8:	00 00 00 
  8004205edb:	48 8b 00             	mov    (%rax),%rax
  8004205ede:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004205ee2:	b9 04 00 00 00       	mov    $0x4,%ecx
  8004205ee7:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004205eec:	48 89 c7             	mov    %rax,%rdi
  8004205eef:	48 b8 d1 32 20 04 80 	movabs $0x80042032d1,%rax
  8004205ef6:	00 00 00 
  8004205ef9:	ff d0                	callq  *%rax
  8004205efb:	85 c0                	test   %eax,%eax
  8004205efd:	74 35                	je     8004205f34 <page_check+0xd6f>
  8004205eff:	48 b9 08 6c 21 04 80 	movabs $0x8004216c08,%rcx
  8004205f06:	00 00 00 
  8004205f09:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004205f10:	00 00 00 
  8004205f13:	be 96 04 00 00       	mov    $0x496,%esi
  8004205f18:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004205f1f:	00 00 00 
  8004205f22:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205f27:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205f2e:	00 00 00 
  8004205f31:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  8004205f34:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  8004205f3b:	00 00 00 
  8004205f3e:	48 8b 00             	mov    (%rax),%rax
  8004205f41:	be 00 10 00 00       	mov    $0x1000,%esi
  8004205f46:	48 89 c7             	mov    %rax,%rdi
  8004205f49:	48 b8 4b 4f 20 04 80 	movabs $0x8004204f4b,%rax
  8004205f50:	00 00 00 
  8004205f53:	ff d0                	callq  *%rax
  8004205f55:	48 89 c3             	mov    %rax,%rbx
  8004205f58:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205f5c:	48 89 c7             	mov    %rax,%rdi
  8004205f5f:	48 b8 64 19 20 04 80 	movabs $0x8004201964,%rax
  8004205f66:	00 00 00 
  8004205f69:	ff d0                	callq  *%rax
  8004205f6b:	48 39 c3             	cmp    %rax,%rbx
  8004205f6e:	74 35                	je     8004205fa5 <page_check+0xde0>
  8004205f70:	48 b9 80 6b 21 04 80 	movabs $0x8004216b80,%rcx
  8004205f77:	00 00 00 
  8004205f7a:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004205f81:	00 00 00 
  8004205f84:	be 97 04 00 00       	mov    $0x497,%esi
  8004205f89:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004205f90:	00 00 00 
  8004205f93:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205f98:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205f9f:	00 00 00 
  8004205fa2:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  8004205fa5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205fa9:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205fad:	66 83 f8 02          	cmp    $0x2,%ax
  8004205fb1:	74 35                	je     8004205fe8 <page_check+0xe23>
  8004205fb3:	48 b9 b0 6b 21 04 80 	movabs $0x8004216bb0,%rcx
  8004205fba:	00 00 00 
  8004205fbd:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004205fc4:	00 00 00 
  8004205fc7:	be 98 04 00 00       	mov    $0x498,%esi
  8004205fcc:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004205fd3:	00 00 00 
  8004205fd6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205fdb:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205fe2:	00 00 00 
  8004205fe5:	41 ff d0             	callq  *%r8
	assert(*pml4e_walk(boot_pml4e, (void*) PGSIZE, 0) & PTE_U);
  8004205fe8:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  8004205fef:	00 00 00 
  8004205ff2:	48 8b 00             	mov    (%rax),%rax
  8004205ff5:	ba 00 00 00 00       	mov    $0x0,%edx
  8004205ffa:	be 00 10 00 00       	mov    $0x1000,%esi
  8004205fff:	48 89 c7             	mov    %rax,%rdi
  8004206002:	48 b8 cf 2c 20 04 80 	movabs $0x8004202ccf,%rax
  8004206009:	00 00 00 
  800420600c:	ff d0                	callq  *%rax
  800420600e:	48 8b 00             	mov    (%rax),%rax
  8004206011:	83 e0 04             	and    $0x4,%eax
  8004206014:	48 85 c0             	test   %rax,%rax
  8004206017:	75 35                	jne    800420604e <page_check+0xe89>
  8004206019:	48 b9 48 6c 21 04 80 	movabs $0x8004216c48,%rcx
  8004206020:	00 00 00 
  8004206023:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  800420602a:	00 00 00 
  800420602d:	be 99 04 00 00       	mov    $0x499,%esi
  8004206032:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004206039:	00 00 00 
  800420603c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206041:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206048:	00 00 00 
  800420604b:	41 ff d0             	callq  *%r8
	assert(boot_pml4e[0] & PTE_U);
  800420604e:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  8004206055:	00 00 00 
  8004206058:	48 8b 00             	mov    (%rax),%rax
  800420605b:	48 8b 00             	mov    (%rax),%rax
  800420605e:	83 e0 04             	and    $0x4,%eax
  8004206061:	48 85 c0             	test   %rax,%rax
  8004206064:	75 35                	jne    800420609b <page_check+0xed6>
  8004206066:	48 b9 7b 6c 21 04 80 	movabs $0x8004216c7b,%rcx
  800420606d:	00 00 00 
  8004206070:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004206077:	00 00 00 
  800420607a:	be 9a 04 00 00       	mov    $0x49a,%esi
  800420607f:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004206086:	00 00 00 
  8004206089:	b8 00 00 00 00       	mov    $0x0,%eax
  800420608e:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206095:	00 00 00 
  8004206098:	41 ff d0             	callq  *%r8


	// should not be able to map at PTSIZE because need free page for page table
	assert(page_insert(boot_pml4e, pp0, (void*) PTSIZE, 0) < 0);
  800420609b:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  80042060a2:	00 00 00 
  80042060a5:	48 8b 00             	mov    (%rax),%rax
  80042060a8:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  80042060ac:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042060b1:	ba 00 00 20 00       	mov    $0x200000,%edx
  80042060b6:	48 89 c7             	mov    %rax,%rdi
  80042060b9:	48 b8 d1 32 20 04 80 	movabs $0x80042032d1,%rax
  80042060c0:	00 00 00 
  80042060c3:	ff d0                	callq  *%rax
  80042060c5:	85 c0                	test   %eax,%eax
  80042060c7:	78 35                	js     80042060fe <page_check+0xf39>
  80042060c9:	48 b9 98 6c 21 04 80 	movabs $0x8004216c98,%rcx
  80042060d0:	00 00 00 
  80042060d3:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  80042060da:	00 00 00 
  80042060dd:	be 9e 04 00 00       	mov    $0x49e,%esi
  80042060e2:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  80042060e9:	00 00 00 
  80042060ec:	b8 00 00 00 00       	mov    $0x0,%eax
  80042060f1:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042060f8:	00 00 00 
  80042060fb:	41 ff d0             	callq  *%r8

	// insert pp1 at PGSIZE (replacing pp3)
	assert(page_insert(boot_pml4e, pp1, (void*) PGSIZE, 0) == 0);
  80042060fe:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  8004206105:	00 00 00 
  8004206108:	48 8b 00             	mov    (%rax),%rax
  800420610b:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420610f:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004206114:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206119:	48 89 c7             	mov    %rax,%rdi
  800420611c:	48 b8 d1 32 20 04 80 	movabs $0x80042032d1,%rax
  8004206123:	00 00 00 
  8004206126:	ff d0                	callq  *%rax
  8004206128:	85 c0                	test   %eax,%eax
  800420612a:	74 35                	je     8004206161 <page_check+0xf9c>
  800420612c:	48 b9 d0 6c 21 04 80 	movabs $0x8004216cd0,%rcx
  8004206133:	00 00 00 
  8004206136:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  800420613d:	00 00 00 
  8004206140:	be a1 04 00 00       	mov    $0x4a1,%esi
  8004206145:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  800420614c:	00 00 00 
  800420614f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206154:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420615b:	00 00 00 
  800420615e:	41 ff d0             	callq  *%r8
	assert(!(*pml4e_walk(boot_pml4e, (void*) PGSIZE, 0) & PTE_U));
  8004206161:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  8004206168:	00 00 00 
  800420616b:	48 8b 00             	mov    (%rax),%rax
  800420616e:	ba 00 00 00 00       	mov    $0x0,%edx
  8004206173:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206178:	48 89 c7             	mov    %rax,%rdi
  800420617b:	48 b8 cf 2c 20 04 80 	movabs $0x8004202ccf,%rax
  8004206182:	00 00 00 
  8004206185:	ff d0                	callq  *%rax
  8004206187:	48 8b 00             	mov    (%rax),%rax
  800420618a:	83 e0 04             	and    $0x4,%eax
  800420618d:	48 85 c0             	test   %rax,%rax
  8004206190:	74 35                	je     80042061c7 <page_check+0x1002>
  8004206192:	48 b9 08 6d 21 04 80 	movabs $0x8004216d08,%rcx
  8004206199:	00 00 00 
  800420619c:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  80042061a3:	00 00 00 
  80042061a6:	be a2 04 00 00       	mov    $0x4a2,%esi
  80042061ab:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  80042061b2:	00 00 00 
  80042061b5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042061ba:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042061c1:	00 00 00 
  80042061c4:	41 ff d0             	callq  *%r8

	// should have pp1 at both 0 and PGSIZE
	assert(check_va2pa(boot_pml4e, 0) == page2pa(pp1));
  80042061c7:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  80042061ce:	00 00 00 
  80042061d1:	48 8b 00             	mov    (%rax),%rax
  80042061d4:	be 00 00 00 00       	mov    $0x0,%esi
  80042061d9:	48 89 c7             	mov    %rax,%rdi
  80042061dc:	48 b8 4b 4f 20 04 80 	movabs $0x8004204f4b,%rax
  80042061e3:	00 00 00 
  80042061e6:	ff d0                	callq  *%rax
  80042061e8:	48 89 c3             	mov    %rax,%rbx
  80042061eb:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042061ef:	48 89 c7             	mov    %rax,%rdi
  80042061f2:	48 b8 64 19 20 04 80 	movabs $0x8004201964,%rax
  80042061f9:	00 00 00 
  80042061fc:	ff d0                	callq  *%rax
  80042061fe:	48 39 c3             	cmp    %rax,%rbx
  8004206201:	74 35                	je     8004206238 <page_check+0x1073>
  8004206203:	48 b9 40 6d 21 04 80 	movabs $0x8004216d40,%rcx
  800420620a:	00 00 00 
  800420620d:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004206214:	00 00 00 
  8004206217:	be a5 04 00 00       	mov    $0x4a5,%esi
  800420621c:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004206223:	00 00 00 
  8004206226:	b8 00 00 00 00       	mov    $0x0,%eax
  800420622b:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206232:	00 00 00 
  8004206235:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp1));
  8004206238:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  800420623f:	00 00 00 
  8004206242:	48 8b 00             	mov    (%rax),%rax
  8004206245:	be 00 10 00 00       	mov    $0x1000,%esi
  800420624a:	48 89 c7             	mov    %rax,%rdi
  800420624d:	48 b8 4b 4f 20 04 80 	movabs $0x8004204f4b,%rax
  8004206254:	00 00 00 
  8004206257:	ff d0                	callq  *%rax
  8004206259:	48 89 c3             	mov    %rax,%rbx
  800420625c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206260:	48 89 c7             	mov    %rax,%rdi
  8004206263:	48 b8 64 19 20 04 80 	movabs $0x8004201964,%rax
  800420626a:	00 00 00 
  800420626d:	ff d0                	callq  *%rax
  800420626f:	48 39 c3             	cmp    %rax,%rbx
  8004206272:	74 35                	je     80042062a9 <page_check+0x10e4>
  8004206274:	48 b9 70 6d 21 04 80 	movabs $0x8004216d70,%rcx
  800420627b:	00 00 00 
  800420627e:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004206285:	00 00 00 
  8004206288:	be a6 04 00 00       	mov    $0x4a6,%esi
  800420628d:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004206294:	00 00 00 
  8004206297:	b8 00 00 00 00       	mov    $0x0,%eax
  800420629c:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042062a3:	00 00 00 
  80042062a6:	41 ff d0             	callq  *%r8
	// ... and ref counts should reflect this
	assert(pp1->pp_ref == 2);
  80042062a9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042062ad:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042062b1:	66 83 f8 02          	cmp    $0x2,%ax
  80042062b5:	74 35                	je     80042062ec <page_check+0x1127>
  80042062b7:	48 b9 a0 6d 21 04 80 	movabs $0x8004216da0,%rcx
  80042062be:	00 00 00 
  80042062c1:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  80042062c8:	00 00 00 
  80042062cb:	be a8 04 00 00       	mov    $0x4a8,%esi
  80042062d0:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  80042062d7:	00 00 00 
  80042062da:	b8 00 00 00 00       	mov    $0x0,%eax
  80042062df:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042062e6:	00 00 00 
  80042062e9:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  80042062ec:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042062f0:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042062f4:	66 83 f8 01          	cmp    $0x1,%ax
  80042062f8:	74 35                	je     800420632f <page_check+0x116a>
  80042062fa:	48 b9 b1 6d 21 04 80 	movabs $0x8004216db1,%rcx
  8004206301:	00 00 00 
  8004206304:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  800420630b:	00 00 00 
  800420630e:	be a9 04 00 00       	mov    $0x4a9,%esi
  8004206313:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  800420631a:	00 00 00 
  800420631d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206322:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206329:	00 00 00 
  800420632c:	41 ff d0             	callq  *%r8


	// unmapping pp1 at 0 should keep pp1 at PGSIZE
	page_remove(boot_pml4e, 0x0);
  800420632f:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  8004206336:	00 00 00 
  8004206339:	48 8b 00             	mov    (%rax),%rax
  800420633c:	be 00 00 00 00       	mov    $0x0,%esi
  8004206341:	48 89 c7             	mov    %rax,%rdi
  8004206344:	48 b8 8f 34 20 04 80 	movabs $0x800420348f,%rax
  800420634b:	00 00 00 
  800420634e:	ff d0                	callq  *%rax
	assert(check_va2pa(boot_pml4e, 0x0) == ~0);
  8004206350:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  8004206357:	00 00 00 
  800420635a:	48 8b 00             	mov    (%rax),%rax
  800420635d:	be 00 00 00 00       	mov    $0x0,%esi
  8004206362:	48 89 c7             	mov    %rax,%rdi
  8004206365:	48 b8 4b 4f 20 04 80 	movabs $0x8004204f4b,%rax
  800420636c:	00 00 00 
  800420636f:	ff d0                	callq  *%rax
  8004206371:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004206375:	74 35                	je     80042063ac <page_check+0x11e7>
  8004206377:	48 b9 c8 6d 21 04 80 	movabs $0x8004216dc8,%rcx
  800420637e:	00 00 00 
  8004206381:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004206388:	00 00 00 
  800420638b:	be ae 04 00 00       	mov    $0x4ae,%esi
  8004206390:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004206397:	00 00 00 
  800420639a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420639f:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042063a6:	00 00 00 
  80042063a9:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp1));
  80042063ac:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  80042063b3:	00 00 00 
  80042063b6:	48 8b 00             	mov    (%rax),%rax
  80042063b9:	be 00 10 00 00       	mov    $0x1000,%esi
  80042063be:	48 89 c7             	mov    %rax,%rdi
  80042063c1:	48 b8 4b 4f 20 04 80 	movabs $0x8004204f4b,%rax
  80042063c8:	00 00 00 
  80042063cb:	ff d0                	callq  *%rax
  80042063cd:	48 89 c3             	mov    %rax,%rbx
  80042063d0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042063d4:	48 89 c7             	mov    %rax,%rdi
  80042063d7:	48 b8 64 19 20 04 80 	movabs $0x8004201964,%rax
  80042063de:	00 00 00 
  80042063e1:	ff d0                	callq  *%rax
  80042063e3:	48 39 c3             	cmp    %rax,%rbx
  80042063e6:	74 35                	je     800420641d <page_check+0x1258>
  80042063e8:	48 b9 70 6d 21 04 80 	movabs $0x8004216d70,%rcx
  80042063ef:	00 00 00 
  80042063f2:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  80042063f9:	00 00 00 
  80042063fc:	be af 04 00 00       	mov    $0x4af,%esi
  8004206401:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004206408:	00 00 00 
  800420640b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206410:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206417:	00 00 00 
  800420641a:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 1);
  800420641d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206421:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206425:	66 83 f8 01          	cmp    $0x1,%ax
  8004206429:	74 35                	je     8004206460 <page_check+0x129b>
  800420642b:	48 b9 15 6b 21 04 80 	movabs $0x8004216b15,%rcx
  8004206432:	00 00 00 
  8004206435:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  800420643c:	00 00 00 
  800420643f:	be b0 04 00 00       	mov    $0x4b0,%esi
  8004206444:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  800420644b:	00 00 00 
  800420644e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206453:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420645a:	00 00 00 
  800420645d:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  8004206460:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206464:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206468:	66 83 f8 01          	cmp    $0x1,%ax
  800420646c:	74 35                	je     80042064a3 <page_check+0x12de>
  800420646e:	48 b9 b1 6d 21 04 80 	movabs $0x8004216db1,%rcx
  8004206475:	00 00 00 
  8004206478:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  800420647f:	00 00 00 
  8004206482:	be b1 04 00 00       	mov    $0x4b1,%esi
  8004206487:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  800420648e:	00 00 00 
  8004206491:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206496:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420649d:	00 00 00 
  80042064a0:	41 ff d0             	callq  *%r8

	// Test re-inserting pp1 at PGSIZE.
	// Thanks to Varun Agrawal for suggesting this test case.
	assert(page_insert(boot_pml4e, pp1, (void*) PGSIZE, 0) == 0);
  80042064a3:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  80042064aa:	00 00 00 
  80042064ad:	48 8b 00             	mov    (%rax),%rax
  80042064b0:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  80042064b4:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042064b9:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042064be:	48 89 c7             	mov    %rax,%rdi
  80042064c1:	48 b8 d1 32 20 04 80 	movabs $0x80042032d1,%rax
  80042064c8:	00 00 00 
  80042064cb:	ff d0                	callq  *%rax
  80042064cd:	85 c0                	test   %eax,%eax
  80042064cf:	74 35                	je     8004206506 <page_check+0x1341>
  80042064d1:	48 b9 d0 6c 21 04 80 	movabs $0x8004216cd0,%rcx
  80042064d8:	00 00 00 
  80042064db:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  80042064e2:	00 00 00 
  80042064e5:	be b5 04 00 00       	mov    $0x4b5,%esi
  80042064ea:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  80042064f1:	00 00 00 
  80042064f4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042064f9:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206500:	00 00 00 
  8004206503:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref);
  8004206506:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420650a:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420650e:	66 85 c0             	test   %ax,%ax
  8004206511:	75 35                	jne    8004206548 <page_check+0x1383>
  8004206513:	48 b9 eb 6d 21 04 80 	movabs $0x8004216deb,%rcx
  800420651a:	00 00 00 
  800420651d:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004206524:	00 00 00 
  8004206527:	be b6 04 00 00       	mov    $0x4b6,%esi
  800420652c:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004206533:	00 00 00 
  8004206536:	b8 00 00 00 00       	mov    $0x0,%eax
  800420653b:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206542:	00 00 00 
  8004206545:	41 ff d0             	callq  *%r8
	assert(pp1->pp_link == NULL);
  8004206548:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420654c:	48 8b 00             	mov    (%rax),%rax
  800420654f:	48 85 c0             	test   %rax,%rax
  8004206552:	74 35                	je     8004206589 <page_check+0x13c4>
  8004206554:	48 b9 f7 6d 21 04 80 	movabs $0x8004216df7,%rcx
  800420655b:	00 00 00 
  800420655e:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004206565:	00 00 00 
  8004206568:	be b7 04 00 00       	mov    $0x4b7,%esi
  800420656d:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004206574:	00 00 00 
  8004206577:	b8 00 00 00 00       	mov    $0x0,%eax
  800420657c:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206583:	00 00 00 
  8004206586:	41 ff d0             	callq  *%r8

	// unmapping pp1 at PGSIZE should free it
	page_remove(boot_pml4e, (void*) PGSIZE);
  8004206589:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  8004206590:	00 00 00 
  8004206593:	48 8b 00             	mov    (%rax),%rax
  8004206596:	be 00 10 00 00       	mov    $0x1000,%esi
  800420659b:	48 89 c7             	mov    %rax,%rdi
  800420659e:	48 b8 8f 34 20 04 80 	movabs $0x800420348f,%rax
  80042065a5:	00 00 00 
  80042065a8:	ff d0                	callq  *%rax
	assert(check_va2pa(boot_pml4e, 0x0) == ~0);
  80042065aa:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  80042065b1:	00 00 00 
  80042065b4:	48 8b 00             	mov    (%rax),%rax
  80042065b7:	be 00 00 00 00       	mov    $0x0,%esi
  80042065bc:	48 89 c7             	mov    %rax,%rdi
  80042065bf:	48 b8 4b 4f 20 04 80 	movabs $0x8004204f4b,%rax
  80042065c6:	00 00 00 
  80042065c9:	ff d0                	callq  *%rax
  80042065cb:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  80042065cf:	74 35                	je     8004206606 <page_check+0x1441>
  80042065d1:	48 b9 c8 6d 21 04 80 	movabs $0x8004216dc8,%rcx
  80042065d8:	00 00 00 
  80042065db:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  80042065e2:	00 00 00 
  80042065e5:	be bb 04 00 00       	mov    $0x4bb,%esi
  80042065ea:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  80042065f1:	00 00 00 
  80042065f4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042065f9:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206600:	00 00 00 
  8004206603:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == ~0);
  8004206606:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  800420660d:	00 00 00 
  8004206610:	48 8b 00             	mov    (%rax),%rax
  8004206613:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206618:	48 89 c7             	mov    %rax,%rdi
  800420661b:	48 b8 4b 4f 20 04 80 	movabs $0x8004204f4b,%rax
  8004206622:	00 00 00 
  8004206625:	ff d0                	callq  *%rax
  8004206627:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  800420662b:	74 35                	je     8004206662 <page_check+0x149d>
  800420662d:	48 b9 10 6e 21 04 80 	movabs $0x8004216e10,%rcx
  8004206634:	00 00 00 
  8004206637:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  800420663e:	00 00 00 
  8004206641:	be bc 04 00 00       	mov    $0x4bc,%esi
  8004206646:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  800420664d:	00 00 00 
  8004206650:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206655:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420665c:	00 00 00 
  800420665f:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 0);
  8004206662:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206666:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420666a:	66 85 c0             	test   %ax,%ax
  800420666d:	74 35                	je     80042066a4 <page_check+0x14df>
  800420666f:	48 b9 36 6e 21 04 80 	movabs $0x8004216e36,%rcx
  8004206676:	00 00 00 
  8004206679:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004206680:	00 00 00 
  8004206683:	be bd 04 00 00       	mov    $0x4bd,%esi
  8004206688:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  800420668f:	00 00 00 
  8004206692:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206697:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420669e:	00 00 00 
  80042066a1:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  80042066a4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042066a8:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042066ac:	66 83 f8 01          	cmp    $0x1,%ax
  80042066b0:	74 35                	je     80042066e7 <page_check+0x1522>
  80042066b2:	48 b9 b1 6d 21 04 80 	movabs $0x8004216db1,%rcx
  80042066b9:	00 00 00 
  80042066bc:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  80042066c3:	00 00 00 
  80042066c6:	be be 04 00 00       	mov    $0x4be,%esi
  80042066cb:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  80042066d2:	00 00 00 
  80042066d5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042066da:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042066e1:	00 00 00 
  80042066e4:	41 ff d0             	callq  *%r8
	page_remove(boot_pgdir, 0x0);
	assert(pp2->pp_ref == 0);
#endif

	// forcibly take pp3 back
	assert(PTE_ADDR(boot_pml4e[0]) == page2pa(pp3));
  80042066e7:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  80042066ee:	00 00 00 
  80042066f1:	48 8b 00             	mov    (%rax),%rax
  80042066f4:	48 8b 00             	mov    (%rax),%rax
  80042066f7:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042066fd:	48 89 c3             	mov    %rax,%rbx
  8004206700:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206704:	48 89 c7             	mov    %rax,%rdi
  8004206707:	48 b8 64 19 20 04 80 	movabs $0x8004201964,%rax
  800420670e:	00 00 00 
  8004206711:	ff d0                	callq  *%rax
  8004206713:	48 39 c3             	cmp    %rax,%rbx
  8004206716:	74 35                	je     800420674d <page_check+0x1588>
  8004206718:	48 b9 48 6e 21 04 80 	movabs $0x8004216e48,%rcx
  800420671f:	00 00 00 
  8004206722:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004206729:	00 00 00 
  800420672c:	be d2 04 00 00       	mov    $0x4d2,%esi
  8004206731:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004206738:	00 00 00 
  800420673b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206740:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206747:	00 00 00 
  800420674a:	41 ff d0             	callq  *%r8
	boot_pml4e[0] = 0;
  800420674d:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  8004206754:	00 00 00 
  8004206757:	48 8b 00             	mov    (%rax),%rax
  800420675a:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	assert(pp3->pp_ref == 1);
  8004206761:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206765:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206769:	66 83 f8 01          	cmp    $0x1,%ax
  800420676d:	74 35                	je     80042067a4 <page_check+0x15df>
  800420676f:	48 b9 b1 6d 21 04 80 	movabs $0x8004216db1,%rcx
  8004206776:	00 00 00 
  8004206779:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004206780:	00 00 00 
  8004206783:	be d4 04 00 00       	mov    $0x4d4,%esi
  8004206788:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  800420678f:	00 00 00 
  8004206792:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206797:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420679e:	00 00 00 
  80042067a1:	41 ff d0             	callq  *%r8
	page_decref(pp3);
  80042067a4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042067a8:	48 89 c7             	mov    %rax,%rdi
  80042067ab:	48 b8 8e 2c 20 04 80 	movabs $0x8004202c8e,%rax
  80042067b2:	00 00 00 
  80042067b5:	ff d0                	callq  *%rax
	// check pointer arithmetic in pml4e_walk
	page_decref(pp0);
  80042067b7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042067bb:	48 89 c7             	mov    %rax,%rdi
  80042067be:	48 b8 8e 2c 20 04 80 	movabs $0x8004202c8e,%rax
  80042067c5:	00 00 00 
  80042067c8:	ff d0                	callq  *%rax
	page_decref(pp2);
  80042067ca:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042067ce:	48 89 c7             	mov    %rax,%rdi
  80042067d1:	48 b8 8e 2c 20 04 80 	movabs $0x8004202c8e,%rax
  80042067d8:	00 00 00 
  80042067db:	ff d0                	callq  *%rax
	va = (void*)(PGSIZE * 100);
  80042067dd:	48 c7 85 68 ff ff ff 	movq   $0x64000,-0x98(%rbp)
  80042067e4:	00 40 06 00 
	ptep = pml4e_walk(boot_pml4e, va, 1);
  80042067e8:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  80042067ef:	00 00 00 
  80042067f2:	48 8b 00             	mov    (%rax),%rax
  80042067f5:	48 8b 8d 68 ff ff ff 	mov    -0x98(%rbp),%rcx
  80042067fc:	ba 01 00 00 00       	mov    $0x1,%edx
  8004206801:	48 89 ce             	mov    %rcx,%rsi
  8004206804:	48 89 c7             	mov    %rax,%rdi
  8004206807:	48 b8 cf 2c 20 04 80 	movabs $0x8004202ccf,%rax
  800420680e:	00 00 00 
  8004206811:	ff d0                	callq  *%rax
  8004206813:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
	pdpe = KADDR(PTE_ADDR(boot_pml4e[PML4(va)]));
  800420681a:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  8004206821:	00 00 00 
  8004206824:	48 8b 00             	mov    (%rax),%rax
  8004206827:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
  800420682e:	48 c1 ea 27          	shr    $0x27,%rdx
  8004206832:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  8004206838:	48 c1 e2 03          	shl    $0x3,%rdx
  800420683c:	48 01 d0             	add    %rdx,%rax
  800420683f:	48 8b 00             	mov    (%rax),%rax
  8004206842:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206848:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
  800420684f:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004206856:	48 c1 e8 0c          	shr    $0xc,%rax
  800420685a:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%rbp)
  8004206860:	8b 95 5c ff ff ff    	mov    -0xa4(%rbp),%edx
  8004206866:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  800420686d:	00 00 00 
  8004206870:	48 8b 00             	mov    (%rax),%rax
  8004206873:	48 39 c2             	cmp    %rax,%rdx
  8004206876:	72 35                	jb     80042068ad <page_check+0x16e8>
  8004206878:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  800420687f:	48 89 c1             	mov    %rax,%rcx
  8004206882:	48 ba e0 61 21 04 80 	movabs $0x80042161e0,%rdx
  8004206889:	00 00 00 
  800420688c:	be db 04 00 00       	mov    $0x4db,%esi
  8004206891:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004206898:	00 00 00 
  800420689b:	b8 00 00 00 00       	mov    $0x0,%eax
  80042068a0:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042068a7:	00 00 00 
  80042068aa:	41 ff d0             	callq  *%r8
  80042068ad:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042068b4:	00 00 00 
  80042068b7:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042068be:	48 01 d0             	add    %rdx,%rax
  80042068c1:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde  = KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  80042068c5:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042068cc:	48 c1 e8 1e          	shr    $0x1e,%rax
  80042068d0:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042068d5:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042068dc:	00 
  80042068dd:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042068e1:	48 01 d0             	add    %rdx,%rax
  80042068e4:	48 8b 00             	mov    (%rax),%rax
  80042068e7:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042068ed:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
  80042068f4:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  80042068fb:	48 c1 e8 0c          	shr    $0xc,%rax
  80042068ff:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
  8004206905:	8b 95 4c ff ff ff    	mov    -0xb4(%rbp),%edx
  800420690b:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  8004206912:	00 00 00 
  8004206915:	48 8b 00             	mov    (%rax),%rax
  8004206918:	48 39 c2             	cmp    %rax,%rdx
  800420691b:	72 35                	jb     8004206952 <page_check+0x178d>
  800420691d:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004206924:	48 89 c1             	mov    %rax,%rcx
  8004206927:	48 ba e0 61 21 04 80 	movabs $0x80042161e0,%rdx
  800420692e:	00 00 00 
  8004206931:	be dc 04 00 00       	mov    $0x4dc,%esi
  8004206936:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  800420693d:	00 00 00 
  8004206940:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206945:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420694c:	00 00 00 
  800420694f:	41 ff d0             	callq  *%r8
  8004206952:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206959:	00 00 00 
  800420695c:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004206963:	48 01 d0             	add    %rdx,%rax
  8004206966:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep1 = KADDR(PTE_ADDR(pde[PDX(va)]));
  800420696a:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004206971:	48 c1 e8 15          	shr    $0x15,%rax
  8004206975:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420697a:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004206981:	00 
  8004206982:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004206986:	48 01 d0             	add    %rdx,%rax
  8004206989:	48 8b 00             	mov    (%rax),%rax
  800420698c:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206992:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  8004206999:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  80042069a0:	48 c1 e8 0c          	shr    $0xc,%rax
  80042069a4:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%rbp)
  80042069aa:	8b 95 3c ff ff ff    	mov    -0xc4(%rbp),%edx
  80042069b0:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  80042069b7:	00 00 00 
  80042069ba:	48 8b 00             	mov    (%rax),%rax
  80042069bd:	48 39 c2             	cmp    %rax,%rdx
  80042069c0:	72 35                	jb     80042069f7 <page_check+0x1832>
  80042069c2:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  80042069c9:	48 89 c1             	mov    %rax,%rcx
  80042069cc:	48 ba e0 61 21 04 80 	movabs $0x80042161e0,%rdx
  80042069d3:	00 00 00 
  80042069d6:	be dd 04 00 00       	mov    $0x4dd,%esi
  80042069db:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  80042069e2:	00 00 00 
  80042069e5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042069ea:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042069f1:	00 00 00 
  80042069f4:	41 ff d0             	callq  *%r8
  80042069f7:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042069fe:	00 00 00 
  8004206a01:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  8004206a08:	48 01 d0             	add    %rdx,%rax
  8004206a0b:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
	assert(ptep == ptep1 + PTX(va));
  8004206a12:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004206a19:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206a1d:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004206a22:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004206a29:	00 
  8004206a2a:	48 8b 85 30 ff ff ff 	mov    -0xd0(%rbp),%rax
  8004206a31:	48 01 c2             	add    %rax,%rdx
  8004206a34:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  8004206a3b:	48 39 c2             	cmp    %rax,%rdx
  8004206a3e:	74 35                	je     8004206a75 <page_check+0x18b0>
  8004206a40:	48 b9 70 6e 21 04 80 	movabs $0x8004216e70,%rcx
  8004206a47:	00 00 00 
  8004206a4a:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004206a51:	00 00 00 
  8004206a54:	be de 04 00 00       	mov    $0x4de,%esi
  8004206a59:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004206a60:	00 00 00 
  8004206a63:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206a68:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206a6f:	00 00 00 
  8004206a72:	41 ff d0             	callq  *%r8
	
	// check that new page tables get cleared
	page_decref(pp4);
  8004206a75:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004206a79:	48 89 c7             	mov    %rax,%rdi
  8004206a7c:	48 b8 8e 2c 20 04 80 	movabs $0x8004202c8e,%rax
  8004206a83:	00 00 00 
  8004206a86:	ff d0                	callq  *%rax
	memset(page2kva(pp4), 0xFF, PGSIZE);
  8004206a88:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004206a8c:	48 89 c7             	mov    %rax,%rdi
  8004206a8f:	48 b8 fa 19 20 04 80 	movabs $0x80042019fa,%rax
  8004206a96:	00 00 00 
  8004206a99:	ff d0                	callq  *%rax
  8004206a9b:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206aa0:	be ff 00 00 00       	mov    $0xff,%esi
  8004206aa5:	48 89 c7             	mov    %rax,%rdi
  8004206aa8:	48 b8 db e8 20 04 80 	movabs $0x800420e8db,%rax
  8004206aaf:	00 00 00 
  8004206ab2:	ff d0                	callq  *%rax
	pml4e_walk(boot_pml4e, 0x0, 1);
  8004206ab4:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  8004206abb:	00 00 00 
  8004206abe:	48 8b 00             	mov    (%rax),%rax
  8004206ac1:	ba 01 00 00 00       	mov    $0x1,%edx
  8004206ac6:	be 00 00 00 00       	mov    $0x0,%esi
  8004206acb:	48 89 c7             	mov    %rax,%rdi
  8004206ace:	48 b8 cf 2c 20 04 80 	movabs $0x8004202ccf,%rax
  8004206ad5:	00 00 00 
  8004206ad8:	ff d0                	callq  *%rax
	pdpe = KADDR(PTE_ADDR(boot_pml4e[0]));
  8004206ada:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  8004206ae1:	00 00 00 
  8004206ae4:	48 8b 00             	mov    (%rax),%rax
  8004206ae7:	48 8b 00             	mov    (%rax),%rax
  8004206aea:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206af0:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
  8004206af7:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004206afe:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206b02:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%rbp)
  8004206b08:	8b 95 24 ff ff ff    	mov    -0xdc(%rbp),%edx
  8004206b0e:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  8004206b15:	00 00 00 
  8004206b18:	48 8b 00             	mov    (%rax),%rax
  8004206b1b:	48 39 c2             	cmp    %rax,%rdx
  8004206b1e:	72 35                	jb     8004206b55 <page_check+0x1990>
  8004206b20:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004206b27:	48 89 c1             	mov    %rax,%rcx
  8004206b2a:	48 ba e0 61 21 04 80 	movabs $0x80042161e0,%rdx
  8004206b31:	00 00 00 
  8004206b34:	be e4 04 00 00       	mov    $0x4e4,%esi
  8004206b39:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004206b40:	00 00 00 
  8004206b43:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206b48:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206b4f:	00 00 00 
  8004206b52:	41 ff d0             	callq  *%r8
  8004206b55:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206b5c:	00 00 00 
  8004206b5f:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004206b66:	48 01 d0             	add    %rdx,%rax
  8004206b69:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde  = KADDR(PTE_ADDR(pdpe[0]));
  8004206b6d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004206b71:	48 8b 00             	mov    (%rax),%rax
  8004206b74:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206b7a:	48 89 85 18 ff ff ff 	mov    %rax,-0xe8(%rbp)
  8004206b81:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004206b88:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206b8c:	89 85 14 ff ff ff    	mov    %eax,-0xec(%rbp)
  8004206b92:	8b 95 14 ff ff ff    	mov    -0xec(%rbp),%edx
  8004206b98:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  8004206b9f:	00 00 00 
  8004206ba2:	48 8b 00             	mov    (%rax),%rax
  8004206ba5:	48 39 c2             	cmp    %rax,%rdx
  8004206ba8:	72 35                	jb     8004206bdf <page_check+0x1a1a>
  8004206baa:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004206bb1:	48 89 c1             	mov    %rax,%rcx
  8004206bb4:	48 ba e0 61 21 04 80 	movabs $0x80042161e0,%rdx
  8004206bbb:	00 00 00 
  8004206bbe:	be e5 04 00 00       	mov    $0x4e5,%esi
  8004206bc3:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004206bca:	00 00 00 
  8004206bcd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206bd2:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206bd9:	00 00 00 
  8004206bdc:	41 ff d0             	callq  *%r8
  8004206bdf:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206be6:	00 00 00 
  8004206be9:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004206bf0:	48 01 d0             	add    %rdx,%rax
  8004206bf3:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep  = KADDR(PTE_ADDR(pde[0]));
  8004206bf7:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004206bfb:	48 8b 00             	mov    (%rax),%rax
  8004206bfe:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206c04:	48 89 85 08 ff ff ff 	mov    %rax,-0xf8(%rbp)
  8004206c0b:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004206c12:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206c16:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%rbp)
  8004206c1c:	8b 95 04 ff ff ff    	mov    -0xfc(%rbp),%edx
  8004206c22:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  8004206c29:	00 00 00 
  8004206c2c:	48 8b 00             	mov    (%rax),%rax
  8004206c2f:	48 39 c2             	cmp    %rax,%rdx
  8004206c32:	72 35                	jb     8004206c69 <page_check+0x1aa4>
  8004206c34:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004206c3b:	48 89 c1             	mov    %rax,%rcx
  8004206c3e:	48 ba e0 61 21 04 80 	movabs $0x80042161e0,%rdx
  8004206c45:	00 00 00 
  8004206c48:	be e6 04 00 00       	mov    $0x4e6,%esi
  8004206c4d:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004206c54:	00 00 00 
  8004206c57:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206c5c:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206c63:	00 00 00 
  8004206c66:	41 ff d0             	callq  *%r8
  8004206c69:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206c70:	00 00 00 
  8004206c73:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004206c7a:	48 01 d0             	add    %rdx,%rax
  8004206c7d:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
	for (i=0; i<NPTENTRIES; i++)
  8004206c84:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004206c8b:	eb 58                	jmp    8004206ce5 <page_check+0x1b20>
		assert((ptep[i] & PTE_P) == 0);
  8004206c8d:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  8004206c94:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004206c97:	48 63 d2             	movslq %edx,%rdx
  8004206c9a:	48 c1 e2 03          	shl    $0x3,%rdx
  8004206c9e:	48 01 d0             	add    %rdx,%rax
  8004206ca1:	48 8b 00             	mov    (%rax),%rax
  8004206ca4:	83 e0 01             	and    $0x1,%eax
  8004206ca7:	48 85 c0             	test   %rax,%rax
  8004206caa:	74 35                	je     8004206ce1 <page_check+0x1b1c>
  8004206cac:	48 b9 88 6e 21 04 80 	movabs $0x8004216e88,%rcx
  8004206cb3:	00 00 00 
  8004206cb6:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004206cbd:	00 00 00 
  8004206cc0:	be e8 04 00 00       	mov    $0x4e8,%esi
  8004206cc5:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004206ccc:	00 00 00 
  8004206ccf:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206cd4:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206cdb:	00 00 00 
  8004206cde:	41 ff d0             	callq  *%r8
	memset(page2kva(pp4), 0xFF, PGSIZE);
	pml4e_walk(boot_pml4e, 0x0, 1);
	pdpe = KADDR(PTE_ADDR(boot_pml4e[0]));
	pde  = KADDR(PTE_ADDR(pdpe[0]));
	ptep  = KADDR(PTE_ADDR(pde[0]));
	for (i=0; i<NPTENTRIES; i++)
  8004206ce1:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004206ce5:	81 7d ec ff 01 00 00 	cmpl   $0x1ff,-0x14(%rbp)
  8004206cec:	7e 9f                	jle    8004206c8d <page_check+0x1ac8>
		assert((ptep[i] & PTE_P) == 0);
	boot_pml4e[0] = 0;
  8004206cee:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  8004206cf5:	00 00 00 
  8004206cf8:	48 8b 00             	mov    (%rax),%rax
  8004206cfb:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// give free list back
	page_free_list = fl;
  8004206d02:	48 b8 38 52 49 04 80 	movabs $0x8004495238,%rax
  8004206d09:	00 00 00 
  8004206d0c:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004206d10:	48 89 10             	mov    %rdx,(%rax)

	// free the pages we took
	page_decref(pp0);
  8004206d13:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004206d17:	48 89 c7             	mov    %rax,%rdi
  8004206d1a:	48 b8 8e 2c 20 04 80 	movabs $0x8004202c8e,%rax
  8004206d21:	00 00 00 
  8004206d24:	ff d0                	callq  *%rax
	page_decref(pp1);
  8004206d26:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206d2a:	48 89 c7             	mov    %rax,%rdi
  8004206d2d:	48 b8 8e 2c 20 04 80 	movabs $0x8004202c8e,%rax
  8004206d34:	00 00 00 
  8004206d37:	ff d0                	callq  *%rax
	page_decref(pp2);
  8004206d39:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004206d3d:	48 89 c7             	mov    %rax,%rdi
  8004206d40:	48 b8 8e 2c 20 04 80 	movabs $0x8004202c8e,%rax
  8004206d47:	00 00 00 
  8004206d4a:	ff d0                	callq  *%rax

	// test mmio_map_region
	mm1 = (uintptr_t) mmio_map_region(0, 4097);
  8004206d4c:	be 01 10 00 00       	mov    $0x1001,%esi
  8004206d51:	bf 00 00 00 00       	mov    $0x0,%edi
  8004206d56:	48 b8 d3 35 20 04 80 	movabs $0x80042035d3,%rax
  8004206d5d:	00 00 00 
  8004206d60:	ff d0                	callq  *%rax
  8004206d62:	48 89 85 f8 fe ff ff 	mov    %rax,-0x108(%rbp)
	mm2 = (uintptr_t) mmio_map_region(0, 4096);
  8004206d69:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206d6e:	bf 00 00 00 00       	mov    $0x0,%edi
  8004206d73:	48 b8 d3 35 20 04 80 	movabs $0x80042035d3,%rax
  8004206d7a:	00 00 00 
  8004206d7d:	ff d0                	callq  *%rax
  8004206d7f:	48 89 85 f0 fe ff ff 	mov    %rax,-0x110(%rbp)
	// check that they're in the right region
	assert(mm1 >= MMIOBASE && mm1 + 8096 < MMIOLIM);
  8004206d86:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004206d8d:	00 00 00 
  8004206d90:	48 39 85 f8 fe ff ff 	cmp    %rax,-0x108(%rbp)
  8004206d97:	76 1d                	jbe    8004206db6 <page_check+0x1bf1>
  8004206d99:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  8004206da0:	48 8d 90 a0 1f 00 00 	lea    0x1fa0(%rax),%rdx
  8004206da7:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  8004206dae:	00 00 00 
  8004206db1:	48 39 c2             	cmp    %rax,%rdx
  8004206db4:	76 35                	jbe    8004206deb <page_check+0x1c26>
  8004206db6:	48 b9 a0 6e 21 04 80 	movabs $0x8004216ea0,%rcx
  8004206dbd:	00 00 00 
  8004206dc0:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004206dc7:	00 00 00 
  8004206dca:	be f7 04 00 00       	mov    $0x4f7,%esi
  8004206dcf:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004206dd6:	00 00 00 
  8004206dd9:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206dde:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206de5:	00 00 00 
  8004206de8:	41 ff d0             	callq  *%r8
	assert(mm2 >= MMIOBASE && mm2 + 8096 < MMIOLIM);
  8004206deb:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004206df2:	00 00 00 
  8004206df5:	48 39 85 f0 fe ff ff 	cmp    %rax,-0x110(%rbp)
  8004206dfc:	76 1d                	jbe    8004206e1b <page_check+0x1c56>
  8004206dfe:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004206e05:	48 8d 90 a0 1f 00 00 	lea    0x1fa0(%rax),%rdx
  8004206e0c:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  8004206e13:	00 00 00 
  8004206e16:	48 39 c2             	cmp    %rax,%rdx
  8004206e19:	76 35                	jbe    8004206e50 <page_check+0x1c8b>
  8004206e1b:	48 b9 c8 6e 21 04 80 	movabs $0x8004216ec8,%rcx
  8004206e22:	00 00 00 
  8004206e25:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004206e2c:	00 00 00 
  8004206e2f:	be f8 04 00 00       	mov    $0x4f8,%esi
  8004206e34:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004206e3b:	00 00 00 
  8004206e3e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206e43:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206e4a:	00 00 00 
  8004206e4d:	41 ff d0             	callq  *%r8
	// check that they're page-aligned
	assert(mm1 % PGSIZE == 0 && mm2 % PGSIZE == 0);
  8004206e50:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  8004206e57:	25 ff 0f 00 00       	and    $0xfff,%eax
  8004206e5c:	48 85 c0             	test   %rax,%rax
  8004206e5f:	75 11                	jne    8004206e72 <page_check+0x1cad>
  8004206e61:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004206e68:	25 ff 0f 00 00       	and    $0xfff,%eax
  8004206e6d:	48 85 c0             	test   %rax,%rax
  8004206e70:	74 35                	je     8004206ea7 <page_check+0x1ce2>
  8004206e72:	48 b9 f0 6e 21 04 80 	movabs $0x8004216ef0,%rcx
  8004206e79:	00 00 00 
  8004206e7c:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004206e83:	00 00 00 
  8004206e86:	be fa 04 00 00       	mov    $0x4fa,%esi
  8004206e8b:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004206e92:	00 00 00 
  8004206e95:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206e9a:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206ea1:	00 00 00 
  8004206ea4:	41 ff d0             	callq  *%r8
	// check that they don't overlap
	assert(mm1 + 8096 <= mm2);
  8004206ea7:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  8004206eae:	48 05 a0 1f 00 00    	add    $0x1fa0,%rax
  8004206eb4:	48 3b 85 f0 fe ff ff 	cmp    -0x110(%rbp),%rax
  8004206ebb:	76 35                	jbe    8004206ef2 <page_check+0x1d2d>
  8004206ebd:	48 b9 17 6f 21 04 80 	movabs $0x8004216f17,%rcx
  8004206ec4:	00 00 00 
  8004206ec7:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004206ece:	00 00 00 
  8004206ed1:	be fc 04 00 00       	mov    $0x4fc,%esi
  8004206ed6:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004206edd:	00 00 00 
  8004206ee0:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206ee5:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206eec:	00 00 00 
  8004206eef:	41 ff d0             	callq  *%r8
	// check page mappings
	
	assert(check_va2pa(boot_pml4e, mm1) == 0);
  8004206ef2:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  8004206ef9:	00 00 00 
  8004206efc:	48 8b 00             	mov    (%rax),%rax
  8004206eff:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  8004206f06:	48 89 d6             	mov    %rdx,%rsi
  8004206f09:	48 89 c7             	mov    %rax,%rdi
  8004206f0c:	48 b8 4b 4f 20 04 80 	movabs $0x8004204f4b,%rax
  8004206f13:	00 00 00 
  8004206f16:	ff d0                	callq  *%rax
  8004206f18:	48 85 c0             	test   %rax,%rax
  8004206f1b:	74 35                	je     8004206f52 <page_check+0x1d8d>
  8004206f1d:	48 b9 30 6f 21 04 80 	movabs $0x8004216f30,%rcx
  8004206f24:	00 00 00 
  8004206f27:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004206f2e:	00 00 00 
  8004206f31:	be ff 04 00 00       	mov    $0x4ff,%esi
  8004206f36:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004206f3d:	00 00 00 
  8004206f40:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206f45:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206f4c:	00 00 00 
  8004206f4f:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm1+PGSIZE) == PGSIZE);
  8004206f52:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  8004206f59:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  8004206f60:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  8004206f67:	00 00 00 
  8004206f6a:	48 8b 00             	mov    (%rax),%rax
  8004206f6d:	48 89 d6             	mov    %rdx,%rsi
  8004206f70:	48 89 c7             	mov    %rax,%rdi
  8004206f73:	48 b8 4b 4f 20 04 80 	movabs $0x8004204f4b,%rax
  8004206f7a:	00 00 00 
  8004206f7d:	ff d0                	callq  *%rax
  8004206f7f:	48 3d 00 10 00 00    	cmp    $0x1000,%rax
  8004206f85:	74 35                	je     8004206fbc <page_check+0x1df7>
  8004206f87:	48 b9 58 6f 21 04 80 	movabs $0x8004216f58,%rcx
  8004206f8e:	00 00 00 
  8004206f91:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004206f98:	00 00 00 
  8004206f9b:	be 00 05 00 00       	mov    $0x500,%esi
  8004206fa0:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004206fa7:	00 00 00 
  8004206faa:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206faf:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206fb6:	00 00 00 
  8004206fb9:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm2) == 0);
  8004206fbc:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  8004206fc3:	00 00 00 
  8004206fc6:	48 8b 00             	mov    (%rax),%rax
  8004206fc9:	48 8b 95 f0 fe ff ff 	mov    -0x110(%rbp),%rdx
  8004206fd0:	48 89 d6             	mov    %rdx,%rsi
  8004206fd3:	48 89 c7             	mov    %rax,%rdi
  8004206fd6:	48 b8 4b 4f 20 04 80 	movabs $0x8004204f4b,%rax
  8004206fdd:	00 00 00 
  8004206fe0:	ff d0                	callq  *%rax
  8004206fe2:	48 85 c0             	test   %rax,%rax
  8004206fe5:	74 35                	je     800420701c <page_check+0x1e57>
  8004206fe7:	48 b9 88 6f 21 04 80 	movabs $0x8004216f88,%rcx
  8004206fee:	00 00 00 
  8004206ff1:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004206ff8:	00 00 00 
  8004206ffb:	be 01 05 00 00       	mov    $0x501,%esi
  8004207000:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004207007:	00 00 00 
  800420700a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420700f:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004207016:	00 00 00 
  8004207019:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm2+PGSIZE) == ~0);
  800420701c:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004207023:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  800420702a:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  8004207031:	00 00 00 
  8004207034:	48 8b 00             	mov    (%rax),%rax
  8004207037:	48 89 d6             	mov    %rdx,%rsi
  800420703a:	48 89 c7             	mov    %rax,%rdi
  800420703d:	48 b8 4b 4f 20 04 80 	movabs $0x8004204f4b,%rax
  8004207044:	00 00 00 
  8004207047:	ff d0                	callq  *%rax
  8004207049:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  800420704d:	74 35                	je     8004207084 <page_check+0x1ebf>
  800420704f:	48 b9 b0 6f 21 04 80 	movabs $0x8004216fb0,%rcx
  8004207056:	00 00 00 
  8004207059:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004207060:	00 00 00 
  8004207063:	be 02 05 00 00       	mov    $0x502,%esi
  8004207068:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  800420706f:	00 00 00 
  8004207072:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207077:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420707e:	00 00 00 
  8004207081:	41 ff d0             	callq  *%r8
	// check permissions
	assert(*pml4e_walk(boot_pml4e, (void*) mm1, 0) & (PTE_W|PTE_PWT|PTE_PCD));
  8004207084:	48 8b 8d f8 fe ff ff 	mov    -0x108(%rbp),%rcx
  800420708b:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  8004207092:	00 00 00 
  8004207095:	48 8b 00             	mov    (%rax),%rax
  8004207098:	ba 00 00 00 00       	mov    $0x0,%edx
  800420709d:	48 89 ce             	mov    %rcx,%rsi
  80042070a0:	48 89 c7             	mov    %rax,%rdi
  80042070a3:	48 b8 cf 2c 20 04 80 	movabs $0x8004202ccf,%rax
  80042070aa:	00 00 00 
  80042070ad:	ff d0                	callq  *%rax
  80042070af:	48 8b 00             	mov    (%rax),%rax
  80042070b2:	83 e0 1a             	and    $0x1a,%eax
  80042070b5:	48 85 c0             	test   %rax,%rax
  80042070b8:	75 35                	jne    80042070ef <page_check+0x1f2a>
  80042070ba:	48 b9 e0 6f 21 04 80 	movabs $0x8004216fe0,%rcx
  80042070c1:	00 00 00 
  80042070c4:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  80042070cb:	00 00 00 
  80042070ce:	be 04 05 00 00       	mov    $0x504,%esi
  80042070d3:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  80042070da:	00 00 00 
  80042070dd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042070e2:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042070e9:	00 00 00 
  80042070ec:	41 ff d0             	callq  *%r8
	assert(!(*pml4e_walk(boot_pml4e, (void*) mm1, 0) & PTE_U));
  80042070ef:	48 8b 8d f8 fe ff ff 	mov    -0x108(%rbp),%rcx
  80042070f6:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  80042070fd:	00 00 00 
  8004207100:	48 8b 00             	mov    (%rax),%rax
  8004207103:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207108:	48 89 ce             	mov    %rcx,%rsi
  800420710b:	48 89 c7             	mov    %rax,%rdi
  800420710e:	48 b8 cf 2c 20 04 80 	movabs $0x8004202ccf,%rax
  8004207115:	00 00 00 
  8004207118:	ff d0                	callq  *%rax
  800420711a:	48 8b 00             	mov    (%rax),%rax
  800420711d:	83 e0 04             	and    $0x4,%eax
  8004207120:	48 85 c0             	test   %rax,%rax
  8004207123:	74 35                	je     800420715a <page_check+0x1f95>
  8004207125:	48 b9 28 70 21 04 80 	movabs $0x8004217028,%rcx
  800420712c:	00 00 00 
  800420712f:	48 ba 59 62 21 04 80 	movabs $0x8004216259,%rdx
  8004207136:	00 00 00 
  8004207139:	be 05 05 00 00       	mov    $0x505,%esi
  800420713e:	48 bf 6e 62 21 04 80 	movabs $0x800421626e,%rdi
  8004207145:	00 00 00 
  8004207148:	b8 00 00 00 00       	mov    $0x0,%eax
  800420714d:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004207154:	00 00 00 
  8004207157:	41 ff d0             	callq  *%r8
	// clear the mappings
	*pml4e_walk(boot_pml4e, (void*) mm1, 0) = 0;
  800420715a:	48 8b 8d f8 fe ff ff 	mov    -0x108(%rbp),%rcx
  8004207161:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  8004207168:	00 00 00 
  800420716b:	48 8b 00             	mov    (%rax),%rax
  800420716e:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207173:	48 89 ce             	mov    %rcx,%rsi
  8004207176:	48 89 c7             	mov    %rax,%rdi
  8004207179:	48 b8 cf 2c 20 04 80 	movabs $0x8004202ccf,%rax
  8004207180:	00 00 00 
  8004207183:	ff d0                	callq  *%rax
  8004207185:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	*pml4e_walk(boot_pml4e, (void*) mm1 + PGSIZE, 0) = 0;
  800420718c:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  8004207193:	48 05 00 10 00 00    	add    $0x1000,%rax
  8004207199:	48 89 c1             	mov    %rax,%rcx
  800420719c:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  80042071a3:	00 00 00 
  80042071a6:	48 8b 00             	mov    (%rax),%rax
  80042071a9:	ba 00 00 00 00       	mov    $0x0,%edx
  80042071ae:	48 89 ce             	mov    %rcx,%rsi
  80042071b1:	48 89 c7             	mov    %rax,%rdi
  80042071b4:	48 b8 cf 2c 20 04 80 	movabs $0x8004202ccf,%rax
  80042071bb:	00 00 00 
  80042071be:	ff d0                	callq  *%rax
  80042071c0:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	*pml4e_walk(boot_pml4e, (void*) mm2, 0) = 0;
  80042071c7:	48 8b 8d f0 fe ff ff 	mov    -0x110(%rbp),%rcx
  80042071ce:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  80042071d5:	00 00 00 
  80042071d8:	48 8b 00             	mov    (%rax),%rax
  80042071db:	ba 00 00 00 00       	mov    $0x0,%edx
  80042071e0:	48 89 ce             	mov    %rcx,%rsi
  80042071e3:	48 89 c7             	mov    %rax,%rdi
  80042071e6:	48 b8 cf 2c 20 04 80 	movabs $0x8004202ccf,%rax
  80042071ed:	00 00 00 
  80042071f0:	ff d0                	callq  *%rax
  80042071f2:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	cprintf("check_page() succeeded!\n");
  80042071f9:	48 bf 5b 70 21 04 80 	movabs $0x800421705b,%rdi
  8004207200:	00 00 00 
  8004207203:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207208:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  800420720f:	00 00 00 
  8004207212:	ff d2                	callq  *%rdx
}
  8004207214:	48 81 c4 18 01 00 00 	add    $0x118,%rsp
  800420721b:	5b                   	pop    %rbx
  800420721c:	5d                   	pop    %rbp
  800420721d:	c3                   	retq   

000000800420721e <page2ppn>:
int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);

static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  800420721e:	55                   	push   %rbp
  800420721f:	48 89 e5             	mov    %rsp,%rbp
  8004207222:	48 83 ec 08          	sub    $0x8,%rsp
  8004207226:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  800420722a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420722e:	48 b8 b8 67 49 04 80 	movabs $0x80044967b8,%rax
  8004207235:	00 00 00 
  8004207238:	48 8b 00             	mov    (%rax),%rax
  800420723b:	48 29 c2             	sub    %rax,%rdx
  800420723e:	48 89 d0             	mov    %rdx,%rax
  8004207241:	48 c1 f8 04          	sar    $0x4,%rax
}
  8004207245:	c9                   	leaveq 
  8004207246:	c3                   	retq   

0000008004207247 <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  8004207247:	55                   	push   %rbp
  8004207248:	48 89 e5             	mov    %rsp,%rbp
  800420724b:	48 83 ec 08          	sub    $0x8,%rsp
  800420724f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  8004207253:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207257:	48 89 c7             	mov    %rax,%rdi
  800420725a:	48 b8 1e 72 20 04 80 	movabs $0x800420721e,%rax
  8004207261:	00 00 00 
  8004207264:	ff d0                	callq  *%rax
  8004207266:	48 c1 e0 0c          	shl    $0xc,%rax
}
  800420726a:	c9                   	leaveq 
  800420726b:	c3                   	retq   

000000800420726c <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  800420726c:	55                   	push   %rbp
  800420726d:	48 89 e5             	mov    %rsp,%rbp
  8004207270:	48 83 ec 10          	sub    $0x10,%rsp
  8004207274:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  8004207278:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420727c:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207280:	48 89 c2             	mov    %rax,%rdx
  8004207283:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  800420728a:	00 00 00 
  800420728d:	48 8b 00             	mov    (%rax),%rax
  8004207290:	48 39 c2             	cmp    %rax,%rdx
  8004207293:	72 2a                	jb     80042072bf <pa2page+0x53>
		panic("pa2page called with invalid pa");
  8004207295:	48 ba 78 70 21 04 80 	movabs $0x8004217078,%rdx
  800420729c:	00 00 00 
  800420729f:	be 54 00 00 00       	mov    $0x54,%esi
  80042072a4:	48 bf 97 70 21 04 80 	movabs $0x8004217097,%rdi
  80042072ab:	00 00 00 
  80042072ae:	b8 00 00 00 00       	mov    $0x0,%eax
  80042072b3:	48 b9 ae 04 20 04 80 	movabs $0x80042004ae,%rcx
  80042072ba:	00 00 00 
  80042072bd:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  80042072bf:	48 b8 b8 67 49 04 80 	movabs $0x80044967b8,%rax
  80042072c6:	00 00 00 
  80042072c9:	48 8b 00             	mov    (%rax),%rax
  80042072cc:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042072d0:	48 c1 ea 0c          	shr    $0xc,%rdx
  80042072d4:	48 c1 e2 04          	shl    $0x4,%rdx
  80042072d8:	48 01 d0             	add    %rdx,%rax
}
  80042072db:	c9                   	leaveq 
  80042072dc:	c3                   	retq   

00000080042072dd <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  80042072dd:	55                   	push   %rbp
  80042072de:	48 89 e5             	mov    %rsp,%rbp
  80042072e1:	48 83 ec 20          	sub    $0x20,%rsp
  80042072e5:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  80042072e9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042072ed:	48 89 c7             	mov    %rax,%rdi
  80042072f0:	48 b8 47 72 20 04 80 	movabs $0x8004207247,%rax
  80042072f7:	00 00 00 
  80042072fa:	ff d0                	callq  *%rax
  80042072fc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004207300:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207304:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207308:	89 45 f4             	mov    %eax,-0xc(%rbp)
  800420730b:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800420730e:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  8004207315:	00 00 00 
  8004207318:	48 8b 00             	mov    (%rax),%rax
  800420731b:	48 39 c2             	cmp    %rax,%rdx
  800420731e:	72 32                	jb     8004207352 <page2kva+0x75>
  8004207320:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207324:	48 89 c1             	mov    %rax,%rcx
  8004207327:	48 ba a8 70 21 04 80 	movabs $0x80042170a8,%rdx
  800420732e:	00 00 00 
  8004207331:	be 5b 00 00 00       	mov    $0x5b,%esi
  8004207336:	48 bf 97 70 21 04 80 	movabs $0x8004217097,%rdi
  800420733d:	00 00 00 
  8004207340:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207345:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420734c:	00 00 00 
  800420734f:	41 ff d0             	callq  *%r8
  8004207352:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207359:	00 00 00 
  800420735c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207360:	48 01 d0             	add    %rdx,%rax
}
  8004207363:	c9                   	leaveq 
  8004207364:	c3                   	retq   

0000008004207365 <unlock_kernel>:

static inline void
unlock_kernel(void)
{
  8004207365:	55                   	push   %rbp
  8004207366:	48 89 e5             	mov    %rsp,%rbp
	spin_unlock(&kernel_lock);
  8004207369:	48 bf 80 b7 22 04 80 	movabs $0x800422b780,%rdi
  8004207370:	00 00 00 
  8004207373:	48 b8 ef 5b 21 04 80 	movabs $0x8004215bef,%rax
  800420737a:	00 00 00 
  800420737d:	ff d0                	callq  *%rax

	// Normally we wouldn't need to do this, but QEMU only runs
	// one CPU at a time and has a long time-slice.  Without the
	// pause, this CPU is likely to reacquire the lock before
	// another CPU has even been given a chance to acquire it.
	asm volatile("pause");
  800420737f:	f3 90                	pause  
}
  8004207381:	5d                   	pop    %rbp
  8004207382:	c3                   	retq   

0000008004207383 <envid2env>:
//   On success, sets *env_store to the environment.
//   On error, sets *env_store to NULL.
//
int
envid2env(envid_t envid, struct Env **env_store, bool checkperm)
{
  8004207383:	55                   	push   %rbp
  8004207384:	48 89 e5             	mov    %rsp,%rbp
  8004207387:	53                   	push   %rbx
  8004207388:	48 83 ec 28          	sub    $0x28,%rsp
  800420738c:	89 7d dc             	mov    %edi,-0x24(%rbp)
  800420738f:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004207393:	89 d0                	mov    %edx,%eax
  8004207395:	88 45 d8             	mov    %al,-0x28(%rbp)
	struct Env *e;

	// If envid is zero, return the current environment.
	if (envid == 0) {
  8004207398:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420739c:	75 42                	jne    80042073e0 <envid2env+0x5d>
		*env_store = curenv;
  800420739e:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  80042073a5:	00 00 00 
  80042073a8:	ff d0                	callq  *%rax
  80042073aa:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  80042073b1:	00 00 00 
  80042073b4:	48 98                	cltq   
  80042073b6:	48 c1 e0 03          	shl    $0x3,%rax
  80042073ba:	48 89 c2             	mov    %rax,%rdx
  80042073bd:	48 c1 e2 04          	shl    $0x4,%rdx
  80042073c1:	48 29 c2             	sub    %rax,%rdx
  80042073c4:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042073c8:	48 83 c0 08          	add    $0x8,%rax
  80042073cc:	48 8b 10             	mov    (%rax),%rdx
  80042073cf:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042073d3:	48 89 10             	mov    %rdx,(%rax)
		return 0;
  80042073d6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042073db:	e9 09 01 00 00       	jmpq   80042074e9 <envid2env+0x166>
	// Look up the Env structure via the index part of the envid,
	// then check the env_id field in that struct Env
	// to ensure that the envid is not stale
	// (i.e., does not refer to a _previous_ environment
	// that used the same slot in the envs[] array).
	e = &envs[ENVX(envid)];
  80042073e0:	48 b8 50 52 49 04 80 	movabs $0x8004495250,%rax
  80042073e7:	00 00 00 
  80042073ea:	48 8b 08             	mov    (%rax),%rcx
  80042073ed:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80042073f0:	48 98                	cltq   
  80042073f2:	25 ff 03 00 00       	and    $0x3ff,%eax
  80042073f7:	48 89 c2             	mov    %rax,%rdx
  80042073fa:	48 89 d0             	mov    %rdx,%rax
  80042073fd:	48 c1 e0 03          	shl    $0x3,%rax
  8004207401:	48 01 d0             	add    %rdx,%rax
  8004207404:	48 c1 e0 05          	shl    $0x5,%rax
  8004207408:	48 01 c8             	add    %rcx,%rax
  800420740b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (e->env_status == ENV_FREE || e->env_id != envid) {
  800420740f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207413:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  8004207419:	85 c0                	test   %eax,%eax
  800420741b:	74 0f                	je     800420742c <envid2env+0xa9>
  800420741d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207421:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004207427:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  800420742a:	74 15                	je     8004207441 <envid2env+0xbe>
		*env_store = 0;
  800420742c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207430:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return -E_BAD_ENV;
  8004207437:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420743c:	e9 a8 00 00 00       	jmpq   80042074e9 <envid2env+0x166>
	// Check that the calling environment has legitimate permission
	// to manipulate the specified environment.
	// If checkperm is set, the specified environment
	// must be either the current environment
	// or an immediate child of the current environment.
	if (checkperm && e != curenv && e->env_parent_id != curenv->env_id) {
  8004207441:	80 7d d8 00          	cmpb   $0x0,-0x28(%rbp)
  8004207445:	0f 84 8e 00 00 00    	je     80042074d9 <envid2env+0x156>
  800420744b:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  8004207452:	00 00 00 
  8004207455:	ff d0                	callq  *%rax
  8004207457:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  800420745e:	00 00 00 
  8004207461:	48 98                	cltq   
  8004207463:	48 c1 e0 03          	shl    $0x3,%rax
  8004207467:	48 89 c2             	mov    %rax,%rdx
  800420746a:	48 c1 e2 04          	shl    $0x4,%rdx
  800420746e:	48 29 c2             	sub    %rax,%rdx
  8004207471:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004207475:	48 83 c0 08          	add    $0x8,%rax
  8004207479:	48 8b 00             	mov    (%rax),%rax
  800420747c:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004207480:	74 57                	je     80042074d9 <envid2env+0x156>
  8004207482:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207486:	8b 98 cc 00 00 00    	mov    0xcc(%rax),%ebx
  800420748c:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  8004207493:	00 00 00 
  8004207496:	ff d0                	callq  *%rax
  8004207498:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  800420749f:	00 00 00 
  80042074a2:	48 98                	cltq   
  80042074a4:	48 c1 e0 03          	shl    $0x3,%rax
  80042074a8:	48 89 c2             	mov    %rax,%rdx
  80042074ab:	48 c1 e2 04          	shl    $0x4,%rdx
  80042074af:	48 29 c2             	sub    %rax,%rdx
  80042074b2:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042074b6:	48 83 c0 08          	add    $0x8,%rax
  80042074ba:	48 8b 00             	mov    (%rax),%rax
  80042074bd:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  80042074c3:	39 c3                	cmp    %eax,%ebx
  80042074c5:	74 12                	je     80042074d9 <envid2env+0x156>
		*env_store = 0;
  80042074c7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042074cb:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return -E_BAD_ENV;
  80042074d2:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  80042074d7:	eb 10                	jmp    80042074e9 <envid2env+0x166>
	}

	*env_store = e;
  80042074d9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042074dd:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042074e1:	48 89 10             	mov    %rdx,(%rax)
	return 0;
  80042074e4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042074e9:	48 83 c4 28          	add    $0x28,%rsp
  80042074ed:	5b                   	pop    %rbx
  80042074ee:	5d                   	pop    %rbp
  80042074ef:	c3                   	retq   

00000080042074f0 <env_init>:
// they are in the envs array (i.e., so that the first call to
// env_alloc() returns envs[0]).
//
void
env_init(void)
{
  80042074f0:	55                   	push   %rbp
  80042074f1:	48 89 e5             	mov    %rsp,%rbp
  80042074f4:	48 83 ec 10          	sub    $0x10,%rsp
	// Set up envs array
	// LAB 3: Your code here.
	int i;
	for (i = NENV - 1; i >= 0; i--) {
  80042074f8:	c7 45 fc ff 03 00 00 	movl   $0x3ff,-0x4(%rbp)
  80042074ff:	e9 27 01 00 00       	jmpq   800420762b <env_init+0x13b>
		envs[i].env_id = 0;
  8004207504:	48 b8 50 52 49 04 80 	movabs $0x8004495250,%rax
  800420750b:	00 00 00 
  800420750e:	48 8b 08             	mov    (%rax),%rcx
  8004207511:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004207514:	48 63 d0             	movslq %eax,%rdx
  8004207517:	48 89 d0             	mov    %rdx,%rax
  800420751a:	48 c1 e0 03          	shl    $0x3,%rax
  800420751e:	48 01 d0             	add    %rdx,%rax
  8004207521:	48 c1 e0 05          	shl    $0x5,%rax
  8004207525:	48 01 c8             	add    %rcx,%rax
  8004207528:	c7 80 c8 00 00 00 00 	movl   $0x0,0xc8(%rax)
  800420752f:	00 00 00 
		envs[i].env_parent_id = 0;
  8004207532:	48 b8 50 52 49 04 80 	movabs $0x8004495250,%rax
  8004207539:	00 00 00 
  800420753c:	48 8b 08             	mov    (%rax),%rcx
  800420753f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004207542:	48 63 d0             	movslq %eax,%rdx
  8004207545:	48 89 d0             	mov    %rdx,%rax
  8004207548:	48 c1 e0 03          	shl    $0x3,%rax
  800420754c:	48 01 d0             	add    %rdx,%rax
  800420754f:	48 c1 e0 05          	shl    $0x5,%rax
  8004207553:	48 01 c8             	add    %rcx,%rax
  8004207556:	c7 80 cc 00 00 00 00 	movl   $0x0,0xcc(%rax)
  800420755d:	00 00 00 
		envs[i].env_status = ENV_FREE;
  8004207560:	48 b8 50 52 49 04 80 	movabs $0x8004495250,%rax
  8004207567:	00 00 00 
  800420756a:	48 8b 08             	mov    (%rax),%rcx
  800420756d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004207570:	48 63 d0             	movslq %eax,%rdx
  8004207573:	48 89 d0             	mov    %rdx,%rax
  8004207576:	48 c1 e0 03          	shl    $0x3,%rax
  800420757a:	48 01 d0             	add    %rdx,%rax
  800420757d:	48 c1 e0 05          	shl    $0x5,%rax
  8004207581:	48 01 c8             	add    %rcx,%rax
  8004207584:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  800420758b:	00 00 00 
		envs[i].env_link = env_free_list;
  800420758e:	48 b8 50 52 49 04 80 	movabs $0x8004495250,%rax
  8004207595:	00 00 00 
  8004207598:	48 8b 08             	mov    (%rax),%rcx
  800420759b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420759e:	48 63 d0             	movslq %eax,%rdx
  80042075a1:	48 89 d0             	mov    %rdx,%rax
  80042075a4:	48 c1 e0 03          	shl    $0x3,%rax
  80042075a8:	48 01 d0             	add    %rdx,%rax
  80042075ab:	48 c1 e0 05          	shl    $0x5,%rax
  80042075af:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042075b3:	48 b8 58 52 49 04 80 	movabs $0x8004495258,%rax
  80042075ba:	00 00 00 
  80042075bd:	48 8b 00             	mov    (%rax),%rax
  80042075c0:	48 89 82 c0 00 00 00 	mov    %rax,0xc0(%rdx)
		envs[i].env_runs = 0;
  80042075c7:	48 b8 50 52 49 04 80 	movabs $0x8004495250,%rax
  80042075ce:	00 00 00 
  80042075d1:	48 8b 08             	mov    (%rax),%rcx
  80042075d4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042075d7:	48 63 d0             	movslq %eax,%rdx
  80042075da:	48 89 d0             	mov    %rdx,%rax
  80042075dd:	48 c1 e0 03          	shl    $0x3,%rax
  80042075e1:	48 01 d0             	add    %rdx,%rax
  80042075e4:	48 c1 e0 05          	shl    $0x5,%rax
  80042075e8:	48 01 c8             	add    %rcx,%rax
  80042075eb:	c7 80 d8 00 00 00 00 	movl   $0x0,0xd8(%rax)
  80042075f2:	00 00 00 
		env_free_list = &envs[i];
  80042075f5:	48 b8 50 52 49 04 80 	movabs $0x8004495250,%rax
  80042075fc:	00 00 00 
  80042075ff:	48 8b 08             	mov    (%rax),%rcx
  8004207602:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004207605:	48 63 d0             	movslq %eax,%rdx
  8004207608:	48 89 d0             	mov    %rdx,%rax
  800420760b:	48 c1 e0 03          	shl    $0x3,%rax
  800420760f:	48 01 d0             	add    %rdx,%rax
  8004207612:	48 c1 e0 05          	shl    $0x5,%rax
  8004207616:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800420761a:	48 b8 58 52 49 04 80 	movabs $0x8004495258,%rax
  8004207621:	00 00 00 
  8004207624:	48 89 10             	mov    %rdx,(%rax)
env_init(void)
{
	// Set up envs array
	// LAB 3: Your code here.
	int i;
	for (i = NENV - 1; i >= 0; i--) {
  8004207627:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
  800420762b:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420762f:	0f 89 cf fe ff ff    	jns    8004207504 <env_init+0x14>
		envs[i].env_runs = 0;
		env_free_list = &envs[i];
	}

	// Per-CPU part of the initialization
	env_init_percpu();
  8004207635:	48 b8 43 76 20 04 80 	movabs $0x8004207643,%rax
  800420763c:	00 00 00 
  800420763f:	ff d0                	callq  *%rax
}
  8004207641:	c9                   	leaveq 
  8004207642:	c3                   	retq   

0000008004207643 <env_init_percpu>:

// Load GDT and segment descriptors.
void
env_init_percpu(void)
{
  8004207643:	55                   	push   %rbp
  8004207644:	48 89 e5             	mov    %rsp,%rbp
  8004207647:	53                   	push   %rbx
  8004207648:	48 83 ec 10          	sub    $0x10,%rsp
  800420764c:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  8004207653:	00 00 00 
  8004207656:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
}

static __inline void
lgdt(void *p)
{
	__asm __volatile("lgdt (%0)" : : "r" (p));
  800420765a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420765e:	0f 01 10             	lgdt   (%rax)
	lgdt(&gdt_pd);

// The kernel never uses GS or FS, so we leave those set to
// the user data segment.
	asm volatile("movw %%ax,%%gs" :: "a" (GD_UD|3));
  8004207661:	b8 23 00 00 00       	mov    $0x23,%eax
  8004207666:	8e e8                	mov    %eax,%gs
	asm volatile("movw %%ax,%%fs" :: "a" (GD_UD|3));
  8004207668:	b8 23 00 00 00       	mov    $0x23,%eax
  800420766d:	8e e0                	mov    %eax,%fs
// The kernel does use ES, DS, and SS.  We'll change between
// the kernel and user data segments as needed.
	asm volatile("movw %%ax,%%es" :: "a" (GD_KD));
  800420766f:	b8 10 00 00 00       	mov    $0x10,%eax
  8004207674:	8e c0                	mov    %eax,%es
	asm volatile("movw %%ax,%%ds" :: "a" (GD_KD));
  8004207676:	b8 10 00 00 00       	mov    $0x10,%eax
  800420767b:	8e d8                	mov    %eax,%ds
	asm volatile("movw %%ax,%%ss" :: "a" (GD_KD));
  800420767d:	b8 10 00 00 00       	mov    $0x10,%eax
  8004207682:	8e d0                	mov    %eax,%ss
// Load the kernel text segment into CS.
	asm volatile("pushq %%rbx \n \t movabs $1f,%%rax \n \t pushq %%rax \n\t lretq \n 1:\n" :: "b" (GD_KT):"cc","memory");
  8004207684:	b8 08 00 00 00       	mov    $0x8,%eax
  8004207689:	89 c3                	mov    %eax,%ebx
  800420768b:	53                   	push   %rbx
  800420768c:	48 b8 99 76 20 04 80 	movabs $0x8004207699,%rax
  8004207693:	00 00 00 
  8004207696:	50                   	push   %rax
  8004207697:	48 cb                	lretq  
  8004207699:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
}

static __inline void
lldt(uint16_t sel)
{
	__asm __volatile("lldt %0" : : "r" (sel));
  800420769f:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80042076a3:	0f 00 d0             	lldt   %ax
// For good measure, clear the local descriptor table (LDT),
// since we don't use it.
	lldt(0);
}
  80042076a6:	48 83 c4 10          	add    $0x10,%rsp
  80042076aa:	5b                   	pop    %rbx
  80042076ab:	5d                   	pop    %rbp
  80042076ac:	c3                   	retq   

00000080042076ad <env_setup_vm>:
// Returns 0 on success, < 0 on error.  Errors include:
//	-E_NO_MEM if page directory or table could not be allocated.
//
static int
env_setup_vm(struct Env *e)
{
  80042076ad:	55                   	push   %rbp
  80042076ae:	48 89 e5             	mov    %rsp,%rbp
  80042076b1:	48 83 ec 20          	sub    $0x20,%rsp
  80042076b5:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int r;
	int i;
	struct PageInfo *p = NULL;
  80042076b9:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  80042076c0:	00 

	// Allocate a page for the page directory
	if (!(p = page_alloc(0)))
  80042076c1:	bf 00 00 00 00       	mov    $0x0,%edi
  80042076c6:	48 b8 72 2b 20 04 80 	movabs $0x8004202b72,%rax
  80042076cd:	00 00 00 
  80042076d0:	ff d0                	callq  *%rax
  80042076d2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042076d6:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80042076db:	75 0a                	jne    80042076e7 <env_setup_vm+0x3a>
		return -E_NO_MEM;
  80042076dd:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80042076e2:	e9 c3 00 00 00       	jmpq   80042077aa <env_setup_vm+0xfd>
	//	is an exception -- you need to increment env_pml4e's
	//	pp_ref for env_free to work correctly.
	//    - The functions in kern/pmap.h are handy.

	// LAB 3: Your code here.
	p->pp_ref++;
  80042076e7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042076eb:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042076ef:	8d 50 01             	lea    0x1(%rax),%edx
  80042076f2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042076f6:	66 89 50 08          	mov    %dx,0x8(%rax)
	e->env_pml4e = page2kva(p);
  80042076fa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042076fe:	48 89 c7             	mov    %rax,%rdi
  8004207701:	48 b8 dd 72 20 04 80 	movabs $0x80042072dd,%rax
  8004207708:	00 00 00 
  800420770b:	ff d0                	callq  *%rax
  800420770d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004207711:	48 89 82 e0 00 00 00 	mov    %rax,0xe0(%rdx)
	e->env_cr3 = page2pa(p);
  8004207718:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420771c:	48 89 c7             	mov    %rax,%rdi
  800420771f:	48 b8 47 72 20 04 80 	movabs $0x8004207247,%rax
  8004207726:	00 00 00 
  8004207729:	ff d0                	callq  *%rax
  800420772b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420772f:	48 89 82 e8 00 00 00 	mov    %rax,0xe8(%rdx)

	for (i = PML4(UTOP); i < NPMLENTRIES; i++)
  8004207736:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)
  800420773d:	eb 3c                	jmp    800420777b <env_setup_vm+0xce>
		e->env_pml4e[i] = boot_pml4e[i];
  800420773f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207743:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420774a:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420774d:	48 63 d2             	movslq %edx,%rdx
  8004207750:	48 c1 e2 03          	shl    $0x3,%rdx
  8004207754:	48 01 c2             	add    %rax,%rdx
  8004207757:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  800420775e:	00 00 00 
  8004207761:	48 8b 00             	mov    (%rax),%rax
  8004207764:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004207767:	48 63 c9             	movslq %ecx,%rcx
  800420776a:	48 c1 e1 03          	shl    $0x3,%rcx
  800420776e:	48 01 c8             	add    %rcx,%rax
  8004207771:	48 8b 00             	mov    (%rax),%rax
  8004207774:	48 89 02             	mov    %rax,(%rdx)
	// LAB 3: Your code here.
	p->pp_ref++;
	e->env_pml4e = page2kva(p);
	e->env_cr3 = page2pa(p);

	for (i = PML4(UTOP); i < NPMLENTRIES; i++)
  8004207777:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420777b:	81 7d fc ff 01 00 00 	cmpl   $0x1ff,-0x4(%rbp)
  8004207782:	7e bb                	jle    800420773f <env_setup_vm+0x92>
		e->env_pml4e[i] = boot_pml4e[i];

	// UVPT maps the env's own page table read-only.
	// Permissions: kernel R, user R
	e->env_pml4e[PML4(UVPT)] = e->env_cr3 | PTE_P | PTE_U;
  8004207784:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207788:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420778f:	48 8d 50 10          	lea    0x10(%rax),%rdx
  8004207793:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207797:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  800420779e:	48 83 c8 05          	or     $0x5,%rax
  80042077a2:	48 89 02             	mov    %rax,(%rdx)

	return 0;
  80042077a5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042077aa:	c9                   	leaveq 
  80042077ab:	c3                   	retq   

00000080042077ac <env_alloc>:
//	-E_NO_FREE_ENV if all NENVS environments are allocated
//	-E_NO_MEM on memory exhaustion
//
int
env_alloc(struct Env **newenv_store, envid_t parent_id)
{
  80042077ac:	55                   	push   %rbp
  80042077ad:	48 89 e5             	mov    %rsp,%rbp
  80042077b0:	53                   	push   %rbx
  80042077b1:	48 83 ec 38          	sub    $0x38,%rsp
  80042077b5:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80042077b9:	89 75 c4             	mov    %esi,-0x3c(%rbp)
	int32_t generation;
	int r;
	struct Env *e;

	if (!(e = env_free_list))
  80042077bc:	48 b8 58 52 49 04 80 	movabs $0x8004495258,%rax
  80042077c3:	00 00 00 
  80042077c6:	48 8b 00             	mov    (%rax),%rax
  80042077c9:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042077cd:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042077d2:	75 0a                	jne    80042077de <env_alloc+0x32>
		return -E_NO_FREE_ENV;
  80042077d4:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  80042077d9:	e9 13 02 00 00       	jmpq   80042079f1 <env_alloc+0x245>

	// Allocate and set up the page directory for this environment.
	if ((r = env_setup_vm(e)) < 0)
  80042077de:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042077e2:	48 89 c7             	mov    %rax,%rdi
  80042077e5:	48 b8 ad 76 20 04 80 	movabs $0x80042076ad,%rax
  80042077ec:	00 00 00 
  80042077ef:	ff d0                	callq  *%rax
  80042077f1:	89 45 dc             	mov    %eax,-0x24(%rbp)
  80042077f4:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  80042077f8:	79 08                	jns    8004207802 <env_alloc+0x56>
		return r;
  80042077fa:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80042077fd:	e9 ef 01 00 00       	jmpq   80042079f1 <env_alloc+0x245>

	// Generate an env_id for this environment.
	generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NENV - 1);
  8004207802:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207806:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420780c:	05 00 10 00 00       	add    $0x1000,%eax
  8004207811:	25 00 fc ff ff       	and    $0xfffffc00,%eax
  8004207816:	89 45 ec             	mov    %eax,-0x14(%rbp)
	if (generation <= 0)	// Don't create a negative env_id.
  8004207819:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420781d:	7f 07                	jg     8004207826 <env_alloc+0x7a>
		generation = 1 << ENVGENSHIFT;
  800420781f:	c7 45 ec 00 10 00 00 	movl   $0x1000,-0x14(%rbp)
	e->env_id = generation | (e - envs);
  8004207826:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420782a:	48 b8 50 52 49 04 80 	movabs $0x8004495250,%rax
  8004207831:	00 00 00 
  8004207834:	48 8b 00             	mov    (%rax),%rax
  8004207837:	48 29 c2             	sub    %rax,%rdx
  800420783a:	48 89 d0             	mov    %rdx,%rax
  800420783d:	48 c1 f8 05          	sar    $0x5,%rax
  8004207841:	48 89 c2             	mov    %rax,%rdx
  8004207844:	48 b8 39 8e e3 38 8e 	movabs $0x8e38e38e38e38e39,%rax
  800420784b:	e3 38 8e 
  800420784e:	48 0f af c2          	imul   %rdx,%rax
  8004207852:	0b 45 ec             	or     -0x14(%rbp),%eax
  8004207855:	89 c2                	mov    %eax,%edx
  8004207857:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420785b:	89 90 c8 00 00 00    	mov    %edx,0xc8(%rax)

	// Set the basic status variables.
	e->env_parent_id = parent_id;
  8004207861:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207865:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004207868:	89 90 cc 00 00 00    	mov    %edx,0xcc(%rax)
	e->env_type = ENV_TYPE_USER;
  800420786e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207872:	c7 80 d0 00 00 00 00 	movl   $0x0,0xd0(%rax)
  8004207879:	00 00 00 
	e->env_status = ENV_RUNNABLE;
  800420787c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207880:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  8004207887:	00 00 00 
	e->env_runs = 0;
  800420788a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420788e:	c7 80 d8 00 00 00 00 	movl   $0x0,0xd8(%rax)
  8004207895:	00 00 00 

	// Clear out all the saved register state,
	// to prevent the register values
	// of a prior environment inhabiting this Env structure
	// from "leaking" into our new environment.
	memset(&e->env_tf, 0, sizeof(e->env_tf));
  8004207898:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420789c:	ba c0 00 00 00       	mov    $0xc0,%edx
  80042078a1:	be 00 00 00 00       	mov    $0x0,%esi
  80042078a6:	48 89 c7             	mov    %rax,%rdi
  80042078a9:	48 b8 db e8 20 04 80 	movabs $0x800420e8db,%rax
  80042078b0:	00 00 00 
  80042078b3:	ff d0                	callq  *%rax
	// The low 2 bits of each segment register contains the
	// Requestor Privilege Level (RPL); 3 means user mode.  When
	// we switch privilege levels, the hardware does various
	// checks involving the RPL and the Descriptor Privilege Level
	// (DPL) stored in the descriptors themselves.
	e->env_tf.tf_ds = GD_UD | 3;
  80042078b5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042078b9:	66 c7 80 80 00 00 00 	movw   $0x23,0x80(%rax)
  80042078c0:	23 00 
	e->env_tf.tf_es = GD_UD | 3;
  80042078c2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042078c6:	66 c7 40 78 23 00    	movw   $0x23,0x78(%rax)
	e->env_tf.tf_ss = GD_UD | 3;
  80042078cc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042078d0:	66 c7 80 b8 00 00 00 	movw   $0x23,0xb8(%rax)
  80042078d7:	23 00 
	e->env_tf.tf_rsp = USTACKTOP;
  80042078d9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042078dd:	bb 00 e0 7f ef       	mov    $0xef7fe000,%ebx
  80042078e2:	48 89 98 b0 00 00 00 	mov    %rbx,0xb0(%rax)
	e->env_tf.tf_cs = GD_UT | 3;
  80042078e9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042078ed:	66 c7 80 a0 00 00 00 	movw   $0x1b,0xa0(%rax)
  80042078f4:	1b 00 
	// You will set e->env_tf.tf_rip later.

	// Enable interrupts while in user mode.
	// LAB 4: Your code here.
	e->env_tf.tf_eflags |= FL_IF;
  80042078f6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042078fa:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  8004207901:	80 cc 02             	or     $0x2,%ah
  8004207904:	48 89 c2             	mov    %rax,%rdx
  8004207907:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420790b:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)

	// Clear the page fault handler until user installs one.
	e->env_pgfault_upcall = 0;
  8004207912:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207916:	48 c7 80 f0 00 00 00 	movq   $0x0,0xf0(%rax)
  800420791d:	00 00 00 00 

	// Also clear the IPC receiving flag.
	e->env_ipc_recving = 0;
  8004207921:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207925:	c6 80 f8 00 00 00 00 	movb   $0x0,0xf8(%rax)

	// commit the allocation
	env_free_list = e->env_link;
  800420792c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207930:	48 8b 90 c0 00 00 00 	mov    0xc0(%rax),%rdx
  8004207937:	48 b8 58 52 49 04 80 	movabs $0x8004495258,%rax
  800420793e:	00 00 00 
  8004207941:	48 89 10             	mov    %rdx,(%rax)
	*newenv_store = e;
  8004207944:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207948:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420794c:	48 89 10             	mov    %rdx,(%rax)

	cprintf("[%08x] new env %08x\n", curenv ? curenv->env_id : 0, e->env_id);
  800420794f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207953:	8b 98 c8 00 00 00    	mov    0xc8(%rax),%ebx
  8004207959:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  8004207960:	00 00 00 
  8004207963:	ff d0                	callq  *%rax
  8004207965:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  800420796c:	00 00 00 
  800420796f:	48 98                	cltq   
  8004207971:	48 c1 e0 03          	shl    $0x3,%rax
  8004207975:	48 89 c2             	mov    %rax,%rdx
  8004207978:	48 c1 e2 04          	shl    $0x4,%rdx
  800420797c:	48 29 c2             	sub    %rax,%rdx
  800420797f:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004207983:	48 83 c0 08          	add    $0x8,%rax
  8004207987:	48 8b 00             	mov    (%rax),%rax
  800420798a:	48 85 c0             	test   %rax,%rax
  800420798d:	74 39                	je     80042079c8 <env_alloc+0x21c>
  800420798f:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  8004207996:	00 00 00 
  8004207999:	ff d0                	callq  *%rax
  800420799b:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  80042079a2:	00 00 00 
  80042079a5:	48 98                	cltq   
  80042079a7:	48 c1 e0 03          	shl    $0x3,%rax
  80042079ab:	48 89 c2             	mov    %rax,%rdx
  80042079ae:	48 c1 e2 04          	shl    $0x4,%rdx
  80042079b2:	48 29 c2             	sub    %rax,%rdx
  80042079b5:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042079b9:	48 83 c0 08          	add    $0x8,%rax
  80042079bd:	48 8b 00             	mov    (%rax),%rax
  80042079c0:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  80042079c6:	eb 05                	jmp    80042079cd <env_alloc+0x221>
  80042079c8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042079cd:	89 da                	mov    %ebx,%edx
  80042079cf:	89 c6                	mov    %eax,%esi
  80042079d1:	48 bf cb 70 21 04 80 	movabs $0x80042170cb,%rdi
  80042079d8:	00 00 00 
  80042079db:	b8 00 00 00 00       	mov    $0x0,%eax
  80042079e0:	48 b9 7a 8a 20 04 80 	movabs $0x8004208a7a,%rcx
  80042079e7:	00 00 00 
  80042079ea:	ff d1                	callq  *%rcx
	return 0;
  80042079ec:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042079f1:	48 83 c4 38          	add    $0x38,%rsp
  80042079f5:	5b                   	pop    %rbx
  80042079f6:	5d                   	pop    %rbp
  80042079f7:	c3                   	retq   

00000080042079f8 <region_alloc>:
// Pages should be writable by user and kernel.
// Panic if any allocation attempt fails.
//
static void
region_alloc(struct Env *e, void *va, size_t len)
{
  80042079f8:	55                   	push   %rbp
  80042079f9:	48 89 e5             	mov    %rsp,%rbp
  80042079fc:	48 83 ec 50          	sub    $0x50,%rsp
  8004207a00:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004207a04:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004207a08:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
	//   You should round va down, and round (va + len) up.
	//   (Watch out for corner-cases!)
	void *bva;
	struct PageInfo *pp;

	for (bva = ROUNDDOWN(va, PGSIZE); bva < ROUNDUP(va + len, PGSIZE); bva += PGSIZE) {
  8004207a0c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004207a10:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004207a14:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207a18:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004207a1e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004207a22:	e9 c2 00 00 00       	jmpq   8004207ae9 <region_alloc+0xf1>
		if ((pp = page_alloc(0)) == NULL)
  8004207a27:	bf 00 00 00 00       	mov    $0x0,%edi
  8004207a2c:	48 b8 72 2b 20 04 80 	movabs $0x8004202b72,%rax
  8004207a33:	00 00 00 
  8004207a36:	ff d0                	callq  *%rax
  8004207a38:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004207a3c:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004207a41:	75 30                	jne    8004207a73 <region_alloc+0x7b>
			panic("region_alloc: %e", -E_NO_MEM);
  8004207a43:	b9 fc ff ff ff       	mov    $0xfffffffc,%ecx
  8004207a48:	48 ba e0 70 21 04 80 	movabs $0x80042170e0,%rdx
  8004207a4f:	00 00 00 
  8004207a52:	be 36 01 00 00       	mov    $0x136,%esi
  8004207a57:	48 bf f1 70 21 04 80 	movabs $0x80042170f1,%rdi
  8004207a5e:	00 00 00 
  8004207a61:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207a66:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004207a6d:	00 00 00 
  8004207a70:	41 ff d0             	callq  *%r8
		pp->pp_ref++;
  8004207a73:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207a77:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004207a7b:	8d 50 01             	lea    0x1(%rax),%edx
  8004207a7e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207a82:	66 89 50 08          	mov    %dx,0x8(%rax)
		if (page_insert(e->env_pml4e, pp, bva, PTE_W | PTE_U))
  8004207a86:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207a8a:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004207a91:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004207a95:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  8004207a99:	b9 06 00 00 00       	mov    $0x6,%ecx
  8004207a9e:	48 89 c7             	mov    %rax,%rdi
  8004207aa1:	48 b8 d1 32 20 04 80 	movabs $0x80042032d1,%rax
  8004207aa8:	00 00 00 
  8004207aab:	ff d0                	callq  *%rax
  8004207aad:	85 c0                	test   %eax,%eax
  8004207aaf:	74 30                	je     8004207ae1 <region_alloc+0xe9>
			panic("region_alloc: %e", -E_NO_MEM);
  8004207ab1:	b9 fc ff ff ff       	mov    $0xfffffffc,%ecx
  8004207ab6:	48 ba e0 70 21 04 80 	movabs $0x80042170e0,%rdx
  8004207abd:	00 00 00 
  8004207ac0:	be 39 01 00 00       	mov    $0x139,%esi
  8004207ac5:	48 bf f1 70 21 04 80 	movabs $0x80042170f1,%rdi
  8004207acc:	00 00 00 
  8004207acf:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207ad4:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004207adb:	00 00 00 
  8004207ade:	41 ff d0             	callq  *%r8
	//   You should round va down, and round (va + len) up.
	//   (Watch out for corner-cases!)
	void *bva;
	struct PageInfo *pp;

	for (bva = ROUNDDOWN(va, PGSIZE); bva < ROUNDUP(va + len, PGSIZE); bva += PGSIZE) {
  8004207ae1:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004207ae8:	00 
  8004207ae9:	48 c7 45 e8 00 10 00 	movq   $0x1000,-0x18(%rbp)
  8004207af0:	00 
  8004207af1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004207af5:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004207af9:	48 01 d0             	add    %rdx,%rax
  8004207afc:	48 89 c2             	mov    %rax,%rdx
  8004207aff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207b03:	48 01 d0             	add    %rdx,%rax
  8004207b06:	48 83 e8 01          	sub    $0x1,%rax
  8004207b0a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004207b0e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207b12:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207b17:	48 f7 75 e8          	divq   -0x18(%rbp)
  8004207b1b:	48 89 d0             	mov    %rdx,%rax
  8004207b1e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004207b22:	48 29 c2             	sub    %rax,%rdx
  8004207b25:	48 89 d0             	mov    %rdx,%rax
  8004207b28:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004207b2c:	0f 87 f5 fe ff ff    	ja     8004207a27 <region_alloc+0x2f>
			panic("region_alloc: %e", -E_NO_MEM);
		pp->pp_ref++;
		if (page_insert(e->env_pml4e, pp, bva, PTE_W | PTE_U))
			panic("region_alloc: %e", -E_NO_MEM);
	}
}
  8004207b32:	c9                   	leaveq 
  8004207b33:	c3                   	retq   

0000008004207b34 <load_icode>:
// load_icode panics if it encounters problems.
//  - How might load_icode fail?  What might be wrong with the given input?
//
void
load_icode(struct Env *e, uint8_t *binary)
{
  8004207b34:	55                   	push   %rbp
  8004207b35:	48 89 e5             	mov    %rsp,%rbp
  8004207b38:	53                   	push   %rbx
  8004207b39:	48 83 ec 38          	sub    $0x38,%rsp
  8004207b3d:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004207b41:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
	// at virtual address USTACKTOP - PGSIZE.
	int i;
	struct Proghdr *ph;
	struct Elf *elf;

	elf = (struct Elf *)binary;
  8004207b45:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004207b49:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if (elf->e_magic != ELF_MAGIC)
  8004207b4d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207b51:	8b 00                	mov    (%rax),%eax
  8004207b53:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
  8004207b58:	74 2a                	je     8004207b84 <load_icode+0x50>
		panic("load_icode: invalid elf\n");
  8004207b5a:	48 ba fc 70 21 04 80 	movabs $0x80042170fc,%rdx
  8004207b61:	00 00 00 
  8004207b64:	be 7b 01 00 00       	mov    $0x17b,%esi
  8004207b69:	48 bf f1 70 21 04 80 	movabs $0x80042170f1,%rdi
  8004207b70:	00 00 00 
  8004207b73:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207b78:	48 b9 ae 04 20 04 80 	movabs $0x80042004ae,%rcx
  8004207b7f:	00 00 00 
  8004207b82:	ff d1                	callq  *%rcx

	lcr3(e->env_cr3);
  8004207b84:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207b88:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004207b8f:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  8004207b93:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207b97:	0f 22 d8             	mov    %rax,%cr3

	ph = (struct Proghdr *)(binary + elf->e_phoff);
  8004207b9a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207b9e:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004207ba2:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004207ba6:	48 01 d0             	add    %rdx,%rax
  8004207ba9:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	for (i = 0; i < elf->e_phnum; i++) {
  8004207bad:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004207bb4:	e9 90 01 00 00       	jmpq   8004207d49 <load_icode+0x215>
		if (ph[i].p_memsz >= ph[i].p_filesz && ph[i].p_type == ELF_PROG_LOAD) {
  8004207bb9:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004207bbc:	48 98                	cltq   
  8004207bbe:	48 c1 e0 03          	shl    $0x3,%rax
  8004207bc2:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004207bc9:	00 
  8004207bca:	48 29 c2             	sub    %rax,%rdx
  8004207bcd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207bd1:	48 01 d0             	add    %rdx,%rax
  8004207bd4:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004207bd8:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004207bdb:	48 98                	cltq   
  8004207bdd:	48 c1 e0 03          	shl    $0x3,%rax
  8004207be1:	48 8d 0c c5 00 00 00 	lea    0x0(,%rax,8),%rcx
  8004207be8:	00 
  8004207be9:	48 29 c1             	sub    %rax,%rcx
  8004207bec:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207bf0:	48 01 c8             	add    %rcx,%rax
  8004207bf3:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004207bf7:	48 39 c2             	cmp    %rax,%rdx
  8004207bfa:	0f 82 45 01 00 00    	jb     8004207d45 <load_icode+0x211>
  8004207c00:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004207c03:	48 98                	cltq   
  8004207c05:	48 c1 e0 03          	shl    $0x3,%rax
  8004207c09:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004207c10:	00 
  8004207c11:	48 29 c2             	sub    %rax,%rdx
  8004207c14:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207c18:	48 01 d0             	add    %rdx,%rax
  8004207c1b:	8b 00                	mov    (%rax),%eax
  8004207c1d:	83 f8 01             	cmp    $0x1,%eax
  8004207c20:	0f 85 1f 01 00 00    	jne    8004207d45 <load_icode+0x211>
			region_alloc(e, (void *)ph[i].p_va, ph[i].p_memsz);
  8004207c26:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004207c29:	48 98                	cltq   
  8004207c2b:	48 c1 e0 03          	shl    $0x3,%rax
  8004207c2f:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004207c36:	00 
  8004207c37:	48 29 c2             	sub    %rax,%rdx
  8004207c3a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207c3e:	48 01 d0             	add    %rdx,%rax
  8004207c41:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004207c45:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004207c48:	48 98                	cltq   
  8004207c4a:	48 c1 e0 03          	shl    $0x3,%rax
  8004207c4e:	48 8d 0c c5 00 00 00 	lea    0x0(,%rax,8),%rcx
  8004207c55:	00 
  8004207c56:	48 29 c1             	sub    %rax,%rcx
  8004207c59:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207c5d:	48 01 c8             	add    %rcx,%rax
  8004207c60:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004207c64:	48 89 c1             	mov    %rax,%rcx
  8004207c67:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207c6b:	48 89 ce             	mov    %rcx,%rsi
  8004207c6e:	48 89 c7             	mov    %rax,%rdi
  8004207c71:	48 b8 f8 79 20 04 80 	movabs $0x80042079f8,%rax
  8004207c78:	00 00 00 
  8004207c7b:	ff d0                	callq  *%rax
			memset((void *)ph[i].p_va, 0, ph[i].p_memsz);
  8004207c7d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004207c80:	48 98                	cltq   
  8004207c82:	48 c1 e0 03          	shl    $0x3,%rax
  8004207c86:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004207c8d:	00 
  8004207c8e:	48 29 c2             	sub    %rax,%rdx
  8004207c91:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207c95:	48 01 d0             	add    %rdx,%rax
  8004207c98:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004207c9c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004207c9f:	48 98                	cltq   
  8004207ca1:	48 c1 e0 03          	shl    $0x3,%rax
  8004207ca5:	48 8d 0c c5 00 00 00 	lea    0x0(,%rax,8),%rcx
  8004207cac:	00 
  8004207cad:	48 29 c1             	sub    %rax,%rcx
  8004207cb0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207cb4:	48 01 c8             	add    %rcx,%rax
  8004207cb7:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004207cbb:	be 00 00 00 00       	mov    $0x0,%esi
  8004207cc0:	48 89 c7             	mov    %rax,%rdi
  8004207cc3:	48 b8 db e8 20 04 80 	movabs $0x800420e8db,%rax
  8004207cca:	00 00 00 
  8004207ccd:	ff d0                	callq  *%rax
			memcpy((void *)ph[i].p_va, binary + ph[i].p_offset, ph[i].p_filesz);
  8004207ccf:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004207cd2:	48 98                	cltq   
  8004207cd4:	48 c1 e0 03          	shl    $0x3,%rax
  8004207cd8:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004207cdf:	00 
  8004207ce0:	48 29 c2             	sub    %rax,%rdx
  8004207ce3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207ce7:	48 01 d0             	add    %rdx,%rax
  8004207cea:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004207cee:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004207cf1:	48 98                	cltq   
  8004207cf3:	48 c1 e0 03          	shl    $0x3,%rax
  8004207cf7:	48 8d 0c c5 00 00 00 	lea    0x0(,%rax,8),%rcx
  8004207cfe:	00 
  8004207cff:	48 29 c1             	sub    %rax,%rcx
  8004207d02:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207d06:	48 01 c8             	add    %rcx,%rax
  8004207d09:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004207d0d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004207d11:	48 01 c1             	add    %rax,%rcx
  8004207d14:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004207d17:	48 98                	cltq   
  8004207d19:	48 c1 e0 03          	shl    $0x3,%rax
  8004207d1d:	48 8d 34 c5 00 00 00 	lea    0x0(,%rax,8),%rsi
  8004207d24:	00 
  8004207d25:	48 29 c6             	sub    %rax,%rsi
  8004207d28:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207d2c:	48 01 f0             	add    %rsi,%rax
  8004207d2f:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004207d33:	48 89 ce             	mov    %rcx,%rsi
  8004207d36:	48 89 c7             	mov    %rax,%rdi
  8004207d39:	48 b8 7d ea 20 04 80 	movabs $0x800420ea7d,%rax
  8004207d40:	00 00 00 
  8004207d43:	ff d0                	callq  *%rax
		panic("load_icode: invalid elf\n");

	lcr3(e->env_cr3);

	ph = (struct Proghdr *)(binary + elf->e_phoff);
	for (i = 0; i < elf->e_phnum; i++) {
  8004207d45:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004207d49:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207d4d:	0f b7 40 38          	movzwl 0x38(%rax),%eax
  8004207d51:	0f b7 c0             	movzwl %ax,%eax
  8004207d54:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004207d57:	0f 8f 5c fe ff ff    	jg     8004207bb9 <load_icode+0x85>
			memcpy((void *)ph[i].p_va, binary + ph[i].p_offset, ph[i].p_filesz);
		}
	}

	// LAB 3: Your code here.
	e->elf = binary;
  8004207d5d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207d61:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004207d65:	48 89 90 18 01 00 00 	mov    %rdx,0x118(%rax)
	e->env_tf.tf_rip = elf->e_entry;
  8004207d6c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207d70:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004207d74:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207d78:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
	e->env_tf.tf_rsp = USTACKTOP;
  8004207d7f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207d83:	bb 00 e0 7f ef       	mov    $0xef7fe000,%ebx
  8004207d88:	48 89 98 b0 00 00 00 	mov    %rbx,0xb0(%rax)
	region_alloc(e, (void *)(USTACKTOP - PGSIZE), PGSIZE);
  8004207d8f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207d93:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004207d98:	be 00 d0 7f ef       	mov    $0xef7fd000,%esi
  8004207d9d:	48 89 c7             	mov    %rax,%rdi
  8004207da0:	48 b8 f8 79 20 04 80 	movabs $0x80042079f8,%rax
  8004207da7:	00 00 00 
  8004207daa:	ff d0                	callq  *%rax
}
  8004207dac:	48 83 c4 38          	add    $0x38,%rsp
  8004207db0:	5b                   	pop    %rbx
  8004207db1:	5d                   	pop    %rbp
  8004207db2:	c3                   	retq   

0000008004207db3 <env_create>:
// before running the first user-mode environment.
// The new env's parent ID is set to 0.
//
void
env_create(uint8_t *binary, enum EnvType type)
{
  8004207db3:	55                   	push   %rbp
  8004207db4:	48 89 e5             	mov    %rsp,%rbp
  8004207db7:	48 83 ec 20          	sub    $0x20,%rsp
  8004207dbb:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004207dbf:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	// LAB 3: Your code here.
	struct Env *e;
	env_alloc(&e, 0);
  8004207dc2:	48 8d 45 f8          	lea    -0x8(%rbp),%rax
  8004207dc6:	be 00 00 00 00       	mov    $0x0,%esi
  8004207dcb:	48 89 c7             	mov    %rax,%rdi
  8004207dce:	48 b8 ac 77 20 04 80 	movabs $0x80042077ac,%rax
  8004207dd5:	00 00 00 
  8004207dd8:	ff d0                	callq  *%rax
	load_icode(e, binary);
  8004207dda:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207dde:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004207de2:	48 89 d6             	mov    %rdx,%rsi
  8004207de5:	48 89 c7             	mov    %rax,%rdi
  8004207de8:	48 b8 34 7b 20 04 80 	movabs $0x8004207b34,%rax
  8004207def:	00 00 00 
  8004207df2:	ff d0                	callq  *%rax
	e->env_type = type;
  8004207df4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207df8:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004207dfb:	89 90 d0 00 00 00    	mov    %edx,0xd0(%rax)

	// If this is the file server (type == ENV_TYPE_FS) give it I/O privileges.
	// LAB 5: Your code here.
	if (e->env_type == ENV_TYPE_FS)
  8004207e01:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207e05:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  8004207e0b:	83 f8 01             	cmp    $0x1,%eax
  8004207e0e:	75 19                	jne    8004207e29 <env_create+0x76>
		e->env_tf.tf_eflags |= FL_IOPL_MASK;
  8004207e10:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207e14:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004207e18:	48 8b 92 a8 00 00 00 	mov    0xa8(%rdx),%rdx
  8004207e1f:	80 ce 30             	or     $0x30,%dh
  8004207e22:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)
}
  8004207e29:	c9                   	leaveq 
  8004207e2a:	c3                   	retq   

0000008004207e2b <env_free>:
//
// Frees env e and all memory it uses.
//
void
env_free(struct Env *e)
{
  8004207e2b:	55                   	push   %rbp
  8004207e2c:	48 89 e5             	mov    %rsp,%rbp
  8004207e2f:	53                   	push   %rbx
  8004207e30:	48 81 ec 98 00 00 00 	sub    $0x98,%rsp
  8004207e37:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
	physaddr_t pa;

	// If freeing the current environment, switch to kern_pgdir
	// before freeing the page directory, just in case the page
	// gets reused.
	if (e == curenv)
  8004207e3e:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  8004207e45:	00 00 00 
  8004207e48:	ff d0                	callq  *%rax
  8004207e4a:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  8004207e51:	00 00 00 
  8004207e54:	48 98                	cltq   
  8004207e56:	48 c1 e0 03          	shl    $0x3,%rax
  8004207e5a:	48 89 c2             	mov    %rax,%rdx
  8004207e5d:	48 c1 e2 04          	shl    $0x4,%rdx
  8004207e61:	48 29 c2             	sub    %rax,%rdx
  8004207e64:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004207e68:	48 83 c0 08          	add    $0x8,%rax
  8004207e6c:	48 8b 00             	mov    (%rax),%rax
  8004207e6f:	48 3b 85 68 ff ff ff 	cmp    -0x98(%rbp),%rax
  8004207e76:	75 1e                	jne    8004207e96 <env_free+0x6b>
		lcr3(boot_cr3);
  8004207e78:	48 b8 a0 67 49 04 80 	movabs $0x80044967a0,%rax
  8004207e7f:	00 00 00 
  8004207e82:	48 8b 00             	mov    (%rax),%rax
  8004207e85:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  8004207e8c:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004207e93:	0f 22 d8             	mov    %rax,%cr3

	// Note the environment's demise.
	cprintf("[%08x] free env %08x\n", curenv ? curenv->env_id : 0, e->env_id);
  8004207e96:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004207e9d:	8b 98 c8 00 00 00    	mov    0xc8(%rax),%ebx
  8004207ea3:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  8004207eaa:	00 00 00 
  8004207ead:	ff d0                	callq  *%rax
  8004207eaf:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  8004207eb6:	00 00 00 
  8004207eb9:	48 98                	cltq   
  8004207ebb:	48 c1 e0 03          	shl    $0x3,%rax
  8004207ebf:	48 89 c2             	mov    %rax,%rdx
  8004207ec2:	48 c1 e2 04          	shl    $0x4,%rdx
  8004207ec6:	48 29 c2             	sub    %rax,%rdx
  8004207ec9:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004207ecd:	48 83 c0 08          	add    $0x8,%rax
  8004207ed1:	48 8b 00             	mov    (%rax),%rax
  8004207ed4:	48 85 c0             	test   %rax,%rax
  8004207ed7:	74 39                	je     8004207f12 <env_free+0xe7>
  8004207ed9:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  8004207ee0:	00 00 00 
  8004207ee3:	ff d0                	callq  *%rax
  8004207ee5:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  8004207eec:	00 00 00 
  8004207eef:	48 98                	cltq   
  8004207ef1:	48 c1 e0 03          	shl    $0x3,%rax
  8004207ef5:	48 89 c2             	mov    %rax,%rdx
  8004207ef8:	48 c1 e2 04          	shl    $0x4,%rdx
  8004207efc:	48 29 c2             	sub    %rax,%rdx
  8004207eff:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004207f03:	48 83 c0 08          	add    $0x8,%rax
  8004207f07:	48 8b 00             	mov    (%rax),%rax
  8004207f0a:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004207f10:	eb 05                	jmp    8004207f17 <env_free+0xec>
  8004207f12:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207f17:	89 da                	mov    %ebx,%edx
  8004207f19:	89 c6                	mov    %eax,%esi
  8004207f1b:	48 bf 15 71 21 04 80 	movabs $0x8004217115,%rdi
  8004207f22:	00 00 00 
  8004207f25:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207f2a:	48 b9 7a 8a 20 04 80 	movabs $0x8004208a7a,%rcx
  8004207f31:	00 00 00 
  8004207f34:	ff d1                	callq  *%rcx

	// Flush all mapped pages in the user portion of the address space
	pdpe_t *env_pdpe = KADDR(PTE_ADDR(e->env_pml4e[0]));
  8004207f36:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004207f3d:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004207f44:	48 8b 00             	mov    (%rax),%rax
  8004207f47:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004207f4d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004207f51:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207f55:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207f59:	89 45 cc             	mov    %eax,-0x34(%rbp)
  8004207f5c:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004207f5f:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  8004207f66:	00 00 00 
  8004207f69:	48 8b 00             	mov    (%rax),%rax
  8004207f6c:	48 39 c2             	cmp    %rax,%rdx
  8004207f6f:	72 32                	jb     8004207fa3 <env_free+0x178>
  8004207f71:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207f75:	48 89 c1             	mov    %rax,%rcx
  8004207f78:	48 ba a8 70 21 04 80 	movabs $0x80042170a8,%rdx
  8004207f7f:	00 00 00 
  8004207f82:	be b9 01 00 00       	mov    $0x1b9,%esi
  8004207f87:	48 bf f1 70 21 04 80 	movabs $0x80042170f1,%rdi
  8004207f8e:	00 00 00 
  8004207f91:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207f96:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004207f9d:	00 00 00 
  8004207fa0:	41 ff d0             	callq  *%r8
  8004207fa3:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207faa:	00 00 00 
  8004207fad:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207fb1:	48 01 d0             	add    %rdx,%rax
  8004207fb4:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
	int pdeno_limit;
	uint64_t pdpe_index;
	// using 3 instead of NPDPENTRIES as we have only first three indices
	// set for 4GB of address space.
	for (pdpe_index = 0; pdpe_index <= 3; pdpe_index++){
  8004207fb8:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  8004207fbf:	00 
  8004207fc0:	e9 ab 02 00 00       	jmpq   8004208270 <env_free+0x445>
		if (!(env_pdpe[pdpe_index] & PTE_P))
  8004207fc5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207fc9:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004207fd0:	00 
  8004207fd1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004207fd5:	48 01 d0             	add    %rdx,%rax
  8004207fd8:	48 8b 00             	mov    (%rax),%rax
  8004207fdb:	83 e0 01             	and    $0x1,%eax
  8004207fde:	48 85 c0             	test   %rax,%rax
  8004207fe1:	75 05                	jne    8004207fe8 <env_free+0x1bd>
			continue;
  8004207fe3:	e9 83 02 00 00       	jmpq   800420826b <env_free+0x440>
		pde_t *env_pgdir = KADDR(PTE_ADDR(env_pdpe[pdpe_index]));
  8004207fe8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207fec:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004207ff3:	00 
  8004207ff4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004207ff8:	48 01 d0             	add    %rdx,%rax
  8004207ffb:	48 8b 00             	mov    (%rax),%rax
  8004207ffe:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208004:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  8004208008:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420800c:	48 c1 e8 0c          	shr    $0xc,%rax
  8004208010:	89 45 b4             	mov    %eax,-0x4c(%rbp)
  8004208013:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  8004208016:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  800420801d:	00 00 00 
  8004208020:	48 8b 00             	mov    (%rax),%rax
  8004208023:	48 39 c2             	cmp    %rax,%rdx
  8004208026:	72 32                	jb     800420805a <env_free+0x22f>
  8004208028:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420802c:	48 89 c1             	mov    %rax,%rcx
  800420802f:	48 ba a8 70 21 04 80 	movabs $0x80042170a8,%rdx
  8004208036:	00 00 00 
  8004208039:	be c1 01 00 00       	mov    $0x1c1,%esi
  800420803e:	48 bf f1 70 21 04 80 	movabs $0x80042170f1,%rdi
  8004208045:	00 00 00 
  8004208048:	b8 00 00 00 00       	mov    $0x0,%eax
  800420804d:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004208054:	00 00 00 
  8004208057:	41 ff d0             	callq  *%r8
  800420805a:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004208061:	00 00 00 
  8004208064:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004208068:	48 01 d0             	add    %rdx,%rax
  800420806b:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
		pdeno_limit  = pdpe_index==3?PDX(UTOP):PDX(0xFFFFFFFF);
  800420806f:	48 83 7d d8 03       	cmpq   $0x3,-0x28(%rbp)
  8004208074:	75 07                	jne    800420807d <env_free+0x252>
  8004208076:	b8 04 00 00 00       	mov    $0x4,%eax
  800420807b:	eb 05                	jmp    8004208082 <env_free+0x257>
  800420807d:	b8 ff 01 00 00       	mov    $0x1ff,%eax
  8004208082:	89 45 a4             	mov    %eax,-0x5c(%rbp)
		static_assert(UTOP % PTSIZE == 0);
		for (pdeno = 0; pdeno < pdeno_limit; pdeno++) {
  8004208085:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  800420808c:	00 
  800420808d:	e9 6e 01 00 00       	jmpq   8004208200 <env_free+0x3d5>

			// only look at mapped page tables
			if (!(env_pgdir[pdeno] & PTE_P))
  8004208092:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208096:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420809d:	00 
  800420809e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042080a2:	48 01 d0             	add    %rdx,%rax
  80042080a5:	48 8b 00             	mov    (%rax),%rax
  80042080a8:	83 e0 01             	and    $0x1,%eax
  80042080ab:	48 85 c0             	test   %rax,%rax
  80042080ae:	75 05                	jne    80042080b5 <env_free+0x28a>
				continue;
  80042080b0:	e9 46 01 00 00       	jmpq   80042081fb <env_free+0x3d0>
			// find the pa and va of the page table
			pa = PTE_ADDR(env_pgdir[pdeno]);
  80042080b5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042080b9:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042080c0:	00 
  80042080c1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042080c5:	48 01 d0             	add    %rdx,%rax
  80042080c8:	48 8b 00             	mov    (%rax),%rax
  80042080cb:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042080d1:	48 89 45 98          	mov    %rax,-0x68(%rbp)
			pt = (pte_t*) KADDR(pa);
  80042080d5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042080d9:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  80042080dd:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042080e1:	48 c1 e8 0c          	shr    $0xc,%rax
  80042080e5:	89 45 8c             	mov    %eax,-0x74(%rbp)
  80042080e8:	8b 55 8c             	mov    -0x74(%rbp),%edx
  80042080eb:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  80042080f2:	00 00 00 
  80042080f5:	48 8b 00             	mov    (%rax),%rax
  80042080f8:	48 39 c2             	cmp    %rax,%rdx
  80042080fb:	72 32                	jb     800420812f <env_free+0x304>
  80042080fd:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004208101:	48 89 c1             	mov    %rax,%rcx
  8004208104:	48 ba a8 70 21 04 80 	movabs $0x80042170a8,%rdx
  800420810b:	00 00 00 
  800420810e:	be cb 01 00 00       	mov    $0x1cb,%esi
  8004208113:	48 bf f1 70 21 04 80 	movabs $0x80042170f1,%rdi
  800420811a:	00 00 00 
  800420811d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208122:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004208129:	00 00 00 
  800420812c:	41 ff d0             	callq  *%r8
  800420812f:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004208136:	00 00 00 
  8004208139:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420813d:	48 01 d0             	add    %rdx,%rax
  8004208140:	48 89 45 80          	mov    %rax,-0x80(%rbp)

			// unmap all PTEs in this page table
			for (pteno = 0; pteno < PTX(~0); pteno++) {
  8004208144:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  800420814b:	00 
  800420814c:	eb 67                	jmp    80042081b5 <env_free+0x38a>
				if (pt[pteno] & PTE_P){
  800420814e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208152:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208159:	00 
  800420815a:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800420815e:	48 01 d0             	add    %rdx,%rax
  8004208161:	48 8b 00             	mov    (%rax),%rax
  8004208164:	83 e0 01             	and    $0x1,%eax
  8004208167:	48 85 c0             	test   %rax,%rax
  800420816a:	74 44                	je     80042081b0 <env_free+0x385>
					page_remove(e->env_pml4e, PGADDR((uint64_t)0,pdpe_index,pdeno, pteno, 0));
  800420816c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004208170:	48 c1 e0 1e          	shl    $0x1e,%rax
  8004208174:	48 89 c2             	mov    %rax,%rdx
  8004208177:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420817b:	48 c1 e0 15          	shl    $0x15,%rax
  800420817f:	48 09 c2             	or     %rax,%rdx
  8004208182:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208186:	48 c1 e0 0c          	shl    $0xc,%rax
  800420818a:	48 09 d0             	or     %rdx,%rax
  800420818d:	48 89 c2             	mov    %rax,%rdx
  8004208190:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004208197:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420819e:	48 89 d6             	mov    %rdx,%rsi
  80042081a1:	48 89 c7             	mov    %rax,%rdi
  80042081a4:	48 b8 8f 34 20 04 80 	movabs $0x800420348f,%rax
  80042081ab:	00 00 00 
  80042081ae:	ff d0                	callq  *%rax
			// find the pa and va of the page table
			pa = PTE_ADDR(env_pgdir[pdeno]);
			pt = (pte_t*) KADDR(pa);

			// unmap all PTEs in this page table
			for (pteno = 0; pteno < PTX(~0); pteno++) {
  80042081b0:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
  80042081b5:	48 81 7d e0 fe 01 00 	cmpq   $0x1fe,-0x20(%rbp)
  80042081bc:	00 
  80042081bd:	76 8f                	jbe    800420814e <env_free+0x323>
					page_remove(e->env_pml4e, PGADDR((uint64_t)0,pdpe_index,pdeno, pteno, 0));
				}
			}

			// free the page table itself
			env_pgdir[pdeno] = 0;
  80042081bf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042081c3:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042081ca:	00 
  80042081cb:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042081cf:	48 01 d0             	add    %rdx,%rax
  80042081d2:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			page_decref(pa2page(pa));
  80042081d9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042081dd:	48 89 c7             	mov    %rax,%rdi
  80042081e0:	48 b8 6c 72 20 04 80 	movabs $0x800420726c,%rax
  80042081e7:	00 00 00 
  80042081ea:	ff d0                	callq  *%rax
  80042081ec:	48 89 c7             	mov    %rax,%rdi
  80042081ef:	48 b8 8e 2c 20 04 80 	movabs $0x8004202c8e,%rax
  80042081f6:	00 00 00 
  80042081f9:	ff d0                	callq  *%rax
		if (!(env_pdpe[pdpe_index] & PTE_P))
			continue;
		pde_t *env_pgdir = KADDR(PTE_ADDR(env_pdpe[pdpe_index]));
		pdeno_limit  = pdpe_index==3?PDX(UTOP):PDX(0xFFFFFFFF);
		static_assert(UTOP % PTSIZE == 0);
		for (pdeno = 0; pdeno < pdeno_limit; pdeno++) {
  80042081fb:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  8004208200:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  8004208203:	48 98                	cltq   
  8004208205:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004208209:	0f 87 83 fe ff ff    	ja     8004208092 <env_free+0x267>
			// free the page table itself
			env_pgdir[pdeno] = 0;
			page_decref(pa2page(pa));
		}
		// free the page directory
		pa = PTE_ADDR(env_pdpe[pdpe_index]);
  800420820f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004208213:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420821a:	00 
  800420821b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420821f:	48 01 d0             	add    %rdx,%rax
  8004208222:	48 8b 00             	mov    (%rax),%rax
  8004208225:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420822b:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		env_pdpe[pdpe_index] = 0;
  800420822f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004208233:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420823a:	00 
  800420823b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420823f:	48 01 d0             	add    %rdx,%rax
  8004208242:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		page_decref(pa2page(pa));
  8004208249:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420824d:	48 89 c7             	mov    %rax,%rdi
  8004208250:	48 b8 6c 72 20 04 80 	movabs $0x800420726c,%rax
  8004208257:	00 00 00 
  800420825a:	ff d0                	callq  *%rax
  800420825c:	48 89 c7             	mov    %rax,%rdi
  800420825f:	48 b8 8e 2c 20 04 80 	movabs $0x8004202c8e,%rax
  8004208266:	00 00 00 
  8004208269:	ff d0                	callq  *%rax
	pdpe_t *env_pdpe = KADDR(PTE_ADDR(e->env_pml4e[0]));
	int pdeno_limit;
	uint64_t pdpe_index;
	// using 3 instead of NPDPENTRIES as we have only first three indices
	// set for 4GB of address space.
	for (pdpe_index = 0; pdpe_index <= 3; pdpe_index++){
  800420826b:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  8004208270:	48 83 7d d8 03       	cmpq   $0x3,-0x28(%rbp)
  8004208275:	0f 86 4a fd ff ff    	jbe    8004207fc5 <env_free+0x19a>
		pa = PTE_ADDR(env_pdpe[pdpe_index]);
		env_pdpe[pdpe_index] = 0;
		page_decref(pa2page(pa));
	}
	// free the page directory pointer
	page_decref(pa2page(PTE_ADDR(e->env_pml4e[0])));
  800420827b:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004208282:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208289:	48 8b 00             	mov    (%rax),%rax
  800420828c:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208292:	48 89 c7             	mov    %rax,%rdi
  8004208295:	48 b8 6c 72 20 04 80 	movabs $0x800420726c,%rax
  800420829c:	00 00 00 
  800420829f:	ff d0                	callq  *%rax
  80042082a1:	48 89 c7             	mov    %rax,%rdi
  80042082a4:	48 b8 8e 2c 20 04 80 	movabs $0x8004202c8e,%rax
  80042082ab:	00 00 00 
  80042082ae:	ff d0                	callq  *%rax
	// free the page map level 4 (PML4)
	e->env_pml4e[0] = 0;
  80042082b0:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042082b7:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042082be:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	pa = e->env_cr3;
  80042082c5:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042082cc:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  80042082d3:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	e->env_pml4e = 0;
  80042082d7:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042082de:	48 c7 80 e0 00 00 00 	movq   $0x0,0xe0(%rax)
  80042082e5:	00 00 00 00 
	e->env_cr3 = 0;
  80042082e9:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042082f0:	48 c7 80 e8 00 00 00 	movq   $0x0,0xe8(%rax)
  80042082f7:	00 00 00 00 
	page_decref(pa2page(pa));
  80042082fb:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042082ff:	48 89 c7             	mov    %rax,%rdi
  8004208302:	48 b8 6c 72 20 04 80 	movabs $0x800420726c,%rax
  8004208309:	00 00 00 
  800420830c:	ff d0                	callq  *%rax
  800420830e:	48 89 c7             	mov    %rax,%rdi
  8004208311:	48 b8 8e 2c 20 04 80 	movabs $0x8004202c8e,%rax
  8004208318:	00 00 00 
  800420831b:	ff d0                	callq  *%rax

	// return the environment to the free list
	e->env_status = ENV_FREE;
  800420831d:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004208324:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  800420832b:	00 00 00 
	e->env_link = env_free_list;
  800420832e:	48 b8 58 52 49 04 80 	movabs $0x8004495258,%rax
  8004208335:	00 00 00 
  8004208338:	48 8b 10             	mov    (%rax),%rdx
  800420833b:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004208342:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
	env_free_list = e;
  8004208349:	48 b8 58 52 49 04 80 	movabs $0x8004495258,%rax
  8004208350:	00 00 00 
  8004208353:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
  800420835a:	48 89 10             	mov    %rdx,(%rax)
}
  800420835d:	48 81 c4 98 00 00 00 	add    $0x98,%rsp
  8004208364:	5b                   	pop    %rbx
  8004208365:	5d                   	pop    %rbp
  8004208366:	c3                   	retq   

0000008004208367 <env_destroy>:
// If e was the current env, then runs a new environment (and does not return
// to the caller).
//
void
env_destroy(struct Env *e)
{
  8004208367:	55                   	push   %rbp
  8004208368:	48 89 e5             	mov    %rsp,%rbp
  800420836b:	48 83 ec 10          	sub    $0x10,%rsp
  800420836f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// If e is currently running on other CPUs, we change its state to
	// ENV_DYING. A zombie environment will be freed the next time
	// it traps to the kernel.
	if (e->env_status == ENV_RUNNING && curenv != e) {
  8004208373:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208377:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420837d:	83 f8 03             	cmp    $0x3,%eax
  8004208380:	75 4a                	jne    80042083cc <env_destroy+0x65>
  8004208382:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  8004208389:	00 00 00 
  800420838c:	ff d0                	callq  *%rax
  800420838e:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  8004208395:	00 00 00 
  8004208398:	48 98                	cltq   
  800420839a:	48 c1 e0 03          	shl    $0x3,%rax
  800420839e:	48 89 c2             	mov    %rax,%rdx
  80042083a1:	48 c1 e2 04          	shl    $0x4,%rdx
  80042083a5:	48 29 c2             	sub    %rax,%rdx
  80042083a8:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042083ac:	48 83 c0 08          	add    $0x8,%rax
  80042083b0:	48 8b 00             	mov    (%rax),%rax
  80042083b3:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042083b7:	74 13                	je     80042083cc <env_destroy+0x65>
		e->env_status = ENV_DYING;
  80042083b9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042083bd:	c7 80 d4 00 00 00 01 	movl   $0x1,0xd4(%rax)
  80042083c4:	00 00 00 
		return;
  80042083c7:	e9 8b 00 00 00       	jmpq   8004208457 <env_destroy+0xf0>
	}

	env_free(e);
  80042083cc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042083d0:	48 89 c7             	mov    %rax,%rdi
  80042083d3:	48 b8 2b 7e 20 04 80 	movabs $0x8004207e2b,%rax
  80042083da:	00 00 00 
  80042083dd:	ff d0                	callq  *%rax

	if (curenv == e) {
  80042083df:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  80042083e6:	00 00 00 
  80042083e9:	ff d0                	callq  *%rax
  80042083eb:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  80042083f2:	00 00 00 
  80042083f5:	48 98                	cltq   
  80042083f7:	48 c1 e0 03          	shl    $0x3,%rax
  80042083fb:	48 89 c2             	mov    %rax,%rdx
  80042083fe:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208402:	48 29 c2             	sub    %rax,%rdx
  8004208405:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208409:	48 83 c0 08          	add    $0x8,%rax
  800420840d:	48 8b 00             	mov    (%rax),%rax
  8004208410:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004208414:	75 41                	jne    8004208457 <env_destroy+0xf0>
		curenv = NULL;
  8004208416:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420841d:	00 00 00 
  8004208420:	ff d0                	callq  *%rax
  8004208422:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  8004208429:	00 00 00 
  800420842c:	48 98                	cltq   
  800420842e:	48 c1 e0 03          	shl    $0x3,%rax
  8004208432:	48 89 c2             	mov    %rax,%rdx
  8004208435:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208439:	48 29 c2             	sub    %rax,%rdx
  800420843c:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208440:	48 83 c0 08          	add    $0x8,%rax
  8004208444:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		sched_yield();
  800420844b:	48 b8 fe ba 20 04 80 	movabs $0x800420bafe,%rax
  8004208452:	00 00 00 
  8004208455:	ff d0                	callq  *%rax
	}
}
  8004208457:	c9                   	leaveq 
  8004208458:	c3                   	retq   

0000008004208459 <env_pop_tf>:
//
// This function does not return.
//
void
env_pop_tf(struct Trapframe *tf)
{
  8004208459:	55                   	push   %rbp
  800420845a:	48 89 e5             	mov    %rsp,%rbp
  800420845d:	53                   	push   %rbx
  800420845e:	48 83 ec 18          	sub    $0x18,%rsp
  8004208462:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	// Record the CPU we are running on for user-space debugging
	curenv->env_cpunum = cpunum();
  8004208466:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420846d:	00 00 00 
  8004208470:	ff d0                	callq  *%rax
  8004208472:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  8004208479:	00 00 00 
  800420847c:	48 98                	cltq   
  800420847e:	48 c1 e0 03          	shl    $0x3,%rax
  8004208482:	48 89 c2             	mov    %rax,%rdx
  8004208485:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208489:	48 29 c2             	sub    %rax,%rdx
  800420848c:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208490:	48 83 c0 08          	add    $0x8,%rax
  8004208494:	48 8b 18             	mov    (%rax),%rbx
  8004208497:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420849e:	00 00 00 
  80042084a1:	ff d0                	callq  *%rax
  80042084a3:	89 83 dc 00 00 00    	mov    %eax,0xdc(%rbx)

	__asm __volatile("movq %0,%%rsp\n"
  80042084a9:	48 8b 65 e8          	mov    -0x18(%rbp),%rsp
  80042084ad:	4c 8b 3c 24          	mov    (%rsp),%r15
  80042084b1:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  80042084b6:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  80042084bb:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12
  80042084c0:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
  80042084c5:	4c 8b 54 24 28       	mov    0x28(%rsp),%r10
  80042084ca:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
  80042084cf:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
  80042084d4:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  80042084d9:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
  80042084de:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
  80042084e3:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  80042084e8:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  80042084ed:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
  80042084f2:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  80042084f7:	48 83 c4 78          	add    $0x78,%rsp
  80042084fb:	8e 04 24             	mov    (%rsp),%es
  80042084fe:	8e 5c 24 08          	mov    0x8(%rsp),%ds
  8004208502:	48 83 c4 10          	add    $0x10,%rsp
  8004208506:	48 83 c4 10          	add    $0x10,%rsp
  800420850a:	48 cf                	iretq  
			 "movw 8(%%rsp),%%ds\n"
			 "addq $16,%%rsp\n"
			 "\taddq $16,%%rsp\n" /* skip tf_trapno and tf_errcode */
			 "\tiretq"
			 : : "g" (tf) : "memory");
	panic("iret failed");  /* mostly to placate the compiler */
  800420850c:	48 ba 2b 71 21 04 80 	movabs $0x800421712b,%rdx
  8004208513:	00 00 00 
  8004208516:	be 19 02 00 00       	mov    $0x219,%esi
  800420851b:	48 bf f1 70 21 04 80 	movabs $0x80042170f1,%rdi
  8004208522:	00 00 00 
  8004208525:	b8 00 00 00 00       	mov    $0x0,%eax
  800420852a:	48 b9 ae 04 20 04 80 	movabs $0x80042004ae,%rcx
  8004208531:	00 00 00 
  8004208534:	ff d1                	callq  *%rcx

0000008004208536 <env_run>:
//
// This function does not return.
//
void
env_run(struct Env *e)
{
  8004208536:	55                   	push   %rbp
  8004208537:	48 89 e5             	mov    %rsp,%rbp
  800420853a:	48 83 ec 20          	sub    $0x20,%rsp
  800420853e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	//	e->env_tf.  Go back through the code you wrote above
	//	and make sure you have set the relevant parts of
	//	e->env_tf to sensible values.

	// LAB 3: Your code here.
	if (curenv && curenv->env_status == ENV_RUNNING)
  8004208542:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  8004208549:	00 00 00 
  800420854c:	ff d0                	callq  *%rax
  800420854e:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  8004208555:	00 00 00 
  8004208558:	48 98                	cltq   
  800420855a:	48 c1 e0 03          	shl    $0x3,%rax
  800420855e:	48 89 c2             	mov    %rax,%rdx
  8004208561:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208565:	48 29 c2             	sub    %rax,%rdx
  8004208568:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420856c:	48 83 c0 08          	add    $0x8,%rax
  8004208570:	48 8b 00             	mov    (%rax),%rax
  8004208573:	48 85 c0             	test   %rax,%rax
  8004208576:	74 77                	je     80042085ef <env_run+0xb9>
  8004208578:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420857f:	00 00 00 
  8004208582:	ff d0                	callq  *%rax
  8004208584:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  800420858b:	00 00 00 
  800420858e:	48 98                	cltq   
  8004208590:	48 c1 e0 03          	shl    $0x3,%rax
  8004208594:	48 89 c2             	mov    %rax,%rdx
  8004208597:	48 c1 e2 04          	shl    $0x4,%rdx
  800420859b:	48 29 c2             	sub    %rax,%rdx
  800420859e:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042085a2:	48 83 c0 08          	add    $0x8,%rax
  80042085a6:	48 8b 00             	mov    (%rax),%rax
  80042085a9:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  80042085af:	83 f8 03             	cmp    $0x3,%eax
  80042085b2:	75 3b                	jne    80042085ef <env_run+0xb9>
		curenv->env_status = ENV_RUNNABLE;
  80042085b4:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  80042085bb:	00 00 00 
  80042085be:	ff d0                	callq  *%rax
  80042085c0:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  80042085c7:	00 00 00 
  80042085ca:	48 98                	cltq   
  80042085cc:	48 c1 e0 03          	shl    $0x3,%rax
  80042085d0:	48 89 c2             	mov    %rax,%rdx
  80042085d3:	48 c1 e2 04          	shl    $0x4,%rdx
  80042085d7:	48 29 c2             	sub    %rax,%rdx
  80042085da:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042085de:	48 83 c0 08          	add    $0x8,%rax
  80042085e2:	48 8b 00             	mov    (%rax),%rax
  80042085e5:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  80042085ec:	00 00 00 

	curenv = e;
  80042085ef:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  80042085f6:	00 00 00 
  80042085f9:	ff d0                	callq  *%rax
  80042085fb:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  8004208602:	00 00 00 
  8004208605:	48 98                	cltq   
  8004208607:	48 c1 e0 03          	shl    $0x3,%rax
  800420860b:	48 89 c2             	mov    %rax,%rdx
  800420860e:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208612:	48 29 c2             	sub    %rax,%rdx
  8004208615:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208619:	48 8d 50 08          	lea    0x8(%rax),%rdx
  800420861d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208621:	48 89 02             	mov    %rax,(%rdx)
	curenv->env_status = ENV_RUNNING;
  8004208624:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420862b:	00 00 00 
  800420862e:	ff d0                	callq  *%rax
  8004208630:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  8004208637:	00 00 00 
  800420863a:	48 98                	cltq   
  800420863c:	48 c1 e0 03          	shl    $0x3,%rax
  8004208640:	48 89 c2             	mov    %rax,%rdx
  8004208643:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208647:	48 29 c2             	sub    %rax,%rdx
  800420864a:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420864e:	48 83 c0 08          	add    $0x8,%rax
  8004208652:	48 8b 00             	mov    (%rax),%rax
  8004208655:	c7 80 d4 00 00 00 03 	movl   $0x3,0xd4(%rax)
  800420865c:	00 00 00 
	curenv->env_runs++;
  800420865f:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  8004208666:	00 00 00 
  8004208669:	ff d0                	callq  *%rax
  800420866b:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  8004208672:	00 00 00 
  8004208675:	48 98                	cltq   
  8004208677:	48 c1 e0 03          	shl    $0x3,%rax
  800420867b:	48 89 c2             	mov    %rax,%rdx
  800420867e:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208682:	48 29 c2             	sub    %rax,%rdx
  8004208685:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208689:	48 83 c0 08          	add    $0x8,%rax
  800420868d:	48 8b 00             	mov    (%rax),%rax
  8004208690:	8b 90 d8 00 00 00    	mov    0xd8(%rax),%edx
  8004208696:	83 c2 01             	add    $0x1,%edx
  8004208699:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)

	lcr3(curenv->env_cr3);
  800420869f:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  80042086a6:	00 00 00 
  80042086a9:	ff d0                	callq  *%rax
  80042086ab:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  80042086b2:	00 00 00 
  80042086b5:	48 98                	cltq   
  80042086b7:	48 c1 e0 03          	shl    $0x3,%rax
  80042086bb:	48 89 c2             	mov    %rax,%rdx
  80042086be:	48 c1 e2 04          	shl    $0x4,%rdx
  80042086c2:	48 29 c2             	sub    %rax,%rdx
  80042086c5:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042086c9:	48 83 c0 08          	add    $0x8,%rax
  80042086cd:	48 8b 00             	mov    (%rax),%rax
  80042086d0:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  80042086d7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042086db:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042086df:	0f 22 d8             	mov    %rax,%cr3

	// note: release lock before switch to user mode in LAB4
	unlock_kernel();
  80042086e2:	48 b8 65 73 20 04 80 	movabs $0x8004207365,%rax
  80042086e9:	00 00 00 
  80042086ec:	ff d0                	callq  *%rax

	env_pop_tf(&curenv->env_tf);
  80042086ee:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  80042086f5:	00 00 00 
  80042086f8:	ff d0                	callq  *%rax
  80042086fa:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  8004208701:	00 00 00 
  8004208704:	48 98                	cltq   
  8004208706:	48 c1 e0 03          	shl    $0x3,%rax
  800420870a:	48 89 c2             	mov    %rax,%rdx
  800420870d:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208711:	48 29 c2             	sub    %rax,%rdx
  8004208714:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208718:	48 83 c0 08          	add    $0x8,%rax
  800420871c:	48 8b 00             	mov    (%rax),%rax
  800420871f:	48 89 c7             	mov    %rax,%rdi
  8004208722:	48 b8 59 84 20 04 80 	movabs $0x8004208459,%rax
  8004208729:	00 00 00 
  800420872c:	ff d0                	callq  *%rax

000000800420872e <mc146818_read>:
#include <kern/kclock.h>


unsigned
mc146818_read(unsigned reg)
{
  800420872e:	55                   	push   %rbp
  800420872f:	48 89 e5             	mov    %rsp,%rbp
  8004208732:	48 83 ec 14          	sub    $0x14,%rsp
  8004208736:	89 7d ec             	mov    %edi,-0x14(%rbp)
	outb(IO_RTC, reg);
  8004208739:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420873c:	0f b6 c0             	movzbl %al,%eax
  800420873f:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%rbp)
  8004208746:	88 45 fb             	mov    %al,-0x5(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004208749:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  800420874d:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004208750:	ee                   	out    %al,(%dx)
  8004208751:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004208758:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420875b:	89 c2                	mov    %eax,%edx
  800420875d:	ec                   	in     (%dx),%al
  800420875e:	88 45 f3             	mov    %al,-0xd(%rbp)
	return data;
  8004208761:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
	return inb(IO_RTC+1);
  8004208765:	0f b6 c0             	movzbl %al,%eax
}
  8004208768:	c9                   	leaveq 
  8004208769:	c3                   	retq   

000000800420876a <mc146818_write>:

void
mc146818_write(unsigned reg, unsigned datum)
{
  800420876a:	55                   	push   %rbp
  800420876b:	48 89 e5             	mov    %rsp,%rbp
  800420876e:	48 83 ec 18          	sub    $0x18,%rsp
  8004208772:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8004208775:	89 75 e8             	mov    %esi,-0x18(%rbp)
	outb(IO_RTC, reg);
  8004208778:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420877b:	0f b6 c0             	movzbl %al,%eax
  800420877e:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%rbp)
  8004208785:	88 45 fb             	mov    %al,-0x5(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004208788:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  800420878c:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420878f:	ee                   	out    %al,(%dx)
	outb(IO_RTC+1, datum);
  8004208790:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004208793:	0f b6 c0             	movzbl %al,%eax
  8004208796:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%rbp)
  800420879d:	88 45 f3             	mov    %al,-0xd(%rbp)
  80042087a0:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  80042087a4:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042087a7:	ee                   	out    %al,(%dx)
}
  80042087a8:	c9                   	leaveq 
  80042087a9:	c3                   	retq   

00000080042087aa <pic_init>:
static bool didinit;

/* Initialize the 8259A interrupt controllers. */
void
pic_init(void)
{
  80042087aa:	55                   	push   %rbp
  80042087ab:	48 89 e5             	mov    %rsp,%rbp
  80042087ae:	48 83 ec 70          	sub    $0x70,%rsp
	didinit = 1;
  80042087b2:	48 b8 60 52 49 04 80 	movabs $0x8004495260,%rax
  80042087b9:	00 00 00 
  80042087bc:	c6 00 01             	movb   $0x1,(%rax)
  80042087bf:	c7 45 fc 21 00 00 00 	movl   $0x21,-0x4(%rbp)
  80042087c6:	c6 45 fb ff          	movb   $0xff,-0x5(%rbp)
  80042087ca:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  80042087ce:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042087d1:	ee                   	out    %al,(%dx)
  80042087d2:	c7 45 f4 a1 00 00 00 	movl   $0xa1,-0xc(%rbp)
  80042087d9:	c6 45 f3 ff          	movb   $0xff,-0xd(%rbp)
  80042087dd:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  80042087e1:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042087e4:	ee                   	out    %al,(%dx)
  80042087e5:	c7 45 ec 20 00 00 00 	movl   $0x20,-0x14(%rbp)
  80042087ec:	c6 45 eb 11          	movb   $0x11,-0x15(%rbp)
  80042087f0:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  80042087f4:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042087f7:	ee                   	out    %al,(%dx)
  80042087f8:	c7 45 e4 21 00 00 00 	movl   $0x21,-0x1c(%rbp)
  80042087ff:	c6 45 e3 20          	movb   $0x20,-0x1d(%rbp)
  8004208803:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004208807:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  800420880a:	ee                   	out    %al,(%dx)
  800420880b:	c7 45 dc 21 00 00 00 	movl   $0x21,-0x24(%rbp)
  8004208812:	c6 45 db 04          	movb   $0x4,-0x25(%rbp)
  8004208816:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  800420881a:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800420881d:	ee                   	out    %al,(%dx)
  800420881e:	c7 45 d4 21 00 00 00 	movl   $0x21,-0x2c(%rbp)
  8004208825:	c6 45 d3 03          	movb   $0x3,-0x2d(%rbp)
  8004208829:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  800420882d:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004208830:	ee                   	out    %al,(%dx)
  8004208831:	c7 45 cc a0 00 00 00 	movl   $0xa0,-0x34(%rbp)
  8004208838:	c6 45 cb 11          	movb   $0x11,-0x35(%rbp)
  800420883c:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  8004208840:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004208843:	ee                   	out    %al,(%dx)
  8004208844:	c7 45 c4 a1 00 00 00 	movl   $0xa1,-0x3c(%rbp)
  800420884b:	c6 45 c3 28          	movb   $0x28,-0x3d(%rbp)
  800420884f:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
  8004208853:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004208856:	ee                   	out    %al,(%dx)
  8004208857:	c7 45 bc a1 00 00 00 	movl   $0xa1,-0x44(%rbp)
  800420885e:	c6 45 bb 02          	movb   $0x2,-0x45(%rbp)
  8004208862:	0f b6 45 bb          	movzbl -0x45(%rbp),%eax
  8004208866:	8b 55 bc             	mov    -0x44(%rbp),%edx
  8004208869:	ee                   	out    %al,(%dx)
  800420886a:	c7 45 b4 a1 00 00 00 	movl   $0xa1,-0x4c(%rbp)
  8004208871:	c6 45 b3 01          	movb   $0x1,-0x4d(%rbp)
  8004208875:	0f b6 45 b3          	movzbl -0x4d(%rbp),%eax
  8004208879:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  800420887c:	ee                   	out    %al,(%dx)
  800420887d:	c7 45 ac 20 00 00 00 	movl   $0x20,-0x54(%rbp)
  8004208884:	c6 45 ab 68          	movb   $0x68,-0x55(%rbp)
  8004208888:	0f b6 45 ab          	movzbl -0x55(%rbp),%eax
  800420888c:	8b 55 ac             	mov    -0x54(%rbp),%edx
  800420888f:	ee                   	out    %al,(%dx)
  8004208890:	c7 45 a4 20 00 00 00 	movl   $0x20,-0x5c(%rbp)
  8004208897:	c6 45 a3 0a          	movb   $0xa,-0x5d(%rbp)
  800420889b:	0f b6 45 a3          	movzbl -0x5d(%rbp),%eax
  800420889f:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  80042088a2:	ee                   	out    %al,(%dx)
  80042088a3:	c7 45 9c a0 00 00 00 	movl   $0xa0,-0x64(%rbp)
  80042088aa:	c6 45 9b 68          	movb   $0x68,-0x65(%rbp)
  80042088ae:	0f b6 45 9b          	movzbl -0x65(%rbp),%eax
  80042088b2:	8b 55 9c             	mov    -0x64(%rbp),%edx
  80042088b5:	ee                   	out    %al,(%dx)
  80042088b6:	c7 45 94 a0 00 00 00 	movl   $0xa0,-0x6c(%rbp)
  80042088bd:	c6 45 93 0a          	movb   $0xa,-0x6d(%rbp)
  80042088c1:	0f b6 45 93          	movzbl -0x6d(%rbp),%eax
  80042088c5:	8b 55 94             	mov    -0x6c(%rbp),%edx
  80042088c8:	ee                   	out    %al,(%dx)
	outb(IO_PIC1, 0x0a);             /* read IRR by default */

	outb(IO_PIC2, 0x68);               /* OCW3 */
	outb(IO_PIC2, 0x0a);               /* OCW3 */

	if (irq_mask_8259A != 0xFFFF)
  80042088c9:	48 b8 92 b6 22 04 80 	movabs $0x800422b692,%rax
  80042088d0:	00 00 00 
  80042088d3:	0f b7 00             	movzwl (%rax),%eax
  80042088d6:	66 83 f8 ff          	cmp    $0xffff,%ax
  80042088da:	74 1e                	je     80042088fa <pic_init+0x150>
		irq_setmask_8259A(irq_mask_8259A);
  80042088dc:	48 b8 92 b6 22 04 80 	movabs $0x800422b692,%rax
  80042088e3:	00 00 00 
  80042088e6:	0f b7 00             	movzwl (%rax),%eax
  80042088e9:	0f b7 c0             	movzwl %ax,%eax
  80042088ec:	89 c7                	mov    %eax,%edi
  80042088ee:	48 b8 fc 88 20 04 80 	movabs $0x80042088fc,%rax
  80042088f5:	00 00 00 
  80042088f8:	ff d0                	callq  *%rax
}
  80042088fa:	c9                   	leaveq 
  80042088fb:	c3                   	retq   

00000080042088fc <irq_setmask_8259A>:

void
irq_setmask_8259A(uint16_t mask)
{
  80042088fc:	55                   	push   %rbp
  80042088fd:	48 89 e5             	mov    %rsp,%rbp
  8004208900:	48 83 ec 30          	sub    $0x30,%rsp
  8004208904:	89 f8                	mov    %edi,%eax
  8004208906:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
	int i;
	irq_mask_8259A = mask;
  800420890a:	48 b8 92 b6 22 04 80 	movabs $0x800422b692,%rax
  8004208911:	00 00 00 
  8004208914:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  8004208918:	66 89 10             	mov    %dx,(%rax)
	if (!didinit)
  800420891b:	48 b8 60 52 49 04 80 	movabs $0x8004495260,%rax
  8004208922:	00 00 00 
  8004208925:	0f b6 00             	movzbl (%rax),%eax
  8004208928:	83 f0 01             	xor    $0x1,%eax
  800420892b:	84 c0                	test   %al,%al
  800420892d:	74 05                	je     8004208934 <irq_setmask_8259A+0x38>
		return;
  800420892f:	e9 b7 00 00 00       	jmpq   80042089eb <irq_setmask_8259A+0xef>
	outb(IO_PIC1+1, (char)mask);
  8004208934:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  8004208938:	0f b6 c0             	movzbl %al,%eax
  800420893b:	c7 45 f8 21 00 00 00 	movl   $0x21,-0x8(%rbp)
  8004208942:	88 45 f7             	mov    %al,-0x9(%rbp)
  8004208945:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  8004208949:	8b 55 f8             	mov    -0x8(%rbp),%edx
  800420894c:	ee                   	out    %al,(%dx)
	outb(IO_PIC2+1, (char)(mask >> 8));
  800420894d:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  8004208951:	66 c1 e8 08          	shr    $0x8,%ax
  8004208955:	0f b6 c0             	movzbl %al,%eax
  8004208958:	c7 45 f0 a1 00 00 00 	movl   $0xa1,-0x10(%rbp)
  800420895f:	88 45 ef             	mov    %al,-0x11(%rbp)
  8004208962:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8004208966:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004208969:	ee                   	out    %al,(%dx)
	cprintf("enabled interrupts:");
  800420896a:	48 bf 37 71 21 04 80 	movabs $0x8004217137,%rdi
  8004208971:	00 00 00 
  8004208974:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208979:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  8004208980:	00 00 00 
  8004208983:	ff d2                	callq  *%rdx
	for (i = 0; i < 16; i++)
  8004208985:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420898c:	eb 3c                	jmp    80042089ca <irq_setmask_8259A+0xce>
		if (~mask & (1<<i))
  800420898e:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  8004208992:	f7 d0                	not    %eax
  8004208994:	89 c2                	mov    %eax,%edx
  8004208996:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004208999:	89 c1                	mov    %eax,%ecx
  800420899b:	d3 fa                	sar    %cl,%edx
  800420899d:	89 d0                	mov    %edx,%eax
  800420899f:	83 e0 01             	and    $0x1,%eax
  80042089a2:	85 c0                	test   %eax,%eax
  80042089a4:	74 20                	je     80042089c6 <irq_setmask_8259A+0xca>
			cprintf(" %d", i);
  80042089a6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042089a9:	89 c6                	mov    %eax,%esi
  80042089ab:	48 bf 4b 71 21 04 80 	movabs $0x800421714b,%rdi
  80042089b2:	00 00 00 
  80042089b5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042089ba:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  80042089c1:	00 00 00 
  80042089c4:	ff d2                	callq  *%rdx
	if (!didinit)
		return;
	outb(IO_PIC1+1, (char)mask);
	outb(IO_PIC2+1, (char)(mask >> 8));
	cprintf("enabled interrupts:");
	for (i = 0; i < 16; i++)
  80042089c6:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042089ca:	83 7d fc 0f          	cmpl   $0xf,-0x4(%rbp)
  80042089ce:	7e be                	jle    800420898e <irq_setmask_8259A+0x92>
		if (~mask & (1<<i))
			cprintf(" %d", i);
	cprintf("\n");
  80042089d0:	48 bf 4f 71 21 04 80 	movabs $0x800421714f,%rdi
  80042089d7:	00 00 00 
  80042089da:	b8 00 00 00 00       	mov    $0x0,%eax
  80042089df:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  80042089e6:	00 00 00 
  80042089e9:	ff d2                	callq  *%rdx
}
  80042089eb:	c9                   	leaveq 
  80042089ec:	c3                   	retq   

00000080042089ed <putch>:
#include <inc/stdarg.h>


static void
putch(int ch, int *cnt)
{
  80042089ed:	55                   	push   %rbp
  80042089ee:	48 89 e5             	mov    %rsp,%rbp
  80042089f1:	48 83 ec 10          	sub    $0x10,%rsp
  80042089f5:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80042089f8:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	cputchar(ch);
  80042089fc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042089ff:	89 c7                	mov    %eax,%edi
  8004208a01:	48 b8 ff 11 20 04 80 	movabs $0x80042011ff,%rax
  8004208a08:	00 00 00 
  8004208a0b:	ff d0                	callq  *%rax
	*cnt++;
  8004208a0d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208a11:	48 83 c0 04          	add    $0x4,%rax
  8004208a15:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
}
  8004208a19:	c9                   	leaveq 
  8004208a1a:	c3                   	retq   

0000008004208a1b <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
  8004208a1b:	55                   	push   %rbp
  8004208a1c:	48 89 e5             	mov    %rsp,%rbp
  8004208a1f:	48 83 ec 30          	sub    $0x30,%rsp
  8004208a23:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004208a27:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int cnt = 0;
  8004208a2b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    va_list aq;
    va_copy(aq,ap);
  8004208a32:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004208a36:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004208a3a:	48 8b 0a             	mov    (%rdx),%rcx
  8004208a3d:	48 89 08             	mov    %rcx,(%rax)
  8004208a40:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004208a44:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8004208a48:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8004208a4c:	48 89 50 10          	mov    %rdx,0x10(%rax)
	vprintfmt((void*)putch, &cnt, fmt, aq);
  8004208a50:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  8004208a54:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004208a58:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  8004208a5c:	48 89 c6             	mov    %rax,%rsi
  8004208a5f:	48 bf ed 89 20 04 80 	movabs $0x80042089ed,%rdi
  8004208a66:	00 00 00 
  8004208a69:	48 b8 f8 da 20 04 80 	movabs $0x800420daf8,%rax
  8004208a70:	00 00 00 
  8004208a73:	ff d0                	callq  *%rax
    va_end(aq);
	return cnt;
  8004208a75:	8b 45 fc             	mov    -0x4(%rbp),%eax

}
  8004208a78:	c9                   	leaveq 
  8004208a79:	c3                   	retq   

0000008004208a7a <cprintf>:

int
cprintf(const char *fmt, ...)
{
  8004208a7a:	55                   	push   %rbp
  8004208a7b:	48 89 e5             	mov    %rsp,%rbp
  8004208a7e:	48 81 ec 00 01 00 00 	sub    $0x100,%rsp
  8004208a85:	48 89 b5 58 ff ff ff 	mov    %rsi,-0xa8(%rbp)
  8004208a8c:	48 89 95 60 ff ff ff 	mov    %rdx,-0xa0(%rbp)
  8004208a93:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  8004208a9a:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  8004208aa1:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  8004208aa8:	84 c0                	test   %al,%al
  8004208aaa:	74 20                	je     8004208acc <cprintf+0x52>
  8004208aac:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  8004208ab0:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  8004208ab4:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  8004208ab8:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  8004208abc:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  8004208ac0:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  8004208ac4:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  8004208ac8:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  8004208acc:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
	va_list ap;
	int cnt;
	va_start(ap, fmt);
  8004208ad3:	c7 85 30 ff ff ff 08 	movl   $0x8,-0xd0(%rbp)
  8004208ada:	00 00 00 
  8004208add:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  8004208ae4:	00 00 00 
  8004208ae7:	48 8d 45 10          	lea    0x10(%rbp),%rax
  8004208aeb:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  8004208af2:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004208af9:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
    va_list aq;
    va_copy(aq,ap);
  8004208b00:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  8004208b07:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  8004208b0e:	48 8b 0a             	mov    (%rdx),%rcx
  8004208b11:	48 89 08             	mov    %rcx,(%rax)
  8004208b14:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004208b18:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8004208b1c:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8004208b20:	48 89 50 10          	mov    %rdx,0x10(%rax)
	cnt = vcprintf(fmt, aq);
  8004208b24:	48 8d 95 18 ff ff ff 	lea    -0xe8(%rbp),%rdx
  8004208b2b:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004208b32:	48 89 d6             	mov    %rdx,%rsi
  8004208b35:	48 89 c7             	mov    %rax,%rdi
  8004208b38:	48 b8 1b 8a 20 04 80 	movabs $0x8004208a1b,%rax
  8004208b3f:	00 00 00 
  8004208b42:	ff d0                	callq  *%rax
  8004208b44:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return cnt;
  8004208b4a:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  8004208b50:	c9                   	leaveq 
  8004208b51:	c3                   	retq   

0000008004208b52 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  8004208b52:	55                   	push   %rbp
  8004208b53:	48 89 e5             	mov    %rsp,%rbp
  8004208b56:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004208b5a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004208b5e:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  8004208b61:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004208b65:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004208b68:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004208b6c:	f0 87 02             	lock xchg %eax,(%rdx)
  8004208b6f:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  8004208b72:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004208b75:	c9                   	leaveq 
  8004208b76:	c3                   	retq   

0000008004208b77 <lock_kernel>:

extern struct spinlock kernel_lock;

static inline void
lock_kernel(void)
{
  8004208b77:	55                   	push   %rbp
  8004208b78:	48 89 e5             	mov    %rsp,%rbp
	spin_lock(&kernel_lock);
  8004208b7b:	48 bf 80 b7 22 04 80 	movabs $0x800422b780,%rdi
  8004208b82:	00 00 00 
  8004208b85:	48 b8 18 5b 21 04 80 	movabs $0x8004215b18,%rax
  8004208b8c:	00 00 00 
  8004208b8f:	ff d0                	callq  *%rax
}
  8004208b91:	5d                   	pop    %rbp
  8004208b92:	c3                   	retq   

0000008004208b93 <trapname>:
struct Gatedesc idt[256] = { { 0 } };
struct Pseudodesc idt_pd = {0,0};


static const char *trapname(int trapno)
{
  8004208b93:	55                   	push   %rbp
  8004208b94:	48 89 e5             	mov    %rsp,%rbp
  8004208b97:	48 83 ec 04          	sub    $0x4,%rsp
  8004208b9b:	89 7d fc             	mov    %edi,-0x4(%rbp)
		"Alignment Check",
		"Machine-Check",
		"SIMD Floating-Point Exception"
	};

	if (trapno < sizeof(excnames)/sizeof(excnames[0]))
  8004208b9e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004208ba1:	83 f8 13             	cmp    $0x13,%eax
  8004208ba4:	77 16                	ja     8004208bbc <trapname+0x29>
		return excnames[trapno];
  8004208ba6:	48 b8 80 75 21 04 80 	movabs $0x8004217580,%rax
  8004208bad:	00 00 00 
  8004208bb0:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004208bb3:	48 63 d2             	movslq %edx,%rdx
  8004208bb6:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004208bba:	eb 34                	jmp    8004208bf0 <trapname+0x5d>
	if (trapno == T_SYSCALL)
  8004208bbc:	83 7d fc 30          	cmpl   $0x30,-0x4(%rbp)
  8004208bc0:	75 0c                	jne    8004208bce <trapname+0x3b>
		return "System call";
  8004208bc2:	48 b8 60 71 21 04 80 	movabs $0x8004217160,%rax
  8004208bc9:	00 00 00 
  8004208bcc:	eb 22                	jmp    8004208bf0 <trapname+0x5d>
	if (trapno >= IRQ_OFFSET && trapno < IRQ_OFFSET + 16)
  8004208bce:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  8004208bd2:	7e 12                	jle    8004208be6 <trapname+0x53>
  8004208bd4:	83 7d fc 2f          	cmpl   $0x2f,-0x4(%rbp)
  8004208bd8:	7f 0c                	jg     8004208be6 <trapname+0x53>
		return "Hardware Interrupt";
  8004208bda:	48 b8 6c 71 21 04 80 	movabs $0x800421716c,%rax
  8004208be1:	00 00 00 
  8004208be4:	eb 0a                	jmp    8004208bf0 <trapname+0x5d>
	return "(unknown trap)";
  8004208be6:	48 b8 7f 71 21 04 80 	movabs $0x800421717f,%rax
  8004208bed:	00 00 00 
}
  8004208bf0:	c9                   	leaveq 
  8004208bf1:	c3                   	retq   

0000008004208bf2 <trap_init>:


void
trap_init(void)
{
  8004208bf2:	55                   	push   %rbp
  8004208bf3:	48 89 e5             	mov    %rsp,%rbp
	extern void __trap_mchk();
	extern void __trap_simderr();
	extern void __trap_syscall();

	// set gate descriptors - LAB4 version
	SETGATE(idt[T_DIVIDE], 0, GD_KT, __trap_divide, 0);
  8004208bf6:	48 b8 08 b9 20 04 80 	movabs $0x800420b908,%rax
  8004208bfd:	00 00 00 
  8004208c00:	89 c2                	mov    %eax,%edx
  8004208c02:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208c09:	00 00 00 
  8004208c0c:	66 89 10             	mov    %dx,(%rax)
  8004208c0f:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208c16:	00 00 00 
  8004208c19:	66 c7 40 02 08 00    	movw   $0x8,0x2(%rax)
  8004208c1f:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208c26:	00 00 00 
  8004208c29:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  8004208c2d:	83 e2 f8             	and    $0xfffffff8,%edx
  8004208c30:	88 50 04             	mov    %dl,0x4(%rax)
  8004208c33:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208c3a:	00 00 00 
  8004208c3d:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  8004208c41:	83 e2 07             	and    $0x7,%edx
  8004208c44:	88 50 04             	mov    %dl,0x4(%rax)
  8004208c47:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208c4e:	00 00 00 
  8004208c51:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004208c55:	83 e2 f0             	and    $0xfffffff0,%edx
  8004208c58:	83 ca 0e             	or     $0xe,%edx
  8004208c5b:	88 50 05             	mov    %dl,0x5(%rax)
  8004208c5e:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208c65:	00 00 00 
  8004208c68:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004208c6c:	83 e2 ef             	and    $0xffffffef,%edx
  8004208c6f:	88 50 05             	mov    %dl,0x5(%rax)
  8004208c72:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208c79:	00 00 00 
  8004208c7c:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004208c80:	83 e2 9f             	and    $0xffffff9f,%edx
  8004208c83:	88 50 05             	mov    %dl,0x5(%rax)
  8004208c86:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208c8d:	00 00 00 
  8004208c90:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004208c94:	83 ca 80             	or     $0xffffff80,%edx
  8004208c97:	88 50 05             	mov    %dl,0x5(%rax)
  8004208c9a:	48 b8 08 b9 20 04 80 	movabs $0x800420b908,%rax
  8004208ca1:	00 00 00 
  8004208ca4:	48 c1 e8 10          	shr    $0x10,%rax
  8004208ca8:	89 c2                	mov    %eax,%edx
  8004208caa:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208cb1:	00 00 00 
  8004208cb4:	66 89 50 06          	mov    %dx,0x6(%rax)
  8004208cb8:	48 b8 08 b9 20 04 80 	movabs $0x800420b908,%rax
  8004208cbf:	00 00 00 
  8004208cc2:	48 c1 e8 20          	shr    $0x20,%rax
  8004208cc6:	89 c2                	mov    %eax,%edx
  8004208cc8:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208ccf:	00 00 00 
  8004208cd2:	89 50 08             	mov    %edx,0x8(%rax)
  8004208cd5:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208cdc:	00 00 00 
  8004208cdf:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%rax)
	SETGATE(idt[T_DEBUG], 0, GD_KT, __trap_debug, 0);
  8004208ce6:	48 b8 12 b9 20 04 80 	movabs $0x800420b912,%rax
  8004208ced:	00 00 00 
  8004208cf0:	89 c2                	mov    %eax,%edx
  8004208cf2:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208cf9:	00 00 00 
  8004208cfc:	66 89 50 10          	mov    %dx,0x10(%rax)
  8004208d00:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208d07:	00 00 00 
  8004208d0a:	66 c7 40 12 08 00    	movw   $0x8,0x12(%rax)
  8004208d10:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208d17:	00 00 00 
  8004208d1a:	0f b6 50 14          	movzbl 0x14(%rax),%edx
  8004208d1e:	83 e2 f8             	and    $0xfffffff8,%edx
  8004208d21:	88 50 14             	mov    %dl,0x14(%rax)
  8004208d24:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208d2b:	00 00 00 
  8004208d2e:	0f b6 50 14          	movzbl 0x14(%rax),%edx
  8004208d32:	83 e2 07             	and    $0x7,%edx
  8004208d35:	88 50 14             	mov    %dl,0x14(%rax)
  8004208d38:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208d3f:	00 00 00 
  8004208d42:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  8004208d46:	83 e2 f0             	and    $0xfffffff0,%edx
  8004208d49:	83 ca 0e             	or     $0xe,%edx
  8004208d4c:	88 50 15             	mov    %dl,0x15(%rax)
  8004208d4f:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208d56:	00 00 00 
  8004208d59:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  8004208d5d:	83 e2 ef             	and    $0xffffffef,%edx
  8004208d60:	88 50 15             	mov    %dl,0x15(%rax)
  8004208d63:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208d6a:	00 00 00 
  8004208d6d:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  8004208d71:	83 e2 9f             	and    $0xffffff9f,%edx
  8004208d74:	88 50 15             	mov    %dl,0x15(%rax)
  8004208d77:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208d7e:	00 00 00 
  8004208d81:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  8004208d85:	83 ca 80             	or     $0xffffff80,%edx
  8004208d88:	88 50 15             	mov    %dl,0x15(%rax)
  8004208d8b:	48 b8 12 b9 20 04 80 	movabs $0x800420b912,%rax
  8004208d92:	00 00 00 
  8004208d95:	48 c1 e8 10          	shr    $0x10,%rax
  8004208d99:	89 c2                	mov    %eax,%edx
  8004208d9b:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208da2:	00 00 00 
  8004208da5:	66 89 50 16          	mov    %dx,0x16(%rax)
  8004208da9:	48 b8 12 b9 20 04 80 	movabs $0x800420b912,%rax
  8004208db0:	00 00 00 
  8004208db3:	48 c1 e8 20          	shr    $0x20,%rax
  8004208db7:	89 c2                	mov    %eax,%edx
  8004208db9:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208dc0:	00 00 00 
  8004208dc3:	89 50 18             	mov    %edx,0x18(%rax)
  8004208dc6:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208dcd:	00 00 00 
  8004208dd0:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%rax)
	SETGATE(idt[T_NMI], 0, GD_KT, __trap_nmi, 0);
  8004208dd7:	48 b8 1c b9 20 04 80 	movabs $0x800420b91c,%rax
  8004208dde:	00 00 00 
  8004208de1:	89 c2                	mov    %eax,%edx
  8004208de3:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208dea:	00 00 00 
  8004208ded:	66 89 50 20          	mov    %dx,0x20(%rax)
  8004208df1:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208df8:	00 00 00 
  8004208dfb:	66 c7 40 22 08 00    	movw   $0x8,0x22(%rax)
  8004208e01:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208e08:	00 00 00 
  8004208e0b:	0f b6 50 24          	movzbl 0x24(%rax),%edx
  8004208e0f:	83 e2 f8             	and    $0xfffffff8,%edx
  8004208e12:	88 50 24             	mov    %dl,0x24(%rax)
  8004208e15:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208e1c:	00 00 00 
  8004208e1f:	0f b6 50 24          	movzbl 0x24(%rax),%edx
  8004208e23:	83 e2 07             	and    $0x7,%edx
  8004208e26:	88 50 24             	mov    %dl,0x24(%rax)
  8004208e29:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208e30:	00 00 00 
  8004208e33:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  8004208e37:	83 e2 f0             	and    $0xfffffff0,%edx
  8004208e3a:	83 ca 0e             	or     $0xe,%edx
  8004208e3d:	88 50 25             	mov    %dl,0x25(%rax)
  8004208e40:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208e47:	00 00 00 
  8004208e4a:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  8004208e4e:	83 e2 ef             	and    $0xffffffef,%edx
  8004208e51:	88 50 25             	mov    %dl,0x25(%rax)
  8004208e54:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208e5b:	00 00 00 
  8004208e5e:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  8004208e62:	83 e2 9f             	and    $0xffffff9f,%edx
  8004208e65:	88 50 25             	mov    %dl,0x25(%rax)
  8004208e68:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208e6f:	00 00 00 
  8004208e72:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  8004208e76:	83 ca 80             	or     $0xffffff80,%edx
  8004208e79:	88 50 25             	mov    %dl,0x25(%rax)
  8004208e7c:	48 b8 1c b9 20 04 80 	movabs $0x800420b91c,%rax
  8004208e83:	00 00 00 
  8004208e86:	48 c1 e8 10          	shr    $0x10,%rax
  8004208e8a:	89 c2                	mov    %eax,%edx
  8004208e8c:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208e93:	00 00 00 
  8004208e96:	66 89 50 26          	mov    %dx,0x26(%rax)
  8004208e9a:	48 b8 1c b9 20 04 80 	movabs $0x800420b91c,%rax
  8004208ea1:	00 00 00 
  8004208ea4:	48 c1 e8 20          	shr    $0x20,%rax
  8004208ea8:	89 c2                	mov    %eax,%edx
  8004208eaa:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208eb1:	00 00 00 
  8004208eb4:	89 50 28             	mov    %edx,0x28(%rax)
  8004208eb7:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208ebe:	00 00 00 
  8004208ec1:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%rax)
	SETGATE(idt[T_BRKPT], 0, GD_KT, __trap_brkpt, 3);
  8004208ec8:	48 b8 26 b9 20 04 80 	movabs $0x800420b926,%rax
  8004208ecf:	00 00 00 
  8004208ed2:	89 c2                	mov    %eax,%edx
  8004208ed4:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208edb:	00 00 00 
  8004208ede:	66 89 50 30          	mov    %dx,0x30(%rax)
  8004208ee2:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208ee9:	00 00 00 
  8004208eec:	66 c7 40 32 08 00    	movw   $0x8,0x32(%rax)
  8004208ef2:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208ef9:	00 00 00 
  8004208efc:	0f b6 50 34          	movzbl 0x34(%rax),%edx
  8004208f00:	83 e2 f8             	and    $0xfffffff8,%edx
  8004208f03:	88 50 34             	mov    %dl,0x34(%rax)
  8004208f06:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208f0d:	00 00 00 
  8004208f10:	0f b6 50 34          	movzbl 0x34(%rax),%edx
  8004208f14:	83 e2 07             	and    $0x7,%edx
  8004208f17:	88 50 34             	mov    %dl,0x34(%rax)
  8004208f1a:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208f21:	00 00 00 
  8004208f24:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  8004208f28:	83 e2 f0             	and    $0xfffffff0,%edx
  8004208f2b:	83 ca 0e             	or     $0xe,%edx
  8004208f2e:	88 50 35             	mov    %dl,0x35(%rax)
  8004208f31:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208f38:	00 00 00 
  8004208f3b:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  8004208f3f:	83 e2 ef             	and    $0xffffffef,%edx
  8004208f42:	88 50 35             	mov    %dl,0x35(%rax)
  8004208f45:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208f4c:	00 00 00 
  8004208f4f:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  8004208f53:	83 ca 60             	or     $0x60,%edx
  8004208f56:	88 50 35             	mov    %dl,0x35(%rax)
  8004208f59:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208f60:	00 00 00 
  8004208f63:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  8004208f67:	83 ca 80             	or     $0xffffff80,%edx
  8004208f6a:	88 50 35             	mov    %dl,0x35(%rax)
  8004208f6d:	48 b8 26 b9 20 04 80 	movabs $0x800420b926,%rax
  8004208f74:	00 00 00 
  8004208f77:	48 c1 e8 10          	shr    $0x10,%rax
  8004208f7b:	89 c2                	mov    %eax,%edx
  8004208f7d:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208f84:	00 00 00 
  8004208f87:	66 89 50 36          	mov    %dx,0x36(%rax)
  8004208f8b:	48 b8 26 b9 20 04 80 	movabs $0x800420b926,%rax
  8004208f92:	00 00 00 
  8004208f95:	48 c1 e8 20          	shr    $0x20,%rax
  8004208f99:	89 c2                	mov    %eax,%edx
  8004208f9b:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208fa2:	00 00 00 
  8004208fa5:	89 50 38             	mov    %edx,0x38(%rax)
  8004208fa8:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208faf:	00 00 00 
  8004208fb2:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%rax)
	SETGATE(idt[T_OFLOW], 0, GD_KT, __trap_oflow, 0);
  8004208fb9:	48 b8 30 b9 20 04 80 	movabs $0x800420b930,%rax
  8004208fc0:	00 00 00 
  8004208fc3:	89 c2                	mov    %eax,%edx
  8004208fc5:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208fcc:	00 00 00 
  8004208fcf:	66 89 50 40          	mov    %dx,0x40(%rax)
  8004208fd3:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208fda:	00 00 00 
  8004208fdd:	66 c7 40 42 08 00    	movw   $0x8,0x42(%rax)
  8004208fe3:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208fea:	00 00 00 
  8004208fed:	0f b6 50 44          	movzbl 0x44(%rax),%edx
  8004208ff1:	83 e2 f8             	and    $0xfffffff8,%edx
  8004208ff4:	88 50 44             	mov    %dl,0x44(%rax)
  8004208ff7:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004208ffe:	00 00 00 
  8004209001:	0f b6 50 44          	movzbl 0x44(%rax),%edx
  8004209005:	83 e2 07             	and    $0x7,%edx
  8004209008:	88 50 44             	mov    %dl,0x44(%rax)
  800420900b:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209012:	00 00 00 
  8004209015:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  8004209019:	83 e2 f0             	and    $0xfffffff0,%edx
  800420901c:	83 ca 0e             	or     $0xe,%edx
  800420901f:	88 50 45             	mov    %dl,0x45(%rax)
  8004209022:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209029:	00 00 00 
  800420902c:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  8004209030:	83 e2 ef             	and    $0xffffffef,%edx
  8004209033:	88 50 45             	mov    %dl,0x45(%rax)
  8004209036:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420903d:	00 00 00 
  8004209040:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  8004209044:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209047:	88 50 45             	mov    %dl,0x45(%rax)
  800420904a:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209051:	00 00 00 
  8004209054:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  8004209058:	83 ca 80             	or     $0xffffff80,%edx
  800420905b:	88 50 45             	mov    %dl,0x45(%rax)
  800420905e:	48 b8 30 b9 20 04 80 	movabs $0x800420b930,%rax
  8004209065:	00 00 00 
  8004209068:	48 c1 e8 10          	shr    $0x10,%rax
  800420906c:	89 c2                	mov    %eax,%edx
  800420906e:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209075:	00 00 00 
  8004209078:	66 89 50 46          	mov    %dx,0x46(%rax)
  800420907c:	48 b8 30 b9 20 04 80 	movabs $0x800420b930,%rax
  8004209083:	00 00 00 
  8004209086:	48 c1 e8 20          	shr    $0x20,%rax
  800420908a:	89 c2                	mov    %eax,%edx
  800420908c:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209093:	00 00 00 
  8004209096:	89 50 48             	mov    %edx,0x48(%rax)
  8004209099:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  80042090a0:	00 00 00 
  80042090a3:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%rax)
	SETGATE(idt[T_BOUND], 0, GD_KT, __trap_bound, 0);
  80042090aa:	48 b8 3a b9 20 04 80 	movabs $0x800420b93a,%rax
  80042090b1:	00 00 00 
  80042090b4:	89 c2                	mov    %eax,%edx
  80042090b6:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  80042090bd:	00 00 00 
  80042090c0:	66 89 50 50          	mov    %dx,0x50(%rax)
  80042090c4:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  80042090cb:	00 00 00 
  80042090ce:	66 c7 40 52 08 00    	movw   $0x8,0x52(%rax)
  80042090d4:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  80042090db:	00 00 00 
  80042090de:	0f b6 50 54          	movzbl 0x54(%rax),%edx
  80042090e2:	83 e2 f8             	and    $0xfffffff8,%edx
  80042090e5:	88 50 54             	mov    %dl,0x54(%rax)
  80042090e8:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  80042090ef:	00 00 00 
  80042090f2:	0f b6 50 54          	movzbl 0x54(%rax),%edx
  80042090f6:	83 e2 07             	and    $0x7,%edx
  80042090f9:	88 50 54             	mov    %dl,0x54(%rax)
  80042090fc:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209103:	00 00 00 
  8004209106:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  800420910a:	83 e2 f0             	and    $0xfffffff0,%edx
  800420910d:	83 ca 0e             	or     $0xe,%edx
  8004209110:	88 50 55             	mov    %dl,0x55(%rax)
  8004209113:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420911a:	00 00 00 
  800420911d:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  8004209121:	83 e2 ef             	and    $0xffffffef,%edx
  8004209124:	88 50 55             	mov    %dl,0x55(%rax)
  8004209127:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420912e:	00 00 00 
  8004209131:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  8004209135:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209138:	88 50 55             	mov    %dl,0x55(%rax)
  800420913b:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209142:	00 00 00 
  8004209145:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  8004209149:	83 ca 80             	or     $0xffffff80,%edx
  800420914c:	88 50 55             	mov    %dl,0x55(%rax)
  800420914f:	48 b8 3a b9 20 04 80 	movabs $0x800420b93a,%rax
  8004209156:	00 00 00 
  8004209159:	48 c1 e8 10          	shr    $0x10,%rax
  800420915d:	89 c2                	mov    %eax,%edx
  800420915f:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209166:	00 00 00 
  8004209169:	66 89 50 56          	mov    %dx,0x56(%rax)
  800420916d:	48 b8 3a b9 20 04 80 	movabs $0x800420b93a,%rax
  8004209174:	00 00 00 
  8004209177:	48 c1 e8 20          	shr    $0x20,%rax
  800420917b:	89 c2                	mov    %eax,%edx
  800420917d:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209184:	00 00 00 
  8004209187:	89 50 58             	mov    %edx,0x58(%rax)
  800420918a:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209191:	00 00 00 
  8004209194:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%rax)
	SETGATE(idt[T_ILLOP], 0, GD_KT, __trap_illop, 0);
  800420919b:	48 b8 44 b9 20 04 80 	movabs $0x800420b944,%rax
  80042091a2:	00 00 00 
  80042091a5:	89 c2                	mov    %eax,%edx
  80042091a7:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  80042091ae:	00 00 00 
  80042091b1:	66 89 50 60          	mov    %dx,0x60(%rax)
  80042091b5:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  80042091bc:	00 00 00 
  80042091bf:	66 c7 40 62 08 00    	movw   $0x8,0x62(%rax)
  80042091c5:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  80042091cc:	00 00 00 
  80042091cf:	0f b6 50 64          	movzbl 0x64(%rax),%edx
  80042091d3:	83 e2 f8             	and    $0xfffffff8,%edx
  80042091d6:	88 50 64             	mov    %dl,0x64(%rax)
  80042091d9:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  80042091e0:	00 00 00 
  80042091e3:	0f b6 50 64          	movzbl 0x64(%rax),%edx
  80042091e7:	83 e2 07             	and    $0x7,%edx
  80042091ea:	88 50 64             	mov    %dl,0x64(%rax)
  80042091ed:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  80042091f4:	00 00 00 
  80042091f7:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  80042091fb:	83 e2 f0             	and    $0xfffffff0,%edx
  80042091fe:	83 ca 0e             	or     $0xe,%edx
  8004209201:	88 50 65             	mov    %dl,0x65(%rax)
  8004209204:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420920b:	00 00 00 
  800420920e:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  8004209212:	83 e2 ef             	and    $0xffffffef,%edx
  8004209215:	88 50 65             	mov    %dl,0x65(%rax)
  8004209218:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420921f:	00 00 00 
  8004209222:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  8004209226:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209229:	88 50 65             	mov    %dl,0x65(%rax)
  800420922c:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209233:	00 00 00 
  8004209236:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  800420923a:	83 ca 80             	or     $0xffffff80,%edx
  800420923d:	88 50 65             	mov    %dl,0x65(%rax)
  8004209240:	48 b8 44 b9 20 04 80 	movabs $0x800420b944,%rax
  8004209247:	00 00 00 
  800420924a:	48 c1 e8 10          	shr    $0x10,%rax
  800420924e:	89 c2                	mov    %eax,%edx
  8004209250:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209257:	00 00 00 
  800420925a:	66 89 50 66          	mov    %dx,0x66(%rax)
  800420925e:	48 b8 44 b9 20 04 80 	movabs $0x800420b944,%rax
  8004209265:	00 00 00 
  8004209268:	48 c1 e8 20          	shr    $0x20,%rax
  800420926c:	89 c2                	mov    %eax,%edx
  800420926e:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209275:	00 00 00 
  8004209278:	89 50 68             	mov    %edx,0x68(%rax)
  800420927b:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209282:	00 00 00 
  8004209285:	c7 40 6c 00 00 00 00 	movl   $0x0,0x6c(%rax)
	SETGATE(idt[T_DEVICE], 0, GD_KT, __trap_device, 0);
  800420928c:	48 b8 4e b9 20 04 80 	movabs $0x800420b94e,%rax
  8004209293:	00 00 00 
  8004209296:	89 c2                	mov    %eax,%edx
  8004209298:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420929f:	00 00 00 
  80042092a2:	66 89 50 70          	mov    %dx,0x70(%rax)
  80042092a6:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  80042092ad:	00 00 00 
  80042092b0:	66 c7 40 72 08 00    	movw   $0x8,0x72(%rax)
  80042092b6:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  80042092bd:	00 00 00 
  80042092c0:	0f b6 50 74          	movzbl 0x74(%rax),%edx
  80042092c4:	83 e2 f8             	and    $0xfffffff8,%edx
  80042092c7:	88 50 74             	mov    %dl,0x74(%rax)
  80042092ca:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  80042092d1:	00 00 00 
  80042092d4:	0f b6 50 74          	movzbl 0x74(%rax),%edx
  80042092d8:	83 e2 07             	and    $0x7,%edx
  80042092db:	88 50 74             	mov    %dl,0x74(%rax)
  80042092de:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  80042092e5:	00 00 00 
  80042092e8:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  80042092ec:	83 e2 f0             	and    $0xfffffff0,%edx
  80042092ef:	83 ca 0e             	or     $0xe,%edx
  80042092f2:	88 50 75             	mov    %dl,0x75(%rax)
  80042092f5:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  80042092fc:	00 00 00 
  80042092ff:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  8004209303:	83 e2 ef             	and    $0xffffffef,%edx
  8004209306:	88 50 75             	mov    %dl,0x75(%rax)
  8004209309:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209310:	00 00 00 
  8004209313:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  8004209317:	83 e2 9f             	and    $0xffffff9f,%edx
  800420931a:	88 50 75             	mov    %dl,0x75(%rax)
  800420931d:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209324:	00 00 00 
  8004209327:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  800420932b:	83 ca 80             	or     $0xffffff80,%edx
  800420932e:	88 50 75             	mov    %dl,0x75(%rax)
  8004209331:	48 b8 4e b9 20 04 80 	movabs $0x800420b94e,%rax
  8004209338:	00 00 00 
  800420933b:	48 c1 e8 10          	shr    $0x10,%rax
  800420933f:	89 c2                	mov    %eax,%edx
  8004209341:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209348:	00 00 00 
  800420934b:	66 89 50 76          	mov    %dx,0x76(%rax)
  800420934f:	48 b8 4e b9 20 04 80 	movabs $0x800420b94e,%rax
  8004209356:	00 00 00 
  8004209359:	48 c1 e8 20          	shr    $0x20,%rax
  800420935d:	89 c2                	mov    %eax,%edx
  800420935f:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209366:	00 00 00 
  8004209369:	89 50 78             	mov    %edx,0x78(%rax)
  800420936c:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209373:	00 00 00 
  8004209376:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%rax)
	SETGATE(idt[T_DBLFLT], 0, GD_KT, __trap_dblflt, 0);
  800420937d:	48 b8 58 b9 20 04 80 	movabs $0x800420b958,%rax
  8004209384:	00 00 00 
  8004209387:	89 c2                	mov    %eax,%edx
  8004209389:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209390:	00 00 00 
  8004209393:	66 89 90 80 00 00 00 	mov    %dx,0x80(%rax)
  800420939a:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  80042093a1:	00 00 00 
  80042093a4:	66 c7 80 82 00 00 00 	movw   $0x8,0x82(%rax)
  80042093ab:	08 00 
  80042093ad:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  80042093b4:	00 00 00 
  80042093b7:	0f b6 90 84 00 00 00 	movzbl 0x84(%rax),%edx
  80042093be:	83 e2 f8             	and    $0xfffffff8,%edx
  80042093c1:	88 90 84 00 00 00    	mov    %dl,0x84(%rax)
  80042093c7:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  80042093ce:	00 00 00 
  80042093d1:	0f b6 90 84 00 00 00 	movzbl 0x84(%rax),%edx
  80042093d8:	83 e2 07             	and    $0x7,%edx
  80042093db:	88 90 84 00 00 00    	mov    %dl,0x84(%rax)
  80042093e1:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  80042093e8:	00 00 00 
  80042093eb:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  80042093f2:	83 e2 f0             	and    $0xfffffff0,%edx
  80042093f5:	83 ca 0e             	or     $0xe,%edx
  80042093f8:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  80042093fe:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209405:	00 00 00 
  8004209408:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  800420940f:	83 e2 ef             	and    $0xffffffef,%edx
  8004209412:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  8004209418:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420941f:	00 00 00 
  8004209422:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  8004209429:	83 e2 9f             	and    $0xffffff9f,%edx
  800420942c:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  8004209432:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209439:	00 00 00 
  800420943c:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  8004209443:	83 ca 80             	or     $0xffffff80,%edx
  8004209446:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  800420944c:	48 b8 58 b9 20 04 80 	movabs $0x800420b958,%rax
  8004209453:	00 00 00 
  8004209456:	48 c1 e8 10          	shr    $0x10,%rax
  800420945a:	89 c2                	mov    %eax,%edx
  800420945c:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209463:	00 00 00 
  8004209466:	66 89 90 86 00 00 00 	mov    %dx,0x86(%rax)
  800420946d:	48 b8 58 b9 20 04 80 	movabs $0x800420b958,%rax
  8004209474:	00 00 00 
  8004209477:	48 c1 e8 20          	shr    $0x20,%rax
  800420947b:	89 c2                	mov    %eax,%edx
  800420947d:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209484:	00 00 00 
  8004209487:	89 90 88 00 00 00    	mov    %edx,0x88(%rax)
  800420948d:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209494:	00 00 00 
  8004209497:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%rax)
  800420949e:	00 00 00 
	//SETGATE(idt[T_COPROC], 0, GD_KT, __trap_coproc, 0);
	SETGATE(idt[T_TSS], 0, GD_KT, __trap_tss, 0);
  80042094a1:	48 b8 60 b9 20 04 80 	movabs $0x800420b960,%rax
  80042094a8:	00 00 00 
  80042094ab:	89 c2                	mov    %eax,%edx
  80042094ad:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  80042094b4:	00 00 00 
  80042094b7:	66 89 90 a0 00 00 00 	mov    %dx,0xa0(%rax)
  80042094be:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  80042094c5:	00 00 00 
  80042094c8:	66 c7 80 a2 00 00 00 	movw   $0x8,0xa2(%rax)
  80042094cf:	08 00 
  80042094d1:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  80042094d8:	00 00 00 
  80042094db:	0f b6 90 a4 00 00 00 	movzbl 0xa4(%rax),%edx
  80042094e2:	83 e2 f8             	and    $0xfffffff8,%edx
  80042094e5:	88 90 a4 00 00 00    	mov    %dl,0xa4(%rax)
  80042094eb:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  80042094f2:	00 00 00 
  80042094f5:	0f b6 90 a4 00 00 00 	movzbl 0xa4(%rax),%edx
  80042094fc:	83 e2 07             	and    $0x7,%edx
  80042094ff:	88 90 a4 00 00 00    	mov    %dl,0xa4(%rax)
  8004209505:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420950c:	00 00 00 
  800420950f:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  8004209516:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209519:	83 ca 0e             	or     $0xe,%edx
  800420951c:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  8004209522:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209529:	00 00 00 
  800420952c:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  8004209533:	83 e2 ef             	and    $0xffffffef,%edx
  8004209536:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  800420953c:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209543:	00 00 00 
  8004209546:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  800420954d:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209550:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  8004209556:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420955d:	00 00 00 
  8004209560:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  8004209567:	83 ca 80             	or     $0xffffff80,%edx
  800420956a:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  8004209570:	48 b8 60 b9 20 04 80 	movabs $0x800420b960,%rax
  8004209577:	00 00 00 
  800420957a:	48 c1 e8 10          	shr    $0x10,%rax
  800420957e:	89 c2                	mov    %eax,%edx
  8004209580:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209587:	00 00 00 
  800420958a:	66 89 90 a6 00 00 00 	mov    %dx,0xa6(%rax)
  8004209591:	48 b8 60 b9 20 04 80 	movabs $0x800420b960,%rax
  8004209598:	00 00 00 
  800420959b:	48 c1 e8 20          	shr    $0x20,%rax
  800420959f:	89 c2                	mov    %eax,%edx
  80042095a1:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  80042095a8:	00 00 00 
  80042095ab:	89 90 a8 00 00 00    	mov    %edx,0xa8(%rax)
  80042095b1:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  80042095b8:	00 00 00 
  80042095bb:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%rax)
  80042095c2:	00 00 00 
	SETGATE(idt[T_SEGNP], 0, GD_KT, __trap_segnp, 0);
  80042095c5:	48 b8 68 b9 20 04 80 	movabs $0x800420b968,%rax
  80042095cc:	00 00 00 
  80042095cf:	89 c2                	mov    %eax,%edx
  80042095d1:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  80042095d8:	00 00 00 
  80042095db:	66 89 90 b0 00 00 00 	mov    %dx,0xb0(%rax)
  80042095e2:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  80042095e9:	00 00 00 
  80042095ec:	66 c7 80 b2 00 00 00 	movw   $0x8,0xb2(%rax)
  80042095f3:	08 00 
  80042095f5:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  80042095fc:	00 00 00 
  80042095ff:	0f b6 90 b4 00 00 00 	movzbl 0xb4(%rax),%edx
  8004209606:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209609:	88 90 b4 00 00 00    	mov    %dl,0xb4(%rax)
  800420960f:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209616:	00 00 00 
  8004209619:	0f b6 90 b4 00 00 00 	movzbl 0xb4(%rax),%edx
  8004209620:	83 e2 07             	and    $0x7,%edx
  8004209623:	88 90 b4 00 00 00    	mov    %dl,0xb4(%rax)
  8004209629:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209630:	00 00 00 
  8004209633:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  800420963a:	83 e2 f0             	and    $0xfffffff0,%edx
  800420963d:	83 ca 0e             	or     $0xe,%edx
  8004209640:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  8004209646:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420964d:	00 00 00 
  8004209650:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  8004209657:	83 e2 ef             	and    $0xffffffef,%edx
  800420965a:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  8004209660:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209667:	00 00 00 
  800420966a:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  8004209671:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209674:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  800420967a:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209681:	00 00 00 
  8004209684:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  800420968b:	83 ca 80             	or     $0xffffff80,%edx
  800420968e:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  8004209694:	48 b8 68 b9 20 04 80 	movabs $0x800420b968,%rax
  800420969b:	00 00 00 
  800420969e:	48 c1 e8 10          	shr    $0x10,%rax
  80042096a2:	89 c2                	mov    %eax,%edx
  80042096a4:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  80042096ab:	00 00 00 
  80042096ae:	66 89 90 b6 00 00 00 	mov    %dx,0xb6(%rax)
  80042096b5:	48 b8 68 b9 20 04 80 	movabs $0x800420b968,%rax
  80042096bc:	00 00 00 
  80042096bf:	48 c1 e8 20          	shr    $0x20,%rax
  80042096c3:	89 c2                	mov    %eax,%edx
  80042096c5:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  80042096cc:	00 00 00 
  80042096cf:	89 90 b8 00 00 00    	mov    %edx,0xb8(%rax)
  80042096d5:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  80042096dc:	00 00 00 
  80042096df:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%rax)
  80042096e6:	00 00 00 
	SETGATE(idt[T_STACK], 0, GD_KT, __trap_stack, 0);
  80042096e9:	48 b8 70 b9 20 04 80 	movabs $0x800420b970,%rax
  80042096f0:	00 00 00 
  80042096f3:	89 c2                	mov    %eax,%edx
  80042096f5:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  80042096fc:	00 00 00 
  80042096ff:	66 89 90 c0 00 00 00 	mov    %dx,0xc0(%rax)
  8004209706:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420970d:	00 00 00 
  8004209710:	66 c7 80 c2 00 00 00 	movw   $0x8,0xc2(%rax)
  8004209717:	08 00 
  8004209719:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209720:	00 00 00 
  8004209723:	0f b6 90 c4 00 00 00 	movzbl 0xc4(%rax),%edx
  800420972a:	83 e2 f8             	and    $0xfffffff8,%edx
  800420972d:	88 90 c4 00 00 00    	mov    %dl,0xc4(%rax)
  8004209733:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420973a:	00 00 00 
  800420973d:	0f b6 90 c4 00 00 00 	movzbl 0xc4(%rax),%edx
  8004209744:	83 e2 07             	and    $0x7,%edx
  8004209747:	88 90 c4 00 00 00    	mov    %dl,0xc4(%rax)
  800420974d:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209754:	00 00 00 
  8004209757:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  800420975e:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209761:	83 ca 0e             	or     $0xe,%edx
  8004209764:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  800420976a:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209771:	00 00 00 
  8004209774:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  800420977b:	83 e2 ef             	and    $0xffffffef,%edx
  800420977e:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  8004209784:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420978b:	00 00 00 
  800420978e:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  8004209795:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209798:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  800420979e:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  80042097a5:	00 00 00 
  80042097a8:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  80042097af:	83 ca 80             	or     $0xffffff80,%edx
  80042097b2:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  80042097b8:	48 b8 70 b9 20 04 80 	movabs $0x800420b970,%rax
  80042097bf:	00 00 00 
  80042097c2:	48 c1 e8 10          	shr    $0x10,%rax
  80042097c6:	89 c2                	mov    %eax,%edx
  80042097c8:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  80042097cf:	00 00 00 
  80042097d2:	66 89 90 c6 00 00 00 	mov    %dx,0xc6(%rax)
  80042097d9:	48 b8 70 b9 20 04 80 	movabs $0x800420b970,%rax
  80042097e0:	00 00 00 
  80042097e3:	48 c1 e8 20          	shr    $0x20,%rax
  80042097e7:	89 c2                	mov    %eax,%edx
  80042097e9:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  80042097f0:	00 00 00 
  80042097f3:	89 90 c8 00 00 00    	mov    %edx,0xc8(%rax)
  80042097f9:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209800:	00 00 00 
  8004209803:	c7 80 cc 00 00 00 00 	movl   $0x0,0xcc(%rax)
  800420980a:	00 00 00 
	SETGATE(idt[T_GPFLT], 0, GD_KT, __trap_gpflt, 0);
  800420980d:	48 b8 78 b9 20 04 80 	movabs $0x800420b978,%rax
  8004209814:	00 00 00 
  8004209817:	89 c2                	mov    %eax,%edx
  8004209819:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209820:	00 00 00 
  8004209823:	66 89 90 d0 00 00 00 	mov    %dx,0xd0(%rax)
  800420982a:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209831:	00 00 00 
  8004209834:	66 c7 80 d2 00 00 00 	movw   $0x8,0xd2(%rax)
  800420983b:	08 00 
  800420983d:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209844:	00 00 00 
  8004209847:	0f b6 90 d4 00 00 00 	movzbl 0xd4(%rax),%edx
  800420984e:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209851:	88 90 d4 00 00 00    	mov    %dl,0xd4(%rax)
  8004209857:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420985e:	00 00 00 
  8004209861:	0f b6 90 d4 00 00 00 	movzbl 0xd4(%rax),%edx
  8004209868:	83 e2 07             	and    $0x7,%edx
  800420986b:	88 90 d4 00 00 00    	mov    %dl,0xd4(%rax)
  8004209871:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209878:	00 00 00 
  800420987b:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  8004209882:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209885:	83 ca 0e             	or     $0xe,%edx
  8004209888:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  800420988e:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209895:	00 00 00 
  8004209898:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  800420989f:	83 e2 ef             	and    $0xffffffef,%edx
  80042098a2:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  80042098a8:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  80042098af:	00 00 00 
  80042098b2:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  80042098b9:	83 e2 9f             	and    $0xffffff9f,%edx
  80042098bc:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  80042098c2:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  80042098c9:	00 00 00 
  80042098cc:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  80042098d3:	83 ca 80             	or     $0xffffff80,%edx
  80042098d6:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  80042098dc:	48 b8 78 b9 20 04 80 	movabs $0x800420b978,%rax
  80042098e3:	00 00 00 
  80042098e6:	48 c1 e8 10          	shr    $0x10,%rax
  80042098ea:	89 c2                	mov    %eax,%edx
  80042098ec:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  80042098f3:	00 00 00 
  80042098f6:	66 89 90 d6 00 00 00 	mov    %dx,0xd6(%rax)
  80042098fd:	48 b8 78 b9 20 04 80 	movabs $0x800420b978,%rax
  8004209904:	00 00 00 
  8004209907:	48 c1 e8 20          	shr    $0x20,%rax
  800420990b:	89 c2                	mov    %eax,%edx
  800420990d:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209914:	00 00 00 
  8004209917:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)
  800420991d:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209924:	00 00 00 
  8004209927:	c7 80 dc 00 00 00 00 	movl   $0x0,0xdc(%rax)
  800420992e:	00 00 00 
	SETGATE(idt[T_PGFLT], 0, GD_KT, __trap_pgflt, 0);
  8004209931:	48 b8 80 b9 20 04 80 	movabs $0x800420b980,%rax
  8004209938:	00 00 00 
  800420993b:	89 c2                	mov    %eax,%edx
  800420993d:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209944:	00 00 00 
  8004209947:	66 89 90 e0 00 00 00 	mov    %dx,0xe0(%rax)
  800420994e:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209955:	00 00 00 
  8004209958:	66 c7 80 e2 00 00 00 	movw   $0x8,0xe2(%rax)
  800420995f:	08 00 
  8004209961:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209968:	00 00 00 
  800420996b:	0f b6 90 e4 00 00 00 	movzbl 0xe4(%rax),%edx
  8004209972:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209975:	88 90 e4 00 00 00    	mov    %dl,0xe4(%rax)
  800420997b:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209982:	00 00 00 
  8004209985:	0f b6 90 e4 00 00 00 	movzbl 0xe4(%rax),%edx
  800420998c:	83 e2 07             	and    $0x7,%edx
  800420998f:	88 90 e4 00 00 00    	mov    %dl,0xe4(%rax)
  8004209995:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420999c:	00 00 00 
  800420999f:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  80042099a6:	83 e2 f0             	and    $0xfffffff0,%edx
  80042099a9:	83 ca 0e             	or     $0xe,%edx
  80042099ac:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  80042099b2:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  80042099b9:	00 00 00 
  80042099bc:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  80042099c3:	83 e2 ef             	and    $0xffffffef,%edx
  80042099c6:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  80042099cc:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  80042099d3:	00 00 00 
  80042099d6:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  80042099dd:	83 e2 9f             	and    $0xffffff9f,%edx
  80042099e0:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  80042099e6:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  80042099ed:	00 00 00 
  80042099f0:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  80042099f7:	83 ca 80             	or     $0xffffff80,%edx
  80042099fa:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  8004209a00:	48 b8 80 b9 20 04 80 	movabs $0x800420b980,%rax
  8004209a07:	00 00 00 
  8004209a0a:	48 c1 e8 10          	shr    $0x10,%rax
  8004209a0e:	89 c2                	mov    %eax,%edx
  8004209a10:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209a17:	00 00 00 
  8004209a1a:	66 89 90 e6 00 00 00 	mov    %dx,0xe6(%rax)
  8004209a21:	48 b8 80 b9 20 04 80 	movabs $0x800420b980,%rax
  8004209a28:	00 00 00 
  8004209a2b:	48 c1 e8 20          	shr    $0x20,%rax
  8004209a2f:	89 c2                	mov    %eax,%edx
  8004209a31:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209a38:	00 00 00 
  8004209a3b:	89 90 e8 00 00 00    	mov    %edx,0xe8(%rax)
  8004209a41:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209a48:	00 00 00 
  8004209a4b:	c7 80 ec 00 00 00 00 	movl   $0x0,0xec(%rax)
  8004209a52:	00 00 00 
	//SETGATE(idt[T_RES], 0, GD_KT, __trap_res, 0);
	SETGATE(idt[T_FPERR], 0, GD_KT, __trap_fperr, 0);
  8004209a55:	48 b8 88 b9 20 04 80 	movabs $0x800420b988,%rax
  8004209a5c:	00 00 00 
  8004209a5f:	89 c2                	mov    %eax,%edx
  8004209a61:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209a68:	00 00 00 
  8004209a6b:	66 89 90 00 01 00 00 	mov    %dx,0x100(%rax)
  8004209a72:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209a79:	00 00 00 
  8004209a7c:	66 c7 80 02 01 00 00 	movw   $0x8,0x102(%rax)
  8004209a83:	08 00 
  8004209a85:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209a8c:	00 00 00 
  8004209a8f:	0f b6 90 04 01 00 00 	movzbl 0x104(%rax),%edx
  8004209a96:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209a99:	88 90 04 01 00 00    	mov    %dl,0x104(%rax)
  8004209a9f:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209aa6:	00 00 00 
  8004209aa9:	0f b6 90 04 01 00 00 	movzbl 0x104(%rax),%edx
  8004209ab0:	83 e2 07             	and    $0x7,%edx
  8004209ab3:	88 90 04 01 00 00    	mov    %dl,0x104(%rax)
  8004209ab9:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209ac0:	00 00 00 
  8004209ac3:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  8004209aca:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209acd:	83 ca 0e             	or     $0xe,%edx
  8004209ad0:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  8004209ad6:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209add:	00 00 00 
  8004209ae0:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  8004209ae7:	83 e2 ef             	and    $0xffffffef,%edx
  8004209aea:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  8004209af0:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209af7:	00 00 00 
  8004209afa:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  8004209b01:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209b04:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  8004209b0a:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209b11:	00 00 00 
  8004209b14:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  8004209b1b:	83 ca 80             	or     $0xffffff80,%edx
  8004209b1e:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  8004209b24:	48 b8 88 b9 20 04 80 	movabs $0x800420b988,%rax
  8004209b2b:	00 00 00 
  8004209b2e:	48 c1 e8 10          	shr    $0x10,%rax
  8004209b32:	89 c2                	mov    %eax,%edx
  8004209b34:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209b3b:	00 00 00 
  8004209b3e:	66 89 90 06 01 00 00 	mov    %dx,0x106(%rax)
  8004209b45:	48 b8 88 b9 20 04 80 	movabs $0x800420b988,%rax
  8004209b4c:	00 00 00 
  8004209b4f:	48 c1 e8 20          	shr    $0x20,%rax
  8004209b53:	89 c2                	mov    %eax,%edx
  8004209b55:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209b5c:	00 00 00 
  8004209b5f:	89 90 08 01 00 00    	mov    %edx,0x108(%rax)
  8004209b65:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209b6c:	00 00 00 
  8004209b6f:	c7 80 0c 01 00 00 00 	movl   $0x0,0x10c(%rax)
  8004209b76:	00 00 00 
	SETGATE(idt[T_ALIGN], 0, GD_KT, __trap_align, 0);
  8004209b79:	48 b8 92 b9 20 04 80 	movabs $0x800420b992,%rax
  8004209b80:	00 00 00 
  8004209b83:	89 c2                	mov    %eax,%edx
  8004209b85:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209b8c:	00 00 00 
  8004209b8f:	66 89 90 10 01 00 00 	mov    %dx,0x110(%rax)
  8004209b96:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209b9d:	00 00 00 
  8004209ba0:	66 c7 80 12 01 00 00 	movw   $0x8,0x112(%rax)
  8004209ba7:	08 00 
  8004209ba9:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209bb0:	00 00 00 
  8004209bb3:	0f b6 90 14 01 00 00 	movzbl 0x114(%rax),%edx
  8004209bba:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209bbd:	88 90 14 01 00 00    	mov    %dl,0x114(%rax)
  8004209bc3:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209bca:	00 00 00 
  8004209bcd:	0f b6 90 14 01 00 00 	movzbl 0x114(%rax),%edx
  8004209bd4:	83 e2 07             	and    $0x7,%edx
  8004209bd7:	88 90 14 01 00 00    	mov    %dl,0x114(%rax)
  8004209bdd:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209be4:	00 00 00 
  8004209be7:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  8004209bee:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209bf1:	83 ca 0e             	or     $0xe,%edx
  8004209bf4:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  8004209bfa:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209c01:	00 00 00 
  8004209c04:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  8004209c0b:	83 e2 ef             	and    $0xffffffef,%edx
  8004209c0e:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  8004209c14:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209c1b:	00 00 00 
  8004209c1e:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  8004209c25:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209c28:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  8004209c2e:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209c35:	00 00 00 
  8004209c38:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  8004209c3f:	83 ca 80             	or     $0xffffff80,%edx
  8004209c42:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  8004209c48:	48 b8 92 b9 20 04 80 	movabs $0x800420b992,%rax
  8004209c4f:	00 00 00 
  8004209c52:	48 c1 e8 10          	shr    $0x10,%rax
  8004209c56:	89 c2                	mov    %eax,%edx
  8004209c58:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209c5f:	00 00 00 
  8004209c62:	66 89 90 16 01 00 00 	mov    %dx,0x116(%rax)
  8004209c69:	48 b8 92 b9 20 04 80 	movabs $0x800420b992,%rax
  8004209c70:	00 00 00 
  8004209c73:	48 c1 e8 20          	shr    $0x20,%rax
  8004209c77:	89 c2                	mov    %eax,%edx
  8004209c79:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209c80:	00 00 00 
  8004209c83:	89 90 18 01 00 00    	mov    %edx,0x118(%rax)
  8004209c89:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209c90:	00 00 00 
  8004209c93:	c7 80 1c 01 00 00 00 	movl   $0x0,0x11c(%rax)
  8004209c9a:	00 00 00 
	SETGATE(idt[T_MCHK], 0, GD_KT, __trap_mchk, 0);
  8004209c9d:	48 b8 9a b9 20 04 80 	movabs $0x800420b99a,%rax
  8004209ca4:	00 00 00 
  8004209ca7:	89 c2                	mov    %eax,%edx
  8004209ca9:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209cb0:	00 00 00 
  8004209cb3:	66 89 90 20 01 00 00 	mov    %dx,0x120(%rax)
  8004209cba:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209cc1:	00 00 00 
  8004209cc4:	66 c7 80 22 01 00 00 	movw   $0x8,0x122(%rax)
  8004209ccb:	08 00 
  8004209ccd:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209cd4:	00 00 00 
  8004209cd7:	0f b6 90 24 01 00 00 	movzbl 0x124(%rax),%edx
  8004209cde:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209ce1:	88 90 24 01 00 00    	mov    %dl,0x124(%rax)
  8004209ce7:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209cee:	00 00 00 
  8004209cf1:	0f b6 90 24 01 00 00 	movzbl 0x124(%rax),%edx
  8004209cf8:	83 e2 07             	and    $0x7,%edx
  8004209cfb:	88 90 24 01 00 00    	mov    %dl,0x124(%rax)
  8004209d01:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209d08:	00 00 00 
  8004209d0b:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  8004209d12:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209d15:	83 ca 0e             	or     $0xe,%edx
  8004209d18:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  8004209d1e:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209d25:	00 00 00 
  8004209d28:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  8004209d2f:	83 e2 ef             	and    $0xffffffef,%edx
  8004209d32:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  8004209d38:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209d3f:	00 00 00 
  8004209d42:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  8004209d49:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209d4c:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  8004209d52:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209d59:	00 00 00 
  8004209d5c:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  8004209d63:	83 ca 80             	or     $0xffffff80,%edx
  8004209d66:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  8004209d6c:	48 b8 9a b9 20 04 80 	movabs $0x800420b99a,%rax
  8004209d73:	00 00 00 
  8004209d76:	48 c1 e8 10          	shr    $0x10,%rax
  8004209d7a:	89 c2                	mov    %eax,%edx
  8004209d7c:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209d83:	00 00 00 
  8004209d86:	66 89 90 26 01 00 00 	mov    %dx,0x126(%rax)
  8004209d8d:	48 b8 9a b9 20 04 80 	movabs $0x800420b99a,%rax
  8004209d94:	00 00 00 
  8004209d97:	48 c1 e8 20          	shr    $0x20,%rax
  8004209d9b:	89 c2                	mov    %eax,%edx
  8004209d9d:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209da4:	00 00 00 
  8004209da7:	89 90 28 01 00 00    	mov    %edx,0x128(%rax)
  8004209dad:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209db4:	00 00 00 
  8004209db7:	c7 80 2c 01 00 00 00 	movl   $0x0,0x12c(%rax)
  8004209dbe:	00 00 00 
	SETGATE(idt[T_SIMDERR], 0, GD_KT, __trap_simderr, 0);
  8004209dc1:	48 b8 a4 b9 20 04 80 	movabs $0x800420b9a4,%rax
  8004209dc8:	00 00 00 
  8004209dcb:	89 c2                	mov    %eax,%edx
  8004209dcd:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209dd4:	00 00 00 
  8004209dd7:	66 89 90 30 01 00 00 	mov    %dx,0x130(%rax)
  8004209dde:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209de5:	00 00 00 
  8004209de8:	66 c7 80 32 01 00 00 	movw   $0x8,0x132(%rax)
  8004209def:	08 00 
  8004209df1:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209df8:	00 00 00 
  8004209dfb:	0f b6 90 34 01 00 00 	movzbl 0x134(%rax),%edx
  8004209e02:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209e05:	88 90 34 01 00 00    	mov    %dl,0x134(%rax)
  8004209e0b:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209e12:	00 00 00 
  8004209e15:	0f b6 90 34 01 00 00 	movzbl 0x134(%rax),%edx
  8004209e1c:	83 e2 07             	and    $0x7,%edx
  8004209e1f:	88 90 34 01 00 00    	mov    %dl,0x134(%rax)
  8004209e25:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209e2c:	00 00 00 
  8004209e2f:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  8004209e36:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209e39:	83 ca 0e             	or     $0xe,%edx
  8004209e3c:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  8004209e42:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209e49:	00 00 00 
  8004209e4c:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  8004209e53:	83 e2 ef             	and    $0xffffffef,%edx
  8004209e56:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  8004209e5c:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209e63:	00 00 00 
  8004209e66:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  8004209e6d:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209e70:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  8004209e76:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209e7d:	00 00 00 
  8004209e80:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  8004209e87:	83 ca 80             	or     $0xffffff80,%edx
  8004209e8a:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  8004209e90:	48 b8 a4 b9 20 04 80 	movabs $0x800420b9a4,%rax
  8004209e97:	00 00 00 
  8004209e9a:	48 c1 e8 10          	shr    $0x10,%rax
  8004209e9e:	89 c2                	mov    %eax,%edx
  8004209ea0:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209ea7:	00 00 00 
  8004209eaa:	66 89 90 36 01 00 00 	mov    %dx,0x136(%rax)
  8004209eb1:	48 b8 a4 b9 20 04 80 	movabs $0x800420b9a4,%rax
  8004209eb8:	00 00 00 
  8004209ebb:	48 c1 e8 20          	shr    $0x20,%rax
  8004209ebf:	89 c2                	mov    %eax,%edx
  8004209ec1:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209ec8:	00 00 00 
  8004209ecb:	89 90 38 01 00 00    	mov    %edx,0x138(%rax)
  8004209ed1:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209ed8:	00 00 00 
  8004209edb:	c7 80 3c 01 00 00 00 	movl   $0x0,0x13c(%rax)
  8004209ee2:	00 00 00 
	SETGATE(idt[T_SYSCALL], 0, GD_KT, __trap_syscall, 3);
  8004209ee5:	48 b8 ae b9 20 04 80 	movabs $0x800420b9ae,%rax
  8004209eec:	00 00 00 
  8004209eef:	89 c2                	mov    %eax,%edx
  8004209ef1:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209ef8:	00 00 00 
  8004209efb:	66 89 90 00 03 00 00 	mov    %dx,0x300(%rax)
  8004209f02:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209f09:	00 00 00 
  8004209f0c:	66 c7 80 02 03 00 00 	movw   $0x8,0x302(%rax)
  8004209f13:	08 00 
  8004209f15:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209f1c:	00 00 00 
  8004209f1f:	0f b6 90 04 03 00 00 	movzbl 0x304(%rax),%edx
  8004209f26:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209f29:	88 90 04 03 00 00    	mov    %dl,0x304(%rax)
  8004209f2f:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209f36:	00 00 00 
  8004209f39:	0f b6 90 04 03 00 00 	movzbl 0x304(%rax),%edx
  8004209f40:	83 e2 07             	and    $0x7,%edx
  8004209f43:	88 90 04 03 00 00    	mov    %dl,0x304(%rax)
  8004209f49:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209f50:	00 00 00 
  8004209f53:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  8004209f5a:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209f5d:	83 ca 0e             	or     $0xe,%edx
  8004209f60:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  8004209f66:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209f6d:	00 00 00 
  8004209f70:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  8004209f77:	83 e2 ef             	and    $0xffffffef,%edx
  8004209f7a:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  8004209f80:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209f87:	00 00 00 
  8004209f8a:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  8004209f91:	83 ca 60             	or     $0x60,%edx
  8004209f94:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  8004209f9a:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209fa1:	00 00 00 
  8004209fa4:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  8004209fab:	83 ca 80             	or     $0xffffff80,%edx
  8004209fae:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  8004209fb4:	48 b8 ae b9 20 04 80 	movabs $0x800420b9ae,%rax
  8004209fbb:	00 00 00 
  8004209fbe:	48 c1 e8 10          	shr    $0x10,%rax
  8004209fc2:	89 c2                	mov    %eax,%edx
  8004209fc4:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209fcb:	00 00 00 
  8004209fce:	66 89 90 06 03 00 00 	mov    %dx,0x306(%rax)
  8004209fd5:	48 b8 ae b9 20 04 80 	movabs $0x800420b9ae,%rax
  8004209fdc:	00 00 00 
  8004209fdf:	48 c1 e8 20          	shr    $0x20,%rax
  8004209fe3:	89 c2                	mov    %eax,%edx
  8004209fe5:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209fec:	00 00 00 
  8004209fef:	89 90 08 03 00 00    	mov    %edx,0x308(%rax)
  8004209ff5:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  8004209ffc:	00 00 00 
  8004209fff:	c7 80 0c 03 00 00 00 	movl   $0x0,0x30c(%rax)
  800420a006:	00 00 00 
	extern void __irq_serial();
	extern void __irq_spurious();
	extern void __irq_ide();
	extern void __irq_error();

	SETGATE(idt[IRQ_OFFSET + IRQ_TIMER], 0, GD_KT, __irq_timer, 0);
  800420a009:	48 b8 b8 b9 20 04 80 	movabs $0x800420b9b8,%rax
  800420a010:	00 00 00 
  800420a013:	89 c2                	mov    %eax,%edx
  800420a015:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a01c:	00 00 00 
  800420a01f:	66 89 90 00 02 00 00 	mov    %dx,0x200(%rax)
  800420a026:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a02d:	00 00 00 
  800420a030:	66 c7 80 02 02 00 00 	movw   $0x8,0x202(%rax)
  800420a037:	08 00 
  800420a039:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a040:	00 00 00 
  800420a043:	0f b6 90 04 02 00 00 	movzbl 0x204(%rax),%edx
  800420a04a:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a04d:	88 90 04 02 00 00    	mov    %dl,0x204(%rax)
  800420a053:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a05a:	00 00 00 
  800420a05d:	0f b6 90 04 02 00 00 	movzbl 0x204(%rax),%edx
  800420a064:	83 e2 07             	and    $0x7,%edx
  800420a067:	88 90 04 02 00 00    	mov    %dl,0x204(%rax)
  800420a06d:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a074:	00 00 00 
  800420a077:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420a07e:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a081:	83 ca 0e             	or     $0xe,%edx
  800420a084:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420a08a:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a091:	00 00 00 
  800420a094:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420a09b:	83 e2 ef             	and    $0xffffffef,%edx
  800420a09e:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420a0a4:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a0ab:	00 00 00 
  800420a0ae:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420a0b5:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a0b8:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420a0be:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a0c5:	00 00 00 
  800420a0c8:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420a0cf:	83 ca 80             	or     $0xffffff80,%edx
  800420a0d2:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420a0d8:	48 b8 b8 b9 20 04 80 	movabs $0x800420b9b8,%rax
  800420a0df:	00 00 00 
  800420a0e2:	48 c1 e8 10          	shr    $0x10,%rax
  800420a0e6:	89 c2                	mov    %eax,%edx
  800420a0e8:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a0ef:	00 00 00 
  800420a0f2:	66 89 90 06 02 00 00 	mov    %dx,0x206(%rax)
  800420a0f9:	48 b8 b8 b9 20 04 80 	movabs $0x800420b9b8,%rax
  800420a100:	00 00 00 
  800420a103:	48 c1 e8 20          	shr    $0x20,%rax
  800420a107:	89 c2                	mov    %eax,%edx
  800420a109:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a110:	00 00 00 
  800420a113:	89 90 08 02 00 00    	mov    %edx,0x208(%rax)
  800420a119:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a120:	00 00 00 
  800420a123:	c7 80 0c 02 00 00 00 	movl   $0x0,0x20c(%rax)
  800420a12a:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + IRQ_KBD], 0, GD_KT, __irq_kbd, 0);
  800420a12d:	48 b8 c2 b9 20 04 80 	movabs $0x800420b9c2,%rax
  800420a134:	00 00 00 
  800420a137:	89 c2                	mov    %eax,%edx
  800420a139:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a140:	00 00 00 
  800420a143:	66 89 90 10 02 00 00 	mov    %dx,0x210(%rax)
  800420a14a:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a151:	00 00 00 
  800420a154:	66 c7 80 12 02 00 00 	movw   $0x8,0x212(%rax)
  800420a15b:	08 00 
  800420a15d:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a164:	00 00 00 
  800420a167:	0f b6 90 14 02 00 00 	movzbl 0x214(%rax),%edx
  800420a16e:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a171:	88 90 14 02 00 00    	mov    %dl,0x214(%rax)
  800420a177:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a17e:	00 00 00 
  800420a181:	0f b6 90 14 02 00 00 	movzbl 0x214(%rax),%edx
  800420a188:	83 e2 07             	and    $0x7,%edx
  800420a18b:	88 90 14 02 00 00    	mov    %dl,0x214(%rax)
  800420a191:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a198:	00 00 00 
  800420a19b:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420a1a2:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a1a5:	83 ca 0e             	or     $0xe,%edx
  800420a1a8:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420a1ae:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a1b5:	00 00 00 
  800420a1b8:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420a1bf:	83 e2 ef             	and    $0xffffffef,%edx
  800420a1c2:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420a1c8:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a1cf:	00 00 00 
  800420a1d2:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420a1d9:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a1dc:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420a1e2:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a1e9:	00 00 00 
  800420a1ec:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420a1f3:	83 ca 80             	or     $0xffffff80,%edx
  800420a1f6:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420a1fc:	48 b8 c2 b9 20 04 80 	movabs $0x800420b9c2,%rax
  800420a203:	00 00 00 
  800420a206:	48 c1 e8 10          	shr    $0x10,%rax
  800420a20a:	89 c2                	mov    %eax,%edx
  800420a20c:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a213:	00 00 00 
  800420a216:	66 89 90 16 02 00 00 	mov    %dx,0x216(%rax)
  800420a21d:	48 b8 c2 b9 20 04 80 	movabs $0x800420b9c2,%rax
  800420a224:	00 00 00 
  800420a227:	48 c1 e8 20          	shr    $0x20,%rax
  800420a22b:	89 c2                	mov    %eax,%edx
  800420a22d:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a234:	00 00 00 
  800420a237:	89 90 18 02 00 00    	mov    %edx,0x218(%rax)
  800420a23d:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a244:	00 00 00 
  800420a247:	c7 80 1c 02 00 00 00 	movl   $0x0,0x21c(%rax)
  800420a24e:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + IRQ_SERIAL], 0, GD_KT, __irq_serial, 0);
  800420a251:	48 b8 cc b9 20 04 80 	movabs $0x800420b9cc,%rax
  800420a258:	00 00 00 
  800420a25b:	89 c2                	mov    %eax,%edx
  800420a25d:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a264:	00 00 00 
  800420a267:	66 89 90 40 02 00 00 	mov    %dx,0x240(%rax)
  800420a26e:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a275:	00 00 00 
  800420a278:	66 c7 80 42 02 00 00 	movw   $0x8,0x242(%rax)
  800420a27f:	08 00 
  800420a281:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a288:	00 00 00 
  800420a28b:	0f b6 90 44 02 00 00 	movzbl 0x244(%rax),%edx
  800420a292:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a295:	88 90 44 02 00 00    	mov    %dl,0x244(%rax)
  800420a29b:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a2a2:	00 00 00 
  800420a2a5:	0f b6 90 44 02 00 00 	movzbl 0x244(%rax),%edx
  800420a2ac:	83 e2 07             	and    $0x7,%edx
  800420a2af:	88 90 44 02 00 00    	mov    %dl,0x244(%rax)
  800420a2b5:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a2bc:	00 00 00 
  800420a2bf:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420a2c6:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a2c9:	83 ca 0e             	or     $0xe,%edx
  800420a2cc:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420a2d2:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a2d9:	00 00 00 
  800420a2dc:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420a2e3:	83 e2 ef             	and    $0xffffffef,%edx
  800420a2e6:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420a2ec:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a2f3:	00 00 00 
  800420a2f6:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420a2fd:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a300:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420a306:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a30d:	00 00 00 
  800420a310:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420a317:	83 ca 80             	or     $0xffffff80,%edx
  800420a31a:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420a320:	48 b8 cc b9 20 04 80 	movabs $0x800420b9cc,%rax
  800420a327:	00 00 00 
  800420a32a:	48 c1 e8 10          	shr    $0x10,%rax
  800420a32e:	89 c2                	mov    %eax,%edx
  800420a330:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a337:	00 00 00 
  800420a33a:	66 89 90 46 02 00 00 	mov    %dx,0x246(%rax)
  800420a341:	48 b8 cc b9 20 04 80 	movabs $0x800420b9cc,%rax
  800420a348:	00 00 00 
  800420a34b:	48 c1 e8 20          	shr    $0x20,%rax
  800420a34f:	89 c2                	mov    %eax,%edx
  800420a351:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a358:	00 00 00 
  800420a35b:	89 90 48 02 00 00    	mov    %edx,0x248(%rax)
  800420a361:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a368:	00 00 00 
  800420a36b:	c7 80 4c 02 00 00 00 	movl   $0x0,0x24c(%rax)
  800420a372:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + IRQ_SPURIOUS], 0, GD_KT, __irq_spurious, 0);
  800420a375:	48 b8 d6 b9 20 04 80 	movabs $0x800420b9d6,%rax
  800420a37c:	00 00 00 
  800420a37f:	89 c2                	mov    %eax,%edx
  800420a381:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a388:	00 00 00 
  800420a38b:	66 89 90 70 02 00 00 	mov    %dx,0x270(%rax)
  800420a392:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a399:	00 00 00 
  800420a39c:	66 c7 80 72 02 00 00 	movw   $0x8,0x272(%rax)
  800420a3a3:	08 00 
  800420a3a5:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a3ac:	00 00 00 
  800420a3af:	0f b6 90 74 02 00 00 	movzbl 0x274(%rax),%edx
  800420a3b6:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a3b9:	88 90 74 02 00 00    	mov    %dl,0x274(%rax)
  800420a3bf:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a3c6:	00 00 00 
  800420a3c9:	0f b6 90 74 02 00 00 	movzbl 0x274(%rax),%edx
  800420a3d0:	83 e2 07             	and    $0x7,%edx
  800420a3d3:	88 90 74 02 00 00    	mov    %dl,0x274(%rax)
  800420a3d9:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a3e0:	00 00 00 
  800420a3e3:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420a3ea:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a3ed:	83 ca 0e             	or     $0xe,%edx
  800420a3f0:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420a3f6:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a3fd:	00 00 00 
  800420a400:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420a407:	83 e2 ef             	and    $0xffffffef,%edx
  800420a40a:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420a410:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a417:	00 00 00 
  800420a41a:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420a421:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a424:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420a42a:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a431:	00 00 00 
  800420a434:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420a43b:	83 ca 80             	or     $0xffffff80,%edx
  800420a43e:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420a444:	48 b8 d6 b9 20 04 80 	movabs $0x800420b9d6,%rax
  800420a44b:	00 00 00 
  800420a44e:	48 c1 e8 10          	shr    $0x10,%rax
  800420a452:	89 c2                	mov    %eax,%edx
  800420a454:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a45b:	00 00 00 
  800420a45e:	66 89 90 76 02 00 00 	mov    %dx,0x276(%rax)
  800420a465:	48 b8 d6 b9 20 04 80 	movabs $0x800420b9d6,%rax
  800420a46c:	00 00 00 
  800420a46f:	48 c1 e8 20          	shr    $0x20,%rax
  800420a473:	89 c2                	mov    %eax,%edx
  800420a475:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a47c:	00 00 00 
  800420a47f:	89 90 78 02 00 00    	mov    %edx,0x278(%rax)
  800420a485:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a48c:	00 00 00 
  800420a48f:	c7 80 7c 02 00 00 00 	movl   $0x0,0x27c(%rax)
  800420a496:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + IRQ_IDE], 0, GD_KT, __irq_ide, 0);
  800420a499:	48 b8 e0 b9 20 04 80 	movabs $0x800420b9e0,%rax
  800420a4a0:	00 00 00 
  800420a4a3:	89 c2                	mov    %eax,%edx
  800420a4a5:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a4ac:	00 00 00 
  800420a4af:	66 89 90 e0 02 00 00 	mov    %dx,0x2e0(%rax)
  800420a4b6:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a4bd:	00 00 00 
  800420a4c0:	66 c7 80 e2 02 00 00 	movw   $0x8,0x2e2(%rax)
  800420a4c7:	08 00 
  800420a4c9:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a4d0:	00 00 00 
  800420a4d3:	0f b6 90 e4 02 00 00 	movzbl 0x2e4(%rax),%edx
  800420a4da:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a4dd:	88 90 e4 02 00 00    	mov    %dl,0x2e4(%rax)
  800420a4e3:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a4ea:	00 00 00 
  800420a4ed:	0f b6 90 e4 02 00 00 	movzbl 0x2e4(%rax),%edx
  800420a4f4:	83 e2 07             	and    $0x7,%edx
  800420a4f7:	88 90 e4 02 00 00    	mov    %dl,0x2e4(%rax)
  800420a4fd:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a504:	00 00 00 
  800420a507:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420a50e:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a511:	83 ca 0e             	or     $0xe,%edx
  800420a514:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420a51a:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a521:	00 00 00 
  800420a524:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420a52b:	83 e2 ef             	and    $0xffffffef,%edx
  800420a52e:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420a534:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a53b:	00 00 00 
  800420a53e:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420a545:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a548:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420a54e:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a555:	00 00 00 
  800420a558:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420a55f:	83 ca 80             	or     $0xffffff80,%edx
  800420a562:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420a568:	48 b8 e0 b9 20 04 80 	movabs $0x800420b9e0,%rax
  800420a56f:	00 00 00 
  800420a572:	48 c1 e8 10          	shr    $0x10,%rax
  800420a576:	89 c2                	mov    %eax,%edx
  800420a578:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a57f:	00 00 00 
  800420a582:	66 89 90 e6 02 00 00 	mov    %dx,0x2e6(%rax)
  800420a589:	48 b8 e0 b9 20 04 80 	movabs $0x800420b9e0,%rax
  800420a590:	00 00 00 
  800420a593:	48 c1 e8 20          	shr    $0x20,%rax
  800420a597:	89 c2                	mov    %eax,%edx
  800420a599:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a5a0:	00 00 00 
  800420a5a3:	89 90 e8 02 00 00    	mov    %edx,0x2e8(%rax)
  800420a5a9:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a5b0:	00 00 00 
  800420a5b3:	c7 80 ec 02 00 00 00 	movl   $0x0,0x2ec(%rax)
  800420a5ba:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + IRQ_ERROR], 0, GD_KT, __irq_error, 0);
  800420a5bd:	48 b8 ea b9 20 04 80 	movabs $0x800420b9ea,%rax
  800420a5c4:	00 00 00 
  800420a5c7:	89 c2                	mov    %eax,%edx
  800420a5c9:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a5d0:	00 00 00 
  800420a5d3:	66 89 90 30 03 00 00 	mov    %dx,0x330(%rax)
  800420a5da:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a5e1:	00 00 00 
  800420a5e4:	66 c7 80 32 03 00 00 	movw   $0x8,0x332(%rax)
  800420a5eb:	08 00 
  800420a5ed:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a5f4:	00 00 00 
  800420a5f7:	0f b6 90 34 03 00 00 	movzbl 0x334(%rax),%edx
  800420a5fe:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a601:	88 90 34 03 00 00    	mov    %dl,0x334(%rax)
  800420a607:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a60e:	00 00 00 
  800420a611:	0f b6 90 34 03 00 00 	movzbl 0x334(%rax),%edx
  800420a618:	83 e2 07             	and    $0x7,%edx
  800420a61b:	88 90 34 03 00 00    	mov    %dl,0x334(%rax)
  800420a621:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a628:	00 00 00 
  800420a62b:	0f b6 90 35 03 00 00 	movzbl 0x335(%rax),%edx
  800420a632:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a635:	83 ca 0e             	or     $0xe,%edx
  800420a638:	88 90 35 03 00 00    	mov    %dl,0x335(%rax)
  800420a63e:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a645:	00 00 00 
  800420a648:	0f b6 90 35 03 00 00 	movzbl 0x335(%rax),%edx
  800420a64f:	83 e2 ef             	and    $0xffffffef,%edx
  800420a652:	88 90 35 03 00 00    	mov    %dl,0x335(%rax)
  800420a658:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a65f:	00 00 00 
  800420a662:	0f b6 90 35 03 00 00 	movzbl 0x335(%rax),%edx
  800420a669:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a66c:	88 90 35 03 00 00    	mov    %dl,0x335(%rax)
  800420a672:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a679:	00 00 00 
  800420a67c:	0f b6 90 35 03 00 00 	movzbl 0x335(%rax),%edx
  800420a683:	83 ca 80             	or     $0xffffff80,%edx
  800420a686:	88 90 35 03 00 00    	mov    %dl,0x335(%rax)
  800420a68c:	48 b8 ea b9 20 04 80 	movabs $0x800420b9ea,%rax
  800420a693:	00 00 00 
  800420a696:	48 c1 e8 10          	shr    $0x10,%rax
  800420a69a:	89 c2                	mov    %eax,%edx
  800420a69c:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a6a3:	00 00 00 
  800420a6a6:	66 89 90 36 03 00 00 	mov    %dx,0x336(%rax)
  800420a6ad:	48 b8 ea b9 20 04 80 	movabs $0x800420b9ea,%rax
  800420a6b4:	00 00 00 
  800420a6b7:	48 c1 e8 20          	shr    $0x20,%rax
  800420a6bb:	89 c2                	mov    %eax,%edx
  800420a6bd:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a6c4:	00 00 00 
  800420a6c7:	89 90 38 03 00 00    	mov    %edx,0x338(%rax)
  800420a6cd:	48 b8 80 52 49 04 80 	movabs $0x8004495280,%rax
  800420a6d4:	00 00 00 
  800420a6d7:	c7 80 3c 03 00 00 00 	movl   $0x0,0x33c(%rax)
  800420a6de:	00 00 00 
	SETGATE(idt[T_MCHK], 1, GD_KT, __trap_mchk, 0);
	SETGATE(idt[T_SIMDERR], 1, GD_KT, __trap_simderr, 0);
	SETGATE(idt[T_SYSCALL], 0, GD_KT, __trap_syscall, 3);
	*/

	idt_pd.pd_lim = sizeof(idt)-1;
  800420a6e1:	48 b8 80 62 49 04 80 	movabs $0x8004496280,%rax
  800420a6e8:	00 00 00 
  800420a6eb:	66 c7 00 ff 0f       	movw   $0xfff,(%rax)
	idt_pd.pd_base = (uint64_t)idt;
  800420a6f0:	48 ba 80 52 49 04 80 	movabs $0x8004495280,%rdx
  800420a6f7:	00 00 00 
  800420a6fa:	48 b8 80 62 49 04 80 	movabs $0x8004496280,%rax
  800420a701:	00 00 00 
  800420a704:	48 89 50 02          	mov    %rdx,0x2(%rax)
	// Per-CPU setup
	trap_init_percpu();
  800420a708:	48 b8 16 a7 20 04 80 	movabs $0x800420a716,%rax
  800420a70f:	00 00 00 
  800420a712:	ff d0                	callq  *%rax
}
  800420a714:	5d                   	pop    %rbp
  800420a715:	c3                   	retq   

000000800420a716 <trap_init_percpu>:

// Initialize and load the per-CPU TSS and IDT
void
trap_init_percpu(void)
{
  800420a716:	55                   	push   %rbp
  800420a717:	48 89 e5             	mov    %rsp,%rbp
  800420a71a:	53                   	push   %rbx
  800420a71b:	48 83 ec 18          	sub    $0x18,%rsp
	// user space on that CPU.
	//
	// LAB 4: Your code here:

	// note: calculate gdt_index for further use
	int idx = (GD_TSS0 >> 3) + 2 * thiscpu->cpu_id;
  800420a71f:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420a726:	00 00 00 
  800420a729:	ff d0                	callq  *%rax
  800420a72b:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  800420a732:	00 00 00 
  800420a735:	48 98                	cltq   
  800420a737:	48 c1 e0 03          	shl    $0x3,%rax
  800420a73b:	48 89 c2             	mov    %rax,%rdx
  800420a73e:	48 c1 e2 04          	shl    $0x4,%rdx
  800420a742:	48 29 c2             	sub    %rax,%rdx
  800420a745:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420a749:	0f b6 00             	movzbl (%rax),%eax
  800420a74c:	0f b6 c0             	movzbl %al,%eax
  800420a74f:	01 c0                	add    %eax,%eax
  800420a751:	83 c0 05             	add    $0x5,%eax
  800420a754:	89 45 ec             	mov    %eax,-0x14(%rbp)

	// note: modified from original given code
	thiscpu->cpu_ts.ts_esp0 = KSTACKTOP - thiscpu->cpu_id * (KSTKSIZE + KSTKGAP);
  800420a757:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420a75e:	00 00 00 
  800420a761:	ff d0                	callq  *%rax
  800420a763:	89 c3                	mov    %eax,%ebx
  800420a765:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420a76c:	00 00 00 
  800420a76f:	ff d0                	callq  *%rax
  800420a771:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  800420a778:	00 00 00 
  800420a77b:	48 98                	cltq   
  800420a77d:	48 c1 e0 03          	shl    $0x3,%rax
  800420a781:	48 89 c2             	mov    %rax,%rdx
  800420a784:	48 c1 e2 04          	shl    $0x4,%rdx
  800420a788:	48 29 c2             	sub    %rax,%rdx
  800420a78b:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420a78f:	0f b6 00             	movzbl (%rax),%eax
  800420a792:	0f b6 d0             	movzbl %al,%edx
  800420a795:	89 d0                	mov    %edx,%eax
  800420a797:	01 c0                	add    %eax,%eax
  800420a799:	01 d0                	add    %edx,%eax
  800420a79b:	c1 e0 0f             	shl    $0xf,%eax
  800420a79e:	48 98                	cltq   
  800420a7a0:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420a7a7:	00 00 00 
  800420a7aa:	48 29 c2             	sub    %rax,%rdx
  800420a7ad:	48 89 d0             	mov    %rdx,%rax
  800420a7b0:	48 89 c1             	mov    %rax,%rcx
  800420a7b3:	48 be 20 80 49 04 80 	movabs $0x8004498020,%rsi
  800420a7ba:	00 00 00 
  800420a7bd:	48 63 c3             	movslq %ebx,%rax
  800420a7c0:	48 c1 e0 03          	shl    $0x3,%rax
  800420a7c4:	48 89 c2             	mov    %rax,%rdx
  800420a7c7:	48 c1 e2 04          	shl    $0x4,%rdx
  800420a7cb:	48 29 c2             	sub    %rax,%rdx
  800420a7ce:	48 8d 04 16          	lea    (%rsi,%rdx,1),%rax
  800420a7d2:	48 83 c0 10          	add    $0x10,%rax
  800420a7d6:	48 89 48 04          	mov    %rcx,0x4(%rax)
	SETTSS((struct SystemSegdesc64 *)(&gdt[idx]), STS_T64A, (uint64_t)(&thiscpu->cpu_ts),sizeof(struct Taskstate), 0);
  800420a7da:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420a7dd:	48 98                	cltq   
  800420a7df:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420a7e6:	00 
  800420a7e7:	48 b8 e0 b5 22 04 80 	movabs $0x800422b5e0,%rax
  800420a7ee:	00 00 00 
  800420a7f1:	48 01 d0             	add    %rdx,%rax
  800420a7f4:	66 c7 00 68 00       	movw   $0x68,(%rax)
  800420a7f9:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420a7fc:	48 98                	cltq   
  800420a7fe:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420a805:	00 
  800420a806:	48 b8 e0 b5 22 04 80 	movabs $0x800422b5e0,%rax
  800420a80d:	00 00 00 
  800420a810:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800420a814:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420a81b:	00 00 00 
  800420a81e:	ff d0                	callq  *%rax
  800420a820:	48 98                	cltq   
  800420a822:	48 c1 e0 03          	shl    $0x3,%rax
  800420a826:	48 89 c2             	mov    %rax,%rdx
  800420a829:	48 c1 e2 04          	shl    $0x4,%rdx
  800420a82d:	48 29 c2             	sub    %rax,%rdx
  800420a830:	48 83 c2 10          	add    $0x10,%rdx
  800420a834:	48 b8 20 80 49 04 80 	movabs $0x8004498020,%rax
  800420a83b:	00 00 00 
  800420a83e:	48 01 d0             	add    %rdx,%rax
  800420a841:	66 89 43 02          	mov    %ax,0x2(%rbx)
  800420a845:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420a848:	48 98                	cltq   
  800420a84a:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420a851:	00 
  800420a852:	48 b8 e0 b5 22 04 80 	movabs $0x800422b5e0,%rax
  800420a859:	00 00 00 
  800420a85c:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800420a860:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420a867:	00 00 00 
  800420a86a:	ff d0                	callq  *%rax
  800420a86c:	48 98                	cltq   
  800420a86e:	48 c1 e0 03          	shl    $0x3,%rax
  800420a872:	48 89 c2             	mov    %rax,%rdx
  800420a875:	48 c1 e2 04          	shl    $0x4,%rdx
  800420a879:	48 29 c2             	sub    %rax,%rdx
  800420a87c:	48 83 c2 10          	add    $0x10,%rdx
  800420a880:	48 b8 20 80 49 04 80 	movabs $0x8004498020,%rax
  800420a887:	00 00 00 
  800420a88a:	48 01 d0             	add    %rdx,%rax
  800420a88d:	48 c1 e8 10          	shr    $0x10,%rax
  800420a891:	88 43 04             	mov    %al,0x4(%rbx)
  800420a894:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420a897:	48 98                	cltq   
  800420a899:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420a8a0:	00 
  800420a8a1:	48 b8 e0 b5 22 04 80 	movabs $0x800422b5e0,%rax
  800420a8a8:	00 00 00 
  800420a8ab:	48 01 d0             	add    %rdx,%rax
  800420a8ae:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420a8b2:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a8b5:	83 ca 09             	or     $0x9,%edx
  800420a8b8:	88 50 05             	mov    %dl,0x5(%rax)
  800420a8bb:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420a8be:	48 98                	cltq   
  800420a8c0:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420a8c7:	00 
  800420a8c8:	48 b8 e0 b5 22 04 80 	movabs $0x800422b5e0,%rax
  800420a8cf:	00 00 00 
  800420a8d2:	48 01 d0             	add    %rdx,%rax
  800420a8d5:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420a8d9:	83 e2 ef             	and    $0xffffffef,%edx
  800420a8dc:	88 50 05             	mov    %dl,0x5(%rax)
  800420a8df:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420a8e2:	48 98                	cltq   
  800420a8e4:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420a8eb:	00 
  800420a8ec:	48 b8 e0 b5 22 04 80 	movabs $0x800422b5e0,%rax
  800420a8f3:	00 00 00 
  800420a8f6:	48 01 d0             	add    %rdx,%rax
  800420a8f9:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420a8fd:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a900:	88 50 05             	mov    %dl,0x5(%rax)
  800420a903:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420a906:	48 98                	cltq   
  800420a908:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420a90f:	00 
  800420a910:	48 b8 e0 b5 22 04 80 	movabs $0x800422b5e0,%rax
  800420a917:	00 00 00 
  800420a91a:	48 01 d0             	add    %rdx,%rax
  800420a91d:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420a921:	83 ca 80             	or     $0xffffff80,%edx
  800420a924:	88 50 05             	mov    %dl,0x5(%rax)
  800420a927:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420a92a:	48 98                	cltq   
  800420a92c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420a933:	00 
  800420a934:	48 b8 e0 b5 22 04 80 	movabs $0x800422b5e0,%rax
  800420a93b:	00 00 00 
  800420a93e:	48 01 d0             	add    %rdx,%rax
  800420a941:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420a945:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a948:	88 50 06             	mov    %dl,0x6(%rax)
  800420a94b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420a94e:	48 98                	cltq   
  800420a950:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420a957:	00 
  800420a958:	48 b8 e0 b5 22 04 80 	movabs $0x800422b5e0,%rax
  800420a95f:	00 00 00 
  800420a962:	48 01 d0             	add    %rdx,%rax
  800420a965:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420a969:	83 e2 ef             	and    $0xffffffef,%edx
  800420a96c:	88 50 06             	mov    %dl,0x6(%rax)
  800420a96f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420a972:	48 98                	cltq   
  800420a974:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420a97b:	00 
  800420a97c:	48 b8 e0 b5 22 04 80 	movabs $0x800422b5e0,%rax
  800420a983:	00 00 00 
  800420a986:	48 01 d0             	add    %rdx,%rax
  800420a989:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420a98d:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a990:	88 50 06             	mov    %dl,0x6(%rax)
  800420a993:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420a996:	48 98                	cltq   
  800420a998:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420a99f:	00 
  800420a9a0:	48 b8 e0 b5 22 04 80 	movabs $0x800422b5e0,%rax
  800420a9a7:	00 00 00 
  800420a9aa:	48 01 d0             	add    %rdx,%rax
  800420a9ad:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420a9b1:	83 e2 7f             	and    $0x7f,%edx
  800420a9b4:	88 50 06             	mov    %dl,0x6(%rax)
  800420a9b7:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420a9ba:	48 98                	cltq   
  800420a9bc:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420a9c3:	00 
  800420a9c4:	48 b8 e0 b5 22 04 80 	movabs $0x800422b5e0,%rax
  800420a9cb:	00 00 00 
  800420a9ce:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800420a9d2:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420a9d9:	00 00 00 
  800420a9dc:	ff d0                	callq  *%rax
  800420a9de:	48 98                	cltq   
  800420a9e0:	48 c1 e0 03          	shl    $0x3,%rax
  800420a9e4:	48 89 c2             	mov    %rax,%rdx
  800420a9e7:	48 c1 e2 04          	shl    $0x4,%rdx
  800420a9eb:	48 29 c2             	sub    %rax,%rdx
  800420a9ee:	48 83 c2 10          	add    $0x10,%rdx
  800420a9f2:	48 b8 20 80 49 04 80 	movabs $0x8004498020,%rax
  800420a9f9:	00 00 00 
  800420a9fc:	48 01 d0             	add    %rdx,%rax
  800420a9ff:	48 c1 e8 18          	shr    $0x18,%rax
  800420aa03:	88 43 07             	mov    %al,0x7(%rbx)
  800420aa06:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420aa09:	48 98                	cltq   
  800420aa0b:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420aa12:	00 
  800420aa13:	48 b8 e0 b5 22 04 80 	movabs $0x800422b5e0,%rax
  800420aa1a:	00 00 00 
  800420aa1d:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800420aa21:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420aa28:	00 00 00 
  800420aa2b:	ff d0                	callq  *%rax
  800420aa2d:	48 98                	cltq   
  800420aa2f:	48 c1 e0 03          	shl    $0x3,%rax
  800420aa33:	48 89 c2             	mov    %rax,%rdx
  800420aa36:	48 c1 e2 04          	shl    $0x4,%rdx
  800420aa3a:	48 29 c2             	sub    %rax,%rdx
  800420aa3d:	48 83 c2 10          	add    $0x10,%rdx
  800420aa41:	48 b8 20 80 49 04 80 	movabs $0x8004498020,%rax
  800420aa48:	00 00 00 
  800420aa4b:	48 01 d0             	add    %rdx,%rax
  800420aa4e:	48 c1 e8 20          	shr    $0x20,%rax
  800420aa52:	89 43 08             	mov    %eax,0x8(%rbx)
  800420aa55:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420aa58:	48 98                	cltq   
  800420aa5a:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420aa61:	00 
  800420aa62:	48 b8 e0 b5 22 04 80 	movabs $0x800422b5e0,%rax
  800420aa69:	00 00 00 
  800420aa6c:	48 01 d0             	add    %rdx,%rax
  800420aa6f:	c6 40 0c 00          	movb   $0x0,0xc(%rax)
  800420aa73:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420aa76:	48 98                	cltq   
  800420aa78:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420aa7f:	00 
  800420aa80:	48 b8 e0 b5 22 04 80 	movabs $0x800422b5e0,%rax
  800420aa87:	00 00 00 
  800420aa8a:	48 01 d0             	add    %rdx,%rax
  800420aa8d:	c6 40 0d 00          	movb   $0x0,0xd(%rax)
  800420aa91:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420aa94:	48 98                	cltq   
  800420aa96:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420aa9d:	00 
  800420aa9e:	48 b8 e0 b5 22 04 80 	movabs $0x800422b5e0,%rax
  800420aaa5:	00 00 00 
  800420aaa8:	48 01 d0             	add    %rdx,%rax
  800420aaab:	66 c7 40 0e 00 00    	movw   $0x0,0xe(%rax)
	ltr(idx << 3);
  800420aab1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420aab4:	c1 e0 03             	shl    $0x3,%eax
  800420aab7:	0f b7 c0             	movzwl %ax,%eax
  800420aaba:	66 89 45 ea          	mov    %ax,-0x16(%rbp)
	__asm __volatile("lgdt (%0)" : : "r" (p));
}
static __inline void
ltr(uint16_t sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
  800420aabe:	0f b7 45 ea          	movzwl -0x16(%rbp),%eax
  800420aac2:	0f 00 d8             	ltr    %ax
  800420aac5:	48 b8 80 62 49 04 80 	movabs $0x8004496280,%rax
  800420aacc:	00 00 00 
  800420aacf:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
}  

static __inline void
lidt(void *p)
{
	__asm __volatile("lidt (%0)" : : "r" (p));
  800420aad3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420aad7:	0f 01 18             	lidt   (%rax)
	// bottom three bits are special; we leave them 0)
	//ltr(GD_TSS0);

	// Load the IDT
	lidt(&idt_pd);
}
  800420aada:	48 83 c4 18          	add    $0x18,%rsp
  800420aade:	5b                   	pop    %rbx
  800420aadf:	5d                   	pop    %rbp
  800420aae0:	c3                   	retq   

000000800420aae1 <print_trapframe>:

void
print_trapframe(struct Trapframe *tf)
{
  800420aae1:	55                   	push   %rbp
  800420aae2:	48 89 e5             	mov    %rsp,%rbp
  800420aae5:	48 83 ec 20          	sub    $0x20,%rsp
  800420aae9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	cprintf("TRAP frame at %p from CPU %d\n", tf, cpunum());
  800420aaed:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420aaf4:	00 00 00 
  800420aaf7:	ff d0                	callq  *%rax
  800420aaf9:	89 c2                	mov    %eax,%edx
  800420aafb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420aaff:	48 89 c6             	mov    %rax,%rsi
  800420ab02:	48 bf 8e 71 21 04 80 	movabs $0x800421718e,%rdi
  800420ab09:	00 00 00 
  800420ab0c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ab11:	48 b9 7a 8a 20 04 80 	movabs $0x8004208a7a,%rcx
  800420ab18:	00 00 00 
  800420ab1b:	ff d1                	callq  *%rcx
	print_regs(&tf->tf_regs);
  800420ab1d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ab21:	48 89 c7             	mov    %rax,%rdi
  800420ab24:	48 b8 f2 ad 20 04 80 	movabs $0x800420adf2,%rax
  800420ab2b:	00 00 00 
  800420ab2e:	ff d0                	callq  *%rax
	cprintf("  es   0x----%04x\n", tf->tf_es);
  800420ab30:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ab34:	0f b7 40 78          	movzwl 0x78(%rax),%eax
  800420ab38:	0f b7 c0             	movzwl %ax,%eax
  800420ab3b:	89 c6                	mov    %eax,%esi
  800420ab3d:	48 bf ac 71 21 04 80 	movabs $0x80042171ac,%rdi
  800420ab44:	00 00 00 
  800420ab47:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ab4c:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  800420ab53:	00 00 00 
  800420ab56:	ff d2                	callq  *%rdx
	cprintf("  ds   0x----%04x\n", tf->tf_ds);
  800420ab58:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ab5c:	0f b7 80 80 00 00 00 	movzwl 0x80(%rax),%eax
  800420ab63:	0f b7 c0             	movzwl %ax,%eax
  800420ab66:	89 c6                	mov    %eax,%esi
  800420ab68:	48 bf bf 71 21 04 80 	movabs $0x80042171bf,%rdi
  800420ab6f:	00 00 00 
  800420ab72:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ab77:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  800420ab7e:	00 00 00 
  800420ab81:	ff d2                	callq  *%rdx
	cprintf("  trap 0x%08x %s\n", tf->tf_trapno, trapname(tf->tf_trapno));
  800420ab83:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ab87:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420ab8e:	89 c7                	mov    %eax,%edi
  800420ab90:	48 b8 93 8b 20 04 80 	movabs $0x8004208b93,%rax
  800420ab97:	00 00 00 
  800420ab9a:	ff d0                	callq  *%rax
  800420ab9c:	48 89 c2             	mov    %rax,%rdx
  800420ab9f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420aba3:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420abaa:	48 89 c6             	mov    %rax,%rsi
  800420abad:	48 bf d2 71 21 04 80 	movabs $0x80042171d2,%rdi
  800420abb4:	00 00 00 
  800420abb7:	b8 00 00 00 00       	mov    $0x0,%eax
  800420abbc:	48 b9 7a 8a 20 04 80 	movabs $0x8004208a7a,%rcx
  800420abc3:	00 00 00 
  800420abc6:	ff d1                	callq  *%rcx
	// If this trap was a page fault that just happened
	// (so %cr2 is meaningful), print the faulting linear address.
	if (tf == last_tf && tf->tf_trapno == T_PGFLT)
  800420abc8:	48 b8 08 63 49 04 80 	movabs $0x8004496308,%rax
  800420abcf:	00 00 00 
  800420abd2:	48 8b 00             	mov    (%rax),%rax
  800420abd5:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  800420abd9:	75 3a                	jne    800420ac15 <print_trapframe+0x134>
  800420abdb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420abdf:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420abe6:	48 83 f8 0e          	cmp    $0xe,%rax
  800420abea:	75 29                	jne    800420ac15 <print_trapframe+0x134>

static __inline uint64_t
rcr2(void)
{
	uint64_t val;
	__asm __volatile("movq %%cr2,%0" : "=r" (val));
  800420abec:	0f 20 d0             	mov    %cr2,%rax
  800420abef:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return val;
  800420abf3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
		cprintf("  cr2  0x%08x\n", rcr2());
  800420abf7:	48 89 c6             	mov    %rax,%rsi
  800420abfa:	48 bf e4 71 21 04 80 	movabs $0x80042171e4,%rdi
  800420ac01:	00 00 00 
  800420ac04:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ac09:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  800420ac10:	00 00 00 
  800420ac13:	ff d2                	callq  *%rdx
	cprintf("  err  0x%08x", tf->tf_err);
  800420ac15:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ac19:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420ac20:	48 89 c6             	mov    %rax,%rsi
  800420ac23:	48 bf f3 71 21 04 80 	movabs $0x80042171f3,%rdi
  800420ac2a:	00 00 00 
  800420ac2d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ac32:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  800420ac39:	00 00 00 
  800420ac3c:	ff d2                	callq  *%rdx
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
  800420ac3e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ac42:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420ac49:	48 83 f8 0e          	cmp    $0xe,%rax
  800420ac4d:	0f 85 9c 00 00 00    	jne    800420acef <print_trapframe+0x20e>
		cprintf(" [%s, %s, %s]\n",
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
			tf->tf_err & 1 ? "protection" : "not-present");
  800420ac53:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ac57:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420ac5e:	83 e0 01             	and    $0x1,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420ac61:	48 85 c0             	test   %rax,%rax
  800420ac64:	74 0c                	je     800420ac72 <print_trapframe+0x191>
  800420ac66:	48 b9 01 72 21 04 80 	movabs $0x8004217201,%rcx
  800420ac6d:	00 00 00 
  800420ac70:	eb 0a                	jmp    800420ac7c <print_trapframe+0x19b>
  800420ac72:	48 b9 0c 72 21 04 80 	movabs $0x800421720c,%rcx
  800420ac79:	00 00 00 
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
  800420ac7c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ac80:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420ac87:	83 e0 02             	and    $0x2,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420ac8a:	48 85 c0             	test   %rax,%rax
  800420ac8d:	74 0c                	je     800420ac9b <print_trapframe+0x1ba>
  800420ac8f:	48 ba 18 72 21 04 80 	movabs $0x8004217218,%rdx
  800420ac96:	00 00 00 
  800420ac99:	eb 0a                	jmp    800420aca5 <print_trapframe+0x1c4>
  800420ac9b:	48 ba 1e 72 21 04 80 	movabs $0x800421721e,%rdx
  800420aca2:	00 00 00 
			tf->tf_err & 4 ? "user" : "kernel",
  800420aca5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420aca9:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420acb0:	83 e0 04             	and    $0x4,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420acb3:	48 85 c0             	test   %rax,%rax
  800420acb6:	74 0c                	je     800420acc4 <print_trapframe+0x1e3>
  800420acb8:	48 b8 23 72 21 04 80 	movabs $0x8004217223,%rax
  800420acbf:	00 00 00 
  800420acc2:	eb 0a                	jmp    800420acce <print_trapframe+0x1ed>
  800420acc4:	48 b8 28 72 21 04 80 	movabs $0x8004217228,%rax
  800420accb:	00 00 00 
  800420acce:	48 89 c6             	mov    %rax,%rsi
  800420acd1:	48 bf 2f 72 21 04 80 	movabs $0x800421722f,%rdi
  800420acd8:	00 00 00 
  800420acdb:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ace0:	49 b8 7a 8a 20 04 80 	movabs $0x8004208a7a,%r8
  800420ace7:	00 00 00 
  800420acea:	41 ff d0             	callq  *%r8
  800420aced:	eb 1b                	jmp    800420ad0a <print_trapframe+0x229>
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
			tf->tf_err & 1 ? "protection" : "not-present");
	else
		cprintf("\n");
  800420acef:	48 bf 3e 72 21 04 80 	movabs $0x800421723e,%rdi
  800420acf6:	00 00 00 
  800420acf9:	b8 00 00 00 00       	mov    $0x0,%eax
  800420acfe:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  800420ad05:	00 00 00 
  800420ad08:	ff d2                	callq  *%rdx
	cprintf("  rip  0x%08x\n", tf->tf_rip);
  800420ad0a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ad0e:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  800420ad15:	48 89 c6             	mov    %rax,%rsi
  800420ad18:	48 bf 40 72 21 04 80 	movabs $0x8004217240,%rdi
  800420ad1f:	00 00 00 
  800420ad22:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ad27:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  800420ad2e:	00 00 00 
  800420ad31:	ff d2                	callq  *%rdx
	cprintf("  cs   0x----%04x\n", tf->tf_cs);
  800420ad33:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ad37:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420ad3e:	0f b7 c0             	movzwl %ax,%eax
  800420ad41:	89 c6                	mov    %eax,%esi
  800420ad43:	48 bf 4f 72 21 04 80 	movabs $0x800421724f,%rdi
  800420ad4a:	00 00 00 
  800420ad4d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ad52:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  800420ad59:	00 00 00 
  800420ad5c:	ff d2                	callq  *%rdx
	cprintf("  flag 0x%08x\n", tf->tf_eflags);
  800420ad5e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ad62:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  800420ad69:	48 89 c6             	mov    %rax,%rsi
  800420ad6c:	48 bf 62 72 21 04 80 	movabs $0x8004217262,%rdi
  800420ad73:	00 00 00 
  800420ad76:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ad7b:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  800420ad82:	00 00 00 
  800420ad85:	ff d2                	callq  *%rdx
	if ((tf->tf_cs & 3) != 0) {
  800420ad87:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ad8b:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420ad92:	0f b7 c0             	movzwl %ax,%eax
  800420ad95:	83 e0 03             	and    $0x3,%eax
  800420ad98:	85 c0                	test   %eax,%eax
  800420ad9a:	74 54                	je     800420adf0 <print_trapframe+0x30f>
		cprintf("  rsp  0x%08x\n", tf->tf_rsp);
  800420ad9c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ada0:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  800420ada7:	48 89 c6             	mov    %rax,%rsi
  800420adaa:	48 bf 71 72 21 04 80 	movabs $0x8004217271,%rdi
  800420adb1:	00 00 00 
  800420adb4:	b8 00 00 00 00       	mov    $0x0,%eax
  800420adb9:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  800420adc0:	00 00 00 
  800420adc3:	ff d2                	callq  *%rdx
		cprintf("  ss   0x----%04x\n", tf->tf_ss);
  800420adc5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420adc9:	0f b7 80 b8 00 00 00 	movzwl 0xb8(%rax),%eax
  800420add0:	0f b7 c0             	movzwl %ax,%eax
  800420add3:	89 c6                	mov    %eax,%esi
  800420add5:	48 bf 80 72 21 04 80 	movabs $0x8004217280,%rdi
  800420addc:	00 00 00 
  800420addf:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ade4:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  800420adeb:	00 00 00 
  800420adee:	ff d2                	callq  *%rdx
	}
}
  800420adf0:	c9                   	leaveq 
  800420adf1:	c3                   	retq   

000000800420adf2 <print_regs>:

void
print_regs(struct PushRegs *regs)
{
  800420adf2:	55                   	push   %rbp
  800420adf3:	48 89 e5             	mov    %rsp,%rbp
  800420adf6:	48 83 ec 10          	sub    $0x10,%rsp
  800420adfa:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	cprintf("  r15  0x%08x\n", regs->reg_r15);
  800420adfe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ae02:	48 8b 00             	mov    (%rax),%rax
  800420ae05:	48 89 c6             	mov    %rax,%rsi
  800420ae08:	48 bf 93 72 21 04 80 	movabs $0x8004217293,%rdi
  800420ae0f:	00 00 00 
  800420ae12:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ae17:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  800420ae1e:	00 00 00 
  800420ae21:	ff d2                	callq  *%rdx
	cprintf("  r14  0x%08x\n", regs->reg_r14);
  800420ae23:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ae27:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420ae2b:	48 89 c6             	mov    %rax,%rsi
  800420ae2e:	48 bf a2 72 21 04 80 	movabs $0x80042172a2,%rdi
  800420ae35:	00 00 00 
  800420ae38:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ae3d:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  800420ae44:	00 00 00 
  800420ae47:	ff d2                	callq  *%rdx
	cprintf("  r13  0x%08x\n", regs->reg_r13);
  800420ae49:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ae4d:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420ae51:	48 89 c6             	mov    %rax,%rsi
  800420ae54:	48 bf b1 72 21 04 80 	movabs $0x80042172b1,%rdi
  800420ae5b:	00 00 00 
  800420ae5e:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ae63:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  800420ae6a:	00 00 00 
  800420ae6d:	ff d2                	callq  *%rdx
	cprintf("  r12  0x%08x\n", regs->reg_r12);
  800420ae6f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ae73:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420ae77:	48 89 c6             	mov    %rax,%rsi
  800420ae7a:	48 bf c0 72 21 04 80 	movabs $0x80042172c0,%rdi
  800420ae81:	00 00 00 
  800420ae84:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ae89:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  800420ae90:	00 00 00 
  800420ae93:	ff d2                	callq  *%rdx
	cprintf("  r11  0x%08x\n", regs->reg_r11);
  800420ae95:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ae99:	48 8b 40 20          	mov    0x20(%rax),%rax
  800420ae9d:	48 89 c6             	mov    %rax,%rsi
  800420aea0:	48 bf cf 72 21 04 80 	movabs $0x80042172cf,%rdi
  800420aea7:	00 00 00 
  800420aeaa:	b8 00 00 00 00       	mov    $0x0,%eax
  800420aeaf:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  800420aeb6:	00 00 00 
  800420aeb9:	ff d2                	callq  *%rdx
	cprintf("  r10  0x%08x\n", regs->reg_r10);
  800420aebb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420aebf:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420aec3:	48 89 c6             	mov    %rax,%rsi
  800420aec6:	48 bf de 72 21 04 80 	movabs $0x80042172de,%rdi
  800420aecd:	00 00 00 
  800420aed0:	b8 00 00 00 00       	mov    $0x0,%eax
  800420aed5:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  800420aedc:	00 00 00 
  800420aedf:	ff d2                	callq  *%rdx
	cprintf("  r9  0x%08x\n", regs->reg_r9);
  800420aee1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420aee5:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420aee9:	48 89 c6             	mov    %rax,%rsi
  800420aeec:	48 bf ed 72 21 04 80 	movabs $0x80042172ed,%rdi
  800420aef3:	00 00 00 
  800420aef6:	b8 00 00 00 00       	mov    $0x0,%eax
  800420aefb:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  800420af02:	00 00 00 
  800420af05:	ff d2                	callq  *%rdx
	cprintf("  r8  0x%08x\n", regs->reg_r8);
  800420af07:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420af0b:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420af0f:	48 89 c6             	mov    %rax,%rsi
  800420af12:	48 bf fb 72 21 04 80 	movabs $0x80042172fb,%rdi
  800420af19:	00 00 00 
  800420af1c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420af21:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  800420af28:	00 00 00 
  800420af2b:	ff d2                	callq  *%rdx
	cprintf("  rdi  0x%08x\n", regs->reg_rdi);
  800420af2d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420af31:	48 8b 40 48          	mov    0x48(%rax),%rax
  800420af35:	48 89 c6             	mov    %rax,%rsi
  800420af38:	48 bf 09 73 21 04 80 	movabs $0x8004217309,%rdi
  800420af3f:	00 00 00 
  800420af42:	b8 00 00 00 00       	mov    $0x0,%eax
  800420af47:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  800420af4e:	00 00 00 
  800420af51:	ff d2                	callq  *%rdx
	cprintf("  rsi  0x%08x\n", regs->reg_rsi);
  800420af53:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420af57:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420af5b:	48 89 c6             	mov    %rax,%rsi
  800420af5e:	48 bf 18 73 21 04 80 	movabs $0x8004217318,%rdi
  800420af65:	00 00 00 
  800420af68:	b8 00 00 00 00       	mov    $0x0,%eax
  800420af6d:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  800420af74:	00 00 00 
  800420af77:	ff d2                	callq  *%rdx
	cprintf("  rbp  0x%08x\n", regs->reg_rbp);
  800420af79:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420af7d:	48 8b 40 50          	mov    0x50(%rax),%rax
  800420af81:	48 89 c6             	mov    %rax,%rsi
  800420af84:	48 bf 27 73 21 04 80 	movabs $0x8004217327,%rdi
  800420af8b:	00 00 00 
  800420af8e:	b8 00 00 00 00       	mov    $0x0,%eax
  800420af93:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  800420af9a:	00 00 00 
  800420af9d:	ff d2                	callq  *%rdx
	cprintf("  rbx  0x%08x\n", regs->reg_rbx);
  800420af9f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420afa3:	48 8b 40 68          	mov    0x68(%rax),%rax
  800420afa7:	48 89 c6             	mov    %rax,%rsi
  800420afaa:	48 bf 36 73 21 04 80 	movabs $0x8004217336,%rdi
  800420afb1:	00 00 00 
  800420afb4:	b8 00 00 00 00       	mov    $0x0,%eax
  800420afb9:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  800420afc0:	00 00 00 
  800420afc3:	ff d2                	callq  *%rdx
	cprintf("  rdx  0x%08x\n", regs->reg_rdx);
  800420afc5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420afc9:	48 8b 40 58          	mov    0x58(%rax),%rax
  800420afcd:	48 89 c6             	mov    %rax,%rsi
  800420afd0:	48 bf 45 73 21 04 80 	movabs $0x8004217345,%rdi
  800420afd7:	00 00 00 
  800420afda:	b8 00 00 00 00       	mov    $0x0,%eax
  800420afdf:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  800420afe6:	00 00 00 
  800420afe9:	ff d2                	callq  *%rdx
	cprintf("  rcx  0x%08x\n", regs->reg_rcx);
  800420afeb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420afef:	48 8b 40 60          	mov    0x60(%rax),%rax
  800420aff3:	48 89 c6             	mov    %rax,%rsi
  800420aff6:	48 bf 54 73 21 04 80 	movabs $0x8004217354,%rdi
  800420affd:	00 00 00 
  800420b000:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b005:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  800420b00c:	00 00 00 
  800420b00f:	ff d2                	callq  *%rdx
	cprintf("  rax  0x%08x\n", regs->reg_rax);
  800420b011:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b015:	48 8b 40 70          	mov    0x70(%rax),%rax
  800420b019:	48 89 c6             	mov    %rax,%rsi
  800420b01c:	48 bf 63 73 21 04 80 	movabs $0x8004217363,%rdi
  800420b023:	00 00 00 
  800420b026:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b02b:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  800420b032:	00 00 00 
  800420b035:	ff d2                	callq  *%rdx
}
  800420b037:	c9                   	leaveq 
  800420b038:	c3                   	retq   

000000800420b039 <trap_dispatch>:

static void
trap_dispatch(struct Trapframe *tf)
{
  800420b039:	55                   	push   %rbp
  800420b03a:	48 89 e5             	mov    %rsp,%rbp
  800420b03d:	48 83 ec 10          	sub    $0x10,%rsp
  800420b041:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// Handle processor exceptions.
	// LAB 3: Your code here.
	switch(tf->tf_trapno) {
  800420b045:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b049:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b050:	48 83 f8 0e          	cmp    $0xe,%rax
  800420b054:	74 27                	je     800420b07d <trap_dispatch+0x44>
  800420b056:	48 83 f8 30          	cmp    $0x30,%rax
  800420b05a:	74 51                	je     800420b0ad <trap_dispatch+0x74>
  800420b05c:	48 83 f8 03          	cmp    $0x3,%rax
  800420b060:	74 33                	je     800420b095 <trap_dispatch+0x5c>
		case T_SYSCALL:
			tf->tf_regs.reg_rax = syscall(tf->tf_regs.reg_rax, tf->tf_regs.reg_rdx, tf->tf_regs.reg_rcx,
					tf->tf_regs.reg_rbx, tf->tf_regs.reg_rdi, tf->tf_regs.reg_rsi);
			return;
		default:
			break;
  800420b062:	90                   	nop
	}

	// Handle spurious interrupts
	// The hardware sometimes raises these because of noise on the
	// IRQ line or other reasons. We don't care.
	if (tf->tf_trapno == IRQ_OFFSET + IRQ_SPURIOUS) {
  800420b063:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b067:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b06e:	48 83 f8 27          	cmp    $0x27,%rax
  800420b072:	0f 85 bd 00 00 00    	jne    800420b135 <trap_dispatch+0xfc>
  800420b078:	e9 85 00 00 00       	jmpq   800420b102 <trap_dispatch+0xc9>
{
	// Handle processor exceptions.
	// LAB 3: Your code here.
	switch(tf->tf_trapno) {
		case T_PGFLT:
			page_fault_handler(tf);
  800420b07d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b081:	48 89 c7             	mov    %rax,%rdi
  800420b084:	48 b8 9d b5 20 04 80 	movabs $0x800420b59d,%rax
  800420b08b:	00 00 00 
  800420b08e:	ff d0                	callq  *%rax
			return;
  800420b090:	e9 9c 01 00 00       	jmpq   800420b231 <trap_dispatch+0x1f8>
		case T_BRKPT:
			monitor(tf);
  800420b095:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b099:	48 89 c7             	mov    %rax,%rdi
  800420b09c:	48 b8 9a 18 20 04 80 	movabs $0x800420189a,%rax
  800420b0a3:	00 00 00 
  800420b0a6:	ff d0                	callq  *%rax
			return;
  800420b0a8:	e9 84 01 00 00       	jmpq   800420b231 <trap_dispatch+0x1f8>
		case T_SYSCALL:
			tf->tf_regs.reg_rax = syscall(tf->tf_regs.reg_rax, tf->tf_regs.reg_rdx, tf->tf_regs.reg_rcx,
  800420b0ad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b0b1:	4c 8b 40 40          	mov    0x40(%rax),%r8
  800420b0b5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b0b9:	48 8b 78 48          	mov    0x48(%rax),%rdi
  800420b0bd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b0c1:	48 8b 48 68          	mov    0x68(%rax),%rcx
  800420b0c5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b0c9:	48 8b 50 60          	mov    0x60(%rax),%rdx
  800420b0cd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b0d1:	48 8b 70 58          	mov    0x58(%rax),%rsi
  800420b0d5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b0d9:	48 8b 40 70          	mov    0x70(%rax),%rax
  800420b0dd:	4d 89 c1             	mov    %r8,%r9
  800420b0e0:	49 89 f8             	mov    %rdi,%r8
  800420b0e3:	48 89 c7             	mov    %rax,%rdi
  800420b0e6:	48 b8 01 ca 20 04 80 	movabs $0x800420ca01,%rax
  800420b0ed:	00 00 00 
  800420b0f0:	ff d0                	callq  *%rax
  800420b0f2:	48 89 c2             	mov    %rax,%rdx
  800420b0f5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b0f9:	48 89 50 70          	mov    %rdx,0x70(%rax)
					tf->tf_regs.reg_rbx, tf->tf_regs.reg_rdi, tf->tf_regs.reg_rsi);
			return;
  800420b0fd:	e9 2f 01 00 00       	jmpq   800420b231 <trap_dispatch+0x1f8>

	// Handle spurious interrupts
	// The hardware sometimes raises these because of noise on the
	// IRQ line or other reasons. We don't care.
	if (tf->tf_trapno == IRQ_OFFSET + IRQ_SPURIOUS) {
		cprintf("Spurious interrupt on irq 7\n");
  800420b102:	48 bf 72 73 21 04 80 	movabs $0x8004217372,%rdi
  800420b109:	00 00 00 
  800420b10c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b111:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  800420b118:	00 00 00 
  800420b11b:	ff d2                	callq  *%rdx
		print_trapframe(tf);
  800420b11d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b121:	48 89 c7             	mov    %rax,%rdi
  800420b124:	48 b8 e1 aa 20 04 80 	movabs $0x800420aae1,%rax
  800420b12b:	00 00 00 
  800420b12e:	ff d0                	callq  *%rax
		return;
  800420b130:	e9 fc 00 00 00       	jmpq   800420b231 <trap_dispatch+0x1f8>
	}

	// Handle clock interrupts. Don't forget to acknowledge the
	// interrupt using lapic_eoi() before calling the scheduler!
	// LAB 4: Your code here.
	if (tf->tf_trapno == IRQ_OFFSET + IRQ_TIMER) {
  800420b135:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b139:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b140:	48 83 f8 20          	cmp    $0x20,%rax
  800420b144:	75 18                	jne    800420b15e <trap_dispatch+0x125>
		lapic_eoi();
  800420b146:	48 b8 c2 57 21 04 80 	movabs $0x80042157c2,%rax
  800420b14d:	00 00 00 
  800420b150:	ff d0                	callq  *%rax
		sched_yield();
  800420b152:	48 b8 fe ba 20 04 80 	movabs $0x800420bafe,%rax
  800420b159:	00 00 00 
  800420b15c:	ff d0                	callq  *%rax
		return;
	}

	// Handle keyboard and serial interrupts.
	// LAB 5: Your code here.
	if (tf->tf_trapno == IRQ_OFFSET + IRQ_KBD) {
  800420b15e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b162:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b169:	48 83 f8 21          	cmp    $0x21,%rax
  800420b16d:	75 11                	jne    800420b180 <trap_dispatch+0x147>
		kbd_intr();
  800420b16f:	48 b8 d8 0f 20 04 80 	movabs $0x8004200fd8,%rax
  800420b176:	00 00 00 
  800420b179:	ff d0                	callq  *%rax
		return;
  800420b17b:	e9 b1 00 00 00       	jmpq   800420b231 <trap_dispatch+0x1f8>
	}

	if (tf->tf_trapno == IRQ_OFFSET + IRQ_SERIAL) {
  800420b180:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b184:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b18b:	48 83 f8 24          	cmp    $0x24,%rax
  800420b18f:	75 11                	jne    800420b1a2 <trap_dispatch+0x169>
		serial_intr();
  800420b191:	48 b8 62 07 20 04 80 	movabs $0x8004200762,%rax
  800420b198:	00 00 00 
  800420b19b:	ff d0                	callq  *%rax
		return;
  800420b19d:	e9 8f 00 00 00       	jmpq   800420b231 <trap_dispatch+0x1f8>
	}

	// Unexpected trap: The user process or the kernel has a bug.
	print_trapframe(tf);
  800420b1a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b1a6:	48 89 c7             	mov    %rax,%rdi
  800420b1a9:	48 b8 e1 aa 20 04 80 	movabs $0x800420aae1,%rax
  800420b1b0:	00 00 00 
  800420b1b3:	ff d0                	callq  *%rax
	if (tf->tf_cs == GD_KT)
  800420b1b5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b1b9:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420b1c0:	66 83 f8 08          	cmp    $0x8,%ax
  800420b1c4:	75 2a                	jne    800420b1f0 <trap_dispatch+0x1b7>
		panic("unhandled trap in kernel");
  800420b1c6:	48 ba 8f 73 21 04 80 	movabs $0x800421738f,%rdx
  800420b1cd:	00 00 00 
  800420b1d0:	be 45 01 00 00       	mov    $0x145,%esi
  800420b1d5:	48 bf a8 73 21 04 80 	movabs $0x80042173a8,%rdi
  800420b1dc:	00 00 00 
  800420b1df:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b1e4:	48 b9 ae 04 20 04 80 	movabs $0x80042004ae,%rcx
  800420b1eb:	00 00 00 
  800420b1ee:	ff d1                	callq  *%rcx
	else {
		env_destroy(curenv);
  800420b1f0:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420b1f7:	00 00 00 
  800420b1fa:	ff d0                	callq  *%rax
  800420b1fc:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  800420b203:	00 00 00 
  800420b206:	48 98                	cltq   
  800420b208:	48 c1 e0 03          	shl    $0x3,%rax
  800420b20c:	48 89 c2             	mov    %rax,%rdx
  800420b20f:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b213:	48 29 c2             	sub    %rax,%rdx
  800420b216:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b21a:	48 83 c0 08          	add    $0x8,%rax
  800420b21e:	48 8b 00             	mov    (%rax),%rax
  800420b221:	48 89 c7             	mov    %rax,%rdi
  800420b224:	48 b8 67 83 20 04 80 	movabs $0x8004208367,%rax
  800420b22b:	00 00 00 
  800420b22e:	ff d0                	callq  *%rax
		return;
  800420b230:	90                   	nop
	}
}
  800420b231:	c9                   	leaveq 
  800420b232:	c3                   	retq   

000000800420b233 <trap>:

void
trap(struct Trapframe *tf)
{
  800420b233:	55                   	push   %rbp
  800420b234:	48 89 e5             	mov    %rsp,%rbp
  800420b237:	48 83 ec 20          	sub    $0x20,%rsp
  800420b23b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    //struct Trapframe *tf = &tf_;
	// The environment may have set DF and some versions
	// of GCC rely on DF being clear
	asm volatile("cld" ::: "cc");
  800420b23f:	fc                   	cld    

	// Halt the CPU if some other CPU has called panic()
	extern char *panicstr;
	if (panicstr)
  800420b240:	48 b8 90 67 49 04 80 	movabs $0x8004496790,%rax
  800420b247:	00 00 00 
  800420b24a:	48 8b 00             	mov    (%rax),%rax
  800420b24d:	48 85 c0             	test   %rax,%rax
  800420b250:	74 01                	je     800420b253 <trap+0x20>
		asm volatile("hlt");
  800420b252:	f4                   	hlt    

	// Re-acqurie the big kernel lock if we were halted in
	// sched_yield()
	if (xchg(&thiscpu->cpu_status, CPU_STARTED) == CPU_HALTED)
  800420b253:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420b25a:	00 00 00 
  800420b25d:	ff d0                	callq  *%rax
  800420b25f:	48 98                	cltq   
  800420b261:	48 c1 e0 03          	shl    $0x3,%rax
  800420b265:	48 89 c2             	mov    %rax,%rdx
  800420b268:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b26c:	48 29 c2             	sub    %rax,%rdx
  800420b26f:	48 b8 20 80 49 04 80 	movabs $0x8004498020,%rax
  800420b276:	00 00 00 
  800420b279:	48 01 d0             	add    %rdx,%rax
  800420b27c:	48 83 c0 04          	add    $0x4,%rax
  800420b280:	be 01 00 00 00       	mov    $0x1,%esi
  800420b285:	48 89 c7             	mov    %rax,%rdi
  800420b288:	48 b8 52 8b 20 04 80 	movabs $0x8004208b52,%rax
  800420b28f:	00 00 00 
  800420b292:	ff d0                	callq  *%rax
  800420b294:	83 f8 02             	cmp    $0x2,%eax
  800420b297:	75 0c                	jne    800420b2a5 <trap+0x72>
		lock_kernel();
  800420b299:	48 b8 77 8b 20 04 80 	movabs $0x8004208b77,%rax
  800420b2a0:	00 00 00 
  800420b2a3:	ff d0                	callq  *%rax

static __inline uint64_t
read_eflags(void)
{
        uint64_t rflags;
        __asm __volatile("pushfq; popq %0" : "=r" (rflags));
  800420b2a5:	9c                   	pushfq 
  800420b2a6:	58                   	pop    %rax
  800420b2a7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
        return rflags;
  800420b2ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
	// Check that interrupts are disabled.  If this assertion
	// fails, DO NOT be tempted to fix it by inserting a "cli" in
	// the interrupt path.
	assert(!(read_eflags() & FL_IF));
  800420b2af:	25 00 02 00 00       	and    $0x200,%eax
  800420b2b4:	48 85 c0             	test   %rax,%rax
  800420b2b7:	74 35                	je     800420b2ee <trap+0xbb>
  800420b2b9:	48 b9 b4 73 21 04 80 	movabs $0x80042173b4,%rcx
  800420b2c0:	00 00 00 
  800420b2c3:	48 ba cd 73 21 04 80 	movabs $0x80042173cd,%rdx
  800420b2ca:	00 00 00 
  800420b2cd:	be 60 01 00 00       	mov    $0x160,%esi
  800420b2d2:	48 bf a8 73 21 04 80 	movabs $0x80042173a8,%rdi
  800420b2d9:	00 00 00 
  800420b2dc:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b2e1:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420b2e8:	00 00 00 
  800420b2eb:	41 ff d0             	callq  *%r8

	if ((tf->tf_cs & 3) == 3) {
  800420b2ee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b2f2:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420b2f9:	0f b7 c0             	movzwl %ax,%eax
  800420b2fc:	83 e0 03             	and    $0x3,%eax
  800420b2ff:	83 f8 03             	cmp    $0x3,%eax
  800420b302:	0f 85 b3 01 00 00    	jne    800420b4bb <trap+0x288>
		// Trapped from user mode.
		// Acquire the big kernel lock before doing any
		// serious kernel work.
		// LAB 4: Your code here.
		lock_kernel();
  800420b308:	48 b8 77 8b 20 04 80 	movabs $0x8004208b77,%rax
  800420b30f:	00 00 00 
  800420b312:	ff d0                	callq  *%rax

		assert(curenv);
  800420b314:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420b31b:	00 00 00 
  800420b31e:	ff d0                	callq  *%rax
  800420b320:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  800420b327:	00 00 00 
  800420b32a:	48 98                	cltq   
  800420b32c:	48 c1 e0 03          	shl    $0x3,%rax
  800420b330:	48 89 c2             	mov    %rax,%rdx
  800420b333:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b337:	48 29 c2             	sub    %rax,%rdx
  800420b33a:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b33e:	48 83 c0 08          	add    $0x8,%rax
  800420b342:	48 8b 00             	mov    (%rax),%rax
  800420b345:	48 85 c0             	test   %rax,%rax
  800420b348:	75 35                	jne    800420b37f <trap+0x14c>
  800420b34a:	48 b9 e2 73 21 04 80 	movabs $0x80042173e2,%rcx
  800420b351:	00 00 00 
  800420b354:	48 ba cd 73 21 04 80 	movabs $0x80042173cd,%rdx
  800420b35b:	00 00 00 
  800420b35e:	be 69 01 00 00       	mov    $0x169,%esi
  800420b363:	48 bf a8 73 21 04 80 	movabs $0x80042173a8,%rdi
  800420b36a:	00 00 00 
  800420b36d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b372:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420b379:	00 00 00 
  800420b37c:	41 ff d0             	callq  *%r8

		// Garbage collect if current enviroment is a zombie
		if (curenv->env_status == ENV_DYING) {
  800420b37f:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420b386:	00 00 00 
  800420b389:	ff d0                	callq  *%rax
  800420b38b:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  800420b392:	00 00 00 
  800420b395:	48 98                	cltq   
  800420b397:	48 c1 e0 03          	shl    $0x3,%rax
  800420b39b:	48 89 c2             	mov    %rax,%rdx
  800420b39e:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b3a2:	48 29 c2             	sub    %rax,%rdx
  800420b3a5:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b3a9:	48 83 c0 08          	add    $0x8,%rax
  800420b3ad:	48 8b 00             	mov    (%rax),%rax
  800420b3b0:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420b3b6:	83 f8 01             	cmp    $0x1,%eax
  800420b3b9:	0f 85 81 00 00 00    	jne    800420b440 <trap+0x20d>
			env_free(curenv);
  800420b3bf:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420b3c6:	00 00 00 
  800420b3c9:	ff d0                	callq  *%rax
  800420b3cb:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  800420b3d2:	00 00 00 
  800420b3d5:	48 98                	cltq   
  800420b3d7:	48 c1 e0 03          	shl    $0x3,%rax
  800420b3db:	48 89 c2             	mov    %rax,%rdx
  800420b3de:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b3e2:	48 29 c2             	sub    %rax,%rdx
  800420b3e5:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b3e9:	48 83 c0 08          	add    $0x8,%rax
  800420b3ed:	48 8b 00             	mov    (%rax),%rax
  800420b3f0:	48 89 c7             	mov    %rax,%rdi
  800420b3f3:	48 b8 2b 7e 20 04 80 	movabs $0x8004207e2b,%rax
  800420b3fa:	00 00 00 
  800420b3fd:	ff d0                	callq  *%rax
			curenv = NULL;
  800420b3ff:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420b406:	00 00 00 
  800420b409:	ff d0                	callq  *%rax
  800420b40b:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  800420b412:	00 00 00 
  800420b415:	48 98                	cltq   
  800420b417:	48 c1 e0 03          	shl    $0x3,%rax
  800420b41b:	48 89 c2             	mov    %rax,%rdx
  800420b41e:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b422:	48 29 c2             	sub    %rax,%rdx
  800420b425:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b429:	48 83 c0 08          	add    $0x8,%rax
  800420b42d:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			sched_yield();
  800420b434:	48 b8 fe ba 20 04 80 	movabs $0x800420bafe,%rax
  800420b43b:	00 00 00 
  800420b43e:	ff d0                	callq  *%rax
		}

		// Copy trap frame (which is currently on the stack)
		// into 'curenv->env_tf', so that running the environment
		// will restart at the trap point.
		curenv->env_tf = *tf;
  800420b440:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420b447:	00 00 00 
  800420b44a:	ff d0                	callq  *%rax
  800420b44c:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  800420b453:	00 00 00 
  800420b456:	48 98                	cltq   
  800420b458:	48 c1 e0 03          	shl    $0x3,%rax
  800420b45c:	48 89 c2             	mov    %rax,%rdx
  800420b45f:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b463:	48 29 c2             	sub    %rax,%rdx
  800420b466:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b46a:	48 83 c0 08          	add    $0x8,%rax
  800420b46e:	48 8b 10             	mov    (%rax),%rdx
  800420b471:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b475:	48 89 c6             	mov    %rax,%rsi
  800420b478:	b8 18 00 00 00       	mov    $0x18,%eax
  800420b47d:	48 89 d7             	mov    %rdx,%rdi
  800420b480:	48 89 c1             	mov    %rax,%rcx
  800420b483:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
		// The trapframe on the stack should be ignored from here on.
		tf = &curenv->env_tf;
  800420b486:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420b48d:	00 00 00 
  800420b490:	ff d0                	callq  *%rax
  800420b492:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  800420b499:	00 00 00 
  800420b49c:	48 98                	cltq   
  800420b49e:	48 c1 e0 03          	shl    $0x3,%rax
  800420b4a2:	48 89 c2             	mov    %rax,%rdx
  800420b4a5:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b4a9:	48 29 c2             	sub    %rax,%rdx
  800420b4ac:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b4b0:	48 83 c0 08          	add    $0x8,%rax
  800420b4b4:	48 8b 00             	mov    (%rax),%rax
  800420b4b7:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	}

	// Record that tf is the last real trapframe so
	// print_trapframe can print some additional information.
	last_tf = tf;
  800420b4bb:	48 b8 08 63 49 04 80 	movabs $0x8004496308,%rax
  800420b4c2:	00 00 00 
  800420b4c5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420b4c9:	48 89 10             	mov    %rdx,(%rax)

	// Dispatch based on what type of trap occurred
	trap_dispatch(tf);
  800420b4cc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b4d0:	48 89 c7             	mov    %rax,%rdi
  800420b4d3:	48 b8 39 b0 20 04 80 	movabs $0x800420b039,%rax
  800420b4da:	00 00 00 
  800420b4dd:	ff d0                	callq  *%rax

	// If we made it to this point, then no other environment was
	// scheduled, so we should return to the current environment
	// if doing so makes sense.
	if (curenv && curenv->env_status == ENV_RUNNING)
  800420b4df:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420b4e6:	00 00 00 
  800420b4e9:	ff d0                	callq  *%rax
  800420b4eb:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  800420b4f2:	00 00 00 
  800420b4f5:	48 98                	cltq   
  800420b4f7:	48 c1 e0 03          	shl    $0x3,%rax
  800420b4fb:	48 89 c2             	mov    %rax,%rdx
  800420b4fe:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b502:	48 29 c2             	sub    %rax,%rdx
  800420b505:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b509:	48 83 c0 08          	add    $0x8,%rax
  800420b50d:	48 8b 00             	mov    (%rax),%rax
  800420b510:	48 85 c0             	test   %rax,%rax
  800420b513:	74 7c                	je     800420b591 <trap+0x35e>
  800420b515:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420b51c:	00 00 00 
  800420b51f:	ff d0                	callq  *%rax
  800420b521:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  800420b528:	00 00 00 
  800420b52b:	48 98                	cltq   
  800420b52d:	48 c1 e0 03          	shl    $0x3,%rax
  800420b531:	48 89 c2             	mov    %rax,%rdx
  800420b534:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b538:	48 29 c2             	sub    %rax,%rdx
  800420b53b:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b53f:	48 83 c0 08          	add    $0x8,%rax
  800420b543:	48 8b 00             	mov    (%rax),%rax
  800420b546:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420b54c:	83 f8 03             	cmp    $0x3,%eax
  800420b54f:	75 40                	jne    800420b591 <trap+0x35e>
		env_run(curenv);
  800420b551:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420b558:	00 00 00 
  800420b55b:	ff d0                	callq  *%rax
  800420b55d:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  800420b564:	00 00 00 
  800420b567:	48 98                	cltq   
  800420b569:	48 c1 e0 03          	shl    $0x3,%rax
  800420b56d:	48 89 c2             	mov    %rax,%rdx
  800420b570:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b574:	48 29 c2             	sub    %rax,%rdx
  800420b577:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b57b:	48 83 c0 08          	add    $0x8,%rax
  800420b57f:	48 8b 00             	mov    (%rax),%rax
  800420b582:	48 89 c7             	mov    %rax,%rdi
  800420b585:	48 b8 36 85 20 04 80 	movabs $0x8004208536,%rax
  800420b58c:	00 00 00 
  800420b58f:	ff d0                	callq  *%rax
	else
		sched_yield();
  800420b591:	48 b8 fe ba 20 04 80 	movabs $0x800420bafe,%rax
  800420b598:	00 00 00 
  800420b59b:	ff d0                	callq  *%rax

000000800420b59d <page_fault_handler>:
}


void
page_fault_handler(struct Trapframe *tf)
{
  800420b59d:	55                   	push   %rbp
  800420b59e:	48 89 e5             	mov    %rsp,%rbp
  800420b5a1:	53                   	push   %rbx
  800420b5a2:	48 83 ec 38          	sub    $0x38,%rsp
  800420b5a6:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)

static __inline uint64_t
rcr2(void)
{
	uint64_t val;
	__asm __volatile("movq %%cr2,%0" : "=r" (val));
  800420b5aa:	0f 20 d0             	mov    %cr2,%rax
  800420b5ad:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	return val;
  800420b5b1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
	uint64_t fault_va;

	// Read processor's CR2 register to find the faulting address
	fault_va = rcr2();
  800420b5b5:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	// Handle kernel-mode page faults.

	// LAB 3: Your code here.
	if ((tf->tf_cs & 3) == 0)
  800420b5b9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420b5bd:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420b5c4:	0f b7 c0             	movzwl %ax,%eax
  800420b5c7:	83 e0 03             	and    $0x3,%eax
  800420b5ca:	85 c0                	test   %eax,%eax
  800420b5cc:	75 2a                	jne    800420b5f8 <page_fault_handler+0x5b>
		panic("page_fault: kernel-mode");
  800420b5ce:	48 ba e9 73 21 04 80 	movabs $0x80042173e9,%rdx
  800420b5d5:	00 00 00 
  800420b5d8:	be 97 01 00 00       	mov    $0x197,%esi
  800420b5dd:	48 bf a8 73 21 04 80 	movabs $0x80042173a8,%rdi
  800420b5e4:	00 00 00 
  800420b5e7:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b5ec:	48 b9 ae 04 20 04 80 	movabs $0x80042004ae,%rcx
  800420b5f3:	00 00 00 
  800420b5f6:	ff d1                	callq  *%rcx
	//   user_mem_assert() and env_run() are useful here.
	//   To change what the user environment runs, modify 'curenv->env_tf'
	//   (the 'tf' variable points at 'curenv->env_tf').

	// LAB 4: Your code here.
	if (curenv->env_pgfault_upcall != NULL) {
  800420b5f8:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420b5ff:	00 00 00 
  800420b602:	ff d0                	callq  *%rax
  800420b604:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  800420b60b:	00 00 00 
  800420b60e:	48 98                	cltq   
  800420b610:	48 c1 e0 03          	shl    $0x3,%rax
  800420b614:	48 89 c2             	mov    %rax,%rdx
  800420b617:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b61b:	48 29 c2             	sub    %rax,%rdx
  800420b61e:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b622:	48 83 c0 08          	add    $0x8,%rax
  800420b626:	48 8b 00             	mov    (%rax),%rax
  800420b629:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
  800420b630:	48 85 c0             	test   %rax,%rax
  800420b633:	0f 84 0d 02 00 00    	je     800420b846 <page_fault_handler+0x2a9>
		struct UTrapframe *utf;

		// allocate memory for another trap-frame
		utf = (struct UTrapframe *)(UXSTACKTOP - sizeof(struct UTrapframe));
  800420b639:	b8 60 ff 7f ef       	mov    $0xef7fff60,%eax
  800420b63e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		if (tf->tf_rsp >= UXSTACKTOP - PGSIZE && tf->tf_rsp < UXSTACKTOP)
  800420b642:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420b646:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420b64d:	b8 ff ef 7f ef       	mov    $0xef7fefff,%eax
  800420b652:	48 39 c2             	cmp    %rax,%rdx
  800420b655:	76 2a                	jbe    800420b681 <page_fault_handler+0xe4>
  800420b657:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420b65b:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420b662:	b8 ff ff 7f ef       	mov    $0xef7fffff,%eax
  800420b667:	48 39 c2             	cmp    %rax,%rdx
  800420b66a:	77 15                	ja     800420b681 <page_fault_handler+0xe4>
			utf = (struct UTrapframe *)(tf->tf_rsp - sizeof(struct UTrapframe) - 8);
  800420b66c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420b670:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  800420b677:	48 2d a8 00 00 00    	sub    $0xa8,%rax
  800420b67d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		user_mem_assert(curenv, utf, sizeof(struct UTrapframe), PTE_U | PTE_W);
  800420b681:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420b688:	00 00 00 
  800420b68b:	ff d0                	callq  *%rax
  800420b68d:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  800420b694:	00 00 00 
  800420b697:	48 98                	cltq   
  800420b699:	48 c1 e0 03          	shl    $0x3,%rax
  800420b69d:	48 89 c2             	mov    %rax,%rdx
  800420b6a0:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b6a4:	48 29 c2             	sub    %rax,%rdx
  800420b6a7:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b6ab:	48 83 c0 08          	add    $0x8,%rax
  800420b6af:	48 8b 00             	mov    (%rax),%rax
  800420b6b2:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  800420b6b6:	b9 06 00 00 00       	mov    $0x6,%ecx
  800420b6bb:	ba a0 00 00 00       	mov    $0xa0,%edx
  800420b6c0:	48 89 c7             	mov    %rax,%rdi
  800420b6c3:	48 b8 5d 38 20 04 80 	movabs $0x800420385d,%rax
  800420b6ca:	00 00 00 
  800420b6cd:	ff d0                	callq  *%rax

		// store current trap-frame information
		utf->utf_fault_va = fault_va;
  800420b6cf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b6d3:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420b6d7:	48 89 10             	mov    %rdx,(%rax)
		utf->utf_err = tf->tf_err;
  800420b6da:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420b6de:	48 8b 90 90 00 00 00 	mov    0x90(%rax),%rdx
  800420b6e5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b6e9:	48 89 50 08          	mov    %rdx,0x8(%rax)
		utf->utf_regs = tf->tf_regs;
  800420b6ed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b6f1:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420b6f5:	48 8b 0a             	mov    (%rdx),%rcx
  800420b6f8:	48 89 48 10          	mov    %rcx,0x10(%rax)
  800420b6fc:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420b700:	48 89 48 18          	mov    %rcx,0x18(%rax)
  800420b704:	48 8b 4a 10          	mov    0x10(%rdx),%rcx
  800420b708:	48 89 48 20          	mov    %rcx,0x20(%rax)
  800420b70c:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
  800420b710:	48 89 48 28          	mov    %rcx,0x28(%rax)
  800420b714:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
  800420b718:	48 89 48 30          	mov    %rcx,0x30(%rax)
  800420b71c:	48 8b 4a 28          	mov    0x28(%rdx),%rcx
  800420b720:	48 89 48 38          	mov    %rcx,0x38(%rax)
  800420b724:	48 8b 4a 30          	mov    0x30(%rdx),%rcx
  800420b728:	48 89 48 40          	mov    %rcx,0x40(%rax)
  800420b72c:	48 8b 4a 38          	mov    0x38(%rdx),%rcx
  800420b730:	48 89 48 48          	mov    %rcx,0x48(%rax)
  800420b734:	48 8b 4a 40          	mov    0x40(%rdx),%rcx
  800420b738:	48 89 48 50          	mov    %rcx,0x50(%rax)
  800420b73c:	48 8b 4a 48          	mov    0x48(%rdx),%rcx
  800420b740:	48 89 48 58          	mov    %rcx,0x58(%rax)
  800420b744:	48 8b 4a 50          	mov    0x50(%rdx),%rcx
  800420b748:	48 89 48 60          	mov    %rcx,0x60(%rax)
  800420b74c:	48 8b 4a 58          	mov    0x58(%rdx),%rcx
  800420b750:	48 89 48 68          	mov    %rcx,0x68(%rax)
  800420b754:	48 8b 4a 60          	mov    0x60(%rdx),%rcx
  800420b758:	48 89 48 70          	mov    %rcx,0x70(%rax)
  800420b75c:	48 8b 4a 68          	mov    0x68(%rdx),%rcx
  800420b760:	48 89 48 78          	mov    %rcx,0x78(%rax)
  800420b764:	48 8b 52 70          	mov    0x70(%rdx),%rdx
  800420b768:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
		utf->utf_rip = tf->tf_rip;
  800420b76f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420b773:	48 8b 90 98 00 00 00 	mov    0x98(%rax),%rdx
  800420b77a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b77e:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
		utf->utf_rsp = tf->tf_rsp;
  800420b785:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420b789:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420b790:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b794:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
		utf->utf_eflags = tf->tf_eflags;
  800420b79b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420b79f:	48 8b 90 a8 00 00 00 	mov    0xa8(%rax),%rdx
  800420b7a6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b7aa:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)

		// modify trap-frame to run env_pgfault_upcall
		tf->tf_rip = (uintptr_t)curenv->env_pgfault_upcall;
  800420b7b1:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420b7b8:	00 00 00 
  800420b7bb:	ff d0                	callq  *%rax
  800420b7bd:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  800420b7c4:	00 00 00 
  800420b7c7:	48 98                	cltq   
  800420b7c9:	48 c1 e0 03          	shl    $0x3,%rax
  800420b7cd:	48 89 c2             	mov    %rax,%rdx
  800420b7d0:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b7d4:	48 29 c2             	sub    %rax,%rdx
  800420b7d7:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b7db:	48 83 c0 08          	add    $0x8,%rax
  800420b7df:	48 8b 00             	mov    (%rax),%rax
  800420b7e2:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
  800420b7e9:	48 89 c2             	mov    %rax,%rdx
  800420b7ec:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420b7f0:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
		tf->tf_rsp = (uintptr_t)utf;
  800420b7f7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420b7fb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420b7ff:	48 89 90 b0 00 00 00 	mov    %rdx,0xb0(%rax)
		env_run(curenv);
  800420b806:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420b80d:	00 00 00 
  800420b810:	ff d0                	callq  *%rax
  800420b812:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  800420b819:	00 00 00 
  800420b81c:	48 98                	cltq   
  800420b81e:	48 c1 e0 03          	shl    $0x3,%rax
  800420b822:	48 89 c2             	mov    %rax,%rdx
  800420b825:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b829:	48 29 c2             	sub    %rax,%rdx
  800420b82c:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b830:	48 83 c0 08          	add    $0x8,%rax
  800420b834:	48 8b 00             	mov    (%rax),%rax
  800420b837:	48 89 c7             	mov    %rax,%rdi
  800420b83a:	48 b8 36 85 20 04 80 	movabs $0x8004208536,%rax
  800420b841:	00 00 00 
  800420b844:	ff d0                	callq  *%rax
	}

	// Destroy the environment that caused the fault.
	cprintf("[%08x] user fault va %08x ip %08x\n",
  800420b846:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420b84a:	48 8b 98 98 00 00 00 	mov    0x98(%rax),%rbx
		curenv->env_id, fault_va, tf->tf_rip);
  800420b851:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420b858:	00 00 00 
  800420b85b:	ff d0                	callq  *%rax
  800420b85d:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  800420b864:	00 00 00 
  800420b867:	48 98                	cltq   
  800420b869:	48 c1 e0 03          	shl    $0x3,%rax
  800420b86d:	48 89 c2             	mov    %rax,%rdx
  800420b870:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b874:	48 29 c2             	sub    %rax,%rdx
  800420b877:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b87b:	48 83 c0 08          	add    $0x8,%rax
  800420b87f:	48 8b 00             	mov    (%rax),%rax
		tf->tf_rsp = (uintptr_t)utf;
		env_run(curenv);
	}

	// Destroy the environment that caused the fault.
	cprintf("[%08x] user fault va %08x ip %08x\n",
  800420b882:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420b888:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420b88c:	48 89 d9             	mov    %rbx,%rcx
  800420b88f:	89 c6                	mov    %eax,%esi
  800420b891:	48 bf 08 74 21 04 80 	movabs $0x8004217408,%rdi
  800420b898:	00 00 00 
  800420b89b:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b8a0:	49 b8 7a 8a 20 04 80 	movabs $0x8004208a7a,%r8
  800420b8a7:	00 00 00 
  800420b8aa:	41 ff d0             	callq  *%r8
		curenv->env_id, fault_va, tf->tf_rip);
	print_trapframe(tf);
  800420b8ad:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420b8b1:	48 89 c7             	mov    %rax,%rdi
  800420b8b4:	48 b8 e1 aa 20 04 80 	movabs $0x800420aae1,%rax
  800420b8bb:	00 00 00 
  800420b8be:	ff d0                	callq  *%rax
	env_destroy(curenv);
  800420b8c0:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420b8c7:	00 00 00 
  800420b8ca:	ff d0                	callq  *%rax
  800420b8cc:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  800420b8d3:	00 00 00 
  800420b8d6:	48 98                	cltq   
  800420b8d8:	48 c1 e0 03          	shl    $0x3,%rax
  800420b8dc:	48 89 c2             	mov    %rax,%rdx
  800420b8df:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b8e3:	48 29 c2             	sub    %rax,%rdx
  800420b8e6:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b8ea:	48 83 c0 08          	add    $0x8,%rax
  800420b8ee:	48 8b 00             	mov    (%rax),%rax
  800420b8f1:	48 89 c7             	mov    %rax,%rdi
  800420b8f4:	48 b8 67 83 20 04 80 	movabs $0x8004208367,%rax
  800420b8fb:	00 00 00 
  800420b8fe:	ff d0                	callq  *%rax
}
  800420b900:	48 83 c4 38          	add    $0x38,%rsp
  800420b904:	5b                   	pop    %rbx
  800420b905:	5d                   	pop    %rbp
  800420b906:	c3                   	retq   
  800420b907:	90                   	nop

000000800420b908 <__trap_divide>:
   pusha,popa so you will find these macros handy.
 */

	// Macros are referred from inc/trap.h
	// See Intel IA-32 Developer's Manual Table 5-1
	TRAPHANDLER_NOEC(__trap_divide, T_DIVIDE)
  800420b908:	6a 00                	pushq  $0x0
  800420b90a:	6a 00                	pushq  $0x0
  800420b90c:	e9 e2 00 00 00       	jmpq   800420b9f3 <_alltraps>
  800420b911:	90                   	nop

000000800420b912 <__trap_debug>:
	TRAPHANDLER_NOEC(__trap_debug, T_DEBUG)
  800420b912:	6a 00                	pushq  $0x0
  800420b914:	6a 01                	pushq  $0x1
  800420b916:	e9 d8 00 00 00       	jmpq   800420b9f3 <_alltraps>
  800420b91b:	90                   	nop

000000800420b91c <__trap_nmi>:
	TRAPHANDLER_NOEC(__trap_nmi, T_NMI)
  800420b91c:	6a 00                	pushq  $0x0
  800420b91e:	6a 02                	pushq  $0x2
  800420b920:	e9 ce 00 00 00       	jmpq   800420b9f3 <_alltraps>
  800420b925:	90                   	nop

000000800420b926 <__trap_brkpt>:
	TRAPHANDLER_NOEC(__trap_brkpt, T_BRKPT)
  800420b926:	6a 00                	pushq  $0x0
  800420b928:	6a 03                	pushq  $0x3
  800420b92a:	e9 c4 00 00 00       	jmpq   800420b9f3 <_alltraps>
  800420b92f:	90                   	nop

000000800420b930 <__trap_oflow>:
	TRAPHANDLER_NOEC(__trap_oflow, T_OFLOW)
  800420b930:	6a 00                	pushq  $0x0
  800420b932:	6a 04                	pushq  $0x4
  800420b934:	e9 ba 00 00 00       	jmpq   800420b9f3 <_alltraps>
  800420b939:	90                   	nop

000000800420b93a <__trap_bound>:
	TRAPHANDLER_NOEC(__trap_bound, T_BOUND)
  800420b93a:	6a 00                	pushq  $0x0
  800420b93c:	6a 05                	pushq  $0x5
  800420b93e:	e9 b0 00 00 00       	jmpq   800420b9f3 <_alltraps>
  800420b943:	90                   	nop

000000800420b944 <__trap_illop>:
	TRAPHANDLER_NOEC(__trap_illop, T_ILLOP)
  800420b944:	6a 00                	pushq  $0x0
  800420b946:	6a 06                	pushq  $0x6
  800420b948:	e9 a6 00 00 00       	jmpq   800420b9f3 <_alltraps>
  800420b94d:	90                   	nop

000000800420b94e <__trap_device>:
	TRAPHANDLER_NOEC(__trap_device, T_DEVICE)
  800420b94e:	6a 00                	pushq  $0x0
  800420b950:	6a 07                	pushq  $0x7
  800420b952:	e9 9c 00 00 00       	jmpq   800420b9f3 <_alltraps>
  800420b957:	90                   	nop

000000800420b958 <__trap_dblflt>:
	TRAPHANDLER(__trap_dblflt, T_DBLFLT)
  800420b958:	6a 08                	pushq  $0x8
  800420b95a:	e9 94 00 00 00       	jmpq   800420b9f3 <_alltraps>
  800420b95f:	90                   	nop

000000800420b960 <__trap_tss>:
	//TRAPHANDLER_NOEC(__trap_coproc, T_COPROC)
	TRAPHANDLER(__trap_tss, T_TSS)
  800420b960:	6a 0a                	pushq  $0xa
  800420b962:	e9 8c 00 00 00       	jmpq   800420b9f3 <_alltraps>
  800420b967:	90                   	nop

000000800420b968 <__trap_segnp>:
	TRAPHANDLER(__trap_segnp, T_SEGNP)
  800420b968:	6a 0b                	pushq  $0xb
  800420b96a:	e9 84 00 00 00       	jmpq   800420b9f3 <_alltraps>
  800420b96f:	90                   	nop

000000800420b970 <__trap_stack>:
	TRAPHANDLER(__trap_stack, T_STACK)
  800420b970:	6a 0c                	pushq  $0xc
  800420b972:	e9 7c 00 00 00       	jmpq   800420b9f3 <_alltraps>
  800420b977:	90                   	nop

000000800420b978 <__trap_gpflt>:
	TRAPHANDLER(__trap_gpflt, T_GPFLT)
  800420b978:	6a 0d                	pushq  $0xd
  800420b97a:	e9 74 00 00 00       	jmpq   800420b9f3 <_alltraps>
  800420b97f:	90                   	nop

000000800420b980 <__trap_pgflt>:
	TRAPHANDLER(__trap_pgflt, T_PGFLT)
  800420b980:	6a 0e                	pushq  $0xe
  800420b982:	e9 6c 00 00 00       	jmpq   800420b9f3 <_alltraps>
  800420b987:	90                   	nop

000000800420b988 <__trap_fperr>:
	//TRAPHANDLER_NOEC(__trap_res, T_RES)
	TRAPHANDLER_NOEC(__trap_fperr, T_FPERR)
  800420b988:	6a 00                	pushq  $0x0
  800420b98a:	6a 10                	pushq  $0x10
  800420b98c:	e9 62 00 00 00       	jmpq   800420b9f3 <_alltraps>
  800420b991:	90                   	nop

000000800420b992 <__trap_align>:
	TRAPHANDLER(__trap_align, T_ALIGN)
  800420b992:	6a 11                	pushq  $0x11
  800420b994:	e9 5a 00 00 00       	jmpq   800420b9f3 <_alltraps>
  800420b999:	90                   	nop

000000800420b99a <__trap_mchk>:
	TRAPHANDLER_NOEC(__trap_mchk, T_MCHK)
  800420b99a:	6a 00                	pushq  $0x0
  800420b99c:	6a 12                	pushq  $0x12
  800420b99e:	e9 50 00 00 00       	jmpq   800420b9f3 <_alltraps>
  800420b9a3:	90                   	nop

000000800420b9a4 <__trap_simderr>:
	TRAPHANDLER_NOEC(__trap_simderr, T_SIMDERR)
  800420b9a4:	6a 00                	pushq  $0x0
  800420b9a6:	6a 13                	pushq  $0x13
  800420b9a8:	e9 46 00 00 00       	jmpq   800420b9f3 <_alltraps>
  800420b9ad:	90                   	nop

000000800420b9ae <__trap_syscall>:
	TRAPHANDLER_NOEC(__trap_syscall, T_SYSCALL)
  800420b9ae:	6a 00                	pushq  $0x0
  800420b9b0:	6a 30                	pushq  $0x30
  800420b9b2:	e9 3c 00 00 00       	jmpq   800420b9f3 <_alltraps>
  800420b9b7:	90                   	nop

000000800420b9b8 <__irq_timer>:

	// note: modified for LAB4
	TRAPHANDLER_NOEC(__irq_timer, IRQ_OFFSET + IRQ_TIMER)
  800420b9b8:	6a 00                	pushq  $0x0
  800420b9ba:	6a 20                	pushq  $0x20
  800420b9bc:	e9 32 00 00 00       	jmpq   800420b9f3 <_alltraps>
  800420b9c1:	90                   	nop

000000800420b9c2 <__irq_kbd>:
	TRAPHANDLER_NOEC(__irq_kbd, IRQ_OFFSET + IRQ_KBD)
  800420b9c2:	6a 00                	pushq  $0x0
  800420b9c4:	6a 21                	pushq  $0x21
  800420b9c6:	e9 28 00 00 00       	jmpq   800420b9f3 <_alltraps>
  800420b9cb:	90                   	nop

000000800420b9cc <__irq_serial>:
	TRAPHANDLER_NOEC(__irq_serial, IRQ_OFFSET + IRQ_SERIAL)
  800420b9cc:	6a 00                	pushq  $0x0
  800420b9ce:	6a 24                	pushq  $0x24
  800420b9d0:	e9 1e 00 00 00       	jmpq   800420b9f3 <_alltraps>
  800420b9d5:	90                   	nop

000000800420b9d6 <__irq_spurious>:
	TRAPHANDLER_NOEC(__irq_spurious, IRQ_OFFSET + IRQ_SPURIOUS)
  800420b9d6:	6a 00                	pushq  $0x0
  800420b9d8:	6a 27                	pushq  $0x27
  800420b9da:	e9 14 00 00 00       	jmpq   800420b9f3 <_alltraps>
  800420b9df:	90                   	nop

000000800420b9e0 <__irq_ide>:
	TRAPHANDLER_NOEC(__irq_ide, IRQ_OFFSET + IRQ_IDE)
  800420b9e0:	6a 00                	pushq  $0x0
  800420b9e2:	6a 2e                	pushq  $0x2e
  800420b9e4:	e9 0a 00 00 00       	jmpq   800420b9f3 <_alltraps>
  800420b9e9:	90                   	nop

000000800420b9ea <__irq_error>:
	TRAPHANDLER_NOEC(__irq_error, IRQ_OFFSET + IRQ_ERROR)
  800420b9ea:	6a 00                	pushq  $0x0
  800420b9ec:	6a 33                	pushq  $0x33
  800420b9ee:	e9 00 00 00 00       	jmpq   800420b9f3 <_alltraps>

000000800420b9f3 <_alltraps>:
 * Hint: Be sure to review the x64 calling convention from lab1
 *       for how to pass a pointer to the trapframe.
 */
.globl _alltraps
_alltraps:
	subq $16, %rsp
  800420b9f3:	48 83 ec 10          	sub    $0x10,%rsp
	movw %ds, 8(%rsp)
  800420b9f7:	8c 5c 24 08          	mov    %ds,0x8(%rsp)
	movw %es, 0(%rsp)
  800420b9fb:	8c 04 24             	mov    %es,(%rsp)

	PUSHA
  800420b9fe:	48 83 ec 78          	sub    $0x78,%rsp
  800420ba02:	48 89 44 24 70       	mov    %rax,0x70(%rsp)
  800420ba07:	48 89 5c 24 68       	mov    %rbx,0x68(%rsp)
  800420ba0c:	48 89 4c 24 60       	mov    %rcx,0x60(%rsp)
  800420ba11:	48 89 54 24 58       	mov    %rdx,0x58(%rsp)
  800420ba16:	48 89 6c 24 50       	mov    %rbp,0x50(%rsp)
  800420ba1b:	48 89 7c 24 48       	mov    %rdi,0x48(%rsp)
  800420ba20:	48 89 74 24 40       	mov    %rsi,0x40(%rsp)
  800420ba25:	4c 89 44 24 38       	mov    %r8,0x38(%rsp)
  800420ba2a:	4c 89 4c 24 30       	mov    %r9,0x30(%rsp)
  800420ba2f:	4c 89 54 24 28       	mov    %r10,0x28(%rsp)
  800420ba34:	4c 89 5c 24 20       	mov    %r11,0x20(%rsp)
  800420ba39:	4c 89 64 24 18       	mov    %r12,0x18(%rsp)
  800420ba3e:	4c 89 6c 24 10       	mov    %r13,0x10(%rsp)
  800420ba43:	4c 89 74 24 08       	mov    %r14,0x8(%rsp)
  800420ba48:	4c 89 3c 24          	mov    %r15,(%rsp)

	movq $GD_KD, %rax
  800420ba4c:	48 c7 c0 10 00 00 00 	mov    $0x10,%rax
	movq %rax, %ds
  800420ba53:	48 8e d8             	mov    %rax,%ds
	movq %rax, %es
  800420ba56:	48 8e c0             	mov    %rax,%es
	movq %rsp, %rdi
  800420ba59:	48 89 e7             	mov    %rsp,%rdi

	call trap
  800420ba5c:	e8 d2 f7 ff ff       	callq  800420b233 <trap>

	POPA_
  800420ba61:	4c 8b 3c 24          	mov    (%rsp),%r15
  800420ba65:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  800420ba6a:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  800420ba6f:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12
  800420ba74:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
  800420ba79:	4c 8b 54 24 28       	mov    0x28(%rsp),%r10
  800420ba7e:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
  800420ba83:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
  800420ba88:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  800420ba8d:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
  800420ba92:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
  800420ba97:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  800420ba9c:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  800420baa1:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
  800420baa6:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  800420baab:	48 83 c4 78          	add    $0x78,%rsp

	movw 0(%rsp), %es
  800420baaf:	8e 04 24             	mov    (%rsp),%es
	movw 8(%rsp), %ds
  800420bab2:	8e 5c 24 08          	mov    0x8(%rsp),%ds
	addq $16, %rsp
  800420bab6:	48 83 c4 10          	add    $0x10,%rsp
	iret
  800420baba:	cf                   	iret   

000000800420babb <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  800420babb:	55                   	push   %rbp
  800420babc:	48 89 e5             	mov    %rsp,%rbp
  800420babf:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420bac3:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420bac7:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  800420baca:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420bace:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420bad1:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420bad5:	f0 87 02             	lock xchg %eax,(%rdx)
  800420bad8:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  800420badb:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420bade:	c9                   	leaveq 
  800420badf:	c3                   	retq   

000000800420bae0 <unlock_kernel>:

static inline void
unlock_kernel(void)
{
  800420bae0:	55                   	push   %rbp
  800420bae1:	48 89 e5             	mov    %rsp,%rbp
	spin_unlock(&kernel_lock);
  800420bae4:	48 bf 80 b7 22 04 80 	movabs $0x800422b780,%rdi
  800420baeb:	00 00 00 
  800420baee:	48 b8 ef 5b 21 04 80 	movabs $0x8004215bef,%rax
  800420baf5:	00 00 00 
  800420baf8:	ff d0                	callq  *%rax

	// Normally we wouldn't need to do this, but QEMU only runs
	// one CPU at a time and has a long time-slice.  Without the
	// pause, this CPU is likely to reacquire the lock before
	// another CPU has even been given a chance to acquire it.
	asm volatile("pause");
  800420bafa:	f3 90                	pause  
}
  800420bafc:	5d                   	pop    %rbp
  800420bafd:	c3                   	retq   

000000800420bafe <sched_yield>:
void sched_halt(void);

// Choose a user environment to run and run it.
void
sched_yield(void)
{
  800420bafe:	55                   	push   %rbp
  800420baff:	48 89 e5             	mov    %rsp,%rbp
  800420bb02:	48 83 ec 10          	sub    $0x10,%rsp
	// below to halt the cpu.

	// LAB 4: Your code here.
	int i, count;

	idle = thiscpu->cpu_env;
  800420bb06:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420bb0d:	00 00 00 
  800420bb10:	ff d0                	callq  *%rax
  800420bb12:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  800420bb19:	00 00 00 
  800420bb1c:	48 98                	cltq   
  800420bb1e:	48 c1 e0 03          	shl    $0x3,%rax
  800420bb22:	48 89 c2             	mov    %rax,%rdx
  800420bb25:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bb29:	48 29 c2             	sub    %rax,%rdx
  800420bb2c:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bb30:	48 83 c0 08          	add    $0x8,%rax
  800420bb34:	48 8b 00             	mov    (%rax),%rax
  800420bb37:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (idle != NULL)
  800420bb3b:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420bb40:	74 12                	je     800420bb54 <sched_yield+0x56>
		i = ENVX(idle->env_id);
  800420bb42:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420bb46:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420bb4c:	25 ff 03 00 00       	and    $0x3ff,%eax
  800420bb51:	89 45 fc             	mov    %eax,-0x4(%rbp)
	for (count = 0; count < NENV; count++) {
  800420bb54:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  800420bb5b:	e9 83 00 00 00       	jmpq   800420bbe3 <sched_yield+0xe5>
		i = (i + 1) % NENV;
  800420bb60:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420bb63:	8d 50 01             	lea    0x1(%rax),%edx
  800420bb66:	89 d0                	mov    %edx,%eax
  800420bb68:	c1 f8 1f             	sar    $0x1f,%eax
  800420bb6b:	c1 e8 16             	shr    $0x16,%eax
  800420bb6e:	01 c2                	add    %eax,%edx
  800420bb70:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
  800420bb76:	29 c2                	sub    %eax,%edx
  800420bb78:	89 d0                	mov    %edx,%eax
  800420bb7a:	89 45 fc             	mov    %eax,-0x4(%rbp)
		if (envs[i].env_status == ENV_RUNNABLE) {
  800420bb7d:	48 b8 50 52 49 04 80 	movabs $0x8004495250,%rax
  800420bb84:	00 00 00 
  800420bb87:	48 8b 08             	mov    (%rax),%rcx
  800420bb8a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420bb8d:	48 63 d0             	movslq %eax,%rdx
  800420bb90:	48 89 d0             	mov    %rdx,%rax
  800420bb93:	48 c1 e0 03          	shl    $0x3,%rax
  800420bb97:	48 01 d0             	add    %rdx,%rax
  800420bb9a:	48 c1 e0 05          	shl    $0x5,%rax
  800420bb9e:	48 01 c8             	add    %rcx,%rax
  800420bba1:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420bba7:	83 f8 02             	cmp    $0x2,%eax
  800420bbaa:	75 33                	jne    800420bbdf <sched_yield+0xe1>
			env_run(&envs[i]);
  800420bbac:	48 b8 50 52 49 04 80 	movabs $0x8004495250,%rax
  800420bbb3:	00 00 00 
  800420bbb6:	48 8b 08             	mov    (%rax),%rcx
  800420bbb9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420bbbc:	48 63 d0             	movslq %eax,%rdx
  800420bbbf:	48 89 d0             	mov    %rdx,%rax
  800420bbc2:	48 c1 e0 03          	shl    $0x3,%rax
  800420bbc6:	48 01 d0             	add    %rdx,%rax
  800420bbc9:	48 c1 e0 05          	shl    $0x5,%rax
  800420bbcd:	48 01 c8             	add    %rcx,%rax
  800420bbd0:	48 89 c7             	mov    %rax,%rdi
  800420bbd3:	48 b8 36 85 20 04 80 	movabs $0x8004208536,%rax
  800420bbda:	00 00 00 
  800420bbdd:	ff d0                	callq  *%rax
	int i, count;

	idle = thiscpu->cpu_env;
	if (idle != NULL)
		i = ENVX(idle->env_id);
	for (count = 0; count < NENV; count++) {
  800420bbdf:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  800420bbe3:	81 7d f8 ff 03 00 00 	cmpl   $0x3ff,-0x8(%rbp)
  800420bbea:	0f 8e 70 ff ff ff    	jle    800420bb60 <sched_yield+0x62>
			env_run(&envs[i]);
			return;
		}
	}

	if (idle && idle->env_status == ENV_RUNNING)
  800420bbf0:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420bbf5:	74 22                	je     800420bc19 <sched_yield+0x11b>
  800420bbf7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420bbfb:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420bc01:	83 f8 03             	cmp    $0x3,%eax
  800420bc04:	75 13                	jne    800420bc19 <sched_yield+0x11b>
		env_run(idle);
  800420bc06:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420bc0a:	48 89 c7             	mov    %rax,%rdi
  800420bc0d:	48 b8 36 85 20 04 80 	movabs $0x8004208536,%rax
  800420bc14:	00 00 00 
  800420bc17:	ff d0                	callq  *%rax

	// sched_halt never returns
	sched_halt();
  800420bc19:	48 b8 27 bc 20 04 80 	movabs $0x800420bc27,%rax
  800420bc20:	00 00 00 
  800420bc23:	ff d0                	callq  *%rax
}
  800420bc25:	c9                   	leaveq 
  800420bc26:	c3                   	retq   

000000800420bc27 <sched_halt>:
// Halt this CPU when there is nothing to do. Wait until the
// timer interrupt wakes it up. This function never returns.
//
void
sched_halt(void)
{
  800420bc27:	55                   	push   %rbp
  800420bc28:	48 89 e5             	mov    %rsp,%rbp
  800420bc2b:	48 83 ec 20          	sub    $0x20,%rsp
	int i;

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
  800420bc2f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420bc36:	e9 91 00 00 00       	jmpq   800420bccc <sched_halt+0xa5>
		if ((envs[i].env_status == ENV_RUNNABLE ||
  800420bc3b:	48 b8 50 52 49 04 80 	movabs $0x8004495250,%rax
  800420bc42:	00 00 00 
  800420bc45:	48 8b 08             	mov    (%rax),%rcx
  800420bc48:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420bc4b:	48 63 d0             	movslq %eax,%rdx
  800420bc4e:	48 89 d0             	mov    %rdx,%rax
  800420bc51:	48 c1 e0 03          	shl    $0x3,%rax
  800420bc55:	48 01 d0             	add    %rdx,%rax
  800420bc58:	48 c1 e0 05          	shl    $0x5,%rax
  800420bc5c:	48 01 c8             	add    %rcx,%rax
  800420bc5f:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420bc65:	83 f8 02             	cmp    $0x2,%eax
  800420bc68:	74 6f                	je     800420bcd9 <sched_halt+0xb2>
		     envs[i].env_status == ENV_RUNNING ||
  800420bc6a:	48 b8 50 52 49 04 80 	movabs $0x8004495250,%rax
  800420bc71:	00 00 00 
  800420bc74:	48 8b 08             	mov    (%rax),%rcx
  800420bc77:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420bc7a:	48 63 d0             	movslq %eax,%rdx
  800420bc7d:	48 89 d0             	mov    %rdx,%rax
  800420bc80:	48 c1 e0 03          	shl    $0x3,%rax
  800420bc84:	48 01 d0             	add    %rdx,%rax
  800420bc87:	48 c1 e0 05          	shl    $0x5,%rax
  800420bc8b:	48 01 c8             	add    %rcx,%rax
  800420bc8e:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
	int i;

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
		if ((envs[i].env_status == ENV_RUNNABLE ||
  800420bc94:	83 f8 03             	cmp    $0x3,%eax
  800420bc97:	74 40                	je     800420bcd9 <sched_halt+0xb2>
		     envs[i].env_status == ENV_RUNNING ||
		     envs[i].env_status == ENV_DYING))
  800420bc99:	48 b8 50 52 49 04 80 	movabs $0x8004495250,%rax
  800420bca0:	00 00 00 
  800420bca3:	48 8b 08             	mov    (%rax),%rcx
  800420bca6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420bca9:	48 63 d0             	movslq %eax,%rdx
  800420bcac:	48 89 d0             	mov    %rdx,%rax
  800420bcaf:	48 c1 e0 03          	shl    $0x3,%rax
  800420bcb3:	48 01 d0             	add    %rdx,%rax
  800420bcb6:	48 c1 e0 05          	shl    $0x5,%rax
  800420bcba:	48 01 c8             	add    %rcx,%rax
  800420bcbd:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
		if ((envs[i].env_status == ENV_RUNNABLE ||
		     envs[i].env_status == ENV_RUNNING ||
  800420bcc3:	83 f8 01             	cmp    $0x1,%eax
  800420bcc6:	74 11                	je     800420bcd9 <sched_halt+0xb2>
{
	int i;

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
  800420bcc8:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420bccc:	81 7d fc ff 03 00 00 	cmpl   $0x3ff,-0x4(%rbp)
  800420bcd3:	0f 8e 62 ff ff ff    	jle    800420bc3b <sched_halt+0x14>
		if ((envs[i].env_status == ENV_RUNNABLE ||
		     envs[i].env_status == ENV_RUNNING ||
		     envs[i].env_status == ENV_DYING))
			break;
	}
	if (i == NENV) {
  800420bcd9:	81 7d fc 00 04 00 00 	cmpl   $0x400,-0x4(%rbp)
  800420bce0:	75 2e                	jne    800420bd10 <sched_halt+0xe9>
		cprintf("No runnable environments in the system!\n");
  800420bce2:	48 bf 20 76 21 04 80 	movabs $0x8004217620,%rdi
  800420bce9:	00 00 00 
  800420bcec:	b8 00 00 00 00       	mov    $0x0,%eax
  800420bcf1:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  800420bcf8:	00 00 00 
  800420bcfb:	ff d2                	callq  *%rdx
		while (1)
			monitor(NULL);
  800420bcfd:	bf 00 00 00 00       	mov    $0x0,%edi
  800420bd02:	48 b8 9a 18 20 04 80 	movabs $0x800420189a,%rax
  800420bd09:	00 00 00 
  800420bd0c:	ff d0                	callq  *%rax
  800420bd0e:	eb ed                	jmp    800420bcfd <sched_halt+0xd6>
	}

	// Mark that no environment is running on this CPU
	curenv = NULL;
  800420bd10:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420bd17:	00 00 00 
  800420bd1a:	ff d0                	callq  *%rax
  800420bd1c:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  800420bd23:	00 00 00 
  800420bd26:	48 98                	cltq   
  800420bd28:	48 c1 e0 03          	shl    $0x3,%rax
  800420bd2c:	48 89 c2             	mov    %rax,%rdx
  800420bd2f:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bd33:	48 29 c2             	sub    %rax,%rdx
  800420bd36:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bd3a:	48 83 c0 08          	add    $0x8,%rax
  800420bd3e:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	lcr3(PADDR(boot_pml4e));
  800420bd45:	48 b8 a8 67 49 04 80 	movabs $0x80044967a8,%rax
  800420bd4c:	00 00 00 
  800420bd4f:	48 8b 00             	mov    (%rax),%rax
  800420bd52:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420bd56:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420bd5d:	00 00 00 
  800420bd60:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  800420bd64:	77 32                	ja     800420bd98 <sched_halt+0x171>
  800420bd66:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420bd6a:	48 89 c1             	mov    %rax,%rcx
  800420bd6d:	48 ba 50 76 21 04 80 	movabs $0x8004217650,%rdx
  800420bd74:	00 00 00 
  800420bd77:	be 4c 00 00 00       	mov    $0x4c,%esi
  800420bd7c:	48 bf 74 76 21 04 80 	movabs $0x8004217674,%rdi
  800420bd83:	00 00 00 
  800420bd86:	b8 00 00 00 00       	mov    $0x0,%eax
  800420bd8b:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420bd92:	00 00 00 
  800420bd95:	41 ff d0             	callq  *%r8
  800420bd98:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420bd9f:	ff ff ff 
  800420bda2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420bda6:	48 01 d0             	add    %rdx,%rax
  800420bda9:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  800420bdad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bdb1:	0f 22 d8             	mov    %rax,%cr3

	// Mark that this CPU is in the HALT state, so that when
	// timer interupts come in, we know we should re-acquire the
	// big kernel lock
	xchg(&thiscpu->cpu_status, CPU_HALTED);
  800420bdb4:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420bdbb:	00 00 00 
  800420bdbe:	ff d0                	callq  *%rax
  800420bdc0:	48 98                	cltq   
  800420bdc2:	48 c1 e0 03          	shl    $0x3,%rax
  800420bdc6:	48 89 c2             	mov    %rax,%rdx
  800420bdc9:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bdcd:	48 29 c2             	sub    %rax,%rdx
  800420bdd0:	48 b8 20 80 49 04 80 	movabs $0x8004498020,%rax
  800420bdd7:	00 00 00 
  800420bdda:	48 01 d0             	add    %rdx,%rax
  800420bddd:	48 83 c0 04          	add    $0x4,%rax
  800420bde1:	be 02 00 00 00       	mov    $0x2,%esi
  800420bde6:	48 89 c7             	mov    %rax,%rdi
  800420bde9:	48 b8 bb ba 20 04 80 	movabs $0x800420babb,%rax
  800420bdf0:	00 00 00 
  800420bdf3:	ff d0                	callq  *%rax

	// Release the big kernel lock as if we were "leaving" the kernel
	unlock_kernel();
  800420bdf5:	48 b8 e0 ba 20 04 80 	movabs $0x800420bae0,%rax
  800420bdfc:	00 00 00 
  800420bdff:	ff d0                	callq  *%rax
		"movq %0, %%rsp\n"
		"pushq $0\n"
		"pushq $0\n"
		"sti\n"
		"hlt\n"
		: : "a" (thiscpu->cpu_ts.ts_esp0));
  800420be01:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420be08:	00 00 00 
  800420be0b:	ff d0                	callq  *%rax
  800420be0d:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  800420be14:	00 00 00 
  800420be17:	48 98                	cltq   
  800420be19:	48 c1 e0 03          	shl    $0x3,%rax
  800420be1d:	48 89 c2             	mov    %rax,%rdx
  800420be20:	48 c1 e2 04          	shl    $0x4,%rdx
  800420be24:	48 29 c2             	sub    %rax,%rdx
  800420be27:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420be2b:	48 83 c0 10          	add    $0x10,%rax
  800420be2f:	48 8b 40 04          	mov    0x4(%rax),%rax

	// Release the big kernel lock as if we were "leaving" the kernel
	unlock_kernel();

	// Reset stack pointer, enable interrupts and then halt.
	asm volatile (
  800420be33:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp
  800420be3a:	48 89 c4             	mov    %rax,%rsp
  800420be3d:	6a 00                	pushq  $0x0
  800420be3f:	6a 00                	pushq  $0x0
  800420be41:	fb                   	sti    
  800420be42:	f4                   	hlt    
		"pushq $0\n"
		"pushq $0\n"
		"sti\n"
		"hlt\n"
		: : "a" (thiscpu->cpu_ts.ts_esp0));
}
  800420be43:	c9                   	leaveq 
  800420be44:	c3                   	retq   

000000800420be45 <page2ppn>:
int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);

static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  800420be45:	55                   	push   %rbp
  800420be46:	48 89 e5             	mov    %rsp,%rbp
  800420be49:	48 83 ec 08          	sub    $0x8,%rsp
  800420be4d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  800420be51:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420be55:	48 b8 b8 67 49 04 80 	movabs $0x80044967b8,%rax
  800420be5c:	00 00 00 
  800420be5f:	48 8b 00             	mov    (%rax),%rax
  800420be62:	48 29 c2             	sub    %rax,%rdx
  800420be65:	48 89 d0             	mov    %rdx,%rax
  800420be68:	48 c1 f8 04          	sar    $0x4,%rax
}
  800420be6c:	c9                   	leaveq 
  800420be6d:	c3                   	retq   

000000800420be6e <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  800420be6e:	55                   	push   %rbp
  800420be6f:	48 89 e5             	mov    %rsp,%rbp
  800420be72:	48 83 ec 08          	sub    $0x8,%rsp
  800420be76:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  800420be7a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420be7e:	48 89 c7             	mov    %rax,%rdi
  800420be81:	48 b8 45 be 20 04 80 	movabs $0x800420be45,%rax
  800420be88:	00 00 00 
  800420be8b:	ff d0                	callq  *%rax
  800420be8d:	48 c1 e0 0c          	shl    $0xc,%rax
}
  800420be91:	c9                   	leaveq 
  800420be92:	c3                   	retq   

000000800420be93 <page2kva>:
	return &pages[PPN(pa)];
}

static inline void*
page2kva(struct PageInfo *pp)
{
  800420be93:	55                   	push   %rbp
  800420be94:	48 89 e5             	mov    %rsp,%rbp
  800420be97:	48 83 ec 20          	sub    $0x20,%rsp
  800420be9b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  800420be9f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bea3:	48 89 c7             	mov    %rax,%rdi
  800420bea6:	48 b8 6e be 20 04 80 	movabs $0x800420be6e,%rax
  800420bead:	00 00 00 
  800420beb0:	ff d0                	callq  *%rax
  800420beb2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420beb6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420beba:	48 c1 e8 0c          	shr    $0xc,%rax
  800420bebe:	89 45 f4             	mov    %eax,-0xc(%rbp)
  800420bec1:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800420bec4:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  800420becb:	00 00 00 
  800420bece:	48 8b 00             	mov    (%rax),%rax
  800420bed1:	48 39 c2             	cmp    %rax,%rdx
  800420bed4:	72 32                	jb     800420bf08 <page2kva+0x75>
  800420bed6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420beda:	48 89 c1             	mov    %rax,%rcx
  800420bedd:	48 ba 88 76 21 04 80 	movabs $0x8004217688,%rdx
  800420bee4:	00 00 00 
  800420bee7:	be 5b 00 00 00       	mov    $0x5b,%esi
  800420beec:	48 bf ab 76 21 04 80 	movabs $0x80042176ab,%rdi
  800420bef3:	00 00 00 
  800420bef6:	b8 00 00 00 00       	mov    $0x0,%eax
  800420befb:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420bf02:	00 00 00 
  800420bf05:	41 ff d0             	callq  *%r8
  800420bf08:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420bf0f:	00 00 00 
  800420bf12:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420bf16:	48 01 d0             	add    %rdx,%rax
}
  800420bf19:	c9                   	leaveq 
  800420bf1a:	c3                   	retq   

000000800420bf1b <sys_cputs>:
// Print a string to the system console.
// The string is exactly 'len' characters long.
// Destroys the environment on memory errors.
static void
sys_cputs(const char *s, size_t len)
{
  800420bf1b:	55                   	push   %rbp
  800420bf1c:	48 89 e5             	mov    %rsp,%rbp
  800420bf1f:	48 83 ec 10          	sub    $0x10,%rsp
  800420bf23:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420bf27:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	// Check that the user has permission to read memory [s, s+len).
	// Destroy the environment if not.

	// LAB 3: Your code here.
	user_mem_assert(curenv, s, len, PTE_U);
  800420bf2b:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420bf32:	00 00 00 
  800420bf35:	ff d0                	callq  *%rax
  800420bf37:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  800420bf3e:	00 00 00 
  800420bf41:	48 98                	cltq   
  800420bf43:	48 c1 e0 03          	shl    $0x3,%rax
  800420bf47:	48 89 c2             	mov    %rax,%rdx
  800420bf4a:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bf4e:	48 29 c2             	sub    %rax,%rdx
  800420bf51:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bf55:	48 83 c0 08          	add    $0x8,%rax
  800420bf59:	48 8b 00             	mov    (%rax),%rax
  800420bf5c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420bf60:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  800420bf64:	b9 04 00 00 00       	mov    $0x4,%ecx
  800420bf69:	48 89 c7             	mov    %rax,%rdi
  800420bf6c:	48 b8 5d 38 20 04 80 	movabs $0x800420385d,%rax
  800420bf73:	00 00 00 
  800420bf76:	ff d0                	callq  *%rax

	// Print the string supplied by the user.
	cprintf("%.*s", len, s);
  800420bf78:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420bf7c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420bf80:	48 89 c6             	mov    %rax,%rsi
  800420bf83:	48 bf b9 76 21 04 80 	movabs $0x80042176b9,%rdi
  800420bf8a:	00 00 00 
  800420bf8d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420bf92:	48 b9 7a 8a 20 04 80 	movabs $0x8004208a7a,%rcx
  800420bf99:	00 00 00 
  800420bf9c:	ff d1                	callq  *%rcx
}
  800420bf9e:	c9                   	leaveq 
  800420bf9f:	c3                   	retq   

000000800420bfa0 <sys_cgetc>:

// Read a character from the system console without blocking.
// Returns the character, or 0 if there is no input waiting.
static int
sys_cgetc(void)
{
  800420bfa0:	55                   	push   %rbp
  800420bfa1:	48 89 e5             	mov    %rsp,%rbp
	return cons_getc();
  800420bfa4:	48 b8 b2 10 20 04 80 	movabs $0x80042010b2,%rax
  800420bfab:	00 00 00 
  800420bfae:	ff d0                	callq  *%rax
}
  800420bfb0:	5d                   	pop    %rbp
  800420bfb1:	c3                   	retq   

000000800420bfb2 <sys_getenvid>:

// Returns the current environment's envid.
static envid_t
sys_getenvid(void)
{
  800420bfb2:	55                   	push   %rbp
  800420bfb3:	48 89 e5             	mov    %rsp,%rbp
	return curenv->env_id;
  800420bfb6:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420bfbd:	00 00 00 
  800420bfc0:	ff d0                	callq  *%rax
  800420bfc2:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  800420bfc9:	00 00 00 
  800420bfcc:	48 98                	cltq   
  800420bfce:	48 c1 e0 03          	shl    $0x3,%rax
  800420bfd2:	48 89 c2             	mov    %rax,%rdx
  800420bfd5:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bfd9:	48 29 c2             	sub    %rax,%rdx
  800420bfdc:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bfe0:	48 83 c0 08          	add    $0x8,%rax
  800420bfe4:	48 8b 00             	mov    (%rax),%rax
  800420bfe7:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
}
  800420bfed:	5d                   	pop    %rbp
  800420bfee:	c3                   	retq   

000000800420bfef <sys_env_destroy>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_destroy(envid_t envid)
{
  800420bfef:	55                   	push   %rbp
  800420bff0:	48 89 e5             	mov    %rsp,%rbp
  800420bff3:	53                   	push   %rbx
  800420bff4:	48 83 ec 28          	sub    $0x28,%rsp
  800420bff8:	89 7d dc             	mov    %edi,-0x24(%rbp)
	int r;
	struct Env *e;

	if ((r = envid2env(envid, &e, 1)) < 0)
  800420bffb:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  800420bfff:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420c002:	ba 01 00 00 00       	mov    $0x1,%edx
  800420c007:	48 89 ce             	mov    %rcx,%rsi
  800420c00a:	89 c7                	mov    %eax,%edi
  800420c00c:	48 b8 83 73 20 04 80 	movabs $0x8004207383,%rax
  800420c013:	00 00 00 
  800420c016:	ff d0                	callq  *%rax
  800420c018:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420c01b:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420c01f:	79 08                	jns    800420c029 <sys_env_destroy+0x3a>
		return r;
  800420c021:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420c024:	e9 08 01 00 00       	jmpq   800420c131 <sys_env_destroy+0x142>
	if (e == curenv)
  800420c029:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420c030:	00 00 00 
  800420c033:	ff d0                	callq  *%rax
  800420c035:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  800420c03c:	00 00 00 
  800420c03f:	48 98                	cltq   
  800420c041:	48 c1 e0 03          	shl    $0x3,%rax
  800420c045:	48 89 c2             	mov    %rax,%rdx
  800420c048:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c04c:	48 29 c2             	sub    %rax,%rdx
  800420c04f:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c053:	48 83 c0 08          	add    $0x8,%rax
  800420c057:	48 8b 10             	mov    (%rax),%rdx
  800420c05a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c05e:	48 39 c2             	cmp    %rax,%rdx
  800420c061:	75 56                	jne    800420c0b9 <sys_env_destroy+0xca>
		cprintf("[%08x] exiting gracefully\n", curenv->env_id);
  800420c063:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420c06a:	00 00 00 
  800420c06d:	ff d0                	callq  *%rax
  800420c06f:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  800420c076:	00 00 00 
  800420c079:	48 98                	cltq   
  800420c07b:	48 c1 e0 03          	shl    $0x3,%rax
  800420c07f:	48 89 c2             	mov    %rax,%rdx
  800420c082:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c086:	48 29 c2             	sub    %rax,%rdx
  800420c089:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c08d:	48 83 c0 08          	add    $0x8,%rax
  800420c091:	48 8b 00             	mov    (%rax),%rax
  800420c094:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420c09a:	89 c6                	mov    %eax,%esi
  800420c09c:	48 bf be 76 21 04 80 	movabs $0x80042176be,%rdi
  800420c0a3:	00 00 00 
  800420c0a6:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c0ab:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  800420c0b2:	00 00 00 
  800420c0b5:	ff d2                	callq  *%rdx
  800420c0b7:	eb 60                	jmp    800420c119 <sys_env_destroy+0x12a>
	else
		cprintf("[%08x] destroying %08x\n", curenv->env_id, e->env_id);
  800420c0b9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c0bd:	8b 98 c8 00 00 00    	mov    0xc8(%rax),%ebx
  800420c0c3:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420c0ca:	00 00 00 
  800420c0cd:	ff d0                	callq  *%rax
  800420c0cf:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  800420c0d6:	00 00 00 
  800420c0d9:	48 98                	cltq   
  800420c0db:	48 c1 e0 03          	shl    $0x3,%rax
  800420c0df:	48 89 c2             	mov    %rax,%rdx
  800420c0e2:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c0e6:	48 29 c2             	sub    %rax,%rdx
  800420c0e9:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c0ed:	48 83 c0 08          	add    $0x8,%rax
  800420c0f1:	48 8b 00             	mov    (%rax),%rax
  800420c0f4:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420c0fa:	89 da                	mov    %ebx,%edx
  800420c0fc:	89 c6                	mov    %eax,%esi
  800420c0fe:	48 bf d9 76 21 04 80 	movabs $0x80042176d9,%rdi
  800420c105:	00 00 00 
  800420c108:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c10d:	48 b9 7a 8a 20 04 80 	movabs $0x8004208a7a,%rcx
  800420c114:	00 00 00 
  800420c117:	ff d1                	callq  *%rcx
	env_destroy(e);
  800420c119:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c11d:	48 89 c7             	mov    %rax,%rdi
  800420c120:	48 b8 67 83 20 04 80 	movabs $0x8004208367,%rax
  800420c127:	00 00 00 
  800420c12a:	ff d0                	callq  *%rax
	return 0;
  800420c12c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420c131:	48 83 c4 28          	add    $0x28,%rsp
  800420c135:	5b                   	pop    %rbx
  800420c136:	5d                   	pop    %rbp
  800420c137:	c3                   	retq   

000000800420c138 <sys_yield>:

// Deschedule current environment and pick a different one to run.
static void
sys_yield(void)
{
  800420c138:	55                   	push   %rbp
  800420c139:	48 89 e5             	mov    %rsp,%rbp
	sched_yield();
  800420c13c:	48 b8 fe ba 20 04 80 	movabs $0x800420bafe,%rax
  800420c143:	00 00 00 
  800420c146:	ff d0                	callq  *%rax

000000800420c148 <sys_exofork>:
// Returns envid of new environment, or < 0 on error.  Errors are:
//	-E_NO_FREE_ENV if no free environment is available.
//	-E_NO_MEM on memory exhaustion.
static envid_t
sys_exofork(void)
{
  800420c148:	55                   	push   %rbp
  800420c149:	48 89 e5             	mov    %rsp,%rbp
  800420c14c:	53                   	push   %rbx
  800420c14d:	48 83 ec 18          	sub    $0x18,%rsp

	// LAB 4: Your code here.
	struct Env *env;
	int ret;

	if ((ret = env_alloc(&env, curenv->env_id)) < 0)
  800420c151:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420c158:	00 00 00 
  800420c15b:	ff d0                	callq  *%rax
  800420c15d:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  800420c164:	00 00 00 
  800420c167:	48 98                	cltq   
  800420c169:	48 c1 e0 03          	shl    $0x3,%rax
  800420c16d:	48 89 c2             	mov    %rax,%rdx
  800420c170:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c174:	48 29 c2             	sub    %rax,%rdx
  800420c177:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c17b:	48 83 c0 08          	add    $0x8,%rax
  800420c17f:	48 8b 00             	mov    (%rax),%rax
  800420c182:	8b 90 c8 00 00 00    	mov    0xc8(%rax),%edx
  800420c188:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  800420c18c:	89 d6                	mov    %edx,%esi
  800420c18e:	48 89 c7             	mov    %rax,%rdi
  800420c191:	48 b8 ac 77 20 04 80 	movabs $0x80042077ac,%rax
  800420c198:	00 00 00 
  800420c19b:	ff d0                	callq  *%rax
  800420c19d:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420c1a0:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420c1a4:	79 08                	jns    800420c1ae <sys_exofork+0x66>
		return ret;
  800420c1a6:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420c1a9:	e9 ae 00 00 00       	jmpq   800420c25c <sys_exofork+0x114>

	env->env_tf = curenv->env_tf;
  800420c1ae:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
  800420c1b2:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420c1b9:	00 00 00 
  800420c1bc:	ff d0                	callq  *%rax
  800420c1be:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  800420c1c5:	00 00 00 
  800420c1c8:	48 98                	cltq   
  800420c1ca:	48 c1 e0 03          	shl    $0x3,%rax
  800420c1ce:	48 89 c2             	mov    %rax,%rdx
  800420c1d1:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c1d5:	48 29 c2             	sub    %rax,%rdx
  800420c1d8:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c1dc:	48 83 c0 08          	add    $0x8,%rax
  800420c1e0:	48 8b 00             	mov    (%rax),%rax
  800420c1e3:	48 89 da             	mov    %rbx,%rdx
  800420c1e6:	48 89 c6             	mov    %rax,%rsi
  800420c1e9:	b8 18 00 00 00       	mov    $0x18,%eax
  800420c1ee:	48 89 d7             	mov    %rdx,%rdi
  800420c1f1:	48 89 c1             	mov    %rax,%rcx
  800420c1f4:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)

	// note: in new environment, return value should be 0
	env->env_tf.tf_regs.reg_rax = 0;
  800420c1f7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c1fb:	48 c7 40 70 00 00 00 	movq   $0x0,0x70(%rax)
  800420c202:	00 
	env->env_status = ENV_NOT_RUNNABLE;
  800420c203:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c207:	c7 80 d4 00 00 00 04 	movl   $0x4,0xd4(%rax)
  800420c20e:	00 00 00 
	env->env_parent_id = curenv->env_id;
  800420c211:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
  800420c215:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420c21c:	00 00 00 
  800420c21f:	ff d0                	callq  *%rax
  800420c221:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  800420c228:	00 00 00 
  800420c22b:	48 98                	cltq   
  800420c22d:	48 c1 e0 03          	shl    $0x3,%rax
  800420c231:	48 89 c2             	mov    %rax,%rdx
  800420c234:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c238:	48 29 c2             	sub    %rax,%rdx
  800420c23b:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c23f:	48 83 c0 08          	add    $0x8,%rax
  800420c243:	48 8b 00             	mov    (%rax),%rax
  800420c246:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420c24c:	89 83 cc 00 00 00    	mov    %eax,0xcc(%rbx)

	return env->env_id;
  800420c252:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c256:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
	//panic("sys_exofork not implemented");
}
  800420c25c:	48 83 c4 18          	add    $0x18,%rsp
  800420c260:	5b                   	pop    %rbx
  800420c261:	5d                   	pop    %rbp
  800420c262:	c3                   	retq   

000000800420c263 <sys_env_set_status>:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if status is not a valid status for an environment.
static int
sys_env_set_status(envid_t envid, int status)
{
  800420c263:	55                   	push   %rbp
  800420c264:	48 89 e5             	mov    %rsp,%rbp
  800420c267:	48 83 ec 20          	sub    $0x20,%rsp
  800420c26b:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420c26e:	89 75 e8             	mov    %esi,-0x18(%rbp)

	// LAB 4: Your code here.
	struct Env *env;
	int ret;

	if ((status != ENV_RUNNABLE) && (status != ENV_NOT_RUNNABLE))
  800420c271:	83 7d e8 02          	cmpl   $0x2,-0x18(%rbp)
  800420c275:	74 0d                	je     800420c284 <sys_env_set_status+0x21>
  800420c277:	83 7d e8 04          	cmpl   $0x4,-0x18(%rbp)
  800420c27b:	74 07                	je     800420c284 <sys_env_set_status+0x21>
		return -E_INVAL;
  800420c27d:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420c282:	eb 3d                	jmp    800420c2c1 <sys_env_set_status+0x5e>

	if ((ret = envid2env(envid, &env, 1)) < 0)
  800420c284:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420c288:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420c28b:	ba 01 00 00 00       	mov    $0x1,%edx
  800420c290:	48 89 ce             	mov    %rcx,%rsi
  800420c293:	89 c7                	mov    %eax,%edi
  800420c295:	48 b8 83 73 20 04 80 	movabs $0x8004207383,%rax
  800420c29c:	00 00 00 
  800420c29f:	ff d0                	callq  *%rax
  800420c2a1:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420c2a4:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420c2a8:	79 05                	jns    800420c2af <sys_env_set_status+0x4c>
		return ret;
  800420c2aa:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420c2ad:	eb 12                	jmp    800420c2c1 <sys_env_set_status+0x5e>

	env->env_status = status;
  800420c2af:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c2b3:	8b 55 e8             	mov    -0x18(%rbp),%edx
  800420c2b6:	89 90 d4 00 00 00    	mov    %edx,0xd4(%rax)

	return 0;
  800420c2bc:	b8 00 00 00 00       	mov    $0x0,%eax
	//panic("sys_env_set_status not implemented");
}
  800420c2c1:	c9                   	leaveq 
  800420c2c2:	c3                   	retq   

000000800420c2c3 <sys_env_set_trapframe>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  800420c2c3:	55                   	push   %rbp
  800420c2c4:	48 89 e5             	mov    %rsp,%rbp
  800420c2c7:	48 83 ec 20          	sub    $0x20,%rsp
  800420c2cb:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420c2ce:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Remember to check whether the user has supplied us with a good
	// address!
	struct Env *env;
	int ret;

	if ((ret = envid2env(envid, &env, 1)) < 0)
  800420c2d2:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420c2d6:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420c2d9:	ba 01 00 00 00       	mov    $0x1,%edx
  800420c2de:	48 89 ce             	mov    %rcx,%rsi
  800420c2e1:	89 c7                	mov    %eax,%edi
  800420c2e3:	48 b8 83 73 20 04 80 	movabs $0x8004207383,%rax
  800420c2ea:	00 00 00 
  800420c2ed:	ff d0                	callq  *%rax
  800420c2ef:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420c2f2:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420c2f6:	79 05                	jns    800420c2fd <sys_env_set_trapframe+0x3a>
		return ret;
  800420c2f8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420c2fb:	eb 44                	jmp    800420c341 <sys_env_set_trapframe+0x7e>

	env->env_tf = *tf;
  800420c2fd:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420c301:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c305:	48 89 c6             	mov    %rax,%rsi
  800420c308:	b8 18 00 00 00       	mov    $0x18,%eax
  800420c30d:	48 89 d7             	mov    %rdx,%rdi
  800420c310:	48 89 c1             	mov    %rax,%rcx
  800420c313:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
	env->env_tf.tf_eflags |= FL_IF;
  800420c316:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c31a:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420c31e:	48 8b 92 a8 00 00 00 	mov    0xa8(%rdx),%rdx
  800420c325:	80 ce 02             	or     $0x2,%dh
  800420c328:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)
	env->env_tf.tf_cs = GD_UT | 3;
  800420c32f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c333:	66 c7 80 a0 00 00 00 	movw   $0x1b,0xa0(%rax)
  800420c33a:	1b 00 

	return 0;
  800420c33c:	b8 00 00 00 00       	mov    $0x0,%eax
	//panic("sys_env_set_trapframe not implemented");
}
  800420c341:	c9                   	leaveq 
  800420c342:	c3                   	retq   

000000800420c343 <sys_env_set_pgfault_upcall>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_set_pgfault_upcall(envid_t envid, void *func)
{
  800420c343:	55                   	push   %rbp
  800420c344:	48 89 e5             	mov    %rsp,%rbp
  800420c347:	48 83 ec 20          	sub    $0x20,%rsp
  800420c34b:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420c34e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// LAB 4: Your code here.
	struct Env *env;
	int ret;

	if ((ret = envid2env(envid, &env, 1)) < 0)
  800420c352:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420c356:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420c359:	ba 01 00 00 00       	mov    $0x1,%edx
  800420c35e:	48 89 ce             	mov    %rcx,%rsi
  800420c361:	89 c7                	mov    %eax,%edi
  800420c363:	48 b8 83 73 20 04 80 	movabs $0x8004207383,%rax
  800420c36a:	00 00 00 
  800420c36d:	ff d0                	callq  *%rax
  800420c36f:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420c372:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420c376:	79 05                	jns    800420c37d <sys_env_set_pgfault_upcall+0x3a>
		return ret;
  800420c378:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420c37b:	eb 14                	jmp    800420c391 <sys_env_set_pgfault_upcall+0x4e>

	env->env_pgfault_upcall = func;
  800420c37d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c381:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420c385:	48 89 90 f0 00 00 00 	mov    %rdx,0xf0(%rax)

	return 0;
  800420c38c:	b8 00 00 00 00       	mov    $0x0,%eax
	//panic("sys_env_set_pgfault_upcall not implemented");
}
  800420c391:	c9                   	leaveq 
  800420c392:	c3                   	retq   

000000800420c393 <sys_page_alloc>:
//	-E_INVAL if perm is inappropriate (see above).
//	-E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  800420c393:	55                   	push   %rbp
  800420c394:	48 89 e5             	mov    %rsp,%rbp
  800420c397:	48 83 ec 30          	sub    $0x30,%rsp
  800420c39b:	89 7d dc             	mov    %edi,-0x24(%rbp)
  800420c39e:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420c3a2:	89 55 d8             	mov    %edx,-0x28(%rbp)
	// LAB 4: Your code here.
	struct Env *env;
	struct PageInfo *pp;
	int ret;

	if ((ret = envid2env(envid, &env, 1)) < 0)
  800420c3a5:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420c3a9:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420c3ac:	ba 01 00 00 00       	mov    $0x1,%edx
  800420c3b1:	48 89 ce             	mov    %rcx,%rsi
  800420c3b4:	89 c7                	mov    %eax,%edi
  800420c3b6:	48 b8 83 73 20 04 80 	movabs $0x8004207383,%rax
  800420c3bd:	00 00 00 
  800420c3c0:	ff d0                	callq  *%rax
  800420c3c2:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420c3c5:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420c3c9:	79 08                	jns    800420c3d3 <sys_page_alloc+0x40>
		return ret;
  800420c3cb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420c3ce:	e9 e6 00 00 00       	jmpq   800420c4b9 <sys_page_alloc+0x126>

	if (((uintptr_t)va >= UTOP) || (PGOFF(va) != 0))
  800420c3d3:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420c3d7:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420c3de:	00 00 00 
  800420c3e1:	48 39 c2             	cmp    %rax,%rdx
  800420c3e4:	77 0e                	ja     800420c3f4 <sys_page_alloc+0x61>
  800420c3e6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420c3ea:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420c3ef:	48 85 c0             	test   %rax,%rax
  800420c3f2:	74 0a                	je     800420c3fe <sys_page_alloc+0x6b>
		return -E_INVAL;
  800420c3f4:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420c3f9:	e9 bb 00 00 00       	jmpq   800420c4b9 <sys_page_alloc+0x126>

	if ((perm & ~PTE_SYSCALL) || ((perm & (PTE_P | PTE_U)) != (PTE_P | PTE_U)))
  800420c3fe:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420c401:	25 f8 f1 ff ff       	and    $0xfffff1f8,%eax
  800420c406:	85 c0                	test   %eax,%eax
  800420c408:	75 0b                	jne    800420c415 <sys_page_alloc+0x82>
  800420c40a:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420c40d:	83 e0 05             	and    $0x5,%eax
  800420c410:	83 f8 05             	cmp    $0x5,%eax
  800420c413:	74 0a                	je     800420c41f <sys_page_alloc+0x8c>
		return -E_INVAL;
  800420c415:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420c41a:	e9 9a 00 00 00       	jmpq   800420c4b9 <sys_page_alloc+0x126>

	if ((pp = page_alloc(0)) == NULL)
  800420c41f:	bf 00 00 00 00       	mov    $0x0,%edi
  800420c424:	48 b8 72 2b 20 04 80 	movabs $0x8004202b72,%rax
  800420c42b:	00 00 00 
  800420c42e:	ff d0                	callq  *%rax
  800420c430:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420c434:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420c439:	75 07                	jne    800420c442 <sys_page_alloc+0xaf>
		return -E_NO_MEM;
  800420c43b:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420c440:	eb 77                	jmp    800420c4b9 <sys_page_alloc+0x126>

	if ((ret = page_insert(env->env_pml4e, pp, va, perm)) < 0) {
  800420c442:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c446:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420c44d:	8b 4d d8             	mov    -0x28(%rbp),%ecx
  800420c450:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420c454:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  800420c458:	48 89 c7             	mov    %rax,%rdi
  800420c45b:	48 b8 d1 32 20 04 80 	movabs $0x80042032d1,%rax
  800420c462:	00 00 00 
  800420c465:	ff d0                	callq  *%rax
  800420c467:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420c46a:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420c46e:	79 18                	jns    800420c488 <sys_page_alloc+0xf5>
		page_free(pp);
  800420c470:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c474:	48 89 c7             	mov    %rax,%rdi
  800420c477:	48 b8 11 2c 20 04 80 	movabs $0x8004202c11,%rax
  800420c47e:	00 00 00 
  800420c481:	ff d0                	callq  *%rax
		return ret;
  800420c483:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420c486:	eb 31                	jmp    800420c4b9 <sys_page_alloc+0x126>
	}

	memset(page2kva(pp), 0, PGSIZE);
  800420c488:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c48c:	48 89 c7             	mov    %rax,%rdi
  800420c48f:	48 b8 93 be 20 04 80 	movabs $0x800420be93,%rax
  800420c496:	00 00 00 
  800420c499:	ff d0                	callq  *%rax
  800420c49b:	ba 00 10 00 00       	mov    $0x1000,%edx
  800420c4a0:	be 00 00 00 00       	mov    $0x0,%esi
  800420c4a5:	48 89 c7             	mov    %rax,%rdi
  800420c4a8:	48 b8 db e8 20 04 80 	movabs $0x800420e8db,%rax
  800420c4af:	00 00 00 
  800420c4b2:	ff d0                	callq  *%rax

	return 0;
  800420c4b4:	b8 00 00 00 00       	mov    $0x0,%eax
	//panic("sys_page_alloc not implemented");
}
  800420c4b9:	c9                   	leaveq 
  800420c4ba:	c3                   	retq   

000000800420c4bb <sys_page_map>:
//		address space.
//	-E_NO_MEM if there's no memory to allocate any necessary page tables.
static int
sys_page_map(envid_t srcenvid, void *srcva,
	     envid_t dstenvid, void *dstva, int perm)
{
  800420c4bb:	55                   	push   %rbp
  800420c4bc:	48 89 e5             	mov    %rsp,%rbp
  800420c4bf:	48 83 ec 40          	sub    $0x40,%rsp
  800420c4c3:	89 7d dc             	mov    %edi,-0x24(%rbp)
  800420c4c6:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420c4ca:	89 55 d8             	mov    %edx,-0x28(%rbp)
  800420c4cd:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
  800420c4d1:	44 89 45 c4          	mov    %r8d,-0x3c(%rbp)
	struct Env *env;
	struct PageInfo *pp;
	int ret;
	pte_t *pte;

	if ((ret = envid2env(srcenvid, &env, 1)) < 0)
  800420c4d5:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420c4d9:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420c4dc:	ba 01 00 00 00       	mov    $0x1,%edx
  800420c4e1:	48 89 ce             	mov    %rcx,%rsi
  800420c4e4:	89 c7                	mov    %eax,%edi
  800420c4e6:	48 b8 83 73 20 04 80 	movabs $0x8004207383,%rax
  800420c4ed:	00 00 00 
  800420c4f0:	ff d0                	callq  *%rax
  800420c4f2:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420c4f5:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420c4f9:	79 08                	jns    800420c503 <sys_page_map+0x48>
		return ret;
  800420c4fb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420c4fe:	e9 34 01 00 00       	jmpq   800420c637 <sys_page_map+0x17c>

	if (((uintptr_t)srcva >= UTOP) || (PGOFF(srcva) != 0))
  800420c503:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420c507:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420c50e:	00 00 00 
  800420c511:	48 39 c2             	cmp    %rax,%rdx
  800420c514:	77 0e                	ja     800420c524 <sys_page_map+0x69>
  800420c516:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420c51a:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420c51f:	48 85 c0             	test   %rax,%rax
  800420c522:	74 0a                	je     800420c52e <sys_page_map+0x73>
		return -E_INVAL;
  800420c524:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420c529:	e9 09 01 00 00       	jmpq   800420c637 <sys_page_map+0x17c>

	if ((perm & ~PTE_SYSCALL) || ((perm & (PTE_P | PTE_U)) != (PTE_P | PTE_U)))
  800420c52e:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800420c531:	25 f8 f1 ff ff       	and    $0xfffff1f8,%eax
  800420c536:	85 c0                	test   %eax,%eax
  800420c538:	75 0b                	jne    800420c545 <sys_page_map+0x8a>
  800420c53a:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800420c53d:	83 e0 05             	and    $0x5,%eax
  800420c540:	83 f8 05             	cmp    $0x5,%eax
  800420c543:	74 0a                	je     800420c54f <sys_page_map+0x94>
		return -E_INVAL;
  800420c545:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420c54a:	e9 e8 00 00 00       	jmpq   800420c637 <sys_page_map+0x17c>

	if ((pp = page_lookup(env->env_pml4e, srcva, &pte)) == NULL)
  800420c54f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c553:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420c55a:	48 8d 55 e0          	lea    -0x20(%rbp),%rdx
  800420c55e:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  800420c562:	48 89 ce             	mov    %rcx,%rsi
  800420c565:	48 89 c7             	mov    %rax,%rdi
  800420c568:	48 b8 1a 34 20 04 80 	movabs $0x800420341a,%rax
  800420c56f:	00 00 00 
  800420c572:	ff d0                	callq  *%rax
  800420c574:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420c578:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420c57d:	75 0a                	jne    800420c589 <sys_page_map+0xce>
		return -E_INVAL;
  800420c57f:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420c584:	e9 ae 00 00 00       	jmpq   800420c637 <sys_page_map+0x17c>

	if ((ret = envid2env(dstenvid, &env, 1)) < 0)
  800420c589:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420c58d:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420c590:	ba 01 00 00 00       	mov    $0x1,%edx
  800420c595:	48 89 ce             	mov    %rcx,%rsi
  800420c598:	89 c7                	mov    %eax,%edi
  800420c59a:	48 b8 83 73 20 04 80 	movabs $0x8004207383,%rax
  800420c5a1:	00 00 00 
  800420c5a4:	ff d0                	callq  *%rax
  800420c5a6:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420c5a9:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420c5ad:	79 08                	jns    800420c5b7 <sys_page_map+0xfc>
		return ret;
  800420c5af:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420c5b2:	e9 80 00 00 00       	jmpq   800420c637 <sys_page_map+0x17c>

	if (((uintptr_t)dstva >= UTOP) || (PGOFF(dstva) != 0))
  800420c5b7:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420c5bb:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420c5c2:	00 00 00 
  800420c5c5:	48 39 c2             	cmp    %rax,%rdx
  800420c5c8:	77 0e                	ja     800420c5d8 <sys_page_map+0x11d>
  800420c5ca:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420c5ce:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420c5d3:	48 85 c0             	test   %rax,%rax
  800420c5d6:	74 07                	je     800420c5df <sys_page_map+0x124>
		return -E_INVAL;
  800420c5d8:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420c5dd:	eb 58                	jmp    800420c637 <sys_page_map+0x17c>

	if ((perm & PTE_W) && !(*pte & PTE_W))
  800420c5df:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800420c5e2:	83 e0 02             	and    $0x2,%eax
  800420c5e5:	85 c0                	test   %eax,%eax
  800420c5e7:	74 16                	je     800420c5ff <sys_page_map+0x144>
  800420c5e9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c5ed:	48 8b 00             	mov    (%rax),%rax
  800420c5f0:	83 e0 02             	and    $0x2,%eax
  800420c5f3:	48 85 c0             	test   %rax,%rax
  800420c5f6:	75 07                	jne    800420c5ff <sys_page_map+0x144>
		return -E_INVAL;
  800420c5f8:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420c5fd:	eb 38                	jmp    800420c637 <sys_page_map+0x17c>

	if ((ret = page_insert(env->env_pml4e, pp, dstva, perm)) < 0)
  800420c5ff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c603:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420c60a:	8b 4d c4             	mov    -0x3c(%rbp),%ecx
  800420c60d:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420c611:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  800420c615:	48 89 c7             	mov    %rax,%rdi
  800420c618:	48 b8 d1 32 20 04 80 	movabs $0x80042032d1,%rax
  800420c61f:	00 00 00 
  800420c622:	ff d0                	callq  *%rax
  800420c624:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420c627:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420c62b:	79 05                	jns    800420c632 <sys_page_map+0x177>
		return ret;
  800420c62d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420c630:	eb 05                	jmp    800420c637 <sys_page_map+0x17c>

	return 0;
  800420c632:	b8 00 00 00 00       	mov    $0x0,%eax
	//panic("sys_page_map not implemented");
}
  800420c637:	c9                   	leaveq 
  800420c638:	c3                   	retq   

000000800420c639 <sys_page_unmap>:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if va >= UTOP, or va is not page-aligned.
static int
sys_page_unmap(envid_t envid, void *va)
{
  800420c639:	55                   	push   %rbp
  800420c63a:	48 89 e5             	mov    %rsp,%rbp
  800420c63d:	48 83 ec 20          	sub    $0x20,%rsp
  800420c641:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420c644:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)

	// LAB 4: Your code here.
	struct Env *env;
	int ret;

	if ((ret = envid2env(envid, &env, 1)) < 0)
  800420c648:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420c64c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420c64f:	ba 01 00 00 00       	mov    $0x1,%edx
  800420c654:	48 89 ce             	mov    %rcx,%rsi
  800420c657:	89 c7                	mov    %eax,%edi
  800420c659:	48 b8 83 73 20 04 80 	movabs $0x8004207383,%rax
  800420c660:	00 00 00 
  800420c663:	ff d0                	callq  *%rax
  800420c665:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420c668:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420c66c:	79 05                	jns    800420c673 <sys_page_unmap+0x3a>
		return ret;
  800420c66e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420c671:	eb 4e                	jmp    800420c6c1 <sys_page_unmap+0x88>

	if (((uintptr_t)va >= UTOP) || (PGOFF(va) != 0))
  800420c673:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420c677:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420c67e:	00 00 00 
  800420c681:	48 39 c2             	cmp    %rax,%rdx
  800420c684:	77 0e                	ja     800420c694 <sys_page_unmap+0x5b>
  800420c686:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c68a:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420c68f:	48 85 c0             	test   %rax,%rax
  800420c692:	74 07                	je     800420c69b <sys_page_unmap+0x62>
		return -E_INVAL;
  800420c694:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420c699:	eb 26                	jmp    800420c6c1 <sys_page_unmap+0x88>

	page_remove(env->env_pml4e, va);
  800420c69b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c69f:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420c6a6:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420c6aa:	48 89 d6             	mov    %rdx,%rsi
  800420c6ad:	48 89 c7             	mov    %rax,%rdi
  800420c6b0:	48 b8 8f 34 20 04 80 	movabs $0x800420348f,%rax
  800420c6b7:	00 00 00 
  800420c6ba:	ff d0                	callq  *%rax

	return 0;
  800420c6bc:	b8 00 00 00 00       	mov    $0x0,%eax
	//panic("sys_page_unmap not implemented");
}
  800420c6c1:	c9                   	leaveq 
  800420c6c2:	c3                   	retq   

000000800420c6c3 <sys_ipc_try_send>:
//		current environment's address space.
//	-E_NO_MEM if there's not enough memory to map srcva in envid's
//		address space.
static int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, unsigned perm)
{
  800420c6c3:	55                   	push   %rbp
  800420c6c4:	48 89 e5             	mov    %rsp,%rbp
  800420c6c7:	53                   	push   %rbx
  800420c6c8:	48 83 ec 48          	sub    $0x48,%rsp
  800420c6cc:	89 7d cc             	mov    %edi,-0x34(%rbp)
  800420c6cf:	89 75 c8             	mov    %esi,-0x38(%rbp)
  800420c6d2:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420c6d6:	89 4d bc             	mov    %ecx,-0x44(%rbp)
	struct Env *env;
	struct PageInfo *pp;
	int ret;
	pte_t *pte;

	if ((ret = envid2env(envid, &env, 0)) < 0)
  800420c6d9:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  800420c6dd:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420c6e0:	ba 00 00 00 00       	mov    $0x0,%edx
  800420c6e5:	48 89 ce             	mov    %rcx,%rsi
  800420c6e8:	89 c7                	mov    %eax,%edi
  800420c6ea:	48 b8 83 73 20 04 80 	movabs $0x8004207383,%rax
  800420c6f1:	00 00 00 
  800420c6f4:	ff d0                	callq  *%rax
  800420c6f6:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420c6f9:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420c6fd:	79 08                	jns    800420c707 <sys_ipc_try_send+0x44>
		return ret;
  800420c6ff:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420c702:	e9 c6 01 00 00       	jmpq   800420c8cd <sys_ipc_try_send+0x20a>

	if (env->env_ipc_recving == 0)
  800420c707:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c70b:	0f b6 80 f8 00 00 00 	movzbl 0xf8(%rax),%eax
  800420c712:	83 f0 01             	xor    $0x1,%eax
  800420c715:	84 c0                	test   %al,%al
  800420c717:	74 0a                	je     800420c723 <sys_ipc_try_send+0x60>
		return -E_IPC_NOT_RECV;
  800420c719:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  800420c71e:	e9 aa 01 00 00       	jmpq   800420c8cd <sys_ipc_try_send+0x20a>

	env->env_ipc_recving = 0;
  800420c723:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c727:	c6 80 f8 00 00 00 00 	movb   $0x0,0xf8(%rax)
	env->env_ipc_from = curenv->env_id;
  800420c72e:	48 8b 5d d8          	mov    -0x28(%rbp),%rbx
  800420c732:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420c739:	00 00 00 
  800420c73c:	ff d0                	callq  *%rax
  800420c73e:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  800420c745:	00 00 00 
  800420c748:	48 98                	cltq   
  800420c74a:	48 c1 e0 03          	shl    $0x3,%rax
  800420c74e:	48 89 c2             	mov    %rax,%rdx
  800420c751:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c755:	48 29 c2             	sub    %rax,%rdx
  800420c758:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c75c:	48 83 c0 08          	add    $0x8,%rax
  800420c760:	48 8b 00             	mov    (%rax),%rax
  800420c763:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420c769:	89 83 0c 01 00 00    	mov    %eax,0x10c(%rbx)
	env->env_ipc_perm = perm;
  800420c76f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c773:	8b 55 bc             	mov    -0x44(%rbp),%edx
  800420c776:	89 90 10 01 00 00    	mov    %edx,0x110(%rax)
	env->env_ipc_value = value;
  800420c77c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c780:	8b 55 c8             	mov    -0x38(%rbp),%edx
  800420c783:	89 90 08 01 00 00    	mov    %edx,0x108(%rax)
	env->env_status = ENV_RUNNABLE;
  800420c789:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c78d:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  800420c794:	00 00 00 

	if ((uintptr_t)srcva >= UTOP || (uintptr_t)env->env_ipc_dstva >= UTOP)
  800420c797:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420c79b:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420c7a2:	00 00 00 
  800420c7a5:	48 39 c2             	cmp    %rax,%rdx
  800420c7a8:	77 1d                	ja     800420c7c7 <sys_ipc_try_send+0x104>
  800420c7aa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c7ae:	48 8b 80 00 01 00 00 	mov    0x100(%rax),%rax
  800420c7b5:	48 89 c2             	mov    %rax,%rdx
  800420c7b8:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420c7bf:	00 00 00 
  800420c7c2:	48 39 c2             	cmp    %rax,%rdx
  800420c7c5:	76 0a                	jbe    800420c7d1 <sys_ipc_try_send+0x10e>
		return 0;
  800420c7c7:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c7cc:	e9 fc 00 00 00       	jmpq   800420c8cd <sys_ipc_try_send+0x20a>

	if (PGOFF(srcva) != 0)
  800420c7d1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420c7d5:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420c7da:	48 85 c0             	test   %rax,%rax
  800420c7dd:	74 0a                	je     800420c7e9 <sys_ipc_try_send+0x126>
		return -E_INVAL;
  800420c7df:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420c7e4:	e9 e4 00 00 00       	jmpq   800420c8cd <sys_ipc_try_send+0x20a>

	if ((perm & ~PTE_SYSCALL) || ((perm & (PTE_P | PTE_U)) != (PTE_P | PTE_U)))
  800420c7e9:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800420c7ec:	25 f8 f1 ff ff       	and    $0xfffff1f8,%eax
  800420c7f1:	85 c0                	test   %eax,%eax
  800420c7f3:	75 0b                	jne    800420c800 <sys_ipc_try_send+0x13d>
  800420c7f5:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800420c7f8:	83 e0 05             	and    $0x5,%eax
  800420c7fb:	83 f8 05             	cmp    $0x5,%eax
  800420c7fe:	74 0a                	je     800420c80a <sys_ipc_try_send+0x147>
		return -E_INVAL;
  800420c800:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420c805:	e9 c3 00 00 00       	jmpq   800420c8cd <sys_ipc_try_send+0x20a>

	if ((pp = page_lookup(curenv->env_pml4e, srcva, &pte)) == NULL)
  800420c80a:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420c811:	00 00 00 
  800420c814:	ff d0                	callq  *%rax
  800420c816:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  800420c81d:	00 00 00 
  800420c820:	48 98                	cltq   
  800420c822:	48 c1 e0 03          	shl    $0x3,%rax
  800420c826:	48 89 c2             	mov    %rax,%rdx
  800420c829:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c82d:	48 29 c2             	sub    %rax,%rdx
  800420c830:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c834:	48 83 c0 08          	add    $0x8,%rax
  800420c838:	48 8b 00             	mov    (%rax),%rax
  800420c83b:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420c842:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  800420c846:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  800420c84a:	48 89 ce             	mov    %rcx,%rsi
  800420c84d:	48 89 c7             	mov    %rax,%rdi
  800420c850:	48 b8 1a 34 20 04 80 	movabs $0x800420341a,%rax
  800420c857:	00 00 00 
  800420c85a:	ff d0                	callq  *%rax
  800420c85c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420c860:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420c865:	75 07                	jne    800420c86e <sys_ipc_try_send+0x1ab>
		return -E_INVAL;
  800420c867:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420c86c:	eb 5f                	jmp    800420c8cd <sys_ipc_try_send+0x20a>

	if ((perm & PTE_W) && !(*pte & PTE_W))
  800420c86e:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800420c871:	83 e0 02             	and    $0x2,%eax
  800420c874:	85 c0                	test   %eax,%eax
  800420c876:	74 16                	je     800420c88e <sys_ipc_try_send+0x1cb>
  800420c878:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420c87c:	48 8b 00             	mov    (%rax),%rax
  800420c87f:	83 e0 02             	and    $0x2,%eax
  800420c882:	48 85 c0             	test   %rax,%rax
  800420c885:	75 07                	jne    800420c88e <sys_ipc_try_send+0x1cb>
		return -E_INVAL;
  800420c887:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420c88c:	eb 3f                	jmp    800420c8cd <sys_ipc_try_send+0x20a>

	if ((ret = page_insert(env->env_pml4e, pp, env->env_ipc_dstva, perm)) < 0)
  800420c88e:	8b 4d bc             	mov    -0x44(%rbp),%ecx
  800420c891:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c895:	48 8b 90 00 01 00 00 	mov    0x100(%rax),%rdx
  800420c89c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c8a0:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420c8a7:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420c8ab:	48 89 c7             	mov    %rax,%rdi
  800420c8ae:	48 b8 d1 32 20 04 80 	movabs $0x80042032d1,%rax
  800420c8b5:	00 00 00 
  800420c8b8:	ff d0                	callq  *%rax
  800420c8ba:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420c8bd:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420c8c1:	79 05                	jns    800420c8c8 <sys_ipc_try_send+0x205>
		return ret;
  800420c8c3:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420c8c6:	eb 05                	jmp    800420c8cd <sys_ipc_try_send+0x20a>

	return 0;
  800420c8c8:	b8 00 00 00 00       	mov    $0x0,%eax
	//panic("sys_ipc_try_send not implemented");
}
  800420c8cd:	48 83 c4 48          	add    $0x48,%rsp
  800420c8d1:	5b                   	pop    %rbx
  800420c8d2:	5d                   	pop    %rbp
  800420c8d3:	c3                   	retq   

000000800420c8d4 <sys_ipc_recv>:
// return 0 on success.
// Return < 0 on error.  Errors are:
//	-E_INVAL if dstva < UTOP but dstva is not page-aligned.
static int
sys_ipc_recv(void *dstva)
{
  800420c8d4:	55                   	push   %rbp
  800420c8d5:	48 89 e5             	mov    %rsp,%rbp
  800420c8d8:	48 83 ec 10          	sub    $0x10,%rsp
  800420c8dc:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// LAB 4: Your code here.
	if ((uintptr_t)dstva < UTOP && PGOFF(dstva) != 0)
  800420c8e0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420c8e4:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420c8eb:	00 00 00 
  800420c8ee:	48 39 c2             	cmp    %rax,%rdx
  800420c8f1:	77 18                	ja     800420c90b <sys_ipc_recv+0x37>
  800420c8f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c8f7:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420c8fc:	48 85 c0             	test   %rax,%rax
  800420c8ff:	74 0a                	je     800420c90b <sys_ipc_recv+0x37>
		return -E_INVAL;
  800420c901:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420c906:	e9 f4 00 00 00       	jmpq   800420c9ff <sys_ipc_recv+0x12b>

	curenv->env_ipc_recving = 1;
  800420c90b:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420c912:	00 00 00 
  800420c915:	ff d0                	callq  *%rax
  800420c917:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  800420c91e:	00 00 00 
  800420c921:	48 98                	cltq   
  800420c923:	48 c1 e0 03          	shl    $0x3,%rax
  800420c927:	48 89 c2             	mov    %rax,%rdx
  800420c92a:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c92e:	48 29 c2             	sub    %rax,%rdx
  800420c931:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c935:	48 83 c0 08          	add    $0x8,%rax
  800420c939:	48 8b 00             	mov    (%rax),%rax
  800420c93c:	c6 80 f8 00 00 00 01 	movb   $0x1,0xf8(%rax)
	curenv->env_ipc_dstva = dstva;
  800420c943:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420c94a:	00 00 00 
  800420c94d:	ff d0                	callq  *%rax
  800420c94f:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  800420c956:	00 00 00 
  800420c959:	48 98                	cltq   
  800420c95b:	48 c1 e0 03          	shl    $0x3,%rax
  800420c95f:	48 89 c2             	mov    %rax,%rdx
  800420c962:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c966:	48 29 c2             	sub    %rax,%rdx
  800420c969:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c96d:	48 83 c0 08          	add    $0x8,%rax
  800420c971:	48 8b 00             	mov    (%rax),%rax
  800420c974:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420c978:	48 89 90 00 01 00 00 	mov    %rdx,0x100(%rax)
	curenv->env_status = ENV_NOT_RUNNABLE;
  800420c97f:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420c986:	00 00 00 
  800420c989:	ff d0                	callq  *%rax
  800420c98b:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  800420c992:	00 00 00 
  800420c995:	48 98                	cltq   
  800420c997:	48 c1 e0 03          	shl    $0x3,%rax
  800420c99b:	48 89 c2             	mov    %rax,%rdx
  800420c99e:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c9a2:	48 29 c2             	sub    %rax,%rdx
  800420c9a5:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c9a9:	48 83 c0 08          	add    $0x8,%rax
  800420c9ad:	48 8b 00             	mov    (%rax),%rax
  800420c9b0:	c7 80 d4 00 00 00 04 	movl   $0x4,0xd4(%rax)
  800420c9b7:	00 00 00 
	curenv->env_tf.tf_regs.reg_rax = 0;
  800420c9ba:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420c9c1:	00 00 00 
  800420c9c4:	ff d0                	callq  *%rax
  800420c9c6:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  800420c9cd:	00 00 00 
  800420c9d0:	48 98                	cltq   
  800420c9d2:	48 c1 e0 03          	shl    $0x3,%rax
  800420c9d6:	48 89 c2             	mov    %rax,%rdx
  800420c9d9:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c9dd:	48 29 c2             	sub    %rax,%rdx
  800420c9e0:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c9e4:	48 83 c0 08          	add    $0x8,%rax
  800420c9e8:	48 8b 00             	mov    (%rax),%rax
  800420c9eb:	48 c7 40 70 00 00 00 	movq   $0x0,0x70(%rax)
  800420c9f2:	00 
	sched_yield();
  800420c9f3:	48 b8 fe ba 20 04 80 	movabs $0x800420bafe,%rax
  800420c9fa:	00 00 00 
  800420c9fd:	ff d0                	callq  *%rax

	//panic("sys_ipc_recv not implemented");
	return 0;
}
  800420c9ff:	c9                   	leaveq 
  800420ca00:	c3                   	retq   

000000800420ca01 <syscall>:


// Dispatches to the correct kernel function, passing the arguments.
int64_t
syscall(uint64_t syscallno, uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  800420ca01:	55                   	push   %rbp
  800420ca02:	48 89 e5             	mov    %rsp,%rbp
  800420ca05:	48 83 ec 30          	sub    $0x30,%rsp
  800420ca09:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420ca0d:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420ca11:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420ca15:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  800420ca19:	4c 89 45 d8          	mov    %r8,-0x28(%rbp)
  800420ca1d:	4c 89 4d d0          	mov    %r9,-0x30(%rbp)
	// Call the function corresponding to the 'syscallno' parameter.
	// Return any appropriate return value.
	// LAB 3: Your code here.

	//panic("syscall not implemented");
	switch (syscallno) {
  800420ca21:	48 83 7d f8 0d       	cmpq   $0xd,-0x8(%rbp)
  800420ca26:	0f 87 b5 01 00 00    	ja     800420cbe1 <syscall+0x1e0>
  800420ca2c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ca30:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420ca37:	00 
  800420ca38:	48 b8 f8 76 21 04 80 	movabs $0x80042176f8,%rax
  800420ca3f:	00 00 00 
  800420ca42:	48 01 d0             	add    %rdx,%rax
  800420ca45:	48 8b 00             	mov    (%rax),%rax
  800420ca48:	ff e0                	jmpq   *%rax
	case SYS_cputs:
		sys_cputs((char *)a1, a2);
  800420ca4a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ca4e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ca52:	48 89 d6             	mov    %rdx,%rsi
  800420ca55:	48 89 c7             	mov    %rax,%rdi
  800420ca58:	48 b8 1b bf 20 04 80 	movabs $0x800420bf1b,%rax
  800420ca5f:	00 00 00 
  800420ca62:	ff d0                	callq  *%rax
		return 0;
  800420ca64:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ca69:	e9 7a 01 00 00       	jmpq   800420cbe8 <syscall+0x1e7>
	case SYS_cgetc:
		return sys_cgetc();
  800420ca6e:	48 b8 a0 bf 20 04 80 	movabs $0x800420bfa0,%rax
  800420ca75:	00 00 00 
  800420ca78:	ff d0                	callq  *%rax
  800420ca7a:	48 98                	cltq   
  800420ca7c:	e9 67 01 00 00       	jmpq   800420cbe8 <syscall+0x1e7>
	case SYS_getenvid:
		return sys_getenvid();
  800420ca81:	48 b8 b2 bf 20 04 80 	movabs $0x800420bfb2,%rax
  800420ca88:	00 00 00 
  800420ca8b:	ff d0                	callq  *%rax
  800420ca8d:	48 98                	cltq   
  800420ca8f:	e9 54 01 00 00       	jmpq   800420cbe8 <syscall+0x1e7>
	case SYS_env_destroy:
		return sys_env_destroy(a1);
  800420ca94:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ca98:	89 c7                	mov    %eax,%edi
  800420ca9a:	48 b8 ef bf 20 04 80 	movabs $0x800420bfef,%rax
  800420caa1:	00 00 00 
  800420caa4:	ff d0                	callq  *%rax
  800420caa6:	48 98                	cltq   
  800420caa8:	e9 3b 01 00 00       	jmpq   800420cbe8 <syscall+0x1e7>

	// note: modified for LAB4
	case SYS_yield:
		sys_yield();
  800420caad:	48 b8 38 c1 20 04 80 	movabs $0x800420c138,%rax
  800420cab4:	00 00 00 
  800420cab7:	ff d0                	callq  *%rax
		return 0;
  800420cab9:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cabe:	e9 25 01 00 00       	jmpq   800420cbe8 <syscall+0x1e7>
	case SYS_exofork:
		return sys_exofork();
  800420cac3:	48 b8 48 c1 20 04 80 	movabs $0x800420c148,%rax
  800420caca:	00 00 00 
  800420cacd:	ff d0                	callq  *%rax
  800420cacf:	48 98                	cltq   
  800420cad1:	e9 12 01 00 00       	jmpq   800420cbe8 <syscall+0x1e7>
	case SYS_env_set_status:
		return sys_env_set_status((envid_t)a1, (int)a2);
  800420cad6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cada:	89 c2                	mov    %eax,%edx
  800420cadc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cae0:	89 d6                	mov    %edx,%esi
  800420cae2:	89 c7                	mov    %eax,%edi
  800420cae4:	48 b8 63 c2 20 04 80 	movabs $0x800420c263,%rax
  800420caeb:	00 00 00 
  800420caee:	ff d0                	callq  *%rax
  800420caf0:	48 98                	cltq   
  800420caf2:	e9 f1 00 00 00       	jmpq   800420cbe8 <syscall+0x1e7>
	case SYS_env_set_pgfault_upcall:
		return sys_env_set_pgfault_upcall((envid_t)a1, (void *)a2);
  800420caf7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420cafb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420caff:	48 89 d6             	mov    %rdx,%rsi
  800420cb02:	89 c7                	mov    %eax,%edi
  800420cb04:	48 b8 43 c3 20 04 80 	movabs $0x800420c343,%rax
  800420cb0b:	00 00 00 
  800420cb0e:	ff d0                	callq  *%rax
  800420cb10:	48 98                	cltq   
  800420cb12:	e9 d1 00 00 00       	jmpq   800420cbe8 <syscall+0x1e7>
	case SYS_page_alloc:
		return sys_page_alloc((envid_t)a1, (void *)a2, (int)a3);
  800420cb17:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420cb1b:	89 c2                	mov    %eax,%edx
  800420cb1d:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420cb21:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cb25:	48 89 ce             	mov    %rcx,%rsi
  800420cb28:	89 c7                	mov    %eax,%edi
  800420cb2a:	48 b8 93 c3 20 04 80 	movabs $0x800420c393,%rax
  800420cb31:	00 00 00 
  800420cb34:	ff d0                	callq  *%rax
  800420cb36:	48 98                	cltq   
  800420cb38:	e9 ab 00 00 00       	jmpq   800420cbe8 <syscall+0x1e7>
	case SYS_page_map:
		return sys_page_map((envid_t)a1, (void *)a2, (envid_t)a3, (void *)a4, (int)a5);
  800420cb3d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420cb41:	89 c7                	mov    %eax,%edi
  800420cb43:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420cb47:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420cb4b:	89 c2                	mov    %eax,%edx
  800420cb4d:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  800420cb51:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cb55:	41 89 f8             	mov    %edi,%r8d
  800420cb58:	89 c7                	mov    %eax,%edi
  800420cb5a:	48 b8 bb c4 20 04 80 	movabs $0x800420c4bb,%rax
  800420cb61:	00 00 00 
  800420cb64:	ff d0                	callq  *%rax
  800420cb66:	48 98                	cltq   
  800420cb68:	eb 7e                	jmp    800420cbe8 <syscall+0x1e7>
	case SYS_page_unmap:
		return sys_page_unmap((envid_t)a1, (void *)a2);
  800420cb6a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420cb6e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cb72:	48 89 d6             	mov    %rdx,%rsi
  800420cb75:	89 c7                	mov    %eax,%edi
  800420cb77:	48 b8 39 c6 20 04 80 	movabs $0x800420c639,%rax
  800420cb7e:	00 00 00 
  800420cb81:	ff d0                	callq  *%rax
  800420cb83:	48 98                	cltq   
  800420cb85:	eb 61                	jmp    800420cbe8 <syscall+0x1e7>
	case SYS_ipc_try_send:
		return sys_ipc_try_send((envid_t)a1, (uint32_t)a2, (void *)a3, (unsigned)a4);
  800420cb87:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420cb8b:	89 c1                	mov    %eax,%ecx
  800420cb8d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420cb91:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cb95:	89 c6                	mov    %eax,%esi
  800420cb97:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cb9b:	89 c7                	mov    %eax,%edi
  800420cb9d:	48 b8 c3 c6 20 04 80 	movabs $0x800420c6c3,%rax
  800420cba4:	00 00 00 
  800420cba7:	ff d0                	callq  *%rax
  800420cba9:	48 98                	cltq   
  800420cbab:	eb 3b                	jmp    800420cbe8 <syscall+0x1e7>
	case SYS_ipc_recv:
		return sys_ipc_recv((void *)a1);
  800420cbad:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cbb1:	48 89 c7             	mov    %rax,%rdi
  800420cbb4:	48 b8 d4 c8 20 04 80 	movabs $0x800420c8d4,%rax
  800420cbbb:	00 00 00 
  800420cbbe:	ff d0                	callq  *%rax
  800420cbc0:	48 98                	cltq   
  800420cbc2:	eb 24                	jmp    800420cbe8 <syscall+0x1e7>

	// note: modified for LAB5
	case SYS_env_set_trapframe:
		return sys_env_set_trapframe((envid_t)a1, (struct Trapframe *)a2);
  800420cbc4:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420cbc8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cbcc:	48 89 d6             	mov    %rdx,%rsi
  800420cbcf:	89 c7                	mov    %eax,%edi
  800420cbd1:	48 b8 c3 c2 20 04 80 	movabs $0x800420c2c3,%rax
  800420cbd8:	00 00 00 
  800420cbdb:	ff d0                	callq  *%rax
  800420cbdd:	48 98                	cltq   
  800420cbdf:	eb 07                	jmp    800420cbe8 <syscall+0x1e7>

	default:
		return -E_NO_SYS;
  800420cbe1:	48 c7 c0 f9 ff ff ff 	mov    $0xfffffffffffffff9,%rax
	}
}
  800420cbe8:	c9                   	leaveq 
  800420cbe9:	c3                   	retq   

000000800420cbea <list_func_die>:
	const char *stabstr;
	const char *stabstr_end;
};

int list_func_die(struct Ripdebuginfo *info, Dwarf_Die *die, uint64_t addr)
{
  800420cbea:	55                   	push   %rbp
  800420cbeb:	48 89 e5             	mov    %rsp,%rbp
  800420cbee:	48 81 ec f0 61 00 00 	sub    $0x61f0,%rsp
  800420cbf5:	48 89 bd 58 9e ff ff 	mov    %rdi,-0x61a8(%rbp)
  800420cbfc:	48 89 b5 50 9e ff ff 	mov    %rsi,-0x61b0(%rbp)
  800420cc03:	48 89 95 48 9e ff ff 	mov    %rdx,-0x61b8(%rbp)
	_Dwarf_Line ln;
	Dwarf_Attribute *low;
	Dwarf_Attribute *high;
	Dwarf_CU *cu = die->cu_header;
  800420cc0a:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420cc11:	48 8b 80 60 03 00 00 	mov    0x360(%rax),%rax
  800420cc18:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	Dwarf_Die *cudie = die->cu_die; 
  800420cc1c:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420cc23:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420cc2a:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	Dwarf_Die ret, sib=*die; 
  800420cc2e:	48 8b 95 50 9e ff ff 	mov    -0x61b0(%rbp),%rdx
  800420cc35:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420cc3c:	48 89 d1             	mov    %rdx,%rcx
  800420cc3f:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420cc44:	48 89 ce             	mov    %rcx,%rsi
  800420cc47:	48 89 c7             	mov    %rax,%rdi
  800420cc4a:	48 b8 7d ea 20 04 80 	movabs $0x800420ea7d,%rax
  800420cc51:	00 00 00 
  800420cc54:	ff d0                	callq  *%rax
	Dwarf_Attribute *attr;
	uint64_t offset;
	uint64_t ret_val=8;
  800420cc56:	48 c7 45 f8 08 00 00 	movq   $0x8,-0x8(%rbp)
  800420cc5d:	00 
	uint64_t ret_offset=0;
  800420cc5e:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420cc65:	00 

	if (die->die_tag != DW_TAG_subprogram)
  800420cc66:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420cc6d:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420cc71:	48 83 f8 2e          	cmp    $0x2e,%rax
  800420cc75:	74 0a                	je     800420cc81 <list_func_die+0x97>
		return 0;
  800420cc77:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cc7c:	e9 cd 06 00 00       	jmpq   800420d34e <list_func_die+0x764>

	memset(&ln, 0, sizeof(_Dwarf_Line));
  800420cc81:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420cc88:	ba 38 00 00 00       	mov    $0x38,%edx
  800420cc8d:	be 00 00 00 00       	mov    $0x0,%esi
  800420cc92:	48 89 c7             	mov    %rax,%rdi
  800420cc95:	48 b8 db e8 20 04 80 	movabs $0x800420e8db,%rax
  800420cc9c:	00 00 00 
  800420cc9f:	ff d0                	callq  *%rax

	low  = _dwarf_attr_find(die, DW_AT_low_pc);
  800420cca1:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420cca8:	be 11 00 00 00       	mov    $0x11,%esi
  800420ccad:	48 89 c7             	mov    %rax,%rdi
  800420ccb0:	48 b8 10 08 21 04 80 	movabs $0x8004210810,%rax
  800420ccb7:	00 00 00 
  800420ccba:	ff d0                	callq  *%rax
  800420ccbc:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	high = _dwarf_attr_find(die, DW_AT_high_pc);
  800420ccc0:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420ccc7:	be 12 00 00 00       	mov    $0x12,%esi
  800420cccc:	48 89 c7             	mov    %rax,%rdi
  800420cccf:	48 b8 10 08 21 04 80 	movabs $0x8004210810,%rax
  800420ccd6:	00 00 00 
  800420ccd9:	ff d0                	callq  *%rax
  800420ccdb:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	if ((low && (low->u[0].u64 < addr)) && (high && (high->u[0].u64 > addr)))
  800420ccdf:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420cce4:	0f 84 5f 06 00 00    	je     800420d349 <list_func_die+0x75f>
  800420ccea:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420ccee:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420ccf2:	48 3b 85 48 9e ff ff 	cmp    -0x61b8(%rbp),%rax
  800420ccf9:	0f 83 4a 06 00 00    	jae    800420d349 <list_func_die+0x75f>
  800420ccff:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420cd04:	0f 84 3f 06 00 00    	je     800420d349 <list_func_die+0x75f>
  800420cd0a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cd0e:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420cd12:	48 3b 85 48 9e ff ff 	cmp    -0x61b8(%rbp),%rax
  800420cd19:	0f 86 2a 06 00 00    	jbe    800420d349 <list_func_die+0x75f>
	{
		info->rip_file = die->cu_die->die_name;
  800420cd1f:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420cd26:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420cd2d:	48 8b 90 50 03 00 00 	mov    0x350(%rax),%rdx
  800420cd34:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420cd3b:	48 89 10             	mov    %rdx,(%rax)

		info->rip_fn_name = die->die_name;
  800420cd3e:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420cd45:	48 8b 90 50 03 00 00 	mov    0x350(%rax),%rdx
  800420cd4c:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420cd53:	48 89 50 10          	mov    %rdx,0x10(%rax)
		info->rip_fn_namelen = strlen(die->die_name);
  800420cd57:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420cd5e:	48 8b 80 50 03 00 00 	mov    0x350(%rax),%rax
  800420cd65:	48 89 c7             	mov    %rax,%rdi
  800420cd68:	48 b8 d6 e5 20 04 80 	movabs $0x800420e5d6,%rax
  800420cd6f:	00 00 00 
  800420cd72:	ff d0                	callq  *%rax
  800420cd74:	48 8b 95 58 9e ff ff 	mov    -0x61a8(%rbp),%rdx
  800420cd7b:	89 42 18             	mov    %eax,0x18(%rdx)

		info->rip_fn_addr = (uintptr_t)low->u[0].u64;
  800420cd7e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420cd82:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420cd86:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420cd8d:	48 89 50 20          	mov    %rdx,0x20(%rax)

		assert(die->cu_die);	
  800420cd91:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420cd98:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420cd9f:	48 85 c0             	test   %rax,%rax
  800420cda2:	75 35                	jne    800420cdd9 <list_func_die+0x1ef>
  800420cda4:	48 b9 a0 7a 21 04 80 	movabs $0x8004217aa0,%rcx
  800420cdab:	00 00 00 
  800420cdae:	48 ba ac 7a 21 04 80 	movabs $0x8004217aac,%rdx
  800420cdb5:	00 00 00 
  800420cdb8:	be 90 00 00 00       	mov    $0x90,%esi
  800420cdbd:	48 bf c1 7a 21 04 80 	movabs $0x8004217ac1,%rdi
  800420cdc4:	00 00 00 
  800420cdc7:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cdcc:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420cdd3:	00 00 00 
  800420cdd6:	41 ff d0             	callq  *%r8
		dwarf_srclines(die->cu_die, &ln, addr, NULL); 
  800420cdd9:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420cde0:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420cde7:	48 8b 95 48 9e ff ff 	mov    -0x61b8(%rbp),%rdx
  800420cdee:	48 8d b5 50 ff ff ff 	lea    -0xb0(%rbp),%rsi
  800420cdf5:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420cdfa:	48 89 c7             	mov    %rax,%rdi
  800420cdfd:	48 b8 07 3e 21 04 80 	movabs $0x8004213e07,%rax
  800420ce04:	00 00 00 
  800420ce07:	ff d0                	callq  *%rax

		info->rip_line = ln.ln_lineno;
  800420ce09:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420ce10:	89 c2                	mov    %eax,%edx
  800420ce12:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420ce19:	89 50 08             	mov    %edx,0x8(%rax)
		info->rip_fn_narg = 0;
  800420ce1c:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420ce23:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%rax)

		Dwarf_Attribute* attr;

		if (dwarf_child(dbg, cu, &sib, &ret) != DW_DLE_NO_ENTRY)
  800420ce2a:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  800420ce31:	00 00 00 
  800420ce34:	48 8b 00             	mov    (%rax),%rax
  800420ce37:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420ce3e:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420ce45:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420ce49:	48 89 c7             	mov    %rax,%rdi
  800420ce4c:	48 b8 e7 0a 21 04 80 	movabs $0x8004210ae7,%rax
  800420ce53:	00 00 00 
  800420ce56:	ff d0                	callq  *%rax
  800420ce58:	83 f8 04             	cmp    $0x4,%eax
  800420ce5b:	0f 84 e1 04 00 00    	je     800420d342 <list_func_die+0x758>
		{
			if (ret.die_tag != DW_TAG_formal_parameter)
  800420ce61:	48 8b 85 f8 ce ff ff 	mov    -0x3108(%rbp),%rax
  800420ce68:	48 83 f8 05          	cmp    $0x5,%rax
  800420ce6c:	74 05                	je     800420ce73 <list_func_die+0x289>
				goto last;
  800420ce6e:	e9 cf 04 00 00       	jmpq   800420d342 <list_func_die+0x758>

			attr = _dwarf_attr_find(&ret, DW_AT_type);
  800420ce73:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420ce7a:	be 49 00 00 00       	mov    $0x49,%esi
  800420ce7f:	48 89 c7             	mov    %rax,%rdi
  800420ce82:	48 b8 10 08 21 04 80 	movabs $0x8004210810,%rax
  800420ce89:	00 00 00 
  800420ce8c:	ff d0                	callq  *%rax
  800420ce8e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	
		try_again:
			if (attr != NULL)
  800420ce92:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420ce97:	0f 84 d7 00 00 00    	je     800420cf74 <list_func_die+0x38a>
			{
				offset = (uint64_t)cu->cu_offset + attr->u[0].u64;
  800420ce9d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420cea1:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800420cea5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cea9:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420cead:	48 01 d0             	add    %rdx,%rax
  800420ceb0:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
				dwarf_offdie(dbg, offset, &sib, *cu);
  800420ceb4:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  800420cebb:	00 00 00 
  800420cebe:	48 8b 08             	mov    (%rax),%rcx
  800420cec1:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420cec8:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420cecc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ced0:	48 8b 38             	mov    (%rax),%rdi
  800420ced3:	48 89 3c 24          	mov    %rdi,(%rsp)
  800420ced7:	48 8b 78 08          	mov    0x8(%rax),%rdi
  800420cedb:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  800420cee0:	48 8b 78 10          	mov    0x10(%rax),%rdi
  800420cee4:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  800420cee9:	48 8b 78 18          	mov    0x18(%rax),%rdi
  800420ceed:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  800420cef2:	48 8b 78 20          	mov    0x20(%rax),%rdi
  800420cef6:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  800420cefb:	48 8b 78 28          	mov    0x28(%rax),%rdi
  800420ceff:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  800420cf04:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420cf08:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  800420cf0d:	48 89 cf             	mov    %rcx,%rdi
  800420cf10:	48 b8 0d 07 21 04 80 	movabs $0x800421070d,%rax
  800420cf17:	00 00 00 
  800420cf1a:	ff d0                	callq  *%rax
				attr = _dwarf_attr_find(&sib, DW_AT_byte_size);
  800420cf1c:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420cf23:	be 0b 00 00 00       	mov    $0xb,%esi
  800420cf28:	48 89 c7             	mov    %rax,%rdi
  800420cf2b:	48 b8 10 08 21 04 80 	movabs $0x8004210810,%rax
  800420cf32:	00 00 00 
  800420cf35:	ff d0                	callq  *%rax
  800420cf37:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		
				if (attr != NULL)
  800420cf3b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420cf40:	74 0e                	je     800420cf50 <list_func_die+0x366>
				{
					ret_val = attr->u[0].u64;
  800420cf42:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cf46:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420cf4a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420cf4e:	eb 24                	jmp    800420cf74 <list_func_die+0x38a>
				}
				else
				{
					attr = _dwarf_attr_find(&sib, DW_AT_type);
  800420cf50:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420cf57:	be 49 00 00 00       	mov    $0x49,%esi
  800420cf5c:	48 89 c7             	mov    %rax,%rdi
  800420cf5f:	48 b8 10 08 21 04 80 	movabs $0x8004210810,%rax
  800420cf66:	00 00 00 
  800420cf69:	ff d0                	callq  *%rax
  800420cf6b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
					goto try_again;
  800420cf6f:	e9 1e ff ff ff       	jmpq   800420ce92 <list_func_die+0x2a8>
				}
			}

			ret_offset = 0;
  800420cf74:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420cf7b:	00 
			attr = _dwarf_attr_find(&ret, DW_AT_location);
  800420cf7c:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420cf83:	be 02 00 00 00       	mov    $0x2,%esi
  800420cf88:	48 89 c7             	mov    %rax,%rdi
  800420cf8b:	48 b8 10 08 21 04 80 	movabs $0x8004210810,%rax
  800420cf92:	00 00 00 
  800420cf95:	ff d0                	callq  *%rax
  800420cf97:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			if (attr != NULL)
  800420cf9b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420cfa0:	0f 84 a2 00 00 00    	je     800420d048 <list_func_die+0x45e>
			{
				Dwarf_Unsigned loc_len = attr->at_block.bl_len;
  800420cfa6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cfaa:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420cfae:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
				Dwarf_Small *loc_ptr = attr->at_block.bl_data;
  800420cfb2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cfb6:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420cfba:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
				Dwarf_Small atom;
				Dwarf_Unsigned op1, op2;

				switch(attr->at_form) {
  800420cfbe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cfc2:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420cfc6:	48 83 f8 03          	cmp    $0x3,%rax
  800420cfca:	72 7c                	jb     800420d048 <list_func_die+0x45e>
  800420cfcc:	48 83 f8 04          	cmp    $0x4,%rax
  800420cfd0:	76 06                	jbe    800420cfd8 <list_func_die+0x3ee>
  800420cfd2:	48 83 f8 0a          	cmp    $0xa,%rax
  800420cfd6:	75 70                	jne    800420d048 <list_func_die+0x45e>
					case DW_FORM_block1:
					case DW_FORM_block2:
					case DW_FORM_block4:
						offset = 0;
  800420cfd8:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  800420cfdf:	00 
						atom = *(loc_ptr++);
  800420cfe0:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420cfe4:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420cfe8:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
  800420cfec:	0f b6 00             	movzbl (%rax),%eax
  800420cfef:	88 45 af             	mov    %al,-0x51(%rbp)
						offset++;
  800420cff2:	48 83 45 c0 01       	addq   $0x1,-0x40(%rbp)
						if (atom == DW_OP_fbreg) {
  800420cff7:	80 7d af 91          	cmpb   $0x91,-0x51(%rbp)
  800420cffb:	75 4a                	jne    800420d047 <list_func_die+0x45d>
							uint8_t *p = loc_ptr;
  800420cffd:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420d001:	48 89 85 68 9e ff ff 	mov    %rax,-0x6198(%rbp)
							ret_offset = _dwarf_decode_sleb128(&p);
  800420d008:	48 8d 85 68 9e ff ff 	lea    -0x6198(%rbp),%rax
  800420d00f:	48 89 c7             	mov    %rax,%rdi
  800420d012:	48 b8 6c f4 20 04 80 	movabs $0x800420f46c,%rax
  800420d019:	00 00 00 
  800420d01c:	ff d0                	callq  *%rax
  800420d01e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
							offset += p - loc_ptr;
  800420d022:	48 8b 85 68 9e ff ff 	mov    -0x6198(%rbp),%rax
  800420d029:	48 89 c2             	mov    %rax,%rdx
  800420d02c:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420d030:	48 29 c2             	sub    %rax,%rdx
  800420d033:	48 89 d0             	mov    %rdx,%rax
  800420d036:	48 01 45 c0          	add    %rax,-0x40(%rbp)
							loc_ptr = p;
  800420d03a:	48 8b 85 68 9e ff ff 	mov    -0x6198(%rbp),%rax
  800420d041:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
						}
						break;
  800420d045:	eb 00                	jmp    800420d047 <list_func_die+0x45d>
  800420d047:	90                   	nop
				}
			}

			info->size_fn_arg[info->rip_fn_narg] = ret_val;
  800420d048:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d04f:	8b 48 28             	mov    0x28(%rax),%ecx
  800420d052:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d056:	89 c2                	mov    %eax,%edx
  800420d058:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d05f:	48 63 c9             	movslq %ecx,%rcx
  800420d062:	48 83 c1 08          	add    $0x8,%rcx
  800420d066:	89 54 88 0c          	mov    %edx,0xc(%rax,%rcx,4)
			info->offset_fn_arg[info->rip_fn_narg] = ret_offset;
  800420d06a:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d071:	8b 50 28             	mov    0x28(%rax),%edx
  800420d074:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d07b:	48 63 d2             	movslq %edx,%rdx
  800420d07e:	48 8d 4a 0a          	lea    0xa(%rdx),%rcx
  800420d082:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420d086:	48 89 54 c8 08       	mov    %rdx,0x8(%rax,%rcx,8)
			info->rip_fn_narg++;
  800420d08b:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d092:	8b 40 28             	mov    0x28(%rax),%eax
  800420d095:	8d 50 01             	lea    0x1(%rax),%edx
  800420d098:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d09f:	89 50 28             	mov    %edx,0x28(%rax)
			sib = ret; 
  800420d0a2:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420d0a9:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420d0b0:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420d0b5:	48 89 ce             	mov    %rcx,%rsi
  800420d0b8:	48 89 c7             	mov    %rax,%rdi
  800420d0bb:	48 b8 7d ea 20 04 80 	movabs $0x800420ea7d,%rax
  800420d0c2:	00 00 00 
  800420d0c5:	ff d0                	callq  *%rax

			while (dwarf_siblingof(dbg, &sib, &ret, cu) == DW_DLV_OK)	
  800420d0c7:	e9 40 02 00 00       	jmpq   800420d30c <list_func_die+0x722>
			{
				if (ret.die_tag != DW_TAG_formal_parameter)
  800420d0cc:	48 8b 85 f8 ce ff ff 	mov    -0x3108(%rbp),%rax
  800420d0d3:	48 83 f8 05          	cmp    $0x5,%rax
  800420d0d7:	74 05                	je     800420d0de <list_func_die+0x4f4>
					break;
  800420d0d9:	e9 64 02 00 00       	jmpq   800420d342 <list_func_die+0x758>

				attr = _dwarf_attr_find(&ret, DW_AT_type);
  800420d0de:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420d0e5:	be 49 00 00 00       	mov    $0x49,%esi
  800420d0ea:	48 89 c7             	mov    %rax,%rdi
  800420d0ed:	48 b8 10 08 21 04 80 	movabs $0x8004210810,%rax
  800420d0f4:	00 00 00 
  800420d0f7:	ff d0                	callq  *%rax
  800420d0f9:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    
				if (attr != NULL)
  800420d0fd:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420d102:	0f 84 b1 00 00 00    	je     800420d1b9 <list_func_die+0x5cf>
				{	   
					offset = (uint64_t)cu->cu_offset + attr->u[0].u64;
  800420d108:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d10c:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800420d110:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d114:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420d118:	48 01 d0             	add    %rdx,%rax
  800420d11b:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
					dwarf_offdie(dbg, offset, &sib, *cu);
  800420d11f:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  800420d126:	00 00 00 
  800420d129:	48 8b 08             	mov    (%rax),%rcx
  800420d12c:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420d133:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420d137:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d13b:	48 8b 38             	mov    (%rax),%rdi
  800420d13e:	48 89 3c 24          	mov    %rdi,(%rsp)
  800420d142:	48 8b 78 08          	mov    0x8(%rax),%rdi
  800420d146:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  800420d14b:	48 8b 78 10          	mov    0x10(%rax),%rdi
  800420d14f:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  800420d154:	48 8b 78 18          	mov    0x18(%rax),%rdi
  800420d158:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  800420d15d:	48 8b 78 20          	mov    0x20(%rax),%rdi
  800420d161:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  800420d166:	48 8b 78 28          	mov    0x28(%rax),%rdi
  800420d16a:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  800420d16f:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420d173:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  800420d178:	48 89 cf             	mov    %rcx,%rdi
  800420d17b:	48 b8 0d 07 21 04 80 	movabs $0x800421070d,%rax
  800420d182:	00 00 00 
  800420d185:	ff d0                	callq  *%rax
					attr = _dwarf_attr_find(&sib, DW_AT_byte_size);
  800420d187:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420d18e:	be 0b 00 00 00       	mov    $0xb,%esi
  800420d193:	48 89 c7             	mov    %rax,%rdi
  800420d196:	48 b8 10 08 21 04 80 	movabs $0x8004210810,%rax
  800420d19d:	00 00 00 
  800420d1a0:	ff d0                	callq  *%rax
  800420d1a2:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        
					if (attr != NULL)
  800420d1a6:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420d1ab:	74 0c                	je     800420d1b9 <list_func_die+0x5cf>
					{
						ret_val = attr->u[0].u64;
  800420d1ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d1b1:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420d1b5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
					}
				}
	
				ret_offset = 0;
  800420d1b9:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420d1c0:	00 
				attr = _dwarf_attr_find(&ret, DW_AT_location);
  800420d1c1:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420d1c8:	be 02 00 00 00       	mov    $0x2,%esi
  800420d1cd:	48 89 c7             	mov    %rax,%rdi
  800420d1d0:	48 b8 10 08 21 04 80 	movabs $0x8004210810,%rax
  800420d1d7:	00 00 00 
  800420d1da:	ff d0                	callq  *%rax
  800420d1dc:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				if (attr != NULL)
  800420d1e0:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420d1e5:	0f 84 a2 00 00 00    	je     800420d28d <list_func_die+0x6a3>
				{
					Dwarf_Unsigned loc_len = attr->at_block.bl_len;
  800420d1eb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d1ef:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420d1f3:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
					Dwarf_Small *loc_ptr = attr->at_block.bl_data;
  800420d1f7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d1fb:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420d1ff:	48 89 45 98          	mov    %rax,-0x68(%rbp)
					Dwarf_Small atom;
					Dwarf_Unsigned op1, op2;

					switch(attr->at_form) {
  800420d203:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d207:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420d20b:	48 83 f8 03          	cmp    $0x3,%rax
  800420d20f:	72 7c                	jb     800420d28d <list_func_die+0x6a3>
  800420d211:	48 83 f8 04          	cmp    $0x4,%rax
  800420d215:	76 06                	jbe    800420d21d <list_func_die+0x633>
  800420d217:	48 83 f8 0a          	cmp    $0xa,%rax
  800420d21b:	75 70                	jne    800420d28d <list_func_die+0x6a3>
						case DW_FORM_block1:
						case DW_FORM_block2:
						case DW_FORM_block4:
							offset = 0;
  800420d21d:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  800420d224:	00 
							atom = *(loc_ptr++);
  800420d225:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420d229:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420d22d:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420d231:	0f b6 00             	movzbl (%rax),%eax
  800420d234:	88 45 97             	mov    %al,-0x69(%rbp)
							offset++;
  800420d237:	48 83 45 c0 01       	addq   $0x1,-0x40(%rbp)
							if (atom == DW_OP_fbreg) {
  800420d23c:	80 7d 97 91          	cmpb   $0x91,-0x69(%rbp)
  800420d240:	75 4a                	jne    800420d28c <list_func_die+0x6a2>
								uint8_t *p = loc_ptr;
  800420d242:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420d246:	48 89 85 60 9e ff ff 	mov    %rax,-0x61a0(%rbp)
								ret_offset = _dwarf_decode_sleb128(&p);
  800420d24d:	48 8d 85 60 9e ff ff 	lea    -0x61a0(%rbp),%rax
  800420d254:	48 89 c7             	mov    %rax,%rdi
  800420d257:	48 b8 6c f4 20 04 80 	movabs $0x800420f46c,%rax
  800420d25e:	00 00 00 
  800420d261:	ff d0                	callq  *%rax
  800420d263:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
								offset += p - loc_ptr;
  800420d267:	48 8b 85 60 9e ff ff 	mov    -0x61a0(%rbp),%rax
  800420d26e:	48 89 c2             	mov    %rax,%rdx
  800420d271:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420d275:	48 29 c2             	sub    %rax,%rdx
  800420d278:	48 89 d0             	mov    %rdx,%rax
  800420d27b:	48 01 45 c0          	add    %rax,-0x40(%rbp)
								loc_ptr = p;
  800420d27f:	48 8b 85 60 9e ff ff 	mov    -0x61a0(%rbp),%rax
  800420d286:	48 89 45 98          	mov    %rax,-0x68(%rbp)
							}
							break;
  800420d28a:	eb 00                	jmp    800420d28c <list_func_die+0x6a2>
  800420d28c:	90                   	nop
					}
				}

				info->size_fn_arg[info->rip_fn_narg]=ret_val;// _get_arg_size(ret);
  800420d28d:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d294:	8b 48 28             	mov    0x28(%rax),%ecx
  800420d297:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d29b:	89 c2                	mov    %eax,%edx
  800420d29d:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d2a4:	48 63 c9             	movslq %ecx,%rcx
  800420d2a7:	48 83 c1 08          	add    $0x8,%rcx
  800420d2ab:	89 54 88 0c          	mov    %edx,0xc(%rax,%rcx,4)
				info->offset_fn_arg[info->rip_fn_narg]=ret_offset;
  800420d2af:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d2b6:	8b 50 28             	mov    0x28(%rax),%edx
  800420d2b9:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d2c0:	48 63 d2             	movslq %edx,%rdx
  800420d2c3:	48 8d 4a 0a          	lea    0xa(%rdx),%rcx
  800420d2c7:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420d2cb:	48 89 54 c8 08       	mov    %rdx,0x8(%rax,%rcx,8)
				info->rip_fn_narg++;
  800420d2d0:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d2d7:	8b 40 28             	mov    0x28(%rax),%eax
  800420d2da:	8d 50 01             	lea    0x1(%rax),%edx
  800420d2dd:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d2e4:	89 50 28             	mov    %edx,0x28(%rax)
				sib = ret; 
  800420d2e7:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420d2ee:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420d2f5:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420d2fa:	48 89 ce             	mov    %rcx,%rsi
  800420d2fd:	48 89 c7             	mov    %rax,%rdi
  800420d300:	48 b8 7d ea 20 04 80 	movabs $0x800420ea7d,%rax
  800420d307:	00 00 00 
  800420d30a:	ff d0                	callq  *%rax
			info->size_fn_arg[info->rip_fn_narg] = ret_val;
			info->offset_fn_arg[info->rip_fn_narg] = ret_offset;
			info->rip_fn_narg++;
			sib = ret; 

			while (dwarf_siblingof(dbg, &sib, &ret, cu) == DW_DLV_OK)	
  800420d30c:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  800420d313:	00 00 00 
  800420d316:	48 8b 00             	mov    (%rax),%rax
  800420d319:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420d31d:	48 8d 95 e0 ce ff ff 	lea    -0x3120(%rbp),%rdx
  800420d324:	48 8d b5 70 9e ff ff 	lea    -0x6190(%rbp),%rsi
  800420d32b:	48 89 c7             	mov    %rax,%rdi
  800420d32e:	48 b8 a3 08 21 04 80 	movabs $0x80042108a3,%rax
  800420d335:	00 00 00 
  800420d338:	ff d0                	callq  *%rax
  800420d33a:	85 c0                	test   %eax,%eax
  800420d33c:	0f 84 8a fd ff ff    	je     800420d0cc <list_func_die+0x4e2>
				info->rip_fn_narg++;
				sib = ret; 
			}
		}
	last:	
		return 1;
  800420d342:	b8 01 00 00 00       	mov    $0x1,%eax
  800420d347:	eb 05                	jmp    800420d34e <list_func_die+0x764>
	}

	return 0;
  800420d349:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420d34e:	c9                   	leaveq 
  800420d34f:	c3                   	retq   

000000800420d350 <debuginfo_rip>:
//	negative if not.  But even if it returns negative it has stored some
//	information into '*info'.
//
int
debuginfo_rip(uintptr_t addr, struct Ripdebuginfo *info)
{
  800420d350:	55                   	push   %rbp
  800420d351:	48 89 e5             	mov    %rsp,%rbp
  800420d354:	53                   	push   %rbx
  800420d355:	48 81 ec c8 91 00 00 	sub    $0x91c8,%rsp
  800420d35c:	48 89 bd 38 6e ff ff 	mov    %rdi,-0x91c8(%rbp)
  800420d363:	48 89 b5 30 6e ff ff 	mov    %rsi,-0x91d0(%rbp)
	static struct Env* lastenv = NULL;
	void* elf;    
	Dwarf_Section *sect;
	Dwarf_CU cu;
	Dwarf_Die die, cudie, die2;
	Dwarf_Regtable *rt = NULL;
  800420d36a:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  800420d371:	00 
	//Set up initial pc
	uint64_t pc  = (uintptr_t)addr;
  800420d372:	48 8b 85 38 6e ff ff 	mov    -0x91c8(%rbp),%rax
  800420d379:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

    
	// Initialize *info
	info->rip_file = "<unknown>";
  800420d37d:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420d384:	48 bb cf 7a 21 04 80 	movabs $0x8004217acf,%rbx
  800420d38b:	00 00 00 
  800420d38e:	48 89 18             	mov    %rbx,(%rax)
	info->rip_line = 0;
  800420d391:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420d398:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
	info->rip_fn_name = "<unknown>";
  800420d39f:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420d3a6:	48 bb cf 7a 21 04 80 	movabs $0x8004217acf,%rbx
  800420d3ad:	00 00 00 
  800420d3b0:	48 89 58 10          	mov    %rbx,0x10(%rax)
	info->rip_fn_namelen = 9;
  800420d3b4:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420d3bb:	c7 40 18 09 00 00 00 	movl   $0x9,0x18(%rax)
	info->rip_fn_addr = addr;
  800420d3c2:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420d3c9:	48 8b 95 38 6e ff ff 	mov    -0x91c8(%rbp),%rdx
  800420d3d0:	48 89 50 20          	mov    %rdx,0x20(%rax)
	info->rip_fn_narg = 0;
  800420d3d4:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420d3db:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%rax)
    
	// Find the relevant set of stabs
	if (addr >= ULIM) {
  800420d3e2:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  800420d3e9:	00 00 00 
  800420d3ec:	48 39 85 38 6e ff ff 	cmp    %rax,-0x91c8(%rbp)
  800420d3f3:	76 13                	jbe    800420d408 <debuginfo_rip+0xb8>
		elf = (void *)0x10000 + KERNBASE;
  800420d3f5:	48 b8 00 00 01 04 80 	movabs $0x8004010000,%rax
  800420d3fc:	00 00 00 
  800420d3ff:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420d403:	e9 08 01 00 00       	jmpq   800420d510 <debuginfo_rip+0x1c0>
	} else {
		if (curenv != lastenv) {
  800420d408:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420d40f:	00 00 00 
  800420d412:	ff d0                	callq  *%rax
  800420d414:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  800420d41b:	00 00 00 
  800420d41e:	48 98                	cltq   
  800420d420:	48 c1 e0 03          	shl    $0x3,%rax
  800420d424:	48 89 c2             	mov    %rax,%rdx
  800420d427:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d42b:	48 29 c2             	sub    %rax,%rdx
  800420d42e:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420d432:	48 83 c0 08          	add    $0x8,%rax
  800420d436:	48 8b 10             	mov    (%rax),%rdx
  800420d439:	48 b8 10 63 49 04 80 	movabs $0x8004496310,%rax
  800420d440:	00 00 00 
  800420d443:	48 8b 00             	mov    (%rax),%rax
  800420d446:	48 39 c2             	cmp    %rax,%rdx
  800420d449:	0f 84 85 00 00 00    	je     800420d4d4 <debuginfo_rip+0x184>
			find_debug_sections((uintptr_t)curenv->elf);
  800420d44f:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420d456:	00 00 00 
  800420d459:	ff d0                	callq  *%rax
  800420d45b:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  800420d462:	00 00 00 
  800420d465:	48 98                	cltq   
  800420d467:	48 c1 e0 03          	shl    $0x3,%rax
  800420d46b:	48 89 c2             	mov    %rax,%rdx
  800420d46e:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d472:	48 29 c2             	sub    %rax,%rdx
  800420d475:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420d479:	48 83 c0 08          	add    $0x8,%rax
  800420d47d:	48 8b 00             	mov    (%rax),%rax
  800420d480:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  800420d487:	48 89 c7             	mov    %rax,%rdi
  800420d48a:	48 b8 02 40 21 04 80 	movabs $0x8004214002,%rax
  800420d491:	00 00 00 
  800420d494:	ff d0                	callq  *%rax
			lastenv = curenv;
  800420d496:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420d49d:	00 00 00 
  800420d4a0:	ff d0                	callq  *%rax
  800420d4a2:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  800420d4a9:	00 00 00 
  800420d4ac:	48 98                	cltq   
  800420d4ae:	48 c1 e0 03          	shl    $0x3,%rax
  800420d4b2:	48 89 c2             	mov    %rax,%rdx
  800420d4b5:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d4b9:	48 29 c2             	sub    %rax,%rdx
  800420d4bc:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420d4c0:	48 83 c0 08          	add    $0x8,%rax
  800420d4c4:	48 8b 10             	mov    (%rax),%rdx
  800420d4c7:	48 b8 10 63 49 04 80 	movabs $0x8004496310,%rax
  800420d4ce:	00 00 00 
  800420d4d1:	48 89 10             	mov    %rdx,(%rax)
		}
		elf = curenv->elf;
  800420d4d4:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800420d4db:	00 00 00 
  800420d4de:	ff d0                	callq  *%rax
  800420d4e0:	48 b9 20 80 49 04 80 	movabs $0x8004498020,%rcx
  800420d4e7:	00 00 00 
  800420d4ea:	48 98                	cltq   
  800420d4ec:	48 c1 e0 03          	shl    $0x3,%rax
  800420d4f0:	48 89 c2             	mov    %rax,%rdx
  800420d4f3:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d4f7:	48 29 c2             	sub    %rax,%rdx
  800420d4fa:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420d4fe:	48 83 c0 08          	add    $0x8,%rax
  800420d502:	48 8b 00             	mov    (%rax),%rax
  800420d505:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  800420d50c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	}
    
    
	_dwarf_init(dbg, elf);
  800420d510:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  800420d517:	00 00 00 
  800420d51a:	48 8b 00             	mov    (%rax),%rax
  800420d51d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d521:	48 89 d6             	mov    %rdx,%rsi
  800420d524:	48 89 c7             	mov    %rax,%rdi
  800420d527:	48 b8 1b f7 20 04 80 	movabs $0x800420f71b,%rax
  800420d52e:	00 00 00 
  800420d531:	ff d0                	callq  *%rax

	sect = _dwarf_find_section(".debug_info");	
  800420d533:	48 bf d9 7a 21 04 80 	movabs $0x8004217ad9,%rdi
  800420d53a:	00 00 00 
  800420d53d:	48 b8 82 3f 21 04 80 	movabs $0x8004213f82,%rax
  800420d544:	00 00 00 
  800420d547:	ff d0                	callq  *%rax
  800420d549:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	dbg->dbg_info_offset_elf = (uint64_t)sect->ds_data; 
  800420d54d:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  800420d554:	00 00 00 
  800420d557:	48 8b 00             	mov    (%rax),%rax
  800420d55a:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420d55e:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420d562:	48 89 50 08          	mov    %rdx,0x8(%rax)
	dbg->dbg_info_size = sect->ds_size;
  800420d566:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  800420d56d:	00 00 00 
  800420d570:	48 8b 00             	mov    (%rax),%rax
  800420d573:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420d577:	48 8b 52 18          	mov    0x18(%rdx),%rdx
  800420d57b:	48 89 50 10          	mov    %rdx,0x10(%rax)
    
	assert(dbg->dbg_info_size);
  800420d57f:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  800420d586:	00 00 00 
  800420d589:	48 8b 00             	mov    (%rax),%rax
  800420d58c:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420d590:	48 85 c0             	test   %rax,%rax
  800420d593:	75 35                	jne    800420d5ca <debuginfo_rip+0x27a>
  800420d595:	48 b9 e5 7a 21 04 80 	movabs $0x8004217ae5,%rcx
  800420d59c:	00 00 00 
  800420d59f:	48 ba ac 7a 21 04 80 	movabs $0x8004217aac,%rdx
  800420d5a6:	00 00 00 
  800420d5a9:	be 38 01 00 00       	mov    $0x138,%esi
  800420d5ae:	48 bf c1 7a 21 04 80 	movabs $0x8004217ac1,%rdi
  800420d5b5:	00 00 00 
  800420d5b8:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d5bd:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420d5c4:	00 00 00 
  800420d5c7:	41 ff d0             	callq  *%r8
	while (_get_next_cu(dbg, &cu) == 0)
  800420d5ca:	e9 6f 01 00 00       	jmpq   800420d73e <debuginfo_rip+0x3ee>
	{
		if (dwarf_siblingof(dbg, NULL, &cudie, &cu) == DW_DLE_NO_ENTRY)
  800420d5cf:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  800420d5d6:	00 00 00 
  800420d5d9:	48 8b 00             	mov    (%rax),%rax
  800420d5dc:	48 8d 4d 90          	lea    -0x70(%rbp),%rcx
  800420d5e0:	48 8d 95 b0 9e ff ff 	lea    -0x6150(%rbp),%rdx
  800420d5e7:	be 00 00 00 00       	mov    $0x0,%esi
  800420d5ec:	48 89 c7             	mov    %rax,%rdi
  800420d5ef:	48 b8 a3 08 21 04 80 	movabs $0x80042108a3,%rax
  800420d5f6:	00 00 00 
  800420d5f9:	ff d0                	callq  *%rax
  800420d5fb:	83 f8 04             	cmp    $0x4,%eax
  800420d5fe:	75 05                	jne    800420d605 <debuginfo_rip+0x2b5>
		{
			continue;
  800420d600:	e9 39 01 00 00       	jmpq   800420d73e <debuginfo_rip+0x3ee>
		}	
		cudie.cu_header = &cu;
  800420d605:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800420d609:	48 89 85 10 a2 ff ff 	mov    %rax,-0x5df0(%rbp)
		cudie.cu_die = NULL;
  800420d610:	48 c7 85 18 a2 ff ff 	movq   $0x0,-0x5de8(%rbp)
  800420d617:	00 00 00 00 
	    
		if (dwarf_child(dbg, &cu, &cudie, &die) == DW_DLE_NO_ENTRY)
  800420d61b:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  800420d622:	00 00 00 
  800420d625:	48 8b 00             	mov    (%rax),%rax
  800420d628:	48 8d 8d 20 cf ff ff 	lea    -0x30e0(%rbp),%rcx
  800420d62f:	48 8d 95 b0 9e ff ff 	lea    -0x6150(%rbp),%rdx
  800420d636:	48 8d 75 90          	lea    -0x70(%rbp),%rsi
  800420d63a:	48 89 c7             	mov    %rax,%rdi
  800420d63d:	48 b8 e7 0a 21 04 80 	movabs $0x8004210ae7,%rax
  800420d644:	00 00 00 
  800420d647:	ff d0                	callq  *%rax
  800420d649:	83 f8 04             	cmp    $0x4,%eax
  800420d64c:	75 05                	jne    800420d653 <debuginfo_rip+0x303>
		{
			continue;
  800420d64e:	e9 eb 00 00 00       	jmpq   800420d73e <debuginfo_rip+0x3ee>
		}	
		die.cu_header = &cu;
  800420d653:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800420d657:	48 89 85 80 d2 ff ff 	mov    %rax,-0x2d80(%rbp)
		die.cu_die = &cudie;
  800420d65e:	48 8d 85 b0 9e ff ff 	lea    -0x6150(%rbp),%rax
  800420d665:	48 89 85 88 d2 ff ff 	mov    %rax,-0x2d78(%rbp)
		while (1)
		{
			if (list_func_die(info, &die, addr))
  800420d66c:	48 8b 95 38 6e ff ff 	mov    -0x91c8(%rbp),%rdx
  800420d673:	48 8d 8d 20 cf ff ff 	lea    -0x30e0(%rbp),%rcx
  800420d67a:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420d681:	48 89 ce             	mov    %rcx,%rsi
  800420d684:	48 89 c7             	mov    %rax,%rdi
  800420d687:	48 b8 ea cb 20 04 80 	movabs $0x800420cbea,%rax
  800420d68e:	00 00 00 
  800420d691:	ff d0                	callq  *%rax
  800420d693:	85 c0                	test   %eax,%eax
  800420d695:	74 30                	je     800420d6c7 <debuginfo_rip+0x377>
				goto find_done;
  800420d697:	90                   	nop
    
	return -1;

find_done:

	if (dwarf_init_eh_section(dbg, NULL) == DW_DLV_ERROR)
  800420d698:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  800420d69f:	00 00 00 
  800420d6a2:	48 8b 00             	mov    (%rax),%rax
  800420d6a5:	be 00 00 00 00       	mov    $0x0,%esi
  800420d6aa:	48 89 c7             	mov    %rax,%rdi
  800420d6ad:	48 b8 8f 31 21 04 80 	movabs $0x800421318f,%rax
  800420d6b4:	00 00 00 
  800420d6b7:	ff d0                	callq  *%rax
  800420d6b9:	83 f8 01             	cmp    $0x1,%eax
  800420d6bc:	0f 85 bb 00 00 00    	jne    800420d77d <debuginfo_rip+0x42d>
  800420d6c2:	e9 ac 00 00 00       	jmpq   800420d773 <debuginfo_rip+0x423>
		die.cu_die = &cudie;
		while (1)
		{
			if (list_func_die(info, &die, addr))
				goto find_done;
			if (dwarf_siblingof(dbg, &die, &die2, &cu) < 0)
  800420d6c7:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  800420d6ce:	00 00 00 
  800420d6d1:	48 8b 00             	mov    (%rax),%rax
  800420d6d4:	48 8d 4d 90          	lea    -0x70(%rbp),%rcx
  800420d6d8:	48 8d 95 40 6e ff ff 	lea    -0x91c0(%rbp),%rdx
  800420d6df:	48 8d b5 20 cf ff ff 	lea    -0x30e0(%rbp),%rsi
  800420d6e6:	48 89 c7             	mov    %rax,%rdi
  800420d6e9:	48 b8 a3 08 21 04 80 	movabs $0x80042108a3,%rax
  800420d6f0:	00 00 00 
  800420d6f3:	ff d0                	callq  *%rax
  800420d6f5:	85 c0                	test   %eax,%eax
  800420d6f7:	79 02                	jns    800420d6fb <debuginfo_rip+0x3ab>
				break; 
  800420d6f9:	eb 43                	jmp    800420d73e <debuginfo_rip+0x3ee>
			die = die2;
  800420d6fb:	48 8d 85 20 cf ff ff 	lea    -0x30e0(%rbp),%rax
  800420d702:	48 8d 8d 40 6e ff ff 	lea    -0x91c0(%rbp),%rcx
  800420d709:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420d70e:	48 89 ce             	mov    %rcx,%rsi
  800420d711:	48 89 c7             	mov    %rax,%rdi
  800420d714:	48 b8 7d ea 20 04 80 	movabs $0x800420ea7d,%rax
  800420d71b:	00 00 00 
  800420d71e:	ff d0                	callq  *%rax
			die.cu_header = &cu;
  800420d720:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800420d724:	48 89 85 80 d2 ff ff 	mov    %rax,-0x2d80(%rbp)
			die.cu_die = &cudie;
  800420d72b:	48 8d 85 b0 9e ff ff 	lea    -0x6150(%rbp),%rax
  800420d732:	48 89 85 88 d2 ff ff 	mov    %rax,-0x2d78(%rbp)
		}
  800420d739:	e9 2e ff ff ff       	jmpq   800420d66c <debuginfo_rip+0x31c>
	sect = _dwarf_find_section(".debug_info");	
	dbg->dbg_info_offset_elf = (uint64_t)sect->ds_data; 
	dbg->dbg_info_size = sect->ds_size;
    
	assert(dbg->dbg_info_size);
	while (_get_next_cu(dbg, &cu) == 0)
  800420d73e:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  800420d745:	00 00 00 
  800420d748:	48 8b 00             	mov    (%rax),%rax
  800420d74b:	48 8d 55 90          	lea    -0x70(%rbp),%rdx
  800420d74f:	48 89 d6             	mov    %rdx,%rsi
  800420d752:	48 89 c7             	mov    %rax,%rdi
  800420d755:	48 b8 fd f7 20 04 80 	movabs $0x800420f7fd,%rax
  800420d75c:	00 00 00 
  800420d75f:	ff d0                	callq  *%rax
  800420d761:	85 c0                	test   %eax,%eax
  800420d763:	0f 84 66 fe ff ff    	je     800420d5cf <debuginfo_rip+0x27f>
			die.cu_header = &cu;
			die.cu_die = &cudie;
		}
	}
    
	return -1;
  800420d769:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420d76e:	e9 a0 00 00 00       	jmpq   800420d813 <debuginfo_rip+0x4c3>

find_done:

	if (dwarf_init_eh_section(dbg, NULL) == DW_DLV_ERROR)
		return -1;
  800420d773:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420d778:	e9 96 00 00 00       	jmpq   800420d813 <debuginfo_rip+0x4c3>

	if (dwarf_get_fde_at_pc(dbg, addr, fde, cie, NULL) == DW_DLV_OK) {
  800420d77d:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  800420d784:	00 00 00 
  800420d787:	48 8b 08             	mov    (%rax),%rcx
  800420d78a:	48 b8 98 b6 22 04 80 	movabs $0x800422b698,%rax
  800420d791:	00 00 00 
  800420d794:	48 8b 10             	mov    (%rax),%rdx
  800420d797:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  800420d79e:	00 00 00 
  800420d7a1:	48 8b 00             	mov    (%rax),%rax
  800420d7a4:	48 8b b5 38 6e ff ff 	mov    -0x91c8(%rbp),%rsi
  800420d7ab:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800420d7b1:	48 89 c7             	mov    %rax,%rdi
  800420d7b4:	48 b8 28 0d 21 04 80 	movabs $0x8004210d28,%rax
  800420d7bb:	00 00 00 
  800420d7be:	ff d0                	callq  *%rax
  800420d7c0:	85 c0                	test   %eax,%eax
  800420d7c2:	75 4a                	jne    800420d80e <debuginfo_rip+0x4be>
		dwarf_get_fde_info_for_all_regs(dbg, fde, addr, &info->reg_table,
  800420d7c4:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420d7cb:	48 8d 88 a8 00 00 00 	lea    0xa8(%rax),%rcx
  800420d7d2:	48 b8 98 b6 22 04 80 	movabs $0x800422b698,%rax
  800420d7d9:	00 00 00 
  800420d7dc:	48 8b 30             	mov    (%rax),%rsi
  800420d7df:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  800420d7e6:	00 00 00 
  800420d7e9:	48 8b 00             	mov    (%rax),%rax
  800420d7ec:	48 8b 95 38 6e ff ff 	mov    -0x91c8(%rbp),%rdx
  800420d7f3:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  800420d7f9:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800420d7ff:	48 89 c7             	mov    %rax,%rdi
  800420d802:	48 b8 34 20 21 04 80 	movabs $0x8004212034,%rax
  800420d809:	00 00 00 
  800420d80c:	ff d0                	callq  *%rax
					break;
			}
		}
#endif
	}
	return 0;
  800420d80e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420d813:	48 81 c4 c8 91 00 00 	add    $0x91c8,%rsp
  800420d81a:	5b                   	pop    %rbx
  800420d81b:	5d                   	pop    %rbp
  800420d81c:	c3                   	retq   

000000800420d81d <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  800420d81d:	55                   	push   %rbp
  800420d81e:	48 89 e5             	mov    %rsp,%rbp
  800420d821:	53                   	push   %rbx
  800420d822:	48 83 ec 38          	sub    $0x38,%rsp
  800420d826:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420d82a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420d82e:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420d832:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
  800420d835:	44 89 45 d0          	mov    %r8d,-0x30(%rbp)
  800420d839:	44 89 4d cc          	mov    %r9d,-0x34(%rbp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  800420d83d:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800420d840:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  800420d844:	77 3b                	ja     800420d881 <printnum+0x64>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  800420d846:	8b 45 d0             	mov    -0x30(%rbp),%eax
  800420d849:	44 8d 40 ff          	lea    -0x1(%rax),%r8d
  800420d84d:	8b 5d d4             	mov    -0x2c(%rbp),%ebx
  800420d850:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420d854:	ba 00 00 00 00       	mov    $0x0,%edx
  800420d859:	48 f7 f3             	div    %rbx
  800420d85c:	48 89 c2             	mov    %rax,%rdx
  800420d85f:	8b 7d cc             	mov    -0x34(%rbp),%edi
  800420d862:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
  800420d865:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420d869:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d86d:	41 89 f9             	mov    %edi,%r9d
  800420d870:	48 89 c7             	mov    %rax,%rdi
  800420d873:	48 b8 1d d8 20 04 80 	movabs $0x800420d81d,%rax
  800420d87a:	00 00 00 
  800420d87d:	ff d0                	callq  *%rax
  800420d87f:	eb 1e                	jmp    800420d89f <printnum+0x82>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  800420d881:	eb 12                	jmp    800420d895 <printnum+0x78>
			putch(padc, putdat);
  800420d883:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420d887:	8b 55 cc             	mov    -0x34(%rbp),%edx
  800420d88a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d88e:	48 89 ce             	mov    %rcx,%rsi
  800420d891:	89 d7                	mov    %edx,%edi
  800420d893:	ff d0                	callq  *%rax
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  800420d895:	83 6d d0 01          	subl   $0x1,-0x30(%rbp)
  800420d899:	83 7d d0 00          	cmpl   $0x0,-0x30(%rbp)
  800420d89d:	7f e4                	jg     800420d883 <printnum+0x66>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  800420d89f:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
  800420d8a2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420d8a6:	ba 00 00 00 00       	mov    $0x0,%edx
  800420d8ab:	48 f7 f1             	div    %rcx
  800420d8ae:	48 89 d0             	mov    %rdx,%rax
  800420d8b1:	48 ba c8 7c 21 04 80 	movabs $0x8004217cc8,%rdx
  800420d8b8:	00 00 00 
  800420d8bb:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  800420d8bf:	0f be d0             	movsbl %al,%edx
  800420d8c2:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420d8c6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d8ca:	48 89 ce             	mov    %rcx,%rsi
  800420d8cd:	89 d7                	mov    %edx,%edi
  800420d8cf:	ff d0                	callq  *%rax
}
  800420d8d1:	48 83 c4 38          	add    $0x38,%rsp
  800420d8d5:	5b                   	pop    %rbx
  800420d8d6:	5d                   	pop    %rbp
  800420d8d7:	c3                   	retq   

000000800420d8d8 <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  800420d8d8:	55                   	push   %rbp
  800420d8d9:	48 89 e5             	mov    %rsp,%rbp
  800420d8dc:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420d8e0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420d8e4:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	unsigned long long x;
	if (lflag >= 2)
  800420d8e7:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  800420d8eb:	7e 52                	jle    800420d93f <getuint+0x67>
		x= va_arg(*ap, unsigned long long);
  800420d8ed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d8f1:	8b 00                	mov    (%rax),%eax
  800420d8f3:	83 f8 30             	cmp    $0x30,%eax
  800420d8f6:	73 24                	jae    800420d91c <getuint+0x44>
  800420d8f8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d8fc:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420d900:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d904:	8b 00                	mov    (%rax),%eax
  800420d906:	89 c0                	mov    %eax,%eax
  800420d908:	48 01 d0             	add    %rdx,%rax
  800420d90b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d90f:	8b 12                	mov    (%rdx),%edx
  800420d911:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420d914:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d918:	89 0a                	mov    %ecx,(%rdx)
  800420d91a:	eb 17                	jmp    800420d933 <getuint+0x5b>
  800420d91c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d920:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420d924:	48 89 d0             	mov    %rdx,%rax
  800420d927:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420d92b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d92f:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420d933:	48 8b 00             	mov    (%rax),%rax
  800420d936:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420d93a:	e9 a3 00 00 00       	jmpq   800420d9e2 <getuint+0x10a>
	else if (lflag)
  800420d93f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420d943:	74 4f                	je     800420d994 <getuint+0xbc>
		x= va_arg(*ap, unsigned long);
  800420d945:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d949:	8b 00                	mov    (%rax),%eax
  800420d94b:	83 f8 30             	cmp    $0x30,%eax
  800420d94e:	73 24                	jae    800420d974 <getuint+0x9c>
  800420d950:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d954:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420d958:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d95c:	8b 00                	mov    (%rax),%eax
  800420d95e:	89 c0                	mov    %eax,%eax
  800420d960:	48 01 d0             	add    %rdx,%rax
  800420d963:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d967:	8b 12                	mov    (%rdx),%edx
  800420d969:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420d96c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d970:	89 0a                	mov    %ecx,(%rdx)
  800420d972:	eb 17                	jmp    800420d98b <getuint+0xb3>
  800420d974:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d978:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420d97c:	48 89 d0             	mov    %rdx,%rax
  800420d97f:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420d983:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d987:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420d98b:	48 8b 00             	mov    (%rax),%rax
  800420d98e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420d992:	eb 4e                	jmp    800420d9e2 <getuint+0x10a>
	else
		x= va_arg(*ap, unsigned int);
  800420d994:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d998:	8b 00                	mov    (%rax),%eax
  800420d99a:	83 f8 30             	cmp    $0x30,%eax
  800420d99d:	73 24                	jae    800420d9c3 <getuint+0xeb>
  800420d99f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d9a3:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420d9a7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d9ab:	8b 00                	mov    (%rax),%eax
  800420d9ad:	89 c0                	mov    %eax,%eax
  800420d9af:	48 01 d0             	add    %rdx,%rax
  800420d9b2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d9b6:	8b 12                	mov    (%rdx),%edx
  800420d9b8:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420d9bb:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d9bf:	89 0a                	mov    %ecx,(%rdx)
  800420d9c1:	eb 17                	jmp    800420d9da <getuint+0x102>
  800420d9c3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d9c7:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420d9cb:	48 89 d0             	mov    %rdx,%rax
  800420d9ce:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420d9d2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d9d6:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420d9da:	8b 00                	mov    (%rax),%eax
  800420d9dc:	89 c0                	mov    %eax,%eax
  800420d9de:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  800420d9e2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420d9e6:	c9                   	leaveq 
  800420d9e7:	c3                   	retq   

000000800420d9e8 <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
  800420d9e8:	55                   	push   %rbp
  800420d9e9:	48 89 e5             	mov    %rsp,%rbp
  800420d9ec:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420d9f0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420d9f4:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	long long x;
	if (lflag >= 2)
  800420d9f7:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  800420d9fb:	7e 52                	jle    800420da4f <getint+0x67>
		x=va_arg(*ap, long long);
  800420d9fd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420da01:	8b 00                	mov    (%rax),%eax
  800420da03:	83 f8 30             	cmp    $0x30,%eax
  800420da06:	73 24                	jae    800420da2c <getint+0x44>
  800420da08:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420da0c:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420da10:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420da14:	8b 00                	mov    (%rax),%eax
  800420da16:	89 c0                	mov    %eax,%eax
  800420da18:	48 01 d0             	add    %rdx,%rax
  800420da1b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420da1f:	8b 12                	mov    (%rdx),%edx
  800420da21:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420da24:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420da28:	89 0a                	mov    %ecx,(%rdx)
  800420da2a:	eb 17                	jmp    800420da43 <getint+0x5b>
  800420da2c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420da30:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420da34:	48 89 d0             	mov    %rdx,%rax
  800420da37:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420da3b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420da3f:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420da43:	48 8b 00             	mov    (%rax),%rax
  800420da46:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420da4a:	e9 a3 00 00 00       	jmpq   800420daf2 <getint+0x10a>
	else if (lflag)
  800420da4f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420da53:	74 4f                	je     800420daa4 <getint+0xbc>
		x=va_arg(*ap, long);
  800420da55:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420da59:	8b 00                	mov    (%rax),%eax
  800420da5b:	83 f8 30             	cmp    $0x30,%eax
  800420da5e:	73 24                	jae    800420da84 <getint+0x9c>
  800420da60:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420da64:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420da68:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420da6c:	8b 00                	mov    (%rax),%eax
  800420da6e:	89 c0                	mov    %eax,%eax
  800420da70:	48 01 d0             	add    %rdx,%rax
  800420da73:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420da77:	8b 12                	mov    (%rdx),%edx
  800420da79:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420da7c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420da80:	89 0a                	mov    %ecx,(%rdx)
  800420da82:	eb 17                	jmp    800420da9b <getint+0xb3>
  800420da84:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420da88:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420da8c:	48 89 d0             	mov    %rdx,%rax
  800420da8f:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420da93:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420da97:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420da9b:	48 8b 00             	mov    (%rax),%rax
  800420da9e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420daa2:	eb 4e                	jmp    800420daf2 <getint+0x10a>
	else
		x=va_arg(*ap, int);
  800420daa4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420daa8:	8b 00                	mov    (%rax),%eax
  800420daaa:	83 f8 30             	cmp    $0x30,%eax
  800420daad:	73 24                	jae    800420dad3 <getint+0xeb>
  800420daaf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dab3:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420dab7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dabb:	8b 00                	mov    (%rax),%eax
  800420dabd:	89 c0                	mov    %eax,%eax
  800420dabf:	48 01 d0             	add    %rdx,%rax
  800420dac2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420dac6:	8b 12                	mov    (%rdx),%edx
  800420dac8:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420dacb:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420dacf:	89 0a                	mov    %ecx,(%rdx)
  800420dad1:	eb 17                	jmp    800420daea <getint+0x102>
  800420dad3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dad7:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420dadb:	48 89 d0             	mov    %rdx,%rax
  800420dade:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420dae2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420dae6:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420daea:	8b 00                	mov    (%rax),%eax
  800420daec:	48 98                	cltq   
  800420daee:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  800420daf2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420daf6:	c9                   	leaveq 
  800420daf7:	c3                   	retq   

000000800420daf8 <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  800420daf8:	55                   	push   %rbp
  800420daf9:	48 89 e5             	mov    %rsp,%rbp
  800420dafc:	41 54                	push   %r12
  800420dafe:	53                   	push   %rbx
  800420daff:	48 83 ec 60          	sub    $0x60,%rsp
  800420db03:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  800420db07:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  800420db0b:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420db0f:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
	register int ch, err, esc_color;
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
  800420db13:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420db17:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  800420db1b:	48 8b 0a             	mov    (%rdx),%rcx
  800420db1e:	48 89 08             	mov    %rcx,(%rax)
  800420db21:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420db25:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420db29:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420db2d:	48 89 50 10          	mov    %rdx,0x10(%rax)
	while (1) {
		ch = *(unsigned char *) fmt++;
  800420db31:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420db35:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420db39:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420db3d:	0f b6 00             	movzbl (%rax),%eax
  800420db40:	0f b6 d8             	movzbl %al,%ebx
		while (ch != '%' && ch != '\033') {
  800420db43:	eb 29                	jmp    800420db6e <vprintfmt+0x76>
			if (ch == '\0')
  800420db45:	85 db                	test   %ebx,%ebx
  800420db47:	0f 84 ad 06 00 00    	je     800420e1fa <vprintfmt+0x702>
				return;
			putch(ch, putdat);
  800420db4d:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420db51:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420db55:	48 89 d6             	mov    %rdx,%rsi
  800420db58:	89 df                	mov    %ebx,%edi
  800420db5a:	ff d0                	callq  *%rax
			ch = *(unsigned char *) fmt++;
  800420db5c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420db60:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420db64:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420db68:	0f b6 00             	movzbl (%rax),%eax
  800420db6b:	0f b6 d8             	movzbl %al,%ebx
	char padc;
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		ch = *(unsigned char *) fmt++;
		while (ch != '%' && ch != '\033') {
  800420db6e:	83 fb 25             	cmp    $0x25,%ebx
  800420db71:	74 05                	je     800420db78 <vprintfmt+0x80>
  800420db73:	83 fb 1b             	cmp    $0x1b,%ebx
  800420db76:	75 cd                	jne    800420db45 <vprintfmt+0x4d>
				return;
			putch(ch, putdat);
			ch = *(unsigned char *) fmt++;
		}

		if (ch == '\033') {
  800420db78:	83 fb 1b             	cmp    $0x1b,%ebx
  800420db7b:	0f 85 ae 01 00 00    	jne    800420dd2f <vprintfmt+0x237>
			// set parsing status to 1, which will temporarily disable the char display sent to CGA
			// but will not affect serial and lpt
			color_parsing = 1;
  800420db81:	48 b8 18 63 49 04 80 	movabs $0x8004496318,%rax
  800420db88:	00 00 00 
  800420db8b:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
			// read Escape sequence
			putch(ch, putdat);
  800420db91:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420db95:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420db99:	48 89 d6             	mov    %rdx,%rsi
  800420db9c:	89 df                	mov    %ebx,%edi
  800420db9e:	ff d0                	callq  *%rax
			putch('[', putdat);
  800420dba0:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420dba4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420dba8:	48 89 d6             	mov    %rdx,%rsi
  800420dbab:	bf 5b 00 00 00       	mov    $0x5b,%edi
  800420dbb0:	ff d0                	callq  *%rax
			// read number
			while (1) {
				esc_color = 0;
  800420dbb2:	41 bc 00 00 00 00    	mov    $0x0,%r12d
				ch = *(unsigned char *) ++fmt;
  800420dbb8:	48 83 45 98 01       	addq   $0x1,-0x68(%rbp)
  800420dbbd:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420dbc1:	0f b6 00             	movzbl (%rax),%eax
  800420dbc4:	0f b6 d8             	movzbl %al,%ebx
				// if encounter ';' or 'm', then we got our number
				while (ch != ';' && ch != 'm') {
  800420dbc7:	eb 32                	jmp    800420dbfb <vprintfmt+0x103>
					putch(ch, putdat);
  800420dbc9:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420dbcd:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420dbd1:	48 89 d6             	mov    %rdx,%rsi
  800420dbd4:	89 df                	mov    %ebx,%edi
  800420dbd6:	ff d0                	callq  *%rax
					esc_color *= 10;
  800420dbd8:	44 89 e0             	mov    %r12d,%eax
  800420dbdb:	c1 e0 02             	shl    $0x2,%eax
  800420dbde:	44 01 e0             	add    %r12d,%eax
  800420dbe1:	01 c0                	add    %eax,%eax
  800420dbe3:	41 89 c4             	mov    %eax,%r12d
					esc_color += ch - '0';
  800420dbe6:	8d 43 d0             	lea    -0x30(%rbx),%eax
  800420dbe9:	41 01 c4             	add    %eax,%r12d
					ch = *(unsigned char *) ++fmt;
  800420dbec:	48 83 45 98 01       	addq   $0x1,-0x68(%rbp)
  800420dbf1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420dbf5:	0f b6 00             	movzbl (%rax),%eax
  800420dbf8:	0f b6 d8             	movzbl %al,%ebx
			// read number
			while (1) {
				esc_color = 0;
				ch = *(unsigned char *) ++fmt;
				// if encounter ';' or 'm', then we got our number
				while (ch != ';' && ch != 'm') {
  800420dbfb:	83 fb 3b             	cmp    $0x3b,%ebx
  800420dbfe:	74 05                	je     800420dc05 <vprintfmt+0x10d>
  800420dc00:	83 fb 6d             	cmp    $0x6d,%ebx
  800420dc03:	75 c4                	jne    800420dbc9 <vprintfmt+0xd1>
					esc_color += ch - '0';
					ch = *(unsigned char *) ++fmt;
				}

				// interpret number
				if (esc_color == 0)
  800420dc05:	45 85 e4             	test   %r12d,%r12d
  800420dc08:	75 15                	jne    800420dc1f <vprintfmt+0x127>
					color_flag = 0x07;
  800420dc0a:	48 b8 b0 b6 22 04 80 	movabs $0x800422b6b0,%rax
  800420dc11:	00 00 00 
  800420dc14:	c7 00 07 00 00 00    	movl   $0x7,(%rax)
  800420dc1a:	e9 dc 00 00 00       	jmpq   800420dcfb <vprintfmt+0x203>
				else if (esc_color >= 30 && esc_color <= 37) {
  800420dc1f:	41 83 fc 1d          	cmp    $0x1d,%r12d
  800420dc23:	7e 69                	jle    800420dc8e <vprintfmt+0x196>
  800420dc25:	41 83 fc 25          	cmp    $0x25,%r12d
  800420dc29:	7f 63                	jg     800420dc8e <vprintfmt+0x196>
					// foreground colors
					color_flag &= 0xf8;
  800420dc2b:	48 b8 b0 b6 22 04 80 	movabs $0x800422b6b0,%rax
  800420dc32:	00 00 00 
  800420dc35:	8b 00                	mov    (%rax),%eax
  800420dc37:	25 f8 00 00 00       	and    $0xf8,%eax
  800420dc3c:	89 c2                	mov    %eax,%edx
  800420dc3e:	48 b8 b0 b6 22 04 80 	movabs $0x800422b6b0,%rax
  800420dc45:	00 00 00 
  800420dc48:	89 10                	mov    %edx,(%rax)
					esc_color -= 30;
  800420dc4a:	41 83 ec 1e          	sub    $0x1e,%r12d
					color_flag |= color_fun(esc_color);
  800420dc4e:	44 89 e0             	mov    %r12d,%eax
  800420dc51:	83 e0 04             	and    $0x4,%eax
  800420dc54:	c1 f8 02             	sar    $0x2,%eax
  800420dc57:	89 c2                	mov    %eax,%edx
  800420dc59:	44 89 e0             	mov    %r12d,%eax
  800420dc5c:	83 e0 02             	and    $0x2,%eax
  800420dc5f:	09 c2                	or     %eax,%edx
  800420dc61:	44 89 e0             	mov    %r12d,%eax
  800420dc64:	83 e0 01             	and    $0x1,%eax
  800420dc67:	c1 e0 02             	shl    $0x2,%eax
  800420dc6a:	09 c2                	or     %eax,%edx
  800420dc6c:	41 89 d4             	mov    %edx,%r12d
  800420dc6f:	48 b8 b0 b6 22 04 80 	movabs $0x800422b6b0,%rax
  800420dc76:	00 00 00 
  800420dc79:	8b 00                	mov    (%rax),%eax
  800420dc7b:	44 89 e2             	mov    %r12d,%edx
  800420dc7e:	09 c2                	or     %eax,%edx
  800420dc80:	48 b8 b0 b6 22 04 80 	movabs $0x800422b6b0,%rax
  800420dc87:	00 00 00 
  800420dc8a:	89 10                	mov    %edx,(%rax)
  800420dc8c:	eb 6d                	jmp    800420dcfb <vprintfmt+0x203>
				}
				else if (esc_color >= 40 && esc_color <= 47) {
  800420dc8e:	41 83 fc 27          	cmp    $0x27,%r12d
  800420dc92:	7e 67                	jle    800420dcfb <vprintfmt+0x203>
  800420dc94:	41 83 fc 2f          	cmp    $0x2f,%r12d
  800420dc98:	7f 61                	jg     800420dcfb <vprintfmt+0x203>
					// background colors
					color_flag &= 0x8f;
  800420dc9a:	48 b8 b0 b6 22 04 80 	movabs $0x800422b6b0,%rax
  800420dca1:	00 00 00 
  800420dca4:	8b 00                	mov    (%rax),%eax
  800420dca6:	25 8f 00 00 00       	and    $0x8f,%eax
  800420dcab:	89 c2                	mov    %eax,%edx
  800420dcad:	48 b8 b0 b6 22 04 80 	movabs $0x800422b6b0,%rax
  800420dcb4:	00 00 00 
  800420dcb7:	89 10                	mov    %edx,(%rax)
					esc_color -= 40;
  800420dcb9:	41 83 ec 28          	sub    $0x28,%r12d
					color_flag |= (color_fun(esc_color) << 4);
  800420dcbd:	44 89 e0             	mov    %r12d,%eax
  800420dcc0:	83 e0 04             	and    $0x4,%eax
  800420dcc3:	c1 f8 02             	sar    $0x2,%eax
  800420dcc6:	89 c2                	mov    %eax,%edx
  800420dcc8:	44 89 e0             	mov    %r12d,%eax
  800420dccb:	83 e0 02             	and    $0x2,%eax
  800420dcce:	09 c2                	or     %eax,%edx
  800420dcd0:	44 89 e0             	mov    %r12d,%eax
  800420dcd3:	83 e0 01             	and    $0x1,%eax
  800420dcd6:	c1 e0 06             	shl    $0x6,%eax
  800420dcd9:	09 c2                	or     %eax,%edx
  800420dcdb:	41 89 d4             	mov    %edx,%r12d
  800420dcde:	48 b8 b0 b6 22 04 80 	movabs $0x800422b6b0,%rax
  800420dce5:	00 00 00 
  800420dce8:	8b 00                	mov    (%rax),%eax
  800420dcea:	44 89 e2             	mov    %r12d,%edx
  800420dced:	09 c2                	or     %eax,%edx
  800420dcef:	48 b8 b0 b6 22 04 80 	movabs $0x800422b6b0,%rax
  800420dcf6:	00 00 00 
  800420dcf9:	89 10                	mov    %edx,(%rax)
				}
				putch(ch, putdat);
  800420dcfb:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420dcff:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420dd03:	48 89 d6             	mov    %rdx,%rsi
  800420dd06:	89 df                	mov    %ebx,%edi
  800420dd08:	ff d0                	callq  *%rax

				// if encounter 'm', escape sequence finish
				if (ch == 'm') {
  800420dd0a:	83 fb 6d             	cmp    $0x6d,%ebx
  800420dd0d:	75 1b                	jne    800420dd2a <vprintfmt+0x232>
					fmt ++;
  800420dd0f:	48 83 45 98 01       	addq   $0x1,-0x68(%rbp)
					break;
  800420dd14:	90                   	nop
				}
			}

			// stop color parsing
			color_parsing = 0;
  800420dd15:	48 b8 18 63 49 04 80 	movabs $0x8004496318,%rax
  800420dd1c:	00 00 00 
  800420dd1f:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
			continue;
  800420dd25:	e9 cb 04 00 00       	jmpq   800420e1f5 <vprintfmt+0x6fd>
				// if encounter 'm', escape sequence finish
				if (ch == 'm') {
					fmt ++;
					break;
				}
			}
  800420dd2a:	e9 83 fe ff ff       	jmpq   800420dbb2 <vprintfmt+0xba>
			color_parsing = 0;
			continue;
		}

		// Process a %-escape sequence
		padc = ' ';
  800420dd2f:	c6 45 d3 20          	movb   $0x20,-0x2d(%rbp)
		width = -1;
  800420dd33:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%rbp)
		precision = -1;
  800420dd3a:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
		lflag = 0;
  800420dd41:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
		altflag = 0;
  800420dd48:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  800420dd4f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420dd53:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420dd57:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420dd5b:	0f b6 00             	movzbl (%rax),%eax
  800420dd5e:	0f b6 d8             	movzbl %al,%ebx
  800420dd61:	8d 43 dd             	lea    -0x23(%rbx),%eax
  800420dd64:	83 f8 55             	cmp    $0x55,%eax
  800420dd67:	0f 87 5a 04 00 00    	ja     800420e1c7 <vprintfmt+0x6cf>
  800420dd6d:	89 c0                	mov    %eax,%eax
  800420dd6f:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420dd76:	00 
  800420dd77:	48 b8 f0 7c 21 04 80 	movabs $0x8004217cf0,%rax
  800420dd7e:	00 00 00 
  800420dd81:	48 01 d0             	add    %rdx,%rax
  800420dd84:	48 8b 00             	mov    (%rax),%rax
  800420dd87:	ff e0                	jmpq   *%rax

		// flag to pad on the right
		case '-':
			padc = '-';
  800420dd89:	c6 45 d3 2d          	movb   $0x2d,-0x2d(%rbp)
			goto reswitch;
  800420dd8d:	eb c0                	jmp    800420dd4f <vprintfmt+0x257>

		// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
  800420dd8f:	c6 45 d3 30          	movb   $0x30,-0x2d(%rbp)
			goto reswitch;
  800420dd93:	eb ba                	jmp    800420dd4f <vprintfmt+0x257>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  800420dd95:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
				precision = precision * 10 + ch - '0';
  800420dd9c:	8b 55 d8             	mov    -0x28(%rbp),%edx
  800420dd9f:	89 d0                	mov    %edx,%eax
  800420dda1:	c1 e0 02             	shl    $0x2,%eax
  800420dda4:	01 d0                	add    %edx,%eax
  800420dda6:	01 c0                	add    %eax,%eax
  800420dda8:	01 d8                	add    %ebx,%eax
  800420ddaa:	83 e8 30             	sub    $0x30,%eax
  800420ddad:	89 45 d8             	mov    %eax,-0x28(%rbp)
				ch = *fmt;
  800420ddb0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420ddb4:	0f b6 00             	movzbl (%rax),%eax
  800420ddb7:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
  800420ddba:	83 fb 2f             	cmp    $0x2f,%ebx
  800420ddbd:	7e 0c                	jle    800420ddcb <vprintfmt+0x2d3>
  800420ddbf:	83 fb 39             	cmp    $0x39,%ebx
  800420ddc2:	7f 07                	jg     800420ddcb <vprintfmt+0x2d3>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  800420ddc4:	48 83 45 98 01       	addq   $0x1,-0x68(%rbp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
  800420ddc9:	eb d1                	jmp    800420dd9c <vprintfmt+0x2a4>
			goto process_precision;
  800420ddcb:	eb 58                	jmp    800420de25 <vprintfmt+0x32d>

		case '*':
			precision = va_arg(aq, int);
  800420ddcd:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420ddd0:	83 f8 30             	cmp    $0x30,%eax
  800420ddd3:	73 17                	jae    800420ddec <vprintfmt+0x2f4>
  800420ddd5:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420ddd9:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420dddc:	89 c0                	mov    %eax,%eax
  800420ddde:	48 01 d0             	add    %rdx,%rax
  800420dde1:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420dde4:	83 c2 08             	add    $0x8,%edx
  800420dde7:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420ddea:	eb 0f                	jmp    800420ddfb <vprintfmt+0x303>
  800420ddec:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420ddf0:	48 89 d0             	mov    %rdx,%rax
  800420ddf3:	48 83 c2 08          	add    $0x8,%rdx
  800420ddf7:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420ddfb:	8b 00                	mov    (%rax),%eax
  800420ddfd:	89 45 d8             	mov    %eax,-0x28(%rbp)
			goto process_precision;
  800420de00:	eb 23                	jmp    800420de25 <vprintfmt+0x32d>

		case '.':
			if (width < 0)
  800420de02:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420de06:	79 0c                	jns    800420de14 <vprintfmt+0x31c>
				width = 0;
  800420de08:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
			goto reswitch;
  800420de0f:	e9 3b ff ff ff       	jmpq   800420dd4f <vprintfmt+0x257>
  800420de14:	e9 36 ff ff ff       	jmpq   800420dd4f <vprintfmt+0x257>

		case '#':
			altflag = 1;
  800420de19:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%rbp)
			goto reswitch;
  800420de20:	e9 2a ff ff ff       	jmpq   800420dd4f <vprintfmt+0x257>

		process_precision:
			if (width < 0)
  800420de25:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420de29:	79 12                	jns    800420de3d <vprintfmt+0x345>
				width = precision, precision = -1;
  800420de2b:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420de2e:	89 45 dc             	mov    %eax,-0x24(%rbp)
  800420de31:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
			goto reswitch;
  800420de38:	e9 12 ff ff ff       	jmpq   800420dd4f <vprintfmt+0x257>
  800420de3d:	e9 0d ff ff ff       	jmpq   800420dd4f <vprintfmt+0x257>

		// long flag (doubled for long long)
		case 'l':
			lflag++;
  800420de42:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
			goto reswitch;
  800420de46:	e9 04 ff ff ff       	jmpq   800420dd4f <vprintfmt+0x257>

		// character
		case 'c':
			putch(va_arg(aq, int), putdat);
  800420de4b:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420de4e:	83 f8 30             	cmp    $0x30,%eax
  800420de51:	73 17                	jae    800420de6a <vprintfmt+0x372>
  800420de53:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420de57:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420de5a:	89 c0                	mov    %eax,%eax
  800420de5c:	48 01 d0             	add    %rdx,%rax
  800420de5f:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420de62:	83 c2 08             	add    $0x8,%edx
  800420de65:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420de68:	eb 0f                	jmp    800420de79 <vprintfmt+0x381>
  800420de6a:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420de6e:	48 89 d0             	mov    %rdx,%rax
  800420de71:	48 83 c2 08          	add    $0x8,%rdx
  800420de75:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420de79:	8b 10                	mov    (%rax),%edx
  800420de7b:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  800420de7f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420de83:	48 89 ce             	mov    %rcx,%rsi
  800420de86:	89 d7                	mov    %edx,%edi
  800420de88:	ff d0                	callq  *%rax
			break;
  800420de8a:	e9 66 03 00 00       	jmpq   800420e1f5 <vprintfmt+0x6fd>

		// error message
		case 'e':
			err = va_arg(aq, int);
  800420de8f:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420de92:	83 f8 30             	cmp    $0x30,%eax
  800420de95:	73 17                	jae    800420deae <vprintfmt+0x3b6>
  800420de97:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420de9b:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420de9e:	89 c0                	mov    %eax,%eax
  800420dea0:	48 01 d0             	add    %rdx,%rax
  800420dea3:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420dea6:	83 c2 08             	add    $0x8,%edx
  800420dea9:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420deac:	eb 0f                	jmp    800420debd <vprintfmt+0x3c5>
  800420deae:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420deb2:	48 89 d0             	mov    %rdx,%rax
  800420deb5:	48 83 c2 08          	add    $0x8,%rdx
  800420deb9:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420debd:	8b 18                	mov    (%rax),%ebx
			if (err < 0)
  800420debf:	85 db                	test   %ebx,%ebx
  800420dec1:	79 02                	jns    800420dec5 <vprintfmt+0x3cd>
				err = -err;
  800420dec3:	f7 db                	neg    %ebx
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  800420dec5:	83 fb 10             	cmp    $0x10,%ebx
  800420dec8:	7f 16                	jg     800420dee0 <vprintfmt+0x3e8>
  800420deca:	48 b8 40 7c 21 04 80 	movabs $0x8004217c40,%rax
  800420ded1:	00 00 00 
  800420ded4:	48 63 d3             	movslq %ebx,%rdx
  800420ded7:	4c 8b 24 d0          	mov    (%rax,%rdx,8),%r12
  800420dedb:	4d 85 e4             	test   %r12,%r12
  800420dede:	75 2e                	jne    800420df0e <vprintfmt+0x416>
				printfmt(putch, putdat, "error %d", err);
  800420dee0:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420dee4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420dee8:	89 d9                	mov    %ebx,%ecx
  800420deea:	48 ba d9 7c 21 04 80 	movabs $0x8004217cd9,%rdx
  800420def1:	00 00 00 
  800420def4:	48 89 c7             	mov    %rax,%rdi
  800420def7:	b8 00 00 00 00       	mov    $0x0,%eax
  800420defc:	49 b8 03 e2 20 04 80 	movabs $0x800420e203,%r8
  800420df03:	00 00 00 
  800420df06:	41 ff d0             	callq  *%r8
			else
				printfmt(putch, putdat, "%s", p);
			break;
  800420df09:	e9 e7 02 00 00       	jmpq   800420e1f5 <vprintfmt+0x6fd>
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
  800420df0e:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420df12:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420df16:	4c 89 e1             	mov    %r12,%rcx
  800420df19:	48 ba e2 7c 21 04 80 	movabs $0x8004217ce2,%rdx
  800420df20:	00 00 00 
  800420df23:	48 89 c7             	mov    %rax,%rdi
  800420df26:	b8 00 00 00 00       	mov    $0x0,%eax
  800420df2b:	49 b8 03 e2 20 04 80 	movabs $0x800420e203,%r8
  800420df32:	00 00 00 
  800420df35:	41 ff d0             	callq  *%r8
			break;
  800420df38:	e9 b8 02 00 00       	jmpq   800420e1f5 <vprintfmt+0x6fd>

		// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
  800420df3d:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420df40:	83 f8 30             	cmp    $0x30,%eax
  800420df43:	73 17                	jae    800420df5c <vprintfmt+0x464>
  800420df45:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420df49:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420df4c:	89 c0                	mov    %eax,%eax
  800420df4e:	48 01 d0             	add    %rdx,%rax
  800420df51:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420df54:	83 c2 08             	add    $0x8,%edx
  800420df57:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420df5a:	eb 0f                	jmp    800420df6b <vprintfmt+0x473>
  800420df5c:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420df60:	48 89 d0             	mov    %rdx,%rax
  800420df63:	48 83 c2 08          	add    $0x8,%rdx
  800420df67:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420df6b:	4c 8b 20             	mov    (%rax),%r12
  800420df6e:	4d 85 e4             	test   %r12,%r12
  800420df71:	75 0a                	jne    800420df7d <vprintfmt+0x485>
				p = "(null)";
  800420df73:	49 bc e5 7c 21 04 80 	movabs $0x8004217ce5,%r12
  800420df7a:	00 00 00 
			if (width > 0 && padc != '-')
  800420df7d:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420df81:	7e 3f                	jle    800420dfc2 <vprintfmt+0x4ca>
  800420df83:	80 7d d3 2d          	cmpb   $0x2d,-0x2d(%rbp)
  800420df87:	74 39                	je     800420dfc2 <vprintfmt+0x4ca>
				for (width -= strnlen(p, precision); width > 0; width--)
  800420df89:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420df8c:	48 98                	cltq   
  800420df8e:	48 89 c6             	mov    %rax,%rsi
  800420df91:	4c 89 e7             	mov    %r12,%rdi
  800420df94:	48 b8 04 e6 20 04 80 	movabs $0x800420e604,%rax
  800420df9b:	00 00 00 
  800420df9e:	ff d0                	callq  *%rax
  800420dfa0:	29 45 dc             	sub    %eax,-0x24(%rbp)
  800420dfa3:	eb 17                	jmp    800420dfbc <vprintfmt+0x4c4>
					putch(padc, putdat);
  800420dfa5:	0f be 55 d3          	movsbl -0x2d(%rbp),%edx
  800420dfa9:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  800420dfad:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420dfb1:	48 89 ce             	mov    %rcx,%rsi
  800420dfb4:	89 d7                	mov    %edx,%edi
  800420dfb6:	ff d0                	callq  *%rax
		// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  800420dfb8:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420dfbc:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420dfc0:	7f e3                	jg     800420dfa5 <vprintfmt+0x4ad>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800420dfc2:	eb 37                	jmp    800420dffb <vprintfmt+0x503>
				if (altflag && (ch < ' ' || ch > '~'))
  800420dfc4:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  800420dfc8:	74 1e                	je     800420dfe8 <vprintfmt+0x4f0>
  800420dfca:	83 fb 1f             	cmp    $0x1f,%ebx
  800420dfcd:	7e 05                	jle    800420dfd4 <vprintfmt+0x4dc>
  800420dfcf:	83 fb 7e             	cmp    $0x7e,%ebx
  800420dfd2:	7e 14                	jle    800420dfe8 <vprintfmt+0x4f0>
					putch('?', putdat);
  800420dfd4:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420dfd8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420dfdc:	48 89 d6             	mov    %rdx,%rsi
  800420dfdf:	bf 3f 00 00 00       	mov    $0x3f,%edi
  800420dfe4:	ff d0                	callq  *%rax
  800420dfe6:	eb 0f                	jmp    800420dff7 <vprintfmt+0x4ff>
				else
					putch(ch, putdat);
  800420dfe8:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420dfec:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420dff0:	48 89 d6             	mov    %rdx,%rsi
  800420dff3:	89 df                	mov    %ebx,%edi
  800420dff5:	ff d0                	callq  *%rax
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800420dff7:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420dffb:	4c 89 e0             	mov    %r12,%rax
  800420dffe:	4c 8d 60 01          	lea    0x1(%rax),%r12
  800420e002:	0f b6 00             	movzbl (%rax),%eax
  800420e005:	0f be d8             	movsbl %al,%ebx
  800420e008:	85 db                	test   %ebx,%ebx
  800420e00a:	74 10                	je     800420e01c <vprintfmt+0x524>
  800420e00c:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  800420e010:	78 b2                	js     800420dfc4 <vprintfmt+0x4cc>
  800420e012:	83 6d d8 01          	subl   $0x1,-0x28(%rbp)
  800420e016:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  800420e01a:	79 a8                	jns    800420dfc4 <vprintfmt+0x4cc>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800420e01c:	eb 16                	jmp    800420e034 <vprintfmt+0x53c>
				putch(' ', putdat);
  800420e01e:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e022:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e026:	48 89 d6             	mov    %rdx,%rsi
  800420e029:	bf 20 00 00 00       	mov    $0x20,%edi
  800420e02e:	ff d0                	callq  *%rax
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800420e030:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420e034:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420e038:	7f e4                	jg     800420e01e <vprintfmt+0x526>
				putch(' ', putdat);
			break;
  800420e03a:	e9 b6 01 00 00       	jmpq   800420e1f5 <vprintfmt+0x6fd>

		// (signed) decimal
		case 'd':
			num = getint(&aq, 3);
  800420e03f:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420e043:	be 03 00 00 00       	mov    $0x3,%esi
  800420e048:	48 89 c7             	mov    %rax,%rdi
  800420e04b:	48 b8 e8 d9 20 04 80 	movabs $0x800420d9e8,%rax
  800420e052:	00 00 00 
  800420e055:	ff d0                	callq  *%rax
  800420e057:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			if ((long long) num < 0) {
  800420e05b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e05f:	48 85 c0             	test   %rax,%rax
  800420e062:	79 1d                	jns    800420e081 <vprintfmt+0x589>
				putch('-', putdat);
  800420e064:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e068:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e06c:	48 89 d6             	mov    %rdx,%rsi
  800420e06f:	bf 2d 00 00 00       	mov    $0x2d,%edi
  800420e074:	ff d0                	callq  *%rax
				num = -(long long) num;
  800420e076:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e07a:	48 f7 d8             	neg    %rax
  800420e07d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			}
			base = 10;
  800420e081:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  800420e088:	e9 fb 00 00 00       	jmpq   800420e188 <vprintfmt+0x690>

		// unsigned decimal
		case 'u':
			num = getuint(&aq, 3);
  800420e08d:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420e091:	be 03 00 00 00       	mov    $0x3,%esi
  800420e096:	48 89 c7             	mov    %rax,%rdi
  800420e099:	48 b8 d8 d8 20 04 80 	movabs $0x800420d8d8,%rax
  800420e0a0:	00 00 00 
  800420e0a3:	ff d0                	callq  *%rax
  800420e0a5:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 10;
  800420e0a9:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  800420e0b0:	e9 d3 00 00 00       	jmpq   800420e188 <vprintfmt+0x690>

		// (unsigned) octal
		case 'o':
			// Replace this with your code.
			num = getint(&aq,3);
  800420e0b5:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420e0b9:	be 03 00 00 00       	mov    $0x3,%esi
  800420e0be:	48 89 c7             	mov    %rax,%rdi
  800420e0c1:	48 b8 e8 d9 20 04 80 	movabs $0x800420d9e8,%rax
  800420e0c8:	00 00 00 
  800420e0cb:	ff d0                	callq  *%rax
  800420e0cd:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			if ((long long) num < 0) {
  800420e0d1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e0d5:	48 85 c0             	test   %rax,%rax
  800420e0d8:	79 1d                	jns    800420e0f7 <vprintfmt+0x5ff>
				putch('-', putdat);
  800420e0da:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e0de:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e0e2:	48 89 d6             	mov    %rdx,%rsi
  800420e0e5:	bf 2d 00 00 00       	mov    $0x2d,%edi
  800420e0ea:	ff d0                	callq  *%rax
				num = -(long long) num;
  800420e0ec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e0f0:	48 f7 d8             	neg    %rax
  800420e0f3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			}
			base = 8;
  800420e0f7:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%rbp)
			goto number;
  800420e0fe:	e9 85 00 00 00       	jmpq   800420e188 <vprintfmt+0x690>

		// pointer
		case 'p':
			putch('0', putdat);
  800420e103:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e107:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e10b:	48 89 d6             	mov    %rdx,%rsi
  800420e10e:	bf 30 00 00 00       	mov    $0x30,%edi
  800420e113:	ff d0                	callq  *%rax
			putch('x', putdat);
  800420e115:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e119:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e11d:	48 89 d6             	mov    %rdx,%rsi
  800420e120:	bf 78 00 00 00       	mov    $0x78,%edi
  800420e125:	ff d0                	callq  *%rax
			num = (unsigned long long)
				(uintptr_t) va_arg(aq, void *);
  800420e127:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420e12a:	83 f8 30             	cmp    $0x30,%eax
  800420e12d:	73 17                	jae    800420e146 <vprintfmt+0x64e>
  800420e12f:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420e133:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420e136:	89 c0                	mov    %eax,%eax
  800420e138:	48 01 d0             	add    %rdx,%rax
  800420e13b:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420e13e:	83 c2 08             	add    $0x8,%edx
  800420e141:	89 55 b8             	mov    %edx,-0x48(%rbp)

		// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  800420e144:	eb 0f                	jmp    800420e155 <vprintfmt+0x65d>
				(uintptr_t) va_arg(aq, void *);
  800420e146:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420e14a:	48 89 d0             	mov    %rdx,%rax
  800420e14d:	48 83 c2 08          	add    $0x8,%rdx
  800420e151:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420e155:	48 8b 00             	mov    (%rax),%rax

		// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  800420e158:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				(uintptr_t) va_arg(aq, void *);
			base = 16;
  800420e15c:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
			goto number;
  800420e163:	eb 23                	jmp    800420e188 <vprintfmt+0x690>

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&aq, 3);
  800420e165:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420e169:	be 03 00 00 00       	mov    $0x3,%esi
  800420e16e:	48 89 c7             	mov    %rax,%rdi
  800420e171:	48 b8 d8 d8 20 04 80 	movabs $0x800420d8d8,%rax
  800420e178:	00 00 00 
  800420e17b:	ff d0                	callq  *%rax
  800420e17d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 16;
  800420e181:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
		number:
			printnum(putch, putdat, num, base, width, padc);
  800420e188:	44 0f be 45 d3       	movsbl -0x2d(%rbp),%r8d
  800420e18d:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  800420e190:	8b 7d dc             	mov    -0x24(%rbp),%edi
  800420e193:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e197:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420e19b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e19f:	45 89 c1             	mov    %r8d,%r9d
  800420e1a2:	41 89 f8             	mov    %edi,%r8d
  800420e1a5:	48 89 c7             	mov    %rax,%rdi
  800420e1a8:	48 b8 1d d8 20 04 80 	movabs $0x800420d81d,%rax
  800420e1af:	00 00 00 
  800420e1b2:	ff d0                	callq  *%rax
			break;
  800420e1b4:	eb 3f                	jmp    800420e1f5 <vprintfmt+0x6fd>

		// escaped '%' character
		case '%':
			putch(ch, putdat);
  800420e1b6:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e1ba:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e1be:	48 89 d6             	mov    %rdx,%rsi
  800420e1c1:	89 df                	mov    %ebx,%edi
  800420e1c3:	ff d0                	callq  *%rax
			break;
  800420e1c5:	eb 2e                	jmp    800420e1f5 <vprintfmt+0x6fd>

		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  800420e1c7:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e1cb:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e1cf:	48 89 d6             	mov    %rdx,%rsi
  800420e1d2:	bf 25 00 00 00       	mov    $0x25,%edi
  800420e1d7:	ff d0                	callq  *%rax
			for (fmt--; fmt[-1] != '%'; fmt--)
  800420e1d9:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  800420e1de:	eb 05                	jmp    800420e1e5 <vprintfmt+0x6ed>
  800420e1e0:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  800420e1e5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420e1e9:	48 83 e8 01          	sub    $0x1,%rax
  800420e1ed:	0f b6 00             	movzbl (%rax),%eax
  800420e1f0:	3c 25                	cmp    $0x25,%al
  800420e1f2:	75 ec                	jne    800420e1e0 <vprintfmt+0x6e8>
				/* do nothing */;
			break;
  800420e1f4:	90                   	nop
		}
	}
  800420e1f5:	e9 37 f9 ff ff       	jmpq   800420db31 <vprintfmt+0x39>
    va_end(aq);
}
  800420e1fa:	48 83 c4 60          	add    $0x60,%rsp
  800420e1fe:	5b                   	pop    %rbx
  800420e1ff:	41 5c                	pop    %r12
  800420e201:	5d                   	pop    %rbp
  800420e202:	c3                   	retq   

000000800420e203 <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  800420e203:	55                   	push   %rbp
  800420e204:	48 89 e5             	mov    %rsp,%rbp
  800420e207:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  800420e20e:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  800420e215:	48 89 b5 20 ff ff ff 	mov    %rsi,-0xe0(%rbp)
  800420e21c:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420e223:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  800420e22a:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  800420e231:	84 c0                	test   %al,%al
  800420e233:	74 20                	je     800420e255 <printfmt+0x52>
  800420e235:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  800420e239:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420e23d:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  800420e241:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420e245:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  800420e249:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420e24d:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800420e251:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  800420e255:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	va_start(ap, fmt);
  800420e25c:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  800420e263:	00 00 00 
  800420e266:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  800420e26d:	00 00 00 
  800420e270:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420e274:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  800420e27b:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420e282:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	vprintfmt(putch, putdat, fmt, ap);
  800420e289:	48 8d 8d 38 ff ff ff 	lea    -0xc8(%rbp),%rcx
  800420e290:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  800420e297:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  800420e29e:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800420e2a5:	48 89 c7             	mov    %rax,%rdi
  800420e2a8:	48 b8 f8 da 20 04 80 	movabs $0x800420daf8,%rax
  800420e2af:	00 00 00 
  800420e2b2:	ff d0                	callq  *%rax
	va_end(ap);
}
  800420e2b4:	c9                   	leaveq 
  800420e2b5:	c3                   	retq   

000000800420e2b6 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  800420e2b6:	55                   	push   %rbp
  800420e2b7:	48 89 e5             	mov    %rsp,%rbp
  800420e2ba:	48 83 ec 10          	sub    $0x10,%rsp
  800420e2be:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800420e2c1:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	b->cnt++;
  800420e2c5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e2c9:	8b 40 10             	mov    0x10(%rax),%eax
  800420e2cc:	8d 50 01             	lea    0x1(%rax),%edx
  800420e2cf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e2d3:	89 50 10             	mov    %edx,0x10(%rax)
	if (b->buf < b->ebuf)
  800420e2d6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e2da:	48 8b 10             	mov    (%rax),%rdx
  800420e2dd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e2e1:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420e2e5:	48 39 c2             	cmp    %rax,%rdx
  800420e2e8:	73 17                	jae    800420e301 <sprintputch+0x4b>
		*b->buf++ = ch;
  800420e2ea:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e2ee:	48 8b 00             	mov    (%rax),%rax
  800420e2f1:	48 8d 48 01          	lea    0x1(%rax),%rcx
  800420e2f5:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420e2f9:	48 89 0a             	mov    %rcx,(%rdx)
  800420e2fc:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420e2ff:	88 10                	mov    %dl,(%rax)
}
  800420e301:	c9                   	leaveq 
  800420e302:	c3                   	retq   

000000800420e303 <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  800420e303:	55                   	push   %rbp
  800420e304:	48 89 e5             	mov    %rsp,%rbp
  800420e307:	48 83 ec 50          	sub    $0x50,%rsp
  800420e30b:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800420e30f:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  800420e312:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  800420e316:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	va_list aq;
	va_copy(aq,ap);
  800420e31a:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  800420e31e:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420e322:	48 8b 0a             	mov    (%rdx),%rcx
  800420e325:	48 89 08             	mov    %rcx,(%rax)
  800420e328:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420e32c:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420e330:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420e334:	48 89 50 10          	mov    %rdx,0x10(%rax)
	struct sprintbuf b = {buf, buf+n-1, 0};
  800420e338:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420e33c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  800420e340:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800420e343:	48 98                	cltq   
  800420e345:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  800420e349:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420e34d:	48 01 d0             	add    %rdx,%rax
  800420e350:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800420e354:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)

	if (buf == NULL || n < 1)
  800420e35b:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420e360:	74 06                	je     800420e368 <vsnprintf+0x65>
  800420e362:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  800420e366:	7f 07                	jg     800420e36f <vsnprintf+0x6c>
		return -E_INVAL;
  800420e368:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e36d:	eb 2f                	jmp    800420e39e <vsnprintf+0x9b>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, aq);
  800420e36f:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420e373:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420e377:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  800420e37b:	48 89 c6             	mov    %rax,%rsi
  800420e37e:	48 bf b6 e2 20 04 80 	movabs $0x800420e2b6,%rdi
  800420e385:	00 00 00 
  800420e388:	48 b8 f8 da 20 04 80 	movabs $0x800420daf8,%rax
  800420e38f:	00 00 00 
  800420e392:	ff d0                	callq  *%rax
	va_end(aq);
	// null terminate the buffer
	*b.buf = '\0';
  800420e394:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e398:	c6 00 00             	movb   $0x0,(%rax)

	return b.cnt;
  800420e39b:	8b 45 e0             	mov    -0x20(%rbp),%eax
}
  800420e39e:	c9                   	leaveq 
  800420e39f:	c3                   	retq   

000000800420e3a0 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  800420e3a0:	55                   	push   %rbp
  800420e3a1:	48 89 e5             	mov    %rsp,%rbp
  800420e3a4:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
  800420e3ab:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
  800420e3b2:	89 b5 04 ff ff ff    	mov    %esi,-0xfc(%rbp)
  800420e3b8:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420e3bf:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  800420e3c6:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  800420e3cd:	84 c0                	test   %al,%al
  800420e3cf:	74 20                	je     800420e3f1 <snprintf+0x51>
  800420e3d1:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  800420e3d5:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420e3d9:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  800420e3dd:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420e3e1:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  800420e3e5:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420e3e9:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800420e3ed:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  800420e3f1:	48 89 95 f8 fe ff ff 	mov    %rdx,-0x108(%rbp)
	va_list ap;
	int rc;
	va_list aq;
	va_start(ap, fmt);
  800420e3f8:	c7 85 30 ff ff ff 18 	movl   $0x18,-0xd0(%rbp)
  800420e3ff:	00 00 00 
  800420e402:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  800420e409:	00 00 00 
  800420e40c:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420e410:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  800420e417:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420e41e:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	va_copy(aq,ap);
  800420e425:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  800420e42c:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  800420e433:	48 8b 0a             	mov    (%rdx),%rcx
  800420e436:	48 89 08             	mov    %rcx,(%rax)
  800420e439:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420e43d:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420e441:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420e445:	48 89 50 10          	mov    %rdx,0x10(%rax)
	rc = vsnprintf(buf, n, fmt, aq);
  800420e449:	48 8d 8d 18 ff ff ff 	lea    -0xe8(%rbp),%rcx
  800420e450:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  800420e457:	8b b5 04 ff ff ff    	mov    -0xfc(%rbp),%esi
  800420e45d:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  800420e464:	48 89 c7             	mov    %rax,%rdi
  800420e467:	48 b8 03 e3 20 04 80 	movabs $0x800420e303,%rax
  800420e46e:	00 00 00 
  800420e471:	ff d0                	callq  *%rax
  800420e473:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return rc;
  800420e479:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  800420e47f:	c9                   	leaveq 
  800420e480:	c3                   	retq   

000000800420e481 <readline>:
#define BUFLEN 1024
static char buf[BUFLEN];

char *
readline(const char *prompt)
{
  800420e481:	55                   	push   %rbp
  800420e482:	48 89 e5             	mov    %rsp,%rbp
  800420e485:	48 83 ec 20          	sub    $0x20,%rsp
  800420e489:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int i, c, echoing;

#if JOS_KERNEL
	if (prompt != NULL)
  800420e48d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420e492:	74 22                	je     800420e4b6 <readline+0x35>
		cprintf("%s", prompt);
  800420e494:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e498:	48 89 c6             	mov    %rax,%rsi
  800420e49b:	48 bf a0 7f 21 04 80 	movabs $0x8004217fa0,%rdi
  800420e4a2:	00 00 00 
  800420e4a5:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e4aa:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  800420e4b1:	00 00 00 
  800420e4b4:	ff d2                	callq  *%rdx
#else
	if (prompt != NULL)
		fprintf(1, "%s", prompt);
#endif

	i = 0;
  800420e4b6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	echoing = iscons(0);
  800420e4bd:	bf 00 00 00 00       	mov    $0x0,%edi
  800420e4c2:	48 b8 3f 12 20 04 80 	movabs $0x800420123f,%rax
  800420e4c9:	00 00 00 
  800420e4cc:	ff d0                	callq  *%rax
  800420e4ce:	89 45 f8             	mov    %eax,-0x8(%rbp)
	while (1) {
		c = getchar();
  800420e4d1:	48 b8 1d 12 20 04 80 	movabs $0x800420121d,%rax
  800420e4d8:	00 00 00 
  800420e4db:	ff d0                	callq  *%rax
  800420e4dd:	89 45 f4             	mov    %eax,-0xc(%rbp)
		if (c < 0) {
  800420e4e0:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  800420e4e4:	79 30                	jns    800420e516 <readline+0x95>
			if (c != -E_EOF)
  800420e4e6:	83 7d f4 f7          	cmpl   $0xfffffff7,-0xc(%rbp)
  800420e4ea:	74 20                	je     800420e50c <readline+0x8b>
				cprintf("read error: %e\n", c);
  800420e4ec:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420e4ef:	89 c6                	mov    %eax,%esi
  800420e4f1:	48 bf a3 7f 21 04 80 	movabs $0x8004217fa3,%rdi
  800420e4f8:	00 00 00 
  800420e4fb:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e500:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  800420e507:	00 00 00 
  800420e50a:	ff d2                	callq  *%rdx
			return NULL;
  800420e50c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e511:	e9 be 00 00 00       	jmpq   800420e5d4 <readline+0x153>
		} else if ((c == '\b' || c == '\x7f') && i > 0) {
  800420e516:	83 7d f4 08          	cmpl   $0x8,-0xc(%rbp)
  800420e51a:	74 06                	je     800420e522 <readline+0xa1>
  800420e51c:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%rbp)
  800420e520:	75 26                	jne    800420e548 <readline+0xc7>
  800420e522:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420e526:	7e 20                	jle    800420e548 <readline+0xc7>
			if (echoing)
  800420e528:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420e52c:	74 11                	je     800420e53f <readline+0xbe>
				cputchar('\b');
  800420e52e:	bf 08 00 00 00       	mov    $0x8,%edi
  800420e533:	48 b8 ff 11 20 04 80 	movabs $0x80042011ff,%rax
  800420e53a:	00 00 00 
  800420e53d:	ff d0                	callq  *%rax
			i--;
  800420e53f:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
  800420e543:	e9 87 00 00 00       	jmpq   800420e5cf <readline+0x14e>
		} else if (c >= ' ' && i < BUFLEN-1) {
  800420e548:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  800420e54c:	7e 3f                	jle    800420e58d <readline+0x10c>
  800420e54e:	81 7d fc fe 03 00 00 	cmpl   $0x3fe,-0x4(%rbp)
  800420e555:	7f 36                	jg     800420e58d <readline+0x10c>
			if (echoing)
  800420e557:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420e55b:	74 11                	je     800420e56e <readline+0xed>
				cputchar(c);
  800420e55d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420e560:	89 c7                	mov    %eax,%edi
  800420e562:	48 b8 ff 11 20 04 80 	movabs $0x80042011ff,%rax
  800420e569:	00 00 00 
  800420e56c:	ff d0                	callq  *%rax
			buf[i++] = c;
  800420e56e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420e571:	8d 50 01             	lea    0x1(%rax),%edx
  800420e574:	89 55 fc             	mov    %edx,-0x4(%rbp)
  800420e577:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800420e57a:	89 d1                	mov    %edx,%ecx
  800420e57c:	48 ba 20 63 49 04 80 	movabs $0x8004496320,%rdx
  800420e583:	00 00 00 
  800420e586:	48 98                	cltq   
  800420e588:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
  800420e58b:	eb 42                	jmp    800420e5cf <readline+0x14e>
		} else if (c == '\n' || c == '\r') {
  800420e58d:	83 7d f4 0a          	cmpl   $0xa,-0xc(%rbp)
  800420e591:	74 06                	je     800420e599 <readline+0x118>
  800420e593:	83 7d f4 0d          	cmpl   $0xd,-0xc(%rbp)
  800420e597:	75 36                	jne    800420e5cf <readline+0x14e>
			if (echoing)
  800420e599:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420e59d:	74 11                	je     800420e5b0 <readline+0x12f>
				cputchar('\n');
  800420e59f:	bf 0a 00 00 00       	mov    $0xa,%edi
  800420e5a4:	48 b8 ff 11 20 04 80 	movabs $0x80042011ff,%rax
  800420e5ab:	00 00 00 
  800420e5ae:	ff d0                	callq  *%rax
			buf[i] = 0;
  800420e5b0:	48 ba 20 63 49 04 80 	movabs $0x8004496320,%rdx
  800420e5b7:	00 00 00 
  800420e5ba:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420e5bd:	48 98                	cltq   
  800420e5bf:	c6 04 02 00          	movb   $0x0,(%rdx,%rax,1)
			return buf;
  800420e5c3:	48 b8 20 63 49 04 80 	movabs $0x8004496320,%rax
  800420e5ca:	00 00 00 
  800420e5cd:	eb 05                	jmp    800420e5d4 <readline+0x153>
		}
	}
  800420e5cf:	e9 fd fe ff ff       	jmpq   800420e4d1 <readline+0x50>
}
  800420e5d4:	c9                   	leaveq 
  800420e5d5:	c3                   	retq   

000000800420e5d6 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  800420e5d6:	55                   	push   %rbp
  800420e5d7:	48 89 e5             	mov    %rsp,%rbp
  800420e5da:	48 83 ec 18          	sub    $0x18,%rsp
  800420e5de:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int n;

	for (n = 0; *s != '\0'; s++)
  800420e5e2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420e5e9:	eb 09                	jmp    800420e5f4 <strlen+0x1e>
		n++;
  800420e5eb:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
  800420e5ef:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420e5f4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e5f8:	0f b6 00             	movzbl (%rax),%eax
  800420e5fb:	84 c0                	test   %al,%al
  800420e5fd:	75 ec                	jne    800420e5eb <strlen+0x15>
		n++;
	return n;
  800420e5ff:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420e602:	c9                   	leaveq 
  800420e603:	c3                   	retq   

000000800420e604 <strnlen>:

int
strnlen(const char *s, size_t size)
{
  800420e604:	55                   	push   %rbp
  800420e605:	48 89 e5             	mov    %rsp,%rbp
  800420e608:	48 83 ec 20          	sub    $0x20,%rsp
  800420e60c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420e610:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  800420e614:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420e61b:	eb 0e                	jmp    800420e62b <strnlen+0x27>
		n++;
  800420e61d:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strnlen(const char *s, size_t size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  800420e621:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420e626:	48 83 6d e0 01       	subq   $0x1,-0x20(%rbp)
  800420e62b:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420e630:	74 0b                	je     800420e63d <strnlen+0x39>
  800420e632:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e636:	0f b6 00             	movzbl (%rax),%eax
  800420e639:	84 c0                	test   %al,%al
  800420e63b:	75 e0                	jne    800420e61d <strnlen+0x19>
		n++;
	return n;
  800420e63d:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420e640:	c9                   	leaveq 
  800420e641:	c3                   	retq   

000000800420e642 <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  800420e642:	55                   	push   %rbp
  800420e643:	48 89 e5             	mov    %rsp,%rbp
  800420e646:	48 83 ec 20          	sub    $0x20,%rsp
  800420e64a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420e64e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	char *ret;

	ret = dst;
  800420e652:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e656:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	while ((*dst++ = *src++) != '\0')
  800420e65a:	90                   	nop
  800420e65b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e65f:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420e663:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420e667:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420e66b:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  800420e66f:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  800420e673:	0f b6 12             	movzbl (%rdx),%edx
  800420e676:	88 10                	mov    %dl,(%rax)
  800420e678:	0f b6 00             	movzbl (%rax),%eax
  800420e67b:	84 c0                	test   %al,%al
  800420e67d:	75 dc                	jne    800420e65b <strcpy+0x19>
		/* do nothing */;
	return ret;
  800420e67f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420e683:	c9                   	leaveq 
  800420e684:	c3                   	retq   

000000800420e685 <strcat>:

char *
strcat(char *dst, const char *src)
{
  800420e685:	55                   	push   %rbp
  800420e686:	48 89 e5             	mov    %rsp,%rbp
  800420e689:	48 83 ec 20          	sub    $0x20,%rsp
  800420e68d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420e691:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int len = strlen(dst);
  800420e695:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e699:	48 89 c7             	mov    %rax,%rdi
  800420e69c:	48 b8 d6 e5 20 04 80 	movabs $0x800420e5d6,%rax
  800420e6a3:	00 00 00 
  800420e6a6:	ff d0                	callq  *%rax
  800420e6a8:	89 45 fc             	mov    %eax,-0x4(%rbp)
	strcpy(dst + len, src);
  800420e6ab:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420e6ae:	48 63 d0             	movslq %eax,%rdx
  800420e6b1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e6b5:	48 01 c2             	add    %rax,%rdx
  800420e6b8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e6bc:	48 89 c6             	mov    %rax,%rsi
  800420e6bf:	48 89 d7             	mov    %rdx,%rdi
  800420e6c2:	48 b8 42 e6 20 04 80 	movabs $0x800420e642,%rax
  800420e6c9:	00 00 00 
  800420e6cc:	ff d0                	callq  *%rax
	return dst;
  800420e6ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420e6d2:	c9                   	leaveq 
  800420e6d3:	c3                   	retq   

000000800420e6d4 <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  800420e6d4:	55                   	push   %rbp
  800420e6d5:	48 89 e5             	mov    %rsp,%rbp
  800420e6d8:	48 83 ec 28          	sub    $0x28,%rsp
  800420e6dc:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420e6e0:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420e6e4:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	size_t i;
	char *ret;

	ret = dst;
  800420e6e8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e6ec:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < size; i++) {
  800420e6f0:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420e6f7:	00 
  800420e6f8:	eb 2a                	jmp    800420e724 <strncpy+0x50>
		*dst++ = *src;
  800420e6fa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e6fe:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420e702:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420e706:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420e70a:	0f b6 12             	movzbl (%rdx),%edx
  800420e70d:	88 10                	mov    %dl,(%rax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
  800420e70f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e713:	0f b6 00             	movzbl (%rax),%eax
  800420e716:	84 c0                	test   %al,%al
  800420e718:	74 05                	je     800420e71f <strncpy+0x4b>
			src++;
  800420e71a:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
strncpy(char *dst, const char *src, size_t size) {
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  800420e71f:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420e724:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e728:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  800420e72c:	72 cc                	jb     800420e6fa <strncpy+0x26>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
  800420e72e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420e732:	c9                   	leaveq 
  800420e733:	c3                   	retq   

000000800420e734 <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  800420e734:	55                   	push   %rbp
  800420e735:	48 89 e5             	mov    %rsp,%rbp
  800420e738:	48 83 ec 28          	sub    $0x28,%rsp
  800420e73c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420e740:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420e744:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *dst_in;

	dst_in = dst;
  800420e748:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e74c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (size > 0) {
  800420e750:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420e755:	74 3d                	je     800420e794 <strlcpy+0x60>
		while (--size > 0 && *src != '\0')
  800420e757:	eb 1d                	jmp    800420e776 <strlcpy+0x42>
			*dst++ = *src++;
  800420e759:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e75d:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420e761:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420e765:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420e769:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  800420e76d:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  800420e771:	0f b6 12             	movzbl (%rdx),%edx
  800420e774:	88 10                	mov    %dl,(%rax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  800420e776:	48 83 6d d8 01       	subq   $0x1,-0x28(%rbp)
  800420e77b:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420e780:	74 0b                	je     800420e78d <strlcpy+0x59>
  800420e782:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e786:	0f b6 00             	movzbl (%rax),%eax
  800420e789:	84 c0                	test   %al,%al
  800420e78b:	75 cc                	jne    800420e759 <strlcpy+0x25>
			*dst++ = *src++;
		*dst = '\0';
  800420e78d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e791:	c6 00 00             	movb   $0x0,(%rax)
	}
	return dst - dst_in;
  800420e794:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e798:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e79c:	48 29 c2             	sub    %rax,%rdx
  800420e79f:	48 89 d0             	mov    %rdx,%rax
}
  800420e7a2:	c9                   	leaveq 
  800420e7a3:	c3                   	retq   

000000800420e7a4 <strcmp>:

int
strcmp(const char *p, const char *q)
{
  800420e7a4:	55                   	push   %rbp
  800420e7a5:	48 89 e5             	mov    %rsp,%rbp
  800420e7a8:	48 83 ec 10          	sub    $0x10,%rsp
  800420e7ac:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420e7b0:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	while (*p && *p == *q)
  800420e7b4:	eb 0a                	jmp    800420e7c0 <strcmp+0x1c>
		p++, q++;
  800420e7b6:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420e7bb:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
  800420e7c0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e7c4:	0f b6 00             	movzbl (%rax),%eax
  800420e7c7:	84 c0                	test   %al,%al
  800420e7c9:	74 12                	je     800420e7dd <strcmp+0x39>
  800420e7cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e7cf:	0f b6 10             	movzbl (%rax),%edx
  800420e7d2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e7d6:	0f b6 00             	movzbl (%rax),%eax
  800420e7d9:	38 c2                	cmp    %al,%dl
  800420e7db:	74 d9                	je     800420e7b6 <strcmp+0x12>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
  800420e7dd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e7e1:	0f b6 00             	movzbl (%rax),%eax
  800420e7e4:	0f b6 d0             	movzbl %al,%edx
  800420e7e7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e7eb:	0f b6 00             	movzbl (%rax),%eax
  800420e7ee:	0f b6 c0             	movzbl %al,%eax
  800420e7f1:	29 c2                	sub    %eax,%edx
  800420e7f3:	89 d0                	mov    %edx,%eax
}
  800420e7f5:	c9                   	leaveq 
  800420e7f6:	c3                   	retq   

000000800420e7f7 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  800420e7f7:	55                   	push   %rbp
  800420e7f8:	48 89 e5             	mov    %rsp,%rbp
  800420e7fb:	48 83 ec 18          	sub    $0x18,%rsp
  800420e7ff:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420e803:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420e807:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	while (n > 0 && *p && *p == *q)
  800420e80b:	eb 0f                	jmp    800420e81c <strncmp+0x25>
		n--, p++, q++;
  800420e80d:	48 83 6d e8 01       	subq   $0x1,-0x18(%rbp)
  800420e812:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420e817:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
  800420e81c:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420e821:	74 1d                	je     800420e840 <strncmp+0x49>
  800420e823:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e827:	0f b6 00             	movzbl (%rax),%eax
  800420e82a:	84 c0                	test   %al,%al
  800420e82c:	74 12                	je     800420e840 <strncmp+0x49>
  800420e82e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e832:	0f b6 10             	movzbl (%rax),%edx
  800420e835:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e839:	0f b6 00             	movzbl (%rax),%eax
  800420e83c:	38 c2                	cmp    %al,%dl
  800420e83e:	74 cd                	je     800420e80d <strncmp+0x16>
		n--, p++, q++;
	if (n == 0)
  800420e840:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420e845:	75 07                	jne    800420e84e <strncmp+0x57>
		return 0;
  800420e847:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e84c:	eb 18                	jmp    800420e866 <strncmp+0x6f>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  800420e84e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e852:	0f b6 00             	movzbl (%rax),%eax
  800420e855:	0f b6 d0             	movzbl %al,%edx
  800420e858:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e85c:	0f b6 00             	movzbl (%rax),%eax
  800420e85f:	0f b6 c0             	movzbl %al,%eax
  800420e862:	29 c2                	sub    %eax,%edx
  800420e864:	89 d0                	mov    %edx,%eax
}
  800420e866:	c9                   	leaveq 
  800420e867:	c3                   	retq   

000000800420e868 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  800420e868:	55                   	push   %rbp
  800420e869:	48 89 e5             	mov    %rsp,%rbp
  800420e86c:	48 83 ec 0c          	sub    $0xc,%rsp
  800420e870:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420e874:	89 f0                	mov    %esi,%eax
  800420e876:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  800420e879:	eb 17                	jmp    800420e892 <strchr+0x2a>
		if (*s == c)
  800420e87b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e87f:	0f b6 00             	movzbl (%rax),%eax
  800420e882:	3a 45 f4             	cmp    -0xc(%rbp),%al
  800420e885:	75 06                	jne    800420e88d <strchr+0x25>
			return (char *) s;
  800420e887:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e88b:	eb 15                	jmp    800420e8a2 <strchr+0x3a>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
  800420e88d:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420e892:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e896:	0f b6 00             	movzbl (%rax),%eax
  800420e899:	84 c0                	test   %al,%al
  800420e89b:	75 de                	jne    800420e87b <strchr+0x13>
		if (*s == c)
			return (char *) s;
	return 0;
  800420e89d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420e8a2:	c9                   	leaveq 
  800420e8a3:	c3                   	retq   

000000800420e8a4 <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  800420e8a4:	55                   	push   %rbp
  800420e8a5:	48 89 e5             	mov    %rsp,%rbp
  800420e8a8:	48 83 ec 0c          	sub    $0xc,%rsp
  800420e8ac:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420e8b0:	89 f0                	mov    %esi,%eax
  800420e8b2:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  800420e8b5:	eb 13                	jmp    800420e8ca <strfind+0x26>
		if (*s == c)
  800420e8b7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e8bb:	0f b6 00             	movzbl (%rax),%eax
  800420e8be:	3a 45 f4             	cmp    -0xc(%rbp),%al
  800420e8c1:	75 02                	jne    800420e8c5 <strfind+0x21>
			break;
  800420e8c3:	eb 10                	jmp    800420e8d5 <strfind+0x31>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
  800420e8c5:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420e8ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e8ce:	0f b6 00             	movzbl (%rax),%eax
  800420e8d1:	84 c0                	test   %al,%al
  800420e8d3:	75 e2                	jne    800420e8b7 <strfind+0x13>
		if (*s == c)
			break;
	return (char *) s;
  800420e8d5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420e8d9:	c9                   	leaveq 
  800420e8da:	c3                   	retq   

000000800420e8db <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  800420e8db:	55                   	push   %rbp
  800420e8dc:	48 89 e5             	mov    %rsp,%rbp
  800420e8df:	48 83 ec 18          	sub    $0x18,%rsp
  800420e8e3:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420e8e7:	89 75 f4             	mov    %esi,-0xc(%rbp)
  800420e8ea:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	char *p;

	if (n == 0)
  800420e8ee:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420e8f3:	75 06                	jne    800420e8fb <memset+0x20>
		return v;
  800420e8f5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e8f9:	eb 69                	jmp    800420e964 <memset+0x89>
	if ((int64_t)v%4 == 0 && n%4 == 0) {
  800420e8fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e8ff:	83 e0 03             	and    $0x3,%eax
  800420e902:	48 85 c0             	test   %rax,%rax
  800420e905:	75 48                	jne    800420e94f <memset+0x74>
  800420e907:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e90b:	83 e0 03             	and    $0x3,%eax
  800420e90e:	48 85 c0             	test   %rax,%rax
  800420e911:	75 3c                	jne    800420e94f <memset+0x74>
		c &= 0xFF;
  800420e913:	81 65 f4 ff 00 00 00 	andl   $0xff,-0xc(%rbp)
		c = (c<<24)|(c<<16)|(c<<8)|c;
  800420e91a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420e91d:	c1 e0 18             	shl    $0x18,%eax
  800420e920:	89 c2                	mov    %eax,%edx
  800420e922:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420e925:	c1 e0 10             	shl    $0x10,%eax
  800420e928:	09 c2                	or     %eax,%edx
  800420e92a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420e92d:	c1 e0 08             	shl    $0x8,%eax
  800420e930:	09 d0                	or     %edx,%eax
  800420e932:	09 45 f4             	or     %eax,-0xc(%rbp)
		asm volatile("cld; rep stosl\n"
			:: "D" (v), "a" (c), "c" (n/4)
  800420e935:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e939:	48 c1 e8 02          	shr    $0x2,%rax
  800420e93d:	48 89 c1             	mov    %rax,%rcx
	if (n == 0)
		return v;
	if ((int64_t)v%4 == 0 && n%4 == 0) {
		c &= 0xFF;
		c = (c<<24)|(c<<16)|(c<<8)|c;
		asm volatile("cld; rep stosl\n"
  800420e940:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420e944:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420e947:	48 89 d7             	mov    %rdx,%rdi
  800420e94a:	fc                   	cld    
  800420e94b:	f3 ab                	rep stos %eax,%es:(%rdi)
  800420e94d:	eb 11                	jmp    800420e960 <memset+0x85>
			:: "D" (v), "a" (c), "c" (n/4)
			: "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  800420e94f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420e953:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420e956:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420e95a:	48 89 d7             	mov    %rdx,%rdi
  800420e95d:	fc                   	cld    
  800420e95e:	f3 aa                	rep stos %al,%es:(%rdi)
			:: "D" (v), "a" (c), "c" (n)
			: "cc", "memory");
	return v;
  800420e960:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420e964:	c9                   	leaveq 
  800420e965:	c3                   	retq   

000000800420e966 <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  800420e966:	55                   	push   %rbp
  800420e967:	48 89 e5             	mov    %rsp,%rbp
  800420e96a:	48 83 ec 28          	sub    $0x28,%rsp
  800420e96e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420e972:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420e976:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const char *s;
	char *d;

	s = src;
  800420e97a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e97e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	d = dst;
  800420e982:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e986:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (s < d && s + n > d) {
  800420e98a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e98e:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  800420e992:	0f 83 88 00 00 00    	jae    800420ea20 <memmove+0xba>
  800420e998:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e99c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420e9a0:	48 01 d0             	add    %rdx,%rax
  800420e9a3:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  800420e9a7:	76 77                	jbe    800420ea20 <memmove+0xba>
		s += n;
  800420e9a9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e9ad:	48 01 45 f8          	add    %rax,-0x8(%rbp)
		d += n;
  800420e9b1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e9b5:	48 01 45 f0          	add    %rax,-0x10(%rbp)
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  800420e9b9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e9bd:	83 e0 03             	and    $0x3,%eax
  800420e9c0:	48 85 c0             	test   %rax,%rax
  800420e9c3:	75 3b                	jne    800420ea00 <memmove+0x9a>
  800420e9c5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e9c9:	83 e0 03             	and    $0x3,%eax
  800420e9cc:	48 85 c0             	test   %rax,%rax
  800420e9cf:	75 2f                	jne    800420ea00 <memmove+0x9a>
  800420e9d1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e9d5:	83 e0 03             	and    $0x3,%eax
  800420e9d8:	48 85 c0             	test   %rax,%rax
  800420e9db:	75 23                	jne    800420ea00 <memmove+0x9a>
			asm volatile("std; rep movsl\n"
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  800420e9dd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e9e1:	48 83 e8 04          	sub    $0x4,%rax
  800420e9e5:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420e9e9:	48 83 ea 04          	sub    $0x4,%rdx
  800420e9ed:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420e9f1:	48 c1 e9 02          	shr    $0x2,%rcx
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
  800420e9f5:	48 89 c7             	mov    %rax,%rdi
  800420e9f8:	48 89 d6             	mov    %rdx,%rsi
  800420e9fb:	fd                   	std    
  800420e9fc:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  800420e9fe:	eb 1d                	jmp    800420ea1d <memmove+0xb7>
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  800420ea00:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ea04:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  800420ea08:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ea0c:	48 8d 70 ff          	lea    -0x1(%rax),%rsi
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
  800420ea10:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ea14:	48 89 d7             	mov    %rdx,%rdi
  800420ea17:	48 89 c1             	mov    %rax,%rcx
  800420ea1a:	fd                   	std    
  800420ea1b:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  800420ea1d:	fc                   	cld    
  800420ea1e:	eb 57                	jmp    800420ea77 <memmove+0x111>
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  800420ea20:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ea24:	83 e0 03             	and    $0x3,%eax
  800420ea27:	48 85 c0             	test   %rax,%rax
  800420ea2a:	75 36                	jne    800420ea62 <memmove+0xfc>
  800420ea2c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ea30:	83 e0 03             	and    $0x3,%eax
  800420ea33:	48 85 c0             	test   %rax,%rax
  800420ea36:	75 2a                	jne    800420ea62 <memmove+0xfc>
  800420ea38:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ea3c:	83 e0 03             	and    $0x3,%eax
  800420ea3f:	48 85 c0             	test   %rax,%rax
  800420ea42:	75 1e                	jne    800420ea62 <memmove+0xfc>
			asm volatile("cld; rep movsl\n"
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  800420ea44:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ea48:	48 c1 e8 02          	shr    $0x2,%rax
  800420ea4c:	48 89 c1             	mov    %rax,%rcx
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("cld; rep movsl\n"
  800420ea4f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ea53:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420ea57:	48 89 c7             	mov    %rax,%rdi
  800420ea5a:	48 89 d6             	mov    %rdx,%rsi
  800420ea5d:	fc                   	cld    
  800420ea5e:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  800420ea60:	eb 15                	jmp    800420ea77 <memmove+0x111>
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  800420ea62:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ea66:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420ea6a:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420ea6e:	48 89 c7             	mov    %rax,%rdi
  800420ea71:	48 89 d6             	mov    %rdx,%rsi
  800420ea74:	fc                   	cld    
  800420ea75:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
  800420ea77:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420ea7b:	c9                   	leaveq 
  800420ea7c:	c3                   	retq   

000000800420ea7d <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  800420ea7d:	55                   	push   %rbp
  800420ea7e:	48 89 e5             	mov    %rsp,%rbp
  800420ea81:	48 83 ec 18          	sub    $0x18,%rsp
  800420ea85:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420ea89:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420ea8d:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	return memmove(dst, src, n);
  800420ea91:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ea95:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  800420ea99:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ea9d:	48 89 ce             	mov    %rcx,%rsi
  800420eaa0:	48 89 c7             	mov    %rax,%rdi
  800420eaa3:	48 b8 66 e9 20 04 80 	movabs $0x800420e966,%rax
  800420eaaa:	00 00 00 
  800420eaad:	ff d0                	callq  *%rax
}
  800420eaaf:	c9                   	leaveq 
  800420eab0:	c3                   	retq   

000000800420eab1 <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  800420eab1:	55                   	push   %rbp
  800420eab2:	48 89 e5             	mov    %rsp,%rbp
  800420eab5:	48 83 ec 28          	sub    $0x28,%rsp
  800420eab9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420eabd:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420eac1:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const uint8_t *s1 = (const uint8_t *) v1;
  800420eac5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eac9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	const uint8_t *s2 = (const uint8_t *) v2;
  800420eacd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ead1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (n-- > 0) {
  800420ead5:	eb 36                	jmp    800420eb0d <memcmp+0x5c>
		if (*s1 != *s2)
  800420ead7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420eadb:	0f b6 10             	movzbl (%rax),%edx
  800420eade:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420eae2:	0f b6 00             	movzbl (%rax),%eax
  800420eae5:	38 c2                	cmp    %al,%dl
  800420eae7:	74 1a                	je     800420eb03 <memcmp+0x52>
			return (int) *s1 - (int) *s2;
  800420eae9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420eaed:	0f b6 00             	movzbl (%rax),%eax
  800420eaf0:	0f b6 d0             	movzbl %al,%edx
  800420eaf3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420eaf7:	0f b6 00             	movzbl (%rax),%eax
  800420eafa:	0f b6 c0             	movzbl %al,%eax
  800420eafd:	29 c2                	sub    %eax,%edx
  800420eaff:	89 d0                	mov    %edx,%eax
  800420eb01:	eb 20                	jmp    800420eb23 <memcmp+0x72>
		s1++, s2++;
  800420eb03:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420eb08:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
memcmp(const void *v1, const void *v2, size_t n)
{
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  800420eb0d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420eb11:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  800420eb15:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420eb19:	48 85 c0             	test   %rax,%rax
  800420eb1c:	75 b9                	jne    800420ead7 <memcmp+0x26>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
  800420eb1e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420eb23:	c9                   	leaveq 
  800420eb24:	c3                   	retq   

000000800420eb25 <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  800420eb25:	55                   	push   %rbp
  800420eb26:	48 89 e5             	mov    %rsp,%rbp
  800420eb29:	48 83 ec 28          	sub    $0x28,%rsp
  800420eb2d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420eb31:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  800420eb34:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const void *ends = (const char *) s + n;
  800420eb38:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420eb3c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420eb40:	48 01 d0             	add    %rdx,%rax
  800420eb43:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for (; s < ends; s++)
  800420eb47:	eb 15                	jmp    800420eb5e <memfind+0x39>
		if (*(const unsigned char *) s == (unsigned char) c)
  800420eb49:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eb4d:	0f b6 10             	movzbl (%rax),%edx
  800420eb50:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420eb53:	38 c2                	cmp    %al,%dl
  800420eb55:	75 02                	jne    800420eb59 <memfind+0x34>
			break;
  800420eb57:	eb 0f                	jmp    800420eb68 <memfind+0x43>

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  800420eb59:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420eb5e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eb62:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420eb66:	72 e1                	jb     800420eb49 <memfind+0x24>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
	return (void *) s;
  800420eb68:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420eb6c:	c9                   	leaveq 
  800420eb6d:	c3                   	retq   

000000800420eb6e <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  800420eb6e:	55                   	push   %rbp
  800420eb6f:	48 89 e5             	mov    %rsp,%rbp
  800420eb72:	48 83 ec 34          	sub    $0x34,%rsp
  800420eb76:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420eb7a:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420eb7e:	89 55 cc             	mov    %edx,-0x34(%rbp)
	int neg = 0;
  800420eb81:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	long val = 0;
  800420eb88:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420eb8f:	00 

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  800420eb90:	eb 05                	jmp    800420eb97 <strtol+0x29>
		s++;
  800420eb92:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  800420eb97:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420eb9b:	0f b6 00             	movzbl (%rax),%eax
  800420eb9e:	3c 20                	cmp    $0x20,%al
  800420eba0:	74 f0                	je     800420eb92 <strtol+0x24>
  800420eba2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420eba6:	0f b6 00             	movzbl (%rax),%eax
  800420eba9:	3c 09                	cmp    $0x9,%al
  800420ebab:	74 e5                	je     800420eb92 <strtol+0x24>
		s++;

	// plus/minus sign
	if (*s == '+')
  800420ebad:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ebb1:	0f b6 00             	movzbl (%rax),%eax
  800420ebb4:	3c 2b                	cmp    $0x2b,%al
  800420ebb6:	75 07                	jne    800420ebbf <strtol+0x51>
		s++;
  800420ebb8:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420ebbd:	eb 17                	jmp    800420ebd6 <strtol+0x68>
	else if (*s == '-')
  800420ebbf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ebc3:	0f b6 00             	movzbl (%rax),%eax
  800420ebc6:	3c 2d                	cmp    $0x2d,%al
  800420ebc8:	75 0c                	jne    800420ebd6 <strtol+0x68>
		s++, neg = 1;
  800420ebca:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420ebcf:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  800420ebd6:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420ebda:	74 06                	je     800420ebe2 <strtol+0x74>
  800420ebdc:	83 7d cc 10          	cmpl   $0x10,-0x34(%rbp)
  800420ebe0:	75 28                	jne    800420ec0a <strtol+0x9c>
  800420ebe2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ebe6:	0f b6 00             	movzbl (%rax),%eax
  800420ebe9:	3c 30                	cmp    $0x30,%al
  800420ebeb:	75 1d                	jne    800420ec0a <strtol+0x9c>
  800420ebed:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ebf1:	48 83 c0 01          	add    $0x1,%rax
  800420ebf5:	0f b6 00             	movzbl (%rax),%eax
  800420ebf8:	3c 78                	cmp    $0x78,%al
  800420ebfa:	75 0e                	jne    800420ec0a <strtol+0x9c>
		s += 2, base = 16;
  800420ebfc:	48 83 45 d8 02       	addq   $0x2,-0x28(%rbp)
  800420ec01:	c7 45 cc 10 00 00 00 	movl   $0x10,-0x34(%rbp)
  800420ec08:	eb 2c                	jmp    800420ec36 <strtol+0xc8>
	else if (base == 0 && s[0] == '0')
  800420ec0a:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420ec0e:	75 19                	jne    800420ec29 <strtol+0xbb>
  800420ec10:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ec14:	0f b6 00             	movzbl (%rax),%eax
  800420ec17:	3c 30                	cmp    $0x30,%al
  800420ec19:	75 0e                	jne    800420ec29 <strtol+0xbb>
		s++, base = 8;
  800420ec1b:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420ec20:	c7 45 cc 08 00 00 00 	movl   $0x8,-0x34(%rbp)
  800420ec27:	eb 0d                	jmp    800420ec36 <strtol+0xc8>
	else if (base == 0)
  800420ec29:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420ec2d:	75 07                	jne    800420ec36 <strtol+0xc8>
		base = 10;
  800420ec2f:	c7 45 cc 0a 00 00 00 	movl   $0xa,-0x34(%rbp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  800420ec36:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ec3a:	0f b6 00             	movzbl (%rax),%eax
  800420ec3d:	3c 2f                	cmp    $0x2f,%al
  800420ec3f:	7e 1d                	jle    800420ec5e <strtol+0xf0>
  800420ec41:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ec45:	0f b6 00             	movzbl (%rax),%eax
  800420ec48:	3c 39                	cmp    $0x39,%al
  800420ec4a:	7f 12                	jg     800420ec5e <strtol+0xf0>
			dig = *s - '0';
  800420ec4c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ec50:	0f b6 00             	movzbl (%rax),%eax
  800420ec53:	0f be c0             	movsbl %al,%eax
  800420ec56:	83 e8 30             	sub    $0x30,%eax
  800420ec59:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420ec5c:	eb 4e                	jmp    800420ecac <strtol+0x13e>
		else if (*s >= 'a' && *s <= 'z')
  800420ec5e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ec62:	0f b6 00             	movzbl (%rax),%eax
  800420ec65:	3c 60                	cmp    $0x60,%al
  800420ec67:	7e 1d                	jle    800420ec86 <strtol+0x118>
  800420ec69:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ec6d:	0f b6 00             	movzbl (%rax),%eax
  800420ec70:	3c 7a                	cmp    $0x7a,%al
  800420ec72:	7f 12                	jg     800420ec86 <strtol+0x118>
			dig = *s - 'a' + 10;
  800420ec74:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ec78:	0f b6 00             	movzbl (%rax),%eax
  800420ec7b:	0f be c0             	movsbl %al,%eax
  800420ec7e:	83 e8 57             	sub    $0x57,%eax
  800420ec81:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420ec84:	eb 26                	jmp    800420ecac <strtol+0x13e>
		else if (*s >= 'A' && *s <= 'Z')
  800420ec86:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ec8a:	0f b6 00             	movzbl (%rax),%eax
  800420ec8d:	3c 40                	cmp    $0x40,%al
  800420ec8f:	7e 48                	jle    800420ecd9 <strtol+0x16b>
  800420ec91:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ec95:	0f b6 00             	movzbl (%rax),%eax
  800420ec98:	3c 5a                	cmp    $0x5a,%al
  800420ec9a:	7f 3d                	jg     800420ecd9 <strtol+0x16b>
			dig = *s - 'A' + 10;
  800420ec9c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420eca0:	0f b6 00             	movzbl (%rax),%eax
  800420eca3:	0f be c0             	movsbl %al,%eax
  800420eca6:	83 e8 37             	sub    $0x37,%eax
  800420eca9:	89 45 ec             	mov    %eax,-0x14(%rbp)
		else
			break;
		if (dig >= base)
  800420ecac:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420ecaf:	3b 45 cc             	cmp    -0x34(%rbp),%eax
  800420ecb2:	7c 02                	jl     800420ecb6 <strtol+0x148>
			break;
  800420ecb4:	eb 23                	jmp    800420ecd9 <strtol+0x16b>
		s++, val = (val * base) + dig;
  800420ecb6:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420ecbb:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420ecbe:	48 98                	cltq   
  800420ecc0:	48 0f af 45 f0       	imul   -0x10(%rbp),%rax
  800420ecc5:	48 89 c2             	mov    %rax,%rdx
  800420ecc8:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420eccb:	48 98                	cltq   
  800420eccd:	48 01 d0             	add    %rdx,%rax
  800420ecd0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		// we don't properly detect overflow!
	}
  800420ecd4:	e9 5d ff ff ff       	jmpq   800420ec36 <strtol+0xc8>

	if (endptr)
  800420ecd9:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420ecde:	74 0b                	je     800420eceb <strtol+0x17d>
		*endptr = (char *) s;
  800420ece0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420ece4:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420ece8:	48 89 10             	mov    %rdx,(%rax)
	return (neg ? -val : val);
  800420eceb:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420ecef:	74 09                	je     800420ecfa <strtol+0x18c>
  800420ecf1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ecf5:	48 f7 d8             	neg    %rax
  800420ecf8:	eb 04                	jmp    800420ecfe <strtol+0x190>
  800420ecfa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420ecfe:	c9                   	leaveq 
  800420ecff:	c3                   	retq   

000000800420ed00 <strstr>:

char * strstr(const char *in, const char *str)
{
  800420ed00:	55                   	push   %rbp
  800420ed01:	48 89 e5             	mov    %rsp,%rbp
  800420ed04:	48 83 ec 30          	sub    $0x30,%rsp
  800420ed08:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420ed0c:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
    char c;
    size_t len;

    c = *str++;
  800420ed10:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420ed14:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420ed18:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  800420ed1c:	0f b6 00             	movzbl (%rax),%eax
  800420ed1f:	88 45 ff             	mov    %al,-0x1(%rbp)
    if (!c)
  800420ed22:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  800420ed26:	75 06                	jne    800420ed2e <strstr+0x2e>
        return (char *) in;	// Trivial empty string case
  800420ed28:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ed2c:	eb 6b                	jmp    800420ed99 <strstr+0x99>

    len = strlen(str);
  800420ed2e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420ed32:	48 89 c7             	mov    %rax,%rdi
  800420ed35:	48 b8 d6 e5 20 04 80 	movabs $0x800420e5d6,%rax
  800420ed3c:	00 00 00 
  800420ed3f:	ff d0                	callq  *%rax
  800420ed41:	48 98                	cltq   
  800420ed43:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    do {
        char sc;

        do {
            sc = *in++;
  800420ed47:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ed4b:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420ed4f:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420ed53:	0f b6 00             	movzbl (%rax),%eax
  800420ed56:	88 45 ef             	mov    %al,-0x11(%rbp)
            if (!sc)
  800420ed59:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  800420ed5d:	75 07                	jne    800420ed66 <strstr+0x66>
                return (char *) 0;
  800420ed5f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ed64:	eb 33                	jmp    800420ed99 <strstr+0x99>
        } while (sc != c);
  800420ed66:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  800420ed6a:	3a 45 ff             	cmp    -0x1(%rbp),%al
  800420ed6d:	75 d8                	jne    800420ed47 <strstr+0x47>
    } while (strncmp(in, str, len) != 0);
  800420ed6f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420ed73:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  800420ed77:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ed7b:	48 89 ce             	mov    %rcx,%rsi
  800420ed7e:	48 89 c7             	mov    %rax,%rdi
  800420ed81:	48 b8 f7 e7 20 04 80 	movabs $0x800420e7f7,%rax
  800420ed88:	00 00 00 
  800420ed8b:	ff d0                	callq  *%rax
  800420ed8d:	85 c0                	test   %eax,%eax
  800420ed8f:	75 b6                	jne    800420ed47 <strstr+0x47>

    return (char *) (in - 1);
  800420ed91:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ed95:	48 83 e8 01          	sub    $0x1,%rax
}
  800420ed99:	c9                   	leaveq 
  800420ed9a:	c3                   	retq   

000000800420ed9b <_dwarf_read_lsb>:
Dwarf_Section *
_dwarf_find_section(const char *name);

uint64_t
_dwarf_read_lsb(uint8_t *data, uint64_t *offsetp, int bytes_to_read)
{
  800420ed9b:	55                   	push   %rbp
  800420ed9c:	48 89 e5             	mov    %rsp,%rbp
  800420ed9f:	48 83 ec 24          	sub    $0x24,%rsp
  800420eda3:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420eda7:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420edab:	89 55 dc             	mov    %edx,-0x24(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = data + *offsetp;
  800420edae:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420edb2:	48 8b 10             	mov    (%rax),%rdx
  800420edb5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420edb9:	48 01 d0             	add    %rdx,%rax
  800420edbc:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  800420edc0:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420edc7:	00 
	switch (bytes_to_read) {
  800420edc8:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420edcb:	83 f8 02             	cmp    $0x2,%eax
  800420edce:	0f 84 ab 00 00 00    	je     800420ee7f <_dwarf_read_lsb+0xe4>
  800420edd4:	83 f8 02             	cmp    $0x2,%eax
  800420edd7:	7f 0e                	jg     800420ede7 <_dwarf_read_lsb+0x4c>
  800420edd9:	83 f8 01             	cmp    $0x1,%eax
  800420eddc:	0f 84 b3 00 00 00    	je     800420ee95 <_dwarf_read_lsb+0xfa>
  800420ede2:	e9 d9 00 00 00       	jmpq   800420eec0 <_dwarf_read_lsb+0x125>
  800420ede7:	83 f8 04             	cmp    $0x4,%eax
  800420edea:	74 65                	je     800420ee51 <_dwarf_read_lsb+0xb6>
  800420edec:	83 f8 08             	cmp    $0x8,%eax
  800420edef:	0f 85 cb 00 00 00    	jne    800420eec0 <_dwarf_read_lsb+0x125>
	case 8:
		ret |= ((uint64_t) src[4]) << 32 | ((uint64_t) src[5]) << 40;
  800420edf5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420edf9:	48 83 c0 04          	add    $0x4,%rax
  800420edfd:	0f b6 00             	movzbl (%rax),%eax
  800420ee00:	0f b6 c0             	movzbl %al,%eax
  800420ee03:	48 c1 e0 20          	shl    $0x20,%rax
  800420ee07:	48 89 c2             	mov    %rax,%rdx
  800420ee0a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ee0e:	48 83 c0 05          	add    $0x5,%rax
  800420ee12:	0f b6 00             	movzbl (%rax),%eax
  800420ee15:	0f b6 c0             	movzbl %al,%eax
  800420ee18:	48 c1 e0 28          	shl    $0x28,%rax
  800420ee1c:	48 09 d0             	or     %rdx,%rax
  800420ee1f:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[6]) << 48 | ((uint64_t) src[7]) << 56;
  800420ee23:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ee27:	48 83 c0 06          	add    $0x6,%rax
  800420ee2b:	0f b6 00             	movzbl (%rax),%eax
  800420ee2e:	0f b6 c0             	movzbl %al,%eax
  800420ee31:	48 c1 e0 30          	shl    $0x30,%rax
  800420ee35:	48 89 c2             	mov    %rax,%rdx
  800420ee38:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ee3c:	48 83 c0 07          	add    $0x7,%rax
  800420ee40:	0f b6 00             	movzbl (%rax),%eax
  800420ee43:	0f b6 c0             	movzbl %al,%eax
  800420ee46:	48 c1 e0 38          	shl    $0x38,%rax
  800420ee4a:	48 09 d0             	or     %rdx,%rax
  800420ee4d:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 4:
		ret |= ((uint64_t) src[2]) << 16 | ((uint64_t) src[3]) << 24;
  800420ee51:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ee55:	48 83 c0 02          	add    $0x2,%rax
  800420ee59:	0f b6 00             	movzbl (%rax),%eax
  800420ee5c:	0f b6 c0             	movzbl %al,%eax
  800420ee5f:	48 c1 e0 10          	shl    $0x10,%rax
  800420ee63:	48 89 c2             	mov    %rax,%rdx
  800420ee66:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ee6a:	48 83 c0 03          	add    $0x3,%rax
  800420ee6e:	0f b6 00             	movzbl (%rax),%eax
  800420ee71:	0f b6 c0             	movzbl %al,%eax
  800420ee74:	48 c1 e0 18          	shl    $0x18,%rax
  800420ee78:	48 09 d0             	or     %rdx,%rax
  800420ee7b:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 2:
		ret |= ((uint64_t) src[1]) << 8;
  800420ee7f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ee83:	48 83 c0 01          	add    $0x1,%rax
  800420ee87:	0f b6 00             	movzbl (%rax),%eax
  800420ee8a:	0f b6 c0             	movzbl %al,%eax
  800420ee8d:	48 c1 e0 08          	shl    $0x8,%rax
  800420ee91:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 1:
		ret |= src[0];
  800420ee95:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ee99:	0f b6 00             	movzbl (%rax),%eax
  800420ee9c:	0f b6 c0             	movzbl %al,%eax
  800420ee9f:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420eea3:	90                   	nop
	default:
		return (0);
	}

	*offsetp += bytes_to_read;
  800420eea4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420eea8:	48 8b 10             	mov    (%rax),%rdx
  800420eeab:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420eeae:	48 98                	cltq   
  800420eeb0:	48 01 c2             	add    %rax,%rdx
  800420eeb3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420eeb7:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420eeba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420eebe:	eb 05                	jmp    800420eec5 <_dwarf_read_lsb+0x12a>
		ret |= ((uint64_t) src[1]) << 8;
	case 1:
		ret |= src[0];
		break;
	default:
		return (0);
  800420eec0:	b8 00 00 00 00       	mov    $0x0,%eax
	}

	*offsetp += bytes_to_read;

	return (ret);
}
  800420eec5:	c9                   	leaveq 
  800420eec6:	c3                   	retq   

000000800420eec7 <_dwarf_decode_lsb>:

uint64_t
_dwarf_decode_lsb(uint8_t **data, int bytes_to_read)
{
  800420eec7:	55                   	push   %rbp
  800420eec8:	48 89 e5             	mov    %rsp,%rbp
  800420eecb:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420eecf:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420eed3:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = *data;
  800420eed6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eeda:	48 8b 00             	mov    (%rax),%rax
  800420eedd:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  800420eee1:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420eee8:	00 
	switch (bytes_to_read) {
  800420eee9:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420eeec:	83 f8 02             	cmp    $0x2,%eax
  800420eeef:	0f 84 ab 00 00 00    	je     800420efa0 <_dwarf_decode_lsb+0xd9>
  800420eef5:	83 f8 02             	cmp    $0x2,%eax
  800420eef8:	7f 0e                	jg     800420ef08 <_dwarf_decode_lsb+0x41>
  800420eefa:	83 f8 01             	cmp    $0x1,%eax
  800420eefd:	0f 84 b3 00 00 00    	je     800420efb6 <_dwarf_decode_lsb+0xef>
  800420ef03:	e9 d9 00 00 00       	jmpq   800420efe1 <_dwarf_decode_lsb+0x11a>
  800420ef08:	83 f8 04             	cmp    $0x4,%eax
  800420ef0b:	74 65                	je     800420ef72 <_dwarf_decode_lsb+0xab>
  800420ef0d:	83 f8 08             	cmp    $0x8,%eax
  800420ef10:	0f 85 cb 00 00 00    	jne    800420efe1 <_dwarf_decode_lsb+0x11a>
	case 8:
		ret |= ((uint64_t) src[4]) << 32 | ((uint64_t) src[5]) << 40;
  800420ef16:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ef1a:	48 83 c0 04          	add    $0x4,%rax
  800420ef1e:	0f b6 00             	movzbl (%rax),%eax
  800420ef21:	0f b6 c0             	movzbl %al,%eax
  800420ef24:	48 c1 e0 20          	shl    $0x20,%rax
  800420ef28:	48 89 c2             	mov    %rax,%rdx
  800420ef2b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ef2f:	48 83 c0 05          	add    $0x5,%rax
  800420ef33:	0f b6 00             	movzbl (%rax),%eax
  800420ef36:	0f b6 c0             	movzbl %al,%eax
  800420ef39:	48 c1 e0 28          	shl    $0x28,%rax
  800420ef3d:	48 09 d0             	or     %rdx,%rax
  800420ef40:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[6]) << 48 | ((uint64_t) src[7]) << 56;
  800420ef44:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ef48:	48 83 c0 06          	add    $0x6,%rax
  800420ef4c:	0f b6 00             	movzbl (%rax),%eax
  800420ef4f:	0f b6 c0             	movzbl %al,%eax
  800420ef52:	48 c1 e0 30          	shl    $0x30,%rax
  800420ef56:	48 89 c2             	mov    %rax,%rdx
  800420ef59:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ef5d:	48 83 c0 07          	add    $0x7,%rax
  800420ef61:	0f b6 00             	movzbl (%rax),%eax
  800420ef64:	0f b6 c0             	movzbl %al,%eax
  800420ef67:	48 c1 e0 38          	shl    $0x38,%rax
  800420ef6b:	48 09 d0             	or     %rdx,%rax
  800420ef6e:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 4:
		ret |= ((uint64_t) src[2]) << 16 | ((uint64_t) src[3]) << 24;
  800420ef72:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ef76:	48 83 c0 02          	add    $0x2,%rax
  800420ef7a:	0f b6 00             	movzbl (%rax),%eax
  800420ef7d:	0f b6 c0             	movzbl %al,%eax
  800420ef80:	48 c1 e0 10          	shl    $0x10,%rax
  800420ef84:	48 89 c2             	mov    %rax,%rdx
  800420ef87:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ef8b:	48 83 c0 03          	add    $0x3,%rax
  800420ef8f:	0f b6 00             	movzbl (%rax),%eax
  800420ef92:	0f b6 c0             	movzbl %al,%eax
  800420ef95:	48 c1 e0 18          	shl    $0x18,%rax
  800420ef99:	48 09 d0             	or     %rdx,%rax
  800420ef9c:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 2:
		ret |= ((uint64_t) src[1]) << 8;
  800420efa0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420efa4:	48 83 c0 01          	add    $0x1,%rax
  800420efa8:	0f b6 00             	movzbl (%rax),%eax
  800420efab:	0f b6 c0             	movzbl %al,%eax
  800420efae:	48 c1 e0 08          	shl    $0x8,%rax
  800420efb2:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 1:
		ret |= src[0];
  800420efb6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420efba:	0f b6 00             	movzbl (%rax),%eax
  800420efbd:	0f b6 c0             	movzbl %al,%eax
  800420efc0:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420efc4:	90                   	nop
	default:
		return (0);
	}

	*data += bytes_to_read;
  800420efc5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420efc9:	48 8b 10             	mov    (%rax),%rdx
  800420efcc:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420efcf:	48 98                	cltq   
  800420efd1:	48 01 c2             	add    %rax,%rdx
  800420efd4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420efd8:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420efdb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420efdf:	eb 05                	jmp    800420efe6 <_dwarf_decode_lsb+0x11f>
		ret |= ((uint64_t) src[1]) << 8;
	case 1:
		ret |= src[0];
		break;
	default:
		return (0);
  800420efe1:	b8 00 00 00 00       	mov    $0x0,%eax
	}

	*data += bytes_to_read;

	return (ret);
}
  800420efe6:	c9                   	leaveq 
  800420efe7:	c3                   	retq   

000000800420efe8 <_dwarf_read_msb>:

uint64_t
_dwarf_read_msb(uint8_t *data, uint64_t *offsetp, int bytes_to_read)
{
  800420efe8:	55                   	push   %rbp
  800420efe9:	48 89 e5             	mov    %rsp,%rbp
  800420efec:	48 83 ec 24          	sub    $0x24,%rsp
  800420eff0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420eff4:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420eff8:	89 55 dc             	mov    %edx,-0x24(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = data + *offsetp;
  800420effb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420efff:	48 8b 10             	mov    (%rax),%rdx
  800420f002:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f006:	48 01 d0             	add    %rdx,%rax
  800420f009:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	switch (bytes_to_read) {
  800420f00d:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420f010:	83 f8 02             	cmp    $0x2,%eax
  800420f013:	74 35                	je     800420f04a <_dwarf_read_msb+0x62>
  800420f015:	83 f8 02             	cmp    $0x2,%eax
  800420f018:	7f 0a                	jg     800420f024 <_dwarf_read_msb+0x3c>
  800420f01a:	83 f8 01             	cmp    $0x1,%eax
  800420f01d:	74 18                	je     800420f037 <_dwarf_read_msb+0x4f>
  800420f01f:	e9 53 01 00 00       	jmpq   800420f177 <_dwarf_read_msb+0x18f>
  800420f024:	83 f8 04             	cmp    $0x4,%eax
  800420f027:	74 49                	je     800420f072 <_dwarf_read_msb+0x8a>
  800420f029:	83 f8 08             	cmp    $0x8,%eax
  800420f02c:	0f 84 96 00 00 00    	je     800420f0c8 <_dwarf_read_msb+0xe0>
  800420f032:	e9 40 01 00 00       	jmpq   800420f177 <_dwarf_read_msb+0x18f>
	case 1:
		ret = src[0];
  800420f037:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f03b:	0f b6 00             	movzbl (%rax),%eax
  800420f03e:	0f b6 c0             	movzbl %al,%eax
  800420f041:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  800420f045:	e9 34 01 00 00       	jmpq   800420f17e <_dwarf_read_msb+0x196>
	case 2:
		ret = src[1] | ((uint64_t) src[0]) << 8;
  800420f04a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f04e:	48 83 c0 01          	add    $0x1,%rax
  800420f052:	0f b6 00             	movzbl (%rax),%eax
  800420f055:	0f b6 d0             	movzbl %al,%edx
  800420f058:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f05c:	0f b6 00             	movzbl (%rax),%eax
  800420f05f:	0f b6 c0             	movzbl %al,%eax
  800420f062:	48 c1 e0 08          	shl    $0x8,%rax
  800420f066:	48 09 d0             	or     %rdx,%rax
  800420f069:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  800420f06d:	e9 0c 01 00 00       	jmpq   800420f17e <_dwarf_read_msb+0x196>
	case 4:
		ret = src[3] | ((uint64_t) src[2]) << 8;
  800420f072:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f076:	48 83 c0 03          	add    $0x3,%rax
  800420f07a:	0f b6 00             	movzbl (%rax),%eax
  800420f07d:	0f b6 c0             	movzbl %al,%eax
  800420f080:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f084:	48 83 c2 02          	add    $0x2,%rdx
  800420f088:	0f b6 12             	movzbl (%rdx),%edx
  800420f08b:	0f b6 d2             	movzbl %dl,%edx
  800420f08e:	48 c1 e2 08          	shl    $0x8,%rdx
  800420f092:	48 09 d0             	or     %rdx,%rax
  800420f095:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 16 | ((uint64_t) src[0]) << 24;
  800420f099:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f09d:	48 83 c0 01          	add    $0x1,%rax
  800420f0a1:	0f b6 00             	movzbl (%rax),%eax
  800420f0a4:	0f b6 c0             	movzbl %al,%eax
  800420f0a7:	48 c1 e0 10          	shl    $0x10,%rax
  800420f0ab:	48 89 c2             	mov    %rax,%rdx
  800420f0ae:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f0b2:	0f b6 00             	movzbl (%rax),%eax
  800420f0b5:	0f b6 c0             	movzbl %al,%eax
  800420f0b8:	48 c1 e0 18          	shl    $0x18,%rax
  800420f0bc:	48 09 d0             	or     %rdx,%rax
  800420f0bf:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420f0c3:	e9 b6 00 00 00       	jmpq   800420f17e <_dwarf_read_msb+0x196>
	case 8:
		ret = src[7] | ((uint64_t) src[6]) << 8;
  800420f0c8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f0cc:	48 83 c0 07          	add    $0x7,%rax
  800420f0d0:	0f b6 00             	movzbl (%rax),%eax
  800420f0d3:	0f b6 c0             	movzbl %al,%eax
  800420f0d6:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f0da:	48 83 c2 06          	add    $0x6,%rdx
  800420f0de:	0f b6 12             	movzbl (%rdx),%edx
  800420f0e1:	0f b6 d2             	movzbl %dl,%edx
  800420f0e4:	48 c1 e2 08          	shl    $0x8,%rdx
  800420f0e8:	48 09 d0             	or     %rdx,%rax
  800420f0eb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[5]) << 16 | ((uint64_t) src[4]) << 24;
  800420f0ef:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f0f3:	48 83 c0 05          	add    $0x5,%rax
  800420f0f7:	0f b6 00             	movzbl (%rax),%eax
  800420f0fa:	0f b6 c0             	movzbl %al,%eax
  800420f0fd:	48 c1 e0 10          	shl    $0x10,%rax
  800420f101:	48 89 c2             	mov    %rax,%rdx
  800420f104:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f108:	48 83 c0 04          	add    $0x4,%rax
  800420f10c:	0f b6 00             	movzbl (%rax),%eax
  800420f10f:	0f b6 c0             	movzbl %al,%eax
  800420f112:	48 c1 e0 18          	shl    $0x18,%rax
  800420f116:	48 09 d0             	or     %rdx,%rax
  800420f119:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[3]) << 32 | ((uint64_t) src[2]) << 40;
  800420f11d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f121:	48 83 c0 03          	add    $0x3,%rax
  800420f125:	0f b6 00             	movzbl (%rax),%eax
  800420f128:	0f b6 c0             	movzbl %al,%eax
  800420f12b:	48 c1 e0 20          	shl    $0x20,%rax
  800420f12f:	48 89 c2             	mov    %rax,%rdx
  800420f132:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f136:	48 83 c0 02          	add    $0x2,%rax
  800420f13a:	0f b6 00             	movzbl (%rax),%eax
  800420f13d:	0f b6 c0             	movzbl %al,%eax
  800420f140:	48 c1 e0 28          	shl    $0x28,%rax
  800420f144:	48 09 d0             	or     %rdx,%rax
  800420f147:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 48 | ((uint64_t) src[0]) << 56;
  800420f14b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f14f:	48 83 c0 01          	add    $0x1,%rax
  800420f153:	0f b6 00             	movzbl (%rax),%eax
  800420f156:	0f b6 c0             	movzbl %al,%eax
  800420f159:	48 c1 e0 30          	shl    $0x30,%rax
  800420f15d:	48 89 c2             	mov    %rax,%rdx
  800420f160:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f164:	0f b6 00             	movzbl (%rax),%eax
  800420f167:	0f b6 c0             	movzbl %al,%eax
  800420f16a:	48 c1 e0 38          	shl    $0x38,%rax
  800420f16e:	48 09 d0             	or     %rdx,%rax
  800420f171:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420f175:	eb 07                	jmp    800420f17e <_dwarf_read_msb+0x196>
	default:
		return (0);
  800420f177:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f17c:	eb 1a                	jmp    800420f198 <_dwarf_read_msb+0x1b0>
	}

	*offsetp += bytes_to_read;
  800420f17e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f182:	48 8b 10             	mov    (%rax),%rdx
  800420f185:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420f188:	48 98                	cltq   
  800420f18a:	48 01 c2             	add    %rax,%rdx
  800420f18d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f191:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420f194:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420f198:	c9                   	leaveq 
  800420f199:	c3                   	retq   

000000800420f19a <_dwarf_decode_msb>:

uint64_t
_dwarf_decode_msb(uint8_t **data, int bytes_to_read)
{
  800420f19a:	55                   	push   %rbp
  800420f19b:	48 89 e5             	mov    %rsp,%rbp
  800420f19e:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420f1a2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f1a6:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = *data;
  800420f1a9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f1ad:	48 8b 00             	mov    (%rax),%rax
  800420f1b0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  800420f1b4:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420f1bb:	00 
	switch (bytes_to_read) {
  800420f1bc:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420f1bf:	83 f8 02             	cmp    $0x2,%eax
  800420f1c2:	74 35                	je     800420f1f9 <_dwarf_decode_msb+0x5f>
  800420f1c4:	83 f8 02             	cmp    $0x2,%eax
  800420f1c7:	7f 0a                	jg     800420f1d3 <_dwarf_decode_msb+0x39>
  800420f1c9:	83 f8 01             	cmp    $0x1,%eax
  800420f1cc:	74 18                	je     800420f1e6 <_dwarf_decode_msb+0x4c>
  800420f1ce:	e9 53 01 00 00       	jmpq   800420f326 <_dwarf_decode_msb+0x18c>
  800420f1d3:	83 f8 04             	cmp    $0x4,%eax
  800420f1d6:	74 49                	je     800420f221 <_dwarf_decode_msb+0x87>
  800420f1d8:	83 f8 08             	cmp    $0x8,%eax
  800420f1db:	0f 84 96 00 00 00    	je     800420f277 <_dwarf_decode_msb+0xdd>
  800420f1e1:	e9 40 01 00 00       	jmpq   800420f326 <_dwarf_decode_msb+0x18c>
	case 1:
		ret = src[0];
  800420f1e6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f1ea:	0f b6 00             	movzbl (%rax),%eax
  800420f1ed:	0f b6 c0             	movzbl %al,%eax
  800420f1f0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  800420f1f4:	e9 34 01 00 00       	jmpq   800420f32d <_dwarf_decode_msb+0x193>
	case 2:
		ret = src[1] | ((uint64_t) src[0]) << 8;
  800420f1f9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f1fd:	48 83 c0 01          	add    $0x1,%rax
  800420f201:	0f b6 00             	movzbl (%rax),%eax
  800420f204:	0f b6 d0             	movzbl %al,%edx
  800420f207:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f20b:	0f b6 00             	movzbl (%rax),%eax
  800420f20e:	0f b6 c0             	movzbl %al,%eax
  800420f211:	48 c1 e0 08          	shl    $0x8,%rax
  800420f215:	48 09 d0             	or     %rdx,%rax
  800420f218:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  800420f21c:	e9 0c 01 00 00       	jmpq   800420f32d <_dwarf_decode_msb+0x193>
	case 4:
		ret = src[3] | ((uint64_t) src[2]) << 8;
  800420f221:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f225:	48 83 c0 03          	add    $0x3,%rax
  800420f229:	0f b6 00             	movzbl (%rax),%eax
  800420f22c:	0f b6 c0             	movzbl %al,%eax
  800420f22f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f233:	48 83 c2 02          	add    $0x2,%rdx
  800420f237:	0f b6 12             	movzbl (%rdx),%edx
  800420f23a:	0f b6 d2             	movzbl %dl,%edx
  800420f23d:	48 c1 e2 08          	shl    $0x8,%rdx
  800420f241:	48 09 d0             	or     %rdx,%rax
  800420f244:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 16 | ((uint64_t) src[0]) << 24;
  800420f248:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f24c:	48 83 c0 01          	add    $0x1,%rax
  800420f250:	0f b6 00             	movzbl (%rax),%eax
  800420f253:	0f b6 c0             	movzbl %al,%eax
  800420f256:	48 c1 e0 10          	shl    $0x10,%rax
  800420f25a:	48 89 c2             	mov    %rax,%rdx
  800420f25d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f261:	0f b6 00             	movzbl (%rax),%eax
  800420f264:	0f b6 c0             	movzbl %al,%eax
  800420f267:	48 c1 e0 18          	shl    $0x18,%rax
  800420f26b:	48 09 d0             	or     %rdx,%rax
  800420f26e:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420f272:	e9 b6 00 00 00       	jmpq   800420f32d <_dwarf_decode_msb+0x193>
	case 8:
		ret = src[7] | ((uint64_t) src[6]) << 8;
  800420f277:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f27b:	48 83 c0 07          	add    $0x7,%rax
  800420f27f:	0f b6 00             	movzbl (%rax),%eax
  800420f282:	0f b6 c0             	movzbl %al,%eax
  800420f285:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f289:	48 83 c2 06          	add    $0x6,%rdx
  800420f28d:	0f b6 12             	movzbl (%rdx),%edx
  800420f290:	0f b6 d2             	movzbl %dl,%edx
  800420f293:	48 c1 e2 08          	shl    $0x8,%rdx
  800420f297:	48 09 d0             	or     %rdx,%rax
  800420f29a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[5]) << 16 | ((uint64_t) src[4]) << 24;
  800420f29e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f2a2:	48 83 c0 05          	add    $0x5,%rax
  800420f2a6:	0f b6 00             	movzbl (%rax),%eax
  800420f2a9:	0f b6 c0             	movzbl %al,%eax
  800420f2ac:	48 c1 e0 10          	shl    $0x10,%rax
  800420f2b0:	48 89 c2             	mov    %rax,%rdx
  800420f2b3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f2b7:	48 83 c0 04          	add    $0x4,%rax
  800420f2bb:	0f b6 00             	movzbl (%rax),%eax
  800420f2be:	0f b6 c0             	movzbl %al,%eax
  800420f2c1:	48 c1 e0 18          	shl    $0x18,%rax
  800420f2c5:	48 09 d0             	or     %rdx,%rax
  800420f2c8:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[3]) << 32 | ((uint64_t) src[2]) << 40;
  800420f2cc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f2d0:	48 83 c0 03          	add    $0x3,%rax
  800420f2d4:	0f b6 00             	movzbl (%rax),%eax
  800420f2d7:	0f b6 c0             	movzbl %al,%eax
  800420f2da:	48 c1 e0 20          	shl    $0x20,%rax
  800420f2de:	48 89 c2             	mov    %rax,%rdx
  800420f2e1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f2e5:	48 83 c0 02          	add    $0x2,%rax
  800420f2e9:	0f b6 00             	movzbl (%rax),%eax
  800420f2ec:	0f b6 c0             	movzbl %al,%eax
  800420f2ef:	48 c1 e0 28          	shl    $0x28,%rax
  800420f2f3:	48 09 d0             	or     %rdx,%rax
  800420f2f6:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 48 | ((uint64_t) src[0]) << 56;
  800420f2fa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f2fe:	48 83 c0 01          	add    $0x1,%rax
  800420f302:	0f b6 00             	movzbl (%rax),%eax
  800420f305:	0f b6 c0             	movzbl %al,%eax
  800420f308:	48 c1 e0 30          	shl    $0x30,%rax
  800420f30c:	48 89 c2             	mov    %rax,%rdx
  800420f30f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f313:	0f b6 00             	movzbl (%rax),%eax
  800420f316:	0f b6 c0             	movzbl %al,%eax
  800420f319:	48 c1 e0 38          	shl    $0x38,%rax
  800420f31d:	48 09 d0             	or     %rdx,%rax
  800420f320:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420f324:	eb 07                	jmp    800420f32d <_dwarf_decode_msb+0x193>
	default:
		return (0);
  800420f326:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f32b:	eb 1a                	jmp    800420f347 <_dwarf_decode_msb+0x1ad>
		break;
	}

	*data += bytes_to_read;
  800420f32d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f331:	48 8b 10             	mov    (%rax),%rdx
  800420f334:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420f337:	48 98                	cltq   
  800420f339:	48 01 c2             	add    %rax,%rdx
  800420f33c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f340:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420f343:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420f347:	c9                   	leaveq 
  800420f348:	c3                   	retq   

000000800420f349 <_dwarf_read_sleb128>:

int64_t
_dwarf_read_sleb128(uint8_t *data, uint64_t *offsetp)
{
  800420f349:	55                   	push   %rbp
  800420f34a:	48 89 e5             	mov    %rsp,%rbp
  800420f34d:	48 83 ec 30          	sub    $0x30,%rsp
  800420f351:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420f355:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int64_t ret = 0;
  800420f359:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420f360:	00 
	uint8_t b;
	int shift = 0;
  800420f361:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	uint8_t *src;

	src = data + *offsetp;
  800420f368:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f36c:	48 8b 10             	mov    (%rax),%rdx
  800420f36f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f373:	48 01 d0             	add    %rdx,%rax
  800420f376:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  800420f37a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f37e:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f382:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420f386:	0f b6 00             	movzbl (%rax),%eax
  800420f389:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  800420f38c:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420f390:	83 e0 7f             	and    $0x7f,%eax
  800420f393:	89 c2                	mov    %eax,%edx
  800420f395:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f398:	89 c1                	mov    %eax,%ecx
  800420f39a:	d3 e2                	shl    %cl,%edx
  800420f39c:	89 d0                	mov    %edx,%eax
  800420f39e:	48 98                	cltq   
  800420f3a0:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		(*offsetp)++;
  800420f3a4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f3a8:	48 8b 00             	mov    (%rax),%rax
  800420f3ab:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f3af:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f3b3:	48 89 10             	mov    %rdx,(%rax)
		shift += 7;
  800420f3b6:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  800420f3ba:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420f3be:	84 c0                	test   %al,%al
  800420f3c0:	78 b8                	js     800420f37a <_dwarf_read_sleb128+0x31>

	if (shift < 32 && (b & 0x40) != 0)
  800420f3c2:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  800420f3c6:	7f 1f                	jg     800420f3e7 <_dwarf_read_sleb128+0x9e>
  800420f3c8:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420f3cc:	83 e0 40             	and    $0x40,%eax
  800420f3cf:	85 c0                	test   %eax,%eax
  800420f3d1:	74 14                	je     800420f3e7 <_dwarf_read_sleb128+0x9e>
		ret |= (-1 << shift);
  800420f3d3:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f3d6:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  800420f3db:	89 c1                	mov    %eax,%ecx
  800420f3dd:	d3 e2                	shl    %cl,%edx
  800420f3df:	89 d0                	mov    %edx,%eax
  800420f3e1:	48 98                	cltq   
  800420f3e3:	48 09 45 f8          	or     %rax,-0x8(%rbp)

	return (ret);
  800420f3e7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420f3eb:	c9                   	leaveq 
  800420f3ec:	c3                   	retq   

000000800420f3ed <_dwarf_read_uleb128>:

uint64_t
_dwarf_read_uleb128(uint8_t *data, uint64_t *offsetp)
{
  800420f3ed:	55                   	push   %rbp
  800420f3ee:	48 89 e5             	mov    %rsp,%rbp
  800420f3f1:	48 83 ec 30          	sub    $0x30,%rsp
  800420f3f5:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420f3f9:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	uint64_t ret = 0;
  800420f3fd:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420f404:	00 
	uint8_t b;
	int shift = 0;
  800420f405:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	uint8_t *src;

	src = data + *offsetp;
  800420f40c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f410:	48 8b 10             	mov    (%rax),%rdx
  800420f413:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f417:	48 01 d0             	add    %rdx,%rax
  800420f41a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  800420f41e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f422:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f426:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420f42a:	0f b6 00             	movzbl (%rax),%eax
  800420f42d:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  800420f430:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420f434:	83 e0 7f             	and    $0x7f,%eax
  800420f437:	89 c2                	mov    %eax,%edx
  800420f439:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f43c:	89 c1                	mov    %eax,%ecx
  800420f43e:	d3 e2                	shl    %cl,%edx
  800420f440:	89 d0                	mov    %edx,%eax
  800420f442:	48 98                	cltq   
  800420f444:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		(*offsetp)++;
  800420f448:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f44c:	48 8b 00             	mov    (%rax),%rax
  800420f44f:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f453:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f457:	48 89 10             	mov    %rdx,(%rax)
		shift += 7;
  800420f45a:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  800420f45e:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420f462:	84 c0                	test   %al,%al
  800420f464:	78 b8                	js     800420f41e <_dwarf_read_uleb128+0x31>

	return (ret);
  800420f466:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420f46a:	c9                   	leaveq 
  800420f46b:	c3                   	retq   

000000800420f46c <_dwarf_decode_sleb128>:

int64_t
_dwarf_decode_sleb128(uint8_t **dp)
{
  800420f46c:	55                   	push   %rbp
  800420f46d:	48 89 e5             	mov    %rsp,%rbp
  800420f470:	48 83 ec 28          	sub    $0x28,%rsp
  800420f474:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	int64_t ret = 0;
  800420f478:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420f47f:	00 
	uint8_t b;
	int shift = 0;
  800420f480:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

	uint8_t *src = *dp;
  800420f487:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f48b:	48 8b 00             	mov    (%rax),%rax
  800420f48e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  800420f492:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f496:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f49a:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420f49e:	0f b6 00             	movzbl (%rax),%eax
  800420f4a1:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  800420f4a4:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420f4a8:	83 e0 7f             	and    $0x7f,%eax
  800420f4ab:	89 c2                	mov    %eax,%edx
  800420f4ad:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f4b0:	89 c1                	mov    %eax,%ecx
  800420f4b2:	d3 e2                	shl    %cl,%edx
  800420f4b4:	89 d0                	mov    %edx,%eax
  800420f4b6:	48 98                	cltq   
  800420f4b8:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		shift += 7;
  800420f4bc:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  800420f4c0:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420f4c4:	84 c0                	test   %al,%al
  800420f4c6:	78 ca                	js     800420f492 <_dwarf_decode_sleb128+0x26>

	if (shift < 32 && (b & 0x40) != 0)
  800420f4c8:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  800420f4cc:	7f 1f                	jg     800420f4ed <_dwarf_decode_sleb128+0x81>
  800420f4ce:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420f4d2:	83 e0 40             	and    $0x40,%eax
  800420f4d5:	85 c0                	test   %eax,%eax
  800420f4d7:	74 14                	je     800420f4ed <_dwarf_decode_sleb128+0x81>
		ret |= (-1 << shift);
  800420f4d9:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f4dc:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  800420f4e1:	89 c1                	mov    %eax,%ecx
  800420f4e3:	d3 e2                	shl    %cl,%edx
  800420f4e5:	89 d0                	mov    %edx,%eax
  800420f4e7:	48 98                	cltq   
  800420f4e9:	48 09 45 f8          	or     %rax,-0x8(%rbp)

	*dp = src;
  800420f4ed:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f4f1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f4f5:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420f4f8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420f4fc:	c9                   	leaveq 
  800420f4fd:	c3                   	retq   

000000800420f4fe <_dwarf_decode_uleb128>:

uint64_t
_dwarf_decode_uleb128(uint8_t **dp)
{
  800420f4fe:	55                   	push   %rbp
  800420f4ff:	48 89 e5             	mov    %rsp,%rbp
  800420f502:	48 83 ec 28          	sub    $0x28,%rsp
  800420f506:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	uint64_t ret = 0;
  800420f50a:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420f511:	00 
	uint8_t b;
	int shift = 0;
  800420f512:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

	uint8_t *src = *dp;
  800420f519:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f51d:	48 8b 00             	mov    (%rax),%rax
  800420f520:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  800420f524:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f528:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f52c:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420f530:	0f b6 00             	movzbl (%rax),%eax
  800420f533:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  800420f536:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420f53a:	83 e0 7f             	and    $0x7f,%eax
  800420f53d:	89 c2                	mov    %eax,%edx
  800420f53f:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f542:	89 c1                	mov    %eax,%ecx
  800420f544:	d3 e2                	shl    %cl,%edx
  800420f546:	89 d0                	mov    %edx,%eax
  800420f548:	48 98                	cltq   
  800420f54a:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		shift += 7;
  800420f54e:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  800420f552:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420f556:	84 c0                	test   %al,%al
  800420f558:	78 ca                	js     800420f524 <_dwarf_decode_uleb128+0x26>

	*dp = src;
  800420f55a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f55e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f562:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420f565:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420f569:	c9                   	leaveq 
  800420f56a:	c3                   	retq   

000000800420f56b <_dwarf_read_string>:

#define Dwarf_Unsigned uint64_t

char *
_dwarf_read_string(void *data, Dwarf_Unsigned size, uint64_t *offsetp)
{
  800420f56b:	55                   	push   %rbp
  800420f56c:	48 89 e5             	mov    %rsp,%rbp
  800420f56f:	48 83 ec 28          	sub    $0x28,%rsp
  800420f573:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f577:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420f57b:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *ret, *src;

	ret = src = (char *) data + *offsetp;
  800420f57f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f583:	48 8b 10             	mov    (%rax),%rdx
  800420f586:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f58a:	48 01 d0             	add    %rdx,%rax
  800420f58d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420f591:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f595:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (*src != '\0' && *offsetp < size) {
  800420f599:	eb 17                	jmp    800420f5b2 <_dwarf_read_string+0x47>
		src++;
  800420f59b:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
		(*offsetp)++;
  800420f5a0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f5a4:	48 8b 00             	mov    (%rax),%rax
  800420f5a7:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f5ab:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f5af:	48 89 10             	mov    %rdx,(%rax)
{
	char *ret, *src;

	ret = src = (char *) data + *offsetp;

	while (*src != '\0' && *offsetp < size) {
  800420f5b2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f5b6:	0f b6 00             	movzbl (%rax),%eax
  800420f5b9:	84 c0                	test   %al,%al
  800420f5bb:	74 0d                	je     800420f5ca <_dwarf_read_string+0x5f>
  800420f5bd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f5c1:	48 8b 00             	mov    (%rax),%rax
  800420f5c4:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800420f5c8:	72 d1                	jb     800420f59b <_dwarf_read_string+0x30>
		src++;
		(*offsetp)++;
	}

	if (*src == '\0' && *offsetp < size)
  800420f5ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f5ce:	0f b6 00             	movzbl (%rax),%eax
  800420f5d1:	84 c0                	test   %al,%al
  800420f5d3:	75 1f                	jne    800420f5f4 <_dwarf_read_string+0x89>
  800420f5d5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f5d9:	48 8b 00             	mov    (%rax),%rax
  800420f5dc:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800420f5e0:	73 12                	jae    800420f5f4 <_dwarf_read_string+0x89>
		(*offsetp)++;
  800420f5e2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f5e6:	48 8b 00             	mov    (%rax),%rax
  800420f5e9:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f5ed:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f5f1:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420f5f4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420f5f8:	c9                   	leaveq 
  800420f5f9:	c3                   	retq   

000000800420f5fa <_dwarf_read_block>:

uint8_t *
_dwarf_read_block(void *data, uint64_t *offsetp, uint64_t length)
{
  800420f5fa:	55                   	push   %rbp
  800420f5fb:	48 89 e5             	mov    %rsp,%rbp
  800420f5fe:	48 83 ec 28          	sub    $0x28,%rsp
  800420f602:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f606:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420f60a:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	uint8_t *ret, *src;

	ret = src = (uint8_t *) data + *offsetp;
  800420f60e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f612:	48 8b 10             	mov    (%rax),%rdx
  800420f615:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f619:	48 01 d0             	add    %rdx,%rax
  800420f61c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420f620:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f624:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	(*offsetp) += length;
  800420f628:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f62c:	48 8b 10             	mov    (%rax),%rdx
  800420f62f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f633:	48 01 c2             	add    %rax,%rdx
  800420f636:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f63a:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420f63d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420f641:	c9                   	leaveq 
  800420f642:	c3                   	retq   

000000800420f643 <_dwarf_elf_get_byte_order>:

Dwarf_Endianness
_dwarf_elf_get_byte_order(void *obj)
{
  800420f643:	55                   	push   %rbp
  800420f644:	48 89 e5             	mov    %rsp,%rbp
  800420f647:	48 83 ec 20          	sub    $0x20,%rsp
  800420f64b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    Elf *e;

    e = (Elf *)obj;
  800420f64f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f653:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    assert(e != NULL);
  800420f657:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420f65c:	75 35                	jne    800420f693 <_dwarf_elf_get_byte_order+0x50>
  800420f65e:	48 b9 b8 7f 21 04 80 	movabs $0x8004217fb8,%rcx
  800420f665:	00 00 00 
  800420f668:	48 ba c2 7f 21 04 80 	movabs $0x8004217fc2,%rdx
  800420f66f:	00 00 00 
  800420f672:	be 29 01 00 00       	mov    $0x129,%esi
  800420f677:	48 bf d7 7f 21 04 80 	movabs $0x8004217fd7,%rdi
  800420f67e:	00 00 00 
  800420f681:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f686:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420f68d:	00 00 00 
  800420f690:	41 ff d0             	callq  *%r8

//TODO: Need to check for 64bit here. Because currently Elf header for
//      64bit doesn't have any memeber e_ident. But need to see what is
//      similar in 64bit.
    switch (e->e_ident[EI_DATA]) {
  800420f693:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f697:	0f b6 40 05          	movzbl 0x5(%rax),%eax
  800420f69b:	0f b6 c0             	movzbl %al,%eax
  800420f69e:	83 f8 02             	cmp    $0x2,%eax
  800420f6a1:	75 07                	jne    800420f6aa <_dwarf_elf_get_byte_order+0x67>
    case ELFDATA2MSB:
        return (DW_OBJECT_MSB);
  800420f6a3:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f6a8:	eb 05                	jmp    800420f6af <_dwarf_elf_get_byte_order+0x6c>

    case ELFDATA2LSB:
    case ELFDATANONE:
    default:
        return (DW_OBJECT_LSB);
  800420f6aa:	b8 01 00 00 00       	mov    $0x1,%eax
    }
}
  800420f6af:	c9                   	leaveq 
  800420f6b0:	c3                   	retq   

000000800420f6b1 <_dwarf_elf_get_pointer_size>:

Dwarf_Small
_dwarf_elf_get_pointer_size(void *obj)
{
  800420f6b1:	55                   	push   %rbp
  800420f6b2:	48 89 e5             	mov    %rsp,%rbp
  800420f6b5:	48 83 ec 20          	sub    $0x20,%rsp
  800420f6b9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    Elf *e;

    e = (Elf *) obj;
  800420f6bd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f6c1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    assert(e != NULL);
  800420f6c5:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420f6ca:	75 35                	jne    800420f701 <_dwarf_elf_get_pointer_size+0x50>
  800420f6cc:	48 b9 b8 7f 21 04 80 	movabs $0x8004217fb8,%rcx
  800420f6d3:	00 00 00 
  800420f6d6:	48 ba c2 7f 21 04 80 	movabs $0x8004217fc2,%rdx
  800420f6dd:	00 00 00 
  800420f6e0:	be 3f 01 00 00       	mov    $0x13f,%esi
  800420f6e5:	48 bf d7 7f 21 04 80 	movabs $0x8004217fd7,%rdi
  800420f6ec:	00 00 00 
  800420f6ef:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f6f4:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420f6fb:	00 00 00 
  800420f6fe:	41 ff d0             	callq  *%r8

    if (e->e_ident[4] == ELFCLASS32)
  800420f701:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f705:	0f b6 40 04          	movzbl 0x4(%rax),%eax
  800420f709:	3c 01                	cmp    $0x1,%al
  800420f70b:	75 07                	jne    800420f714 <_dwarf_elf_get_pointer_size+0x63>
        return (4);
  800420f70d:	b8 04 00 00 00       	mov    $0x4,%eax
  800420f712:	eb 05                	jmp    800420f719 <_dwarf_elf_get_pointer_size+0x68>
    else
        return (8);
  800420f714:	b8 08 00 00 00       	mov    $0x8,%eax
}
  800420f719:	c9                   	leaveq 
  800420f71a:	c3                   	retq   

000000800420f71b <_dwarf_init>:

//Return 0 on success
int _dwarf_init(Dwarf_Debug dbg, void *obj)
{
  800420f71b:	55                   	push   %rbp
  800420f71c:	48 89 e5             	mov    %rsp,%rbp
  800420f71f:	53                   	push   %rbx
  800420f720:	48 83 ec 18          	sub    $0x18,%rsp
  800420f724:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f728:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
    memset(dbg, 0, sizeof(struct _Dwarf_Debug));
  800420f72c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f730:	ba 60 00 00 00       	mov    $0x60,%edx
  800420f735:	be 00 00 00 00       	mov    $0x0,%esi
  800420f73a:	48 89 c7             	mov    %rax,%rdi
  800420f73d:	48 b8 db e8 20 04 80 	movabs $0x800420e8db,%rax
  800420f744:	00 00 00 
  800420f747:	ff d0                	callq  *%rax
    dbg->curr_off_dbginfo = 0;
  800420f749:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f74d:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    dbg->dbg_info_size = 0;
  800420f754:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f758:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  800420f75f:	00 
    dbg->dbg_pointer_size = _dwarf_elf_get_pointer_size(obj); 
  800420f760:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f764:	48 89 c7             	mov    %rax,%rdi
  800420f767:	48 b8 b1 f6 20 04 80 	movabs $0x800420f6b1,%rax
  800420f76e:	00 00 00 
  800420f771:	ff d0                	callq  *%rax
  800420f773:	0f b6 d0             	movzbl %al,%edx
  800420f776:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f77a:	89 50 28             	mov    %edx,0x28(%rax)

    if (_dwarf_elf_get_byte_order(obj) == DW_OBJECT_MSB) {
  800420f77d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f781:	48 89 c7             	mov    %rax,%rdi
  800420f784:	48 b8 43 f6 20 04 80 	movabs $0x800420f643,%rax
  800420f78b:	00 00 00 
  800420f78e:	ff d0                	callq  *%rax
  800420f790:	85 c0                	test   %eax,%eax
  800420f792:	75 26                	jne    800420f7ba <_dwarf_init+0x9f>
        dbg->read = _dwarf_read_msb;
  800420f794:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f798:	48 b9 e8 ef 20 04 80 	movabs $0x800420efe8,%rcx
  800420f79f:	00 00 00 
  800420f7a2:	48 89 48 18          	mov    %rcx,0x18(%rax)
        dbg->decode = _dwarf_decode_msb;
  800420f7a6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f7aa:	48 bb 9a f1 20 04 80 	movabs $0x800420f19a,%rbx
  800420f7b1:	00 00 00 
  800420f7b4:	48 89 58 20          	mov    %rbx,0x20(%rax)
  800420f7b8:	eb 24                	jmp    800420f7de <_dwarf_init+0xc3>
    } else {
        dbg->read = _dwarf_read_lsb;
  800420f7ba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f7be:	48 b9 9b ed 20 04 80 	movabs $0x800420ed9b,%rcx
  800420f7c5:	00 00 00 
  800420f7c8:	48 89 48 18          	mov    %rcx,0x18(%rax)
        dbg->decode = _dwarf_decode_lsb;
  800420f7cc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f7d0:	48 be c7 ee 20 04 80 	movabs $0x800420eec7,%rsi
  800420f7d7:	00 00 00 
  800420f7da:	48 89 70 20          	mov    %rsi,0x20(%rax)
    }
   _dwarf_frame_params_init(dbg);
  800420f7de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f7e2:	48 89 c7             	mov    %rax,%rdi
  800420f7e5:	48 b8 e8 0c 21 04 80 	movabs $0x8004210ce8,%rax
  800420f7ec:	00 00 00 
  800420f7ef:	ff d0                	callq  *%rax
   return 0;
  800420f7f1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420f7f6:	48 83 c4 18          	add    $0x18,%rsp
  800420f7fa:	5b                   	pop    %rbx
  800420f7fb:	5d                   	pop    %rbp
  800420f7fc:	c3                   	retq   

000000800420f7fd <_get_next_cu>:

//Return 0 on success
int _get_next_cu(Dwarf_Debug dbg, Dwarf_CU *cu)
{
  800420f7fd:	55                   	push   %rbp
  800420f7fe:	48 89 e5             	mov    %rsp,%rbp
  800420f801:	48 83 ec 20          	sub    $0x20,%rsp
  800420f805:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f809:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
    uint32_t length;
    uint64_t offset;
    uint8_t dwarf_size;

    if (dbg->curr_off_dbginfo > dbg->dbg_info_size)
  800420f80d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f811:	48 8b 10             	mov    (%rax),%rdx
  800420f814:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f818:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420f81c:	48 39 c2             	cmp    %rax,%rdx
  800420f81f:	76 0a                	jbe    800420f82b <_get_next_cu+0x2e>
        return -1;
  800420f821:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420f826:	e9 6b 01 00 00       	jmpq   800420f996 <_get_next_cu+0x199>

    offset = dbg->curr_off_dbginfo;
  800420f82b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f82f:	48 8b 00             	mov    (%rax),%rax
  800420f832:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	cu->cu_offset = offset;
  800420f836:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f83a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f83e:	48 89 50 30          	mov    %rdx,0x30(%rax)

    length = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset,4);
  800420f842:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f846:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420f84a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f84e:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420f852:	48 89 d1             	mov    %rdx,%rcx
  800420f855:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  800420f859:	ba 04 00 00 00       	mov    $0x4,%edx
  800420f85e:	48 89 cf             	mov    %rcx,%rdi
  800420f861:	ff d0                	callq  *%rax
  800420f863:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (length == 0xffffffff) {
  800420f866:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  800420f86a:	75 2a                	jne    800420f896 <_get_next_cu+0x99>
        length = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 8);
  800420f86c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f870:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420f874:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f878:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420f87c:	48 89 d1             	mov    %rdx,%rcx
  800420f87f:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  800420f883:	ba 08 00 00 00       	mov    $0x8,%edx
  800420f888:	48 89 cf             	mov    %rcx,%rdi
  800420f88b:	ff d0                	callq  *%rax
  800420f88d:	89 45 fc             	mov    %eax,-0x4(%rbp)
        dwarf_size = 8;
  800420f890:	c6 45 fb 08          	movb   $0x8,-0x5(%rbp)
  800420f894:	eb 04                	jmp    800420f89a <_get_next_cu+0x9d>
    } else {
        dwarf_size = 4;
  800420f896:	c6 45 fb 04          	movb   $0x4,-0x5(%rbp)
    }

    cu->cu_dwarf_size = dwarf_size;
  800420f89a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f89e:	0f b6 55 fb          	movzbl -0x5(%rbp),%edx
  800420f8a2:	88 50 19             	mov    %dl,0x19(%rax)
	if (length > ds->ds_size - offset) {
		return (DW_DLE_CU_LENGTH_ERROR);
	}*/

	/* Compute the offset to the next compilation unit: */
	dbg->curr_off_dbginfo = offset + length;
  800420f8a5:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420f8a8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f8ac:	48 01 c2             	add    %rax,%rdx
  800420f8af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f8b3:	48 89 10             	mov    %rdx,(%rax)
	cu->cu_next_offset   = dbg->curr_off_dbginfo;
  800420f8b6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f8ba:	48 8b 10             	mov    (%rax),%rdx
  800420f8bd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f8c1:	48 89 50 20          	mov    %rdx,0x20(%rax)

	/* Initialise the compilation unit. */
	cu->cu_length = (uint64_t)length;
  800420f8c5:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420f8c8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f8cc:	48 89 10             	mov    %rdx,(%rax)

	cu->cu_length_size   = (dwarf_size == 4 ? 4 : 12);
  800420f8cf:	80 7d fb 04          	cmpb   $0x4,-0x5(%rbp)
  800420f8d3:	75 07                	jne    800420f8dc <_get_next_cu+0xdf>
  800420f8d5:	b8 04 00 00 00       	mov    $0x4,%eax
  800420f8da:	eb 05                	jmp    800420f8e1 <_get_next_cu+0xe4>
  800420f8dc:	b8 0c 00 00 00       	mov    $0xc,%eax
  800420f8e1:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420f8e5:	88 42 18             	mov    %al,0x18(%rdx)
	cu->version              = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 2);
  800420f8e8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f8ec:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420f8f0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f8f4:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420f8f8:	48 89 d1             	mov    %rdx,%rcx
  800420f8fb:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  800420f8ff:	ba 02 00 00 00       	mov    $0x2,%edx
  800420f904:	48 89 cf             	mov    %rcx,%rdi
  800420f907:	ff d0                	callq  *%rax
  800420f909:	89 c2                	mov    %eax,%edx
  800420f90b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f90f:	66 89 50 08          	mov    %dx,0x8(%rax)
	cu->debug_abbrev_offset  = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, dwarf_size);
  800420f913:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f917:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420f91b:	0f b6 55 fb          	movzbl -0x5(%rbp),%edx
  800420f91f:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420f923:	48 8b 49 08          	mov    0x8(%rcx),%rcx
  800420f927:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  800420f92b:	48 89 cf             	mov    %rcx,%rdi
  800420f92e:	ff d0                	callq  *%rax
  800420f930:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420f934:	48 89 42 10          	mov    %rax,0x10(%rdx)
	//cu->cu_abbrev_offset_cur = cu->cu_abbrev_offset;
	cu->addr_size  = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 1);
  800420f938:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f93c:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420f940:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f944:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420f948:	48 89 d1             	mov    %rdx,%rcx
  800420f94b:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  800420f94f:	ba 01 00 00 00       	mov    $0x1,%edx
  800420f954:	48 89 cf             	mov    %rcx,%rdi
  800420f957:	ff d0                	callq  *%rax
  800420f959:	89 c2                	mov    %eax,%edx
  800420f95b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f95f:	88 50 0a             	mov    %dl,0xa(%rax)

	if (cu->version < 2 || cu->version > 4) {
  800420f962:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f966:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420f96a:	66 83 f8 01          	cmp    $0x1,%ax
  800420f96e:	76 0e                	jbe    800420f97e <_get_next_cu+0x181>
  800420f970:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f974:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420f978:	66 83 f8 04          	cmp    $0x4,%ax
  800420f97c:	76 07                	jbe    800420f985 <_get_next_cu+0x188>
		return -1;
  800420f97e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420f983:	eb 11                	jmp    800420f996 <_get_next_cu+0x199>
	}

	cu->cu_die_offset = offset;
  800420f985:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f989:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f98d:	48 89 50 28          	mov    %rdx,0x28(%rax)

	return 0;
  800420f991:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420f996:	c9                   	leaveq 
  800420f997:	c3                   	retq   

000000800420f998 <print_cu>:

void print_cu(Dwarf_CU cu)
{
  800420f998:	55                   	push   %rbp
  800420f999:	48 89 e5             	mov    %rsp,%rbp
    cprintf("%ld---%du--%d\n",cu.cu_length,cu.version,cu.addr_size);
  800420f99c:	0f b6 45 1a          	movzbl 0x1a(%rbp),%eax
  800420f9a0:	0f b6 c8             	movzbl %al,%ecx
  800420f9a3:	0f b7 45 18          	movzwl 0x18(%rbp),%eax
  800420f9a7:	0f b7 d0             	movzwl %ax,%edx
  800420f9aa:	48 8b 45 10          	mov    0x10(%rbp),%rax
  800420f9ae:	48 89 c6             	mov    %rax,%rsi
  800420f9b1:	48 bf ea 7f 21 04 80 	movabs $0x8004217fea,%rdi
  800420f9b8:	00 00 00 
  800420f9bb:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f9c0:	49 b8 7a 8a 20 04 80 	movabs $0x8004208a7a,%r8
  800420f9c7:	00 00 00 
  800420f9ca:	41 ff d0             	callq  *%r8
}
  800420f9cd:	5d                   	pop    %rbp
  800420f9ce:	c3                   	retq   

000000800420f9cf <_dwarf_abbrev_parse>:

//Return 0 on success
int
_dwarf_abbrev_parse(Dwarf_Debug dbg, Dwarf_CU cu, Dwarf_Unsigned *offset,
    Dwarf_Abbrev *abp, Dwarf_Section *ds)
{
  800420f9cf:	55                   	push   %rbp
  800420f9d0:	48 89 e5             	mov    %rsp,%rbp
  800420f9d3:	48 83 ec 60          	sub    $0x60,%rsp
  800420f9d7:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  800420f9db:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  800420f9df:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  800420f9e3:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
    uint64_t tag;
    uint8_t children;
    uint64_t abbr_addr;
    int ret;

    assert(abp != NULL);
  800420f9e7:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  800420f9ec:	75 35                	jne    800420fa23 <_dwarf_abbrev_parse+0x54>
  800420f9ee:	48 b9 f9 7f 21 04 80 	movabs $0x8004217ff9,%rcx
  800420f9f5:	00 00 00 
  800420f9f8:	48 ba c2 7f 21 04 80 	movabs $0x8004217fc2,%rdx
  800420f9ff:	00 00 00 
  800420fa02:	be a4 01 00 00       	mov    $0x1a4,%esi
  800420fa07:	48 bf d7 7f 21 04 80 	movabs $0x8004217fd7,%rdi
  800420fa0e:	00 00 00 
  800420fa11:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fa16:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420fa1d:	00 00 00 
  800420fa20:	41 ff d0             	callq  *%r8
    assert(ds != NULL);
  800420fa23:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  800420fa28:	75 35                	jne    800420fa5f <_dwarf_abbrev_parse+0x90>
  800420fa2a:	48 b9 05 80 21 04 80 	movabs $0x8004218005,%rcx
  800420fa31:	00 00 00 
  800420fa34:	48 ba c2 7f 21 04 80 	movabs $0x8004217fc2,%rdx
  800420fa3b:	00 00 00 
  800420fa3e:	be a5 01 00 00       	mov    $0x1a5,%esi
  800420fa43:	48 bf d7 7f 21 04 80 	movabs $0x8004217fd7,%rdi
  800420fa4a:	00 00 00 
  800420fa4d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fa52:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420fa59:	00 00 00 
  800420fa5c:	41 ff d0             	callq  *%r8

    if (*offset >= ds->ds_size)
  800420fa5f:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420fa63:	48 8b 10             	mov    (%rax),%rdx
  800420fa66:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420fa6a:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420fa6e:	48 39 c2             	cmp    %rax,%rdx
  800420fa71:	72 0a                	jb     800420fa7d <_dwarf_abbrev_parse+0xae>
        	return (DW_DLE_NO_ENTRY);
  800420fa73:	b8 04 00 00 00       	mov    $0x4,%eax
  800420fa78:	e9 d3 01 00 00       	jmpq   800420fc50 <_dwarf_abbrev_parse+0x281>

    aboff = *offset;
  800420fa7d:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420fa81:	48 8b 00             	mov    (%rax),%rax
  800420fa84:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

    abbr_addr = (uint64_t)ds->ds_data; //(uint64_t)((uint8_t *)elf_base_ptr + ds->sh_offset);
  800420fa88:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420fa8c:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420fa90:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

    entry = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  800420fa94:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fa98:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420fa9c:	48 89 d6             	mov    %rdx,%rsi
  800420fa9f:	48 89 c7             	mov    %rax,%rdi
  800420faa2:	48 b8 ed f3 20 04 80 	movabs $0x800420f3ed,%rax
  800420faa9:	00 00 00 
  800420faac:	ff d0                	callq  *%rax
  800420faae:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

    if (entry == 0) {
  800420fab2:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420fab7:	75 15                	jne    800420face <_dwarf_abbrev_parse+0xff>
        /* Last entry. */
        //Need to make connection from below function
        abp->ab_entry = 0;
  800420fab9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420fabd:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
        return DW_DLE_NONE;
  800420fac4:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fac9:	e9 82 01 00 00       	jmpq   800420fc50 <_dwarf_abbrev_parse+0x281>
    }

    tag = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  800420face:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fad2:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420fad6:	48 89 d6             	mov    %rdx,%rsi
  800420fad9:	48 89 c7             	mov    %rax,%rdi
  800420fadc:	48 b8 ed f3 20 04 80 	movabs $0x800420f3ed,%rax
  800420fae3:	00 00 00 
  800420fae6:	ff d0                	callq  *%rax
  800420fae8:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    children = dbg->read((uint8_t *)abbr_addr, offset, 1);
  800420faec:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420faf0:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420faf4:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  800420faf8:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  800420fafc:	ba 01 00 00 00       	mov    $0x1,%edx
  800420fb01:	48 89 cf             	mov    %rcx,%rdi
  800420fb04:	ff d0                	callq  *%rax
  800420fb06:	88 45 df             	mov    %al,-0x21(%rbp)

    abp->ab_entry    = entry;
  800420fb09:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420fb0d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fb11:	48 89 10             	mov    %rdx,(%rax)
    abp->ab_tag      = tag;
  800420fb14:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420fb18:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420fb1c:	48 89 50 08          	mov    %rdx,0x8(%rax)
    abp->ab_children = children;
  800420fb20:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420fb24:	0f b6 55 df          	movzbl -0x21(%rbp),%edx
  800420fb28:	88 50 10             	mov    %dl,0x10(%rax)
    abp->ab_offset   = aboff;
  800420fb2b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420fb2f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420fb33:	48 89 50 18          	mov    %rdx,0x18(%rax)
    abp->ab_length   = 0;    /* fill in later. */
  800420fb37:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420fb3b:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
  800420fb42:	00 
    abp->ab_atnum    = 0;
  800420fb43:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420fb47:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
  800420fb4e:	00 

    /* Parse attribute definitions. */
    do {
        adoff = *offset;
  800420fb4f:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420fb53:	48 8b 00             	mov    (%rax),%rax
  800420fb56:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
        attr = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  800420fb5a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fb5e:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420fb62:	48 89 d6             	mov    %rdx,%rsi
  800420fb65:	48 89 c7             	mov    %rax,%rdi
  800420fb68:	48 b8 ed f3 20 04 80 	movabs $0x800420f3ed,%rax
  800420fb6f:	00 00 00 
  800420fb72:	ff d0                	callq  *%rax
  800420fb74:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
        form = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  800420fb78:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fb7c:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420fb80:	48 89 d6             	mov    %rdx,%rsi
  800420fb83:	48 89 c7             	mov    %rax,%rdi
  800420fb86:	48 b8 ed f3 20 04 80 	movabs $0x800420f3ed,%rax
  800420fb8d:	00 00 00 
  800420fb90:	ff d0                	callq  *%rax
  800420fb92:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
        if (attr != 0)
  800420fb96:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420fb9b:	0f 84 89 00 00 00    	je     800420fc2a <_dwarf_abbrev_parse+0x25b>
        {
            /* Initialise the attribute definition structure. */
            abp->ab_attrdef[abp->ab_atnum].ad_attrib = attr;
  800420fba1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420fba5:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420fba9:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  800420fbad:	48 89 d0             	mov    %rdx,%rax
  800420fbb0:	48 01 c0             	add    %rax,%rax
  800420fbb3:	48 01 d0             	add    %rdx,%rax
  800420fbb6:	48 c1 e0 03          	shl    $0x3,%rax
  800420fbba:	48 01 c8             	add    %rcx,%rax
  800420fbbd:	48 8d 50 30          	lea    0x30(%rax),%rdx
  800420fbc1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420fbc5:	48 89 02             	mov    %rax,(%rdx)
            abp->ab_attrdef[abp->ab_atnum].ad_form   = form;
  800420fbc8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420fbcc:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420fbd0:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  800420fbd4:	48 89 d0             	mov    %rdx,%rax
  800420fbd7:	48 01 c0             	add    %rax,%rax
  800420fbda:	48 01 d0             	add    %rdx,%rax
  800420fbdd:	48 c1 e0 03          	shl    $0x3,%rax
  800420fbe1:	48 01 c8             	add    %rcx,%rax
  800420fbe4:	48 8d 50 38          	lea    0x38(%rax),%rdx
  800420fbe8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420fbec:	48 89 02             	mov    %rax,(%rdx)
            abp->ab_attrdef[abp->ab_atnum].ad_offset = adoff;
  800420fbef:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420fbf3:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420fbf7:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  800420fbfb:	48 89 d0             	mov    %rdx,%rax
  800420fbfe:	48 01 c0             	add    %rax,%rax
  800420fc01:	48 01 d0             	add    %rdx,%rax
  800420fc04:	48 c1 e0 03          	shl    $0x3,%rax
  800420fc08:	48 01 c8             	add    %rcx,%rax
  800420fc0b:	48 8d 50 40          	lea    0x40(%rax),%rdx
  800420fc0f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420fc13:	48 89 02             	mov    %rax,(%rdx)
            abp->ab_atnum++;
  800420fc16:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420fc1a:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420fc1e:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420fc22:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420fc26:	48 89 50 28          	mov    %rdx,0x28(%rax)
        }
    } while (attr != 0);
  800420fc2a:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420fc2f:	0f 85 1a ff ff ff    	jne    800420fb4f <_dwarf_abbrev_parse+0x180>

    //(*abp)->ab_length = *offset - aboff;
    abp->ab_length = (uint64_t)(*offset - aboff);
  800420fc35:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420fc39:	48 8b 00             	mov    (%rax),%rax
  800420fc3c:	48 2b 45 f8          	sub    -0x8(%rbp),%rax
  800420fc40:	48 89 c2             	mov    %rax,%rdx
  800420fc43:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420fc47:	48 89 50 20          	mov    %rdx,0x20(%rax)

    return DW_DLV_OK;
  800420fc4b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420fc50:	c9                   	leaveq 
  800420fc51:	c3                   	retq   

000000800420fc52 <_dwarf_abbrev_find>:

//Return 0 on success
int
_dwarf_abbrev_find(Dwarf_Debug dbg, Dwarf_CU cu, uint64_t entry, Dwarf_Abbrev *abp)
{
  800420fc52:	55                   	push   %rbp
  800420fc53:	48 89 e5             	mov    %rsp,%rbp
  800420fc56:	48 83 ec 70          	sub    $0x70,%rsp
  800420fc5a:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420fc5e:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420fc62:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
    Dwarf_Section *ds;
    uint64_t offset;
    int ret;

    if (entry == 0)
  800420fc66:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420fc6b:	75 0a                	jne    800420fc77 <_dwarf_abbrev_find+0x25>
    {
		return (DW_DLE_NO_ENTRY);
  800420fc6d:	b8 04 00 00 00       	mov    $0x4,%eax
  800420fc72:	e9 0a 01 00 00       	jmpq   800420fd81 <_dwarf_abbrev_find+0x12f>
    }

    /* Load and search the abbrev table. */
    ds = _dwarf_find_section(".debug_abbrev");
  800420fc77:	48 bf 10 80 21 04 80 	movabs $0x8004218010,%rdi
  800420fc7e:	00 00 00 
  800420fc81:	48 b8 82 3f 21 04 80 	movabs $0x8004213f82,%rax
  800420fc88:	00 00 00 
  800420fc8b:	ff d0                	callq  *%rax
  800420fc8d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    assert(ds != NULL);
  800420fc91:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420fc96:	75 35                	jne    800420fccd <_dwarf_abbrev_find+0x7b>
  800420fc98:	48 b9 05 80 21 04 80 	movabs $0x8004218005,%rcx
  800420fc9f:	00 00 00 
  800420fca2:	48 ba c2 7f 21 04 80 	movabs $0x8004217fc2,%rdx
  800420fca9:	00 00 00 
  800420fcac:	be e5 01 00 00       	mov    $0x1e5,%esi
  800420fcb1:	48 bf d7 7f 21 04 80 	movabs $0x8004217fd7,%rdi
  800420fcb8:	00 00 00 
  800420fcbb:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fcc0:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420fcc7:	00 00 00 
  800420fcca:	41 ff d0             	callq  *%r8

    //TODO: We are starting offset from 0, however libdwarf logic
    //      is keeping a counter for current offset. Ok. let use
    //      that. I relent, but this will be done in Phase 2. :)
    //offset = 0; //cu->cu_abbrev_offset_cur;
    offset = cu.debug_abbrev_offset; //cu->cu_abbrev_offset_cur;
  800420fccd:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800420fcd1:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    while (offset < ds->ds_size) {
  800420fcd5:	e9 8d 00 00 00       	jmpq   800420fd67 <_dwarf_abbrev_find+0x115>
        ret = _dwarf_abbrev_parse(dbg, cu, &offset, abp, ds);
  800420fcda:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  800420fcde:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420fce2:	48 8d 75 e8          	lea    -0x18(%rbp),%rsi
  800420fce6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fcea:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  800420fcee:	48 89 3c 24          	mov    %rdi,(%rsp)
  800420fcf2:	48 8b 7d 18          	mov    0x18(%rbp),%rdi
  800420fcf6:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  800420fcfb:	48 8b 7d 20          	mov    0x20(%rbp),%rdi
  800420fcff:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  800420fd04:	48 8b 7d 28          	mov    0x28(%rbp),%rdi
  800420fd08:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  800420fd0d:	48 8b 7d 30          	mov    0x30(%rbp),%rdi
  800420fd11:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  800420fd16:	48 8b 7d 38          	mov    0x38(%rbp),%rdi
  800420fd1a:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  800420fd1f:	48 8b 7d 40          	mov    0x40(%rbp),%rdi
  800420fd23:	48 89 7c 24 30       	mov    %rdi,0x30(%rsp)
  800420fd28:	48 89 c7             	mov    %rax,%rdi
  800420fd2b:	48 b8 cf f9 20 04 80 	movabs $0x800420f9cf,%rax
  800420fd32:	00 00 00 
  800420fd35:	ff d0                	callq  *%rax
  800420fd37:	89 45 f4             	mov    %eax,-0xc(%rbp)
        if (ret != DW_DLE_NONE)
  800420fd3a:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  800420fd3e:	74 05                	je     800420fd45 <_dwarf_abbrev_find+0xf3>
            return (ret);
  800420fd40:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420fd43:	eb 3c                	jmp    800420fd81 <_dwarf_abbrev_find+0x12f>
        if (abp->ab_entry == entry) {
  800420fd45:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420fd49:	48 8b 00             	mov    (%rax),%rax
  800420fd4c:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800420fd50:	75 07                	jne    800420fd59 <_dwarf_abbrev_find+0x107>
            //cu->cu_abbrev_offset_cur = offset;
            return DW_DLE_NONE;
  800420fd52:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fd57:	eb 28                	jmp    800420fd81 <_dwarf_abbrev_find+0x12f>
        }
        if (abp->ab_entry == 0) {
  800420fd59:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420fd5d:	48 8b 00             	mov    (%rax),%rax
  800420fd60:	48 85 c0             	test   %rax,%rax
  800420fd63:	75 02                	jne    800420fd67 <_dwarf_abbrev_find+0x115>
            //cu->cu_abbrev_offset_cur = offset;
            //cu->cu_abbrev_loaded = 1;
            break;
  800420fd65:	eb 15                	jmp    800420fd7c <_dwarf_abbrev_find+0x12a>
    //TODO: We are starting offset from 0, however libdwarf logic
    //      is keeping a counter for current offset. Ok. let use
    //      that. I relent, but this will be done in Phase 2. :)
    //offset = 0; //cu->cu_abbrev_offset_cur;
    offset = cu.debug_abbrev_offset; //cu->cu_abbrev_offset_cur;
    while (offset < ds->ds_size) {
  800420fd67:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fd6b:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800420fd6f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fd73:	48 39 c2             	cmp    %rax,%rdx
  800420fd76:	0f 87 5e ff ff ff    	ja     800420fcda <_dwarf_abbrev_find+0x88>
            //cu->cu_abbrev_loaded = 1;
            break;
        }
    }

    return DW_DLE_NO_ENTRY;
  800420fd7c:	b8 04 00 00 00       	mov    $0x4,%eax
}
  800420fd81:	c9                   	leaveq 
  800420fd82:	c3                   	retq   

000000800420fd83 <_dwarf_attr_init>:

//Return 0 on success
int
_dwarf_attr_init(Dwarf_Debug dbg, uint64_t *offsetp, Dwarf_CU *cu, Dwarf_Die *ret_die, Dwarf_AttrDef *ad,
    uint64_t form, int indirect)
{
  800420fd83:	55                   	push   %rbp
  800420fd84:	48 89 e5             	mov    %rsp,%rbp
  800420fd87:	48 81 ec d0 00 00 00 	sub    $0xd0,%rsp
  800420fd8e:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  800420fd95:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  800420fd9c:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
  800420fda3:	48 89 8d 50 ff ff ff 	mov    %rcx,-0xb0(%rbp)
  800420fdaa:	4c 89 85 48 ff ff ff 	mov    %r8,-0xb8(%rbp)
  800420fdb1:	4c 89 8d 40 ff ff ff 	mov    %r9,-0xc0(%rbp)
    struct _Dwarf_Attribute atref;
    Dwarf_Section *str;
    int ret;
    Dwarf_Section *ds = _dwarf_find_section(".debug_info");
  800420fdb8:	48 bf 1e 80 21 04 80 	movabs $0x800421801e,%rdi
  800420fdbf:	00 00 00 
  800420fdc2:	48 b8 82 3f 21 04 80 	movabs $0x8004213f82,%rax
  800420fdc9:	00 00 00 
  800420fdcc:	ff d0                	callq  *%rax
  800420fdce:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    uint8_t *ds_data = (uint8_t *)ds->ds_data; //(uint8_t *)dbg->dbg_info_offset_elf;
  800420fdd2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fdd6:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420fdda:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    uint8_t dwarf_size = cu->cu_dwarf_size;
  800420fdde:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800420fde5:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  800420fde9:	88 45 e7             	mov    %al,-0x19(%rbp)

    ret = DW_DLE_NONE;
  800420fdec:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    memset(&atref, 0, sizeof(atref));
  800420fdf3:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  800420fdfa:	ba 60 00 00 00       	mov    $0x60,%edx
  800420fdff:	be 00 00 00 00       	mov    $0x0,%esi
  800420fe04:	48 89 c7             	mov    %rax,%rdi
  800420fe07:	48 b8 db e8 20 04 80 	movabs $0x800420e8db,%rax
  800420fe0e:	00 00 00 
  800420fe11:	ff d0                	callq  *%rax
    atref.at_die = ret_die;
  800420fe13:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  800420fe1a:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
    atref.at_attrib = ad->ad_attrib;
  800420fe21:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  800420fe28:	48 8b 00             	mov    (%rax),%rax
  800420fe2b:	48 89 45 80          	mov    %rax,-0x80(%rbp)
    atref.at_form = ad->ad_form;
  800420fe2f:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  800420fe36:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420fe3a:	48 89 45 88          	mov    %rax,-0x78(%rbp)
    atref.at_indirect = indirect;
  800420fe3e:	8b 45 10             	mov    0x10(%rbp),%eax
  800420fe41:	89 45 90             	mov    %eax,-0x70(%rbp)
    atref.at_ld = NULL;
  800420fe44:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  800420fe4b:	00 

    switch (form) {
  800420fe4c:	48 83 bd 40 ff ff ff 	cmpq   $0x20,-0xc0(%rbp)
  800420fe53:	20 
  800420fe54:	0f 87 82 04 00 00    	ja     80042102dc <_dwarf_attr_init+0x559>
  800420fe5a:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  800420fe61:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420fe68:	00 
  800420fe69:	48 b8 48 80 21 04 80 	movabs $0x8004218048,%rax
  800420fe70:	00 00 00 
  800420fe73:	48 01 d0             	add    %rdx,%rax
  800420fe76:	48 8b 00             	mov    (%rax),%rax
  800420fe79:	ff e0                	jmpq   *%rax
    case DW_FORM_addr:
        atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
  800420fe7b:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420fe82:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420fe86:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  800420fe8d:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  800420fe91:	0f b6 d2             	movzbl %dl,%edx
  800420fe94:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420fe9b:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420fe9f:	48 89 cf             	mov    %rcx,%rdi
  800420fea2:	ff d0                	callq  *%rax
  800420fea4:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        break;
  800420fea8:	e9 37 04 00 00       	jmpq   80042102e4 <_dwarf_attr_init+0x561>
    case DW_FORM_block:
    case DW_FORM_exprloc:
        atref.u[0].u64 = _dwarf_read_uleb128(ds_data, offsetp);
  800420fead:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800420feb4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420feb8:	48 89 d6             	mov    %rdx,%rsi
  800420febb:	48 89 c7             	mov    %rax,%rdi
  800420febe:	48 b8 ed f3 20 04 80 	movabs $0x800420f3ed,%rax
  800420fec5:	00 00 00 
  800420fec8:	ff d0                	callq  *%rax
  800420feca:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  800420fece:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800420fed2:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800420fed9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fedd:	48 89 ce             	mov    %rcx,%rsi
  800420fee0:	48 89 c7             	mov    %rax,%rdi
  800420fee3:	48 b8 fa f5 20 04 80 	movabs $0x800420f5fa,%rax
  800420feea:	00 00 00 
  800420feed:	ff d0                	callq  *%rax
  800420feef:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
        break;
  800420fef3:	e9 ec 03 00 00       	jmpq   80042102e4 <_dwarf_attr_init+0x561>
    case DW_FORM_block1:
        atref.u[0].u64 = dbg->read(ds_data, offsetp, 1);
  800420fef8:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420feff:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420ff03:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420ff0a:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420ff0e:	ba 01 00 00 00       	mov    $0x1,%edx
  800420ff13:	48 89 cf             	mov    %rcx,%rdi
  800420ff16:	ff d0                	callq  *%rax
  800420ff18:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  800420ff1c:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800420ff20:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800420ff27:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ff2b:	48 89 ce             	mov    %rcx,%rsi
  800420ff2e:	48 89 c7             	mov    %rax,%rdi
  800420ff31:	48 b8 fa f5 20 04 80 	movabs $0x800420f5fa,%rax
  800420ff38:	00 00 00 
  800420ff3b:	ff d0                	callq  *%rax
  800420ff3d:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
        break;
  800420ff41:	e9 9e 03 00 00       	jmpq   80042102e4 <_dwarf_attr_init+0x561>
    case DW_FORM_block2:
        atref.u[0].u64 = dbg->read(ds_data, offsetp, 2);
  800420ff46:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420ff4d:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420ff51:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420ff58:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420ff5c:	ba 02 00 00 00       	mov    $0x2,%edx
  800420ff61:	48 89 cf             	mov    %rcx,%rdi
  800420ff64:	ff d0                	callq  *%rax
  800420ff66:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  800420ff6a:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800420ff6e:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800420ff75:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ff79:	48 89 ce             	mov    %rcx,%rsi
  800420ff7c:	48 89 c7             	mov    %rax,%rdi
  800420ff7f:	48 b8 fa f5 20 04 80 	movabs $0x800420f5fa,%rax
  800420ff86:	00 00 00 
  800420ff89:	ff d0                	callq  *%rax
  800420ff8b:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
        break;
  800420ff8f:	e9 50 03 00 00       	jmpq   80042102e4 <_dwarf_attr_init+0x561>
   case DW_FORM_block4:
        atref.u[0].u64 = dbg->read(ds_data, offsetp, 4);
  800420ff94:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420ff9b:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420ff9f:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420ffa6:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420ffaa:	ba 04 00 00 00       	mov    $0x4,%edx
  800420ffaf:	48 89 cf             	mov    %rcx,%rdi
  800420ffb2:	ff d0                	callq  *%rax
  800420ffb4:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  800420ffb8:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800420ffbc:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800420ffc3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ffc7:	48 89 ce             	mov    %rcx,%rsi
  800420ffca:	48 89 c7             	mov    %rax,%rdi
  800420ffcd:	48 b8 fa f5 20 04 80 	movabs $0x800420f5fa,%rax
  800420ffd4:	00 00 00 
  800420ffd7:	ff d0                	callq  *%rax
  800420ffd9:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
        break;
  800420ffdd:	e9 02 03 00 00       	jmpq   80042102e4 <_dwarf_attr_init+0x561>
    case DW_FORM_data1:
    case DW_FORM_flag:
    case DW_FORM_ref1:
        atref.u[0].u64 = dbg->read(ds_data, offsetp, 1);
  800420ffe2:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420ffe9:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420ffed:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420fff4:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420fff8:	ba 01 00 00 00       	mov    $0x1,%edx
  800420fffd:	48 89 cf             	mov    %rcx,%rdi
  8004210000:	ff d0                	callq  *%rax
  8004210002:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        break;
  8004210006:	e9 d9 02 00 00       	jmpq   80042102e4 <_dwarf_attr_init+0x561>
    case DW_FORM_data2:
    case DW_FORM_ref2:
        atref.u[0].u64 = dbg->read(ds_data, offsetp, 2);
  800421000b:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004210012:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210016:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800421001d:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004210021:	ba 02 00 00 00       	mov    $0x2,%edx
  8004210026:	48 89 cf             	mov    %rcx,%rdi
  8004210029:	ff d0                	callq  *%rax
  800421002b:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        break;
  800421002f:	e9 b0 02 00 00       	jmpq   80042102e4 <_dwarf_attr_init+0x561>
    case DW_FORM_data4:
    case DW_FORM_ref4:
        atref.u[0].u64 = dbg->read(ds_data, offsetp, 4);
  8004210034:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421003b:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421003f:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004210046:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421004a:	ba 04 00 00 00       	mov    $0x4,%edx
  800421004f:	48 89 cf             	mov    %rcx,%rdi
  8004210052:	ff d0                	callq  *%rax
  8004210054:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        break;
  8004210058:	e9 87 02 00 00       	jmpq   80042102e4 <_dwarf_attr_init+0x561>
    case DW_FORM_data8:
    case DW_FORM_ref8:
        atref.u[0].u64 = dbg->read(ds_data, offsetp, 8);
  800421005d:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004210064:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210068:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800421006f:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004210073:	ba 08 00 00 00       	mov    $0x8,%edx
  8004210078:	48 89 cf             	mov    %rcx,%rdi
  800421007b:	ff d0                	callq  *%rax
  800421007d:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        break;
  8004210081:	e9 5e 02 00 00       	jmpq   80042102e4 <_dwarf_attr_init+0x561>
    case DW_FORM_indirect:
        form = _dwarf_read_uleb128(ds_data, offsetp);
  8004210086:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800421008d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210091:	48 89 d6             	mov    %rdx,%rsi
  8004210094:	48 89 c7             	mov    %rax,%rdi
  8004210097:	48 b8 ed f3 20 04 80 	movabs $0x800420f3ed,%rax
  800421009e:	00 00 00 
  80042100a1:	ff d0                	callq  *%rax
  80042100a3:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
        return (_dwarf_attr_init(dbg, offsetp, cu, ret_die, ad, form, 1));
  80042100aa:	4c 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%r8
  80042100b1:	48 8b bd 48 ff ff ff 	mov    -0xb8(%rbp),%rdi
  80042100b8:	48 8b 8d 50 ff ff ff 	mov    -0xb0(%rbp),%rcx
  80042100bf:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  80042100c6:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042100cd:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042100d4:	c7 04 24 01 00 00 00 	movl   $0x1,(%rsp)
  80042100db:	4d 89 c1             	mov    %r8,%r9
  80042100de:	49 89 f8             	mov    %rdi,%r8
  80042100e1:	48 89 c7             	mov    %rax,%rdi
  80042100e4:	48 b8 83 fd 20 04 80 	movabs $0x800420fd83,%rax
  80042100eb:	00 00 00 
  80042100ee:	ff d0                	callq  *%rax
  80042100f0:	e9 1d 03 00 00       	jmpq   8004210412 <_dwarf_attr_init+0x68f>
    case DW_FORM_ref_addr:
        if (cu->version == 2)
  80042100f5:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042100fc:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004210100:	66 83 f8 02          	cmp    $0x2,%ax
  8004210104:	75 2f                	jne    8004210135 <_dwarf_attr_init+0x3b2>
            atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
  8004210106:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421010d:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210111:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  8004210118:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  800421011c:	0f b6 d2             	movzbl %dl,%edx
  800421011f:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004210126:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421012a:	48 89 cf             	mov    %rcx,%rdi
  800421012d:	ff d0                	callq  *%rax
  800421012f:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  8004210133:	eb 39                	jmp    800421016e <_dwarf_attr_init+0x3eb>
        else if (cu->version == 3)
  8004210135:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800421013c:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004210140:	66 83 f8 03          	cmp    $0x3,%ax
  8004210144:	75 28                	jne    800421016e <_dwarf_attr_init+0x3eb>
            atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  8004210146:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421014d:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210151:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  8004210155:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800421015c:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004210160:	48 89 cf             	mov    %rcx,%rdi
  8004210163:	ff d0                	callq  *%rax
  8004210165:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        break;
  8004210169:	e9 76 01 00 00       	jmpq   80042102e4 <_dwarf_attr_init+0x561>
  800421016e:	e9 71 01 00 00       	jmpq   80042102e4 <_dwarf_attr_init+0x561>
    case DW_FORM_ref_udata:
    case DW_FORM_udata:
        atref.u[0].u64 = _dwarf_read_uleb128(ds_data, offsetp);
  8004210173:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800421017a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421017e:	48 89 d6             	mov    %rdx,%rsi
  8004210181:	48 89 c7             	mov    %rax,%rdi
  8004210184:	48 b8 ed f3 20 04 80 	movabs $0x800420f3ed,%rax
  800421018b:	00 00 00 
  800421018e:	ff d0                	callq  *%rax
  8004210190:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        break;
  8004210194:	e9 4b 01 00 00       	jmpq   80042102e4 <_dwarf_attr_init+0x561>
    case DW_FORM_sdata:
        atref.u[0].s64 = _dwarf_read_sleb128(ds_data, offsetp);
  8004210199:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  80042101a0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042101a4:	48 89 d6             	mov    %rdx,%rsi
  80042101a7:	48 89 c7             	mov    %rax,%rdi
  80042101aa:	48 b8 49 f3 20 04 80 	movabs $0x800420f349,%rax
  80042101b1:	00 00 00 
  80042101b4:	ff d0                	callq  *%rax
  80042101b6:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        break;
  80042101ba:	e9 25 01 00 00       	jmpq   80042102e4 <_dwarf_attr_init+0x561>
    case DW_FORM_sec_offset:
        atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  80042101bf:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042101c6:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042101ca:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  80042101ce:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042101d5:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042101d9:	48 89 cf             	mov    %rcx,%rdi
  80042101dc:	ff d0                	callq  *%rax
  80042101de:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        break;
  80042101e2:	e9 fd 00 00 00       	jmpq   80042102e4 <_dwarf_attr_init+0x561>
    case DW_FORM_string:
        atref.u[0].s =(char*) _dwarf_read_string(ds_data, (uint64_t)ds->ds_size, offsetp);
  80042101e7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042101eb:	48 8b 48 18          	mov    0x18(%rax),%rcx
  80042101ef:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  80042101f6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042101fa:	48 89 ce             	mov    %rcx,%rsi
  80042101fd:	48 89 c7             	mov    %rax,%rdi
  8004210200:	48 b8 6b f5 20 04 80 	movabs $0x800420f56b,%rax
  8004210207:	00 00 00 
  800421020a:	ff d0                	callq  *%rax
  800421020c:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        break;
  8004210210:	e9 cf 00 00 00       	jmpq   80042102e4 <_dwarf_attr_init+0x561>
    case DW_FORM_strp:
        atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  8004210215:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421021c:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210220:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  8004210224:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800421022b:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421022f:	48 89 cf             	mov    %rcx,%rdi
  8004210232:	ff d0                	callq  *%rax
  8004210234:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        str = _dwarf_find_section(".debug_str");
  8004210238:	48 bf 2a 80 21 04 80 	movabs $0x800421802a,%rdi
  800421023f:	00 00 00 
  8004210242:	48 b8 82 3f 21 04 80 	movabs $0x8004213f82,%rax
  8004210249:	00 00 00 
  800421024c:	ff d0                	callq  *%rax
  800421024e:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        assert(str != NULL);
  8004210252:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004210257:	75 35                	jne    800421028e <_dwarf_attr_init+0x50b>
  8004210259:	48 b9 35 80 21 04 80 	movabs $0x8004218035,%rcx
  8004210260:	00 00 00 
  8004210263:	48 ba c2 7f 21 04 80 	movabs $0x8004217fc2,%rdx
  800421026a:	00 00 00 
  800421026d:	be 51 02 00 00       	mov    $0x251,%esi
  8004210272:	48 bf d7 7f 21 04 80 	movabs $0x8004217fd7,%rdi
  8004210279:	00 00 00 
  800421027c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210281:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004210288:	00 00 00 
  800421028b:	41 ff d0             	callq  *%r8
        //atref.u[1].s = (char *)(elf_base_ptr + str->sh_offset) + atref.u[0].u64;
        atref.u[1].s = (char *)str->ds_data + atref.u[0].u64;
  800421028e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210292:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004210296:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421029a:	48 01 d0             	add    %rdx,%rax
  800421029d:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
        break;
  80042102a1:	eb 41                	jmp    80042102e4 <_dwarf_attr_init+0x561>
    case DW_FORM_ref_sig8:
        atref.u[0].u64 = 8;
  80042102a3:	48 c7 45 98 08 00 00 	movq   $0x8,-0x68(%rbp)
  80042102aa:	00 
        atref.u[1].u8p = (uint8_t*)(_dwarf_read_block(ds_data, offsetp, atref.u[0].u64));
  80042102ab:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  80042102af:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  80042102b6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042102ba:	48 89 ce             	mov    %rcx,%rsi
  80042102bd:	48 89 c7             	mov    %rax,%rdi
  80042102c0:	48 b8 fa f5 20 04 80 	movabs $0x800420f5fa,%rax
  80042102c7:	00 00 00 
  80042102ca:	ff d0                	callq  *%rax
  80042102cc:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
        break;
  80042102d0:	eb 12                	jmp    80042102e4 <_dwarf_attr_init+0x561>
    case DW_FORM_flag_present:
        /* This form has no value encoded in the DIE. */
        atref.u[0].u64 = 1;
  80042102d2:	48 c7 45 98 01 00 00 	movq   $0x1,-0x68(%rbp)
  80042102d9:	00 
        break;
  80042102da:	eb 08                	jmp    80042102e4 <_dwarf_attr_init+0x561>
    default:
        //DWARF_SET_ERROR(dbg, error, DW_DLE_ATTR_FORM_BAD);
        ret = DW_DLE_ATTR_FORM_BAD;
  80042102dc:	c7 45 fc 0e 00 00 00 	movl   $0xe,-0x4(%rbp)
        break;
  80042102e3:	90                   	nop
    }

    if (ret == DW_DLE_NONE) {
  80042102e4:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042102e8:	0f 85 21 01 00 00    	jne    800421040f <_dwarf_attr_init+0x68c>
        if (form == DW_FORM_block || form == DW_FORM_block1 ||
  80042102ee:	48 83 bd 40 ff ff ff 	cmpq   $0x9,-0xc0(%rbp)
  80042102f5:	09 
  80042102f6:	74 1e                	je     8004210316 <_dwarf_attr_init+0x593>
  80042102f8:	48 83 bd 40 ff ff ff 	cmpq   $0xa,-0xc0(%rbp)
  80042102ff:	0a 
  8004210300:	74 14                	je     8004210316 <_dwarf_attr_init+0x593>
  8004210302:	48 83 bd 40 ff ff ff 	cmpq   $0x3,-0xc0(%rbp)
  8004210309:	03 
  800421030a:	74 0a                	je     8004210316 <_dwarf_attr_init+0x593>
            form == DW_FORM_block2 || form == DW_FORM_block4) {
  800421030c:	48 83 bd 40 ff ff ff 	cmpq   $0x4,-0xc0(%rbp)
  8004210313:	04 
  8004210314:	75 10                	jne    8004210326 <_dwarf_attr_init+0x5a3>
            atref.at_block.bl_len = atref.u[0].u64;
  8004210316:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421031a:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
            atref.at_block.bl_data = atref.u[1].u8p;
  800421031e:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004210322:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
        }
        //ret = _dwarf_attr_add(die, &atref, NULL, error);
        if (atref.at_attrib == DW_AT_name) {
  8004210326:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421032a:	48 83 f8 03          	cmp    $0x3,%rax
  800421032e:	75 39                	jne    8004210369 <_dwarf_attr_init+0x5e6>
                switch (atref.at_form) {
  8004210330:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004210334:	48 83 f8 08          	cmp    $0x8,%rax
  8004210338:	74 1c                	je     8004210356 <_dwarf_attr_init+0x5d3>
  800421033a:	48 83 f8 0e          	cmp    $0xe,%rax
  800421033e:	74 02                	je     8004210342 <_dwarf_attr_init+0x5bf>
                    break;
                case DW_FORM_string:
                    ret_die->die_name = atref.u[0].s;
                    break;
                default:
                    break;
  8004210340:	eb 27                	jmp    8004210369 <_dwarf_attr_init+0x5e6>
        }
        //ret = _dwarf_attr_add(die, &atref, NULL, error);
        if (atref.at_attrib == DW_AT_name) {
                switch (atref.at_form) {
                case DW_FORM_strp:
                    ret_die->die_name = atref.u[1].s;
  8004210342:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004210346:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  800421034d:	48 89 90 50 03 00 00 	mov    %rdx,0x350(%rax)
                    break;
  8004210354:	eb 13                	jmp    8004210369 <_dwarf_attr_init+0x5e6>
                case DW_FORM_string:
                    ret_die->die_name = atref.u[0].s;
  8004210356:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800421035a:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004210361:	48 89 90 50 03 00 00 	mov    %rdx,0x350(%rax)
                    break;
  8004210368:	90                   	nop
                default:
                    break;
                }
        }
        ret_die->die_attr[ret_die->die_attr_count++] = atref;
  8004210369:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004210370:	0f b6 80 58 03 00 00 	movzbl 0x358(%rax),%eax
  8004210377:	8d 48 01             	lea    0x1(%rax),%ecx
  800421037a:	48 8b 95 50 ff ff ff 	mov    -0xb0(%rbp),%rdx
  8004210381:	88 8a 58 03 00 00    	mov    %cl,0x358(%rdx)
  8004210387:	0f b6 c0             	movzbl %al,%eax
  800421038a:	48 8b 8d 50 ff ff ff 	mov    -0xb0(%rbp),%rcx
  8004210391:	48 63 d0             	movslq %eax,%rdx
  8004210394:	48 89 d0             	mov    %rdx,%rax
  8004210397:	48 01 c0             	add    %rax,%rax
  800421039a:	48 01 d0             	add    %rdx,%rax
  800421039d:	48 c1 e0 05          	shl    $0x5,%rax
  80042103a1:	48 01 c8             	add    %rcx,%rax
  80042103a4:	48 05 70 03 00 00    	add    $0x370,%rax
  80042103aa:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  80042103b1:	48 89 10             	mov    %rdx,(%rax)
  80042103b4:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  80042103bb:	48 89 50 08          	mov    %rdx,0x8(%rax)
  80042103bf:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  80042103c3:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80042103c7:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  80042103cb:	48 89 50 18          	mov    %rdx,0x18(%rax)
  80042103cf:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  80042103d3:	48 89 50 20          	mov    %rdx,0x20(%rax)
  80042103d7:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  80042103db:	48 89 50 28          	mov    %rdx,0x28(%rax)
  80042103df:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042103e3:	48 89 50 30          	mov    %rdx,0x30(%rax)
  80042103e7:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  80042103eb:	48 89 50 38          	mov    %rdx,0x38(%rax)
  80042103ef:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  80042103f3:	48 89 50 40          	mov    %rdx,0x40(%rax)
  80042103f7:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  80042103fb:	48 89 50 48          	mov    %rdx,0x48(%rax)
  80042103ff:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004210403:	48 89 50 50          	mov    %rdx,0x50(%rax)
  8004210407:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421040b:	48 89 50 58          	mov    %rdx,0x58(%rax)
    }

    return (ret);
  800421040f:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004210412:	c9                   	leaveq 
  8004210413:	c3                   	retq   

0000008004210414 <dwarf_search_die_within_cu>:

int
dwarf_search_die_within_cu(Dwarf_Debug dbg, Dwarf_CU cu, uint64_t offset, Dwarf_Die *ret_die, int search_sibling)
{
  8004210414:	55                   	push   %rbp
  8004210415:	48 89 e5             	mov    %rsp,%rbp
  8004210418:	48 81 ec d0 03 00 00 	sub    $0x3d0,%rsp
  800421041f:	48 89 bd 88 fc ff ff 	mov    %rdi,-0x378(%rbp)
  8004210426:	48 89 b5 80 fc ff ff 	mov    %rsi,-0x380(%rbp)
  800421042d:	48 89 95 78 fc ff ff 	mov    %rdx,-0x388(%rbp)
  8004210434:	89 8d 74 fc ff ff    	mov    %ecx,-0x38c(%rbp)
    uint64_t abnum;
    uint64_t die_offset;
    int ret, level;
    int i;

    assert(dbg);
  800421043a:	48 83 bd 88 fc ff ff 	cmpq   $0x0,-0x378(%rbp)
  8004210441:	00 
  8004210442:	75 35                	jne    8004210479 <dwarf_search_die_within_cu+0x65>
  8004210444:	48 b9 50 81 21 04 80 	movabs $0x8004218150,%rcx
  800421044b:	00 00 00 
  800421044e:	48 ba c2 7f 21 04 80 	movabs $0x8004217fc2,%rdx
  8004210455:	00 00 00 
  8004210458:	be 86 02 00 00       	mov    $0x286,%esi
  800421045d:	48 bf d7 7f 21 04 80 	movabs $0x8004217fd7,%rdi
  8004210464:	00 00 00 
  8004210467:	b8 00 00 00 00       	mov    $0x0,%eax
  800421046c:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004210473:	00 00 00 
  8004210476:	41 ff d0             	callq  *%r8
    //assert(cu);
    assert(ret_die);
  8004210479:	48 83 bd 78 fc ff ff 	cmpq   $0x0,-0x388(%rbp)
  8004210480:	00 
  8004210481:	75 35                	jne    80042104b8 <dwarf_search_die_within_cu+0xa4>
  8004210483:	48 b9 54 81 21 04 80 	movabs $0x8004218154,%rcx
  800421048a:	00 00 00 
  800421048d:	48 ba c2 7f 21 04 80 	movabs $0x8004217fc2,%rdx
  8004210494:	00 00 00 
  8004210497:	be 88 02 00 00       	mov    $0x288,%esi
  800421049c:	48 bf d7 7f 21 04 80 	movabs $0x8004217fd7,%rdi
  80042104a3:	00 00 00 
  80042104a6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042104ab:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042104b2:	00 00 00 
  80042104b5:	41 ff d0             	callq  *%r8

    level = 1;
  80042104b8:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

    while (offset < cu.cu_next_offset && offset < dbg->dbg_info_size) {
  80042104bf:	e9 17 02 00 00       	jmpq   80042106db <dwarf_search_die_within_cu+0x2c7>

        die_offset = offset;
  80042104c4:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  80042104cb:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

        abnum = _dwarf_read_uleb128((uint8_t *)dbg->dbg_info_offset_elf, &offset);
  80042104cf:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  80042104d6:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042104da:	48 8d 95 80 fc ff ff 	lea    -0x380(%rbp),%rdx
  80042104e1:	48 89 d6             	mov    %rdx,%rsi
  80042104e4:	48 89 c7             	mov    %rax,%rdi
  80042104e7:	48 b8 ed f3 20 04 80 	movabs $0x800420f3ed,%rax
  80042104ee:	00 00 00 
  80042104f1:	ff d0                	callq  *%rax
  80042104f3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

        if (abnum == 0) {
  80042104f7:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042104fc:	75 22                	jne    8004210520 <dwarf_search_die_within_cu+0x10c>
            if (level == 0 || !search_sibling) {
  80042104fe:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004210502:	74 09                	je     800421050d <dwarf_search_die_within_cu+0xf9>
  8004210504:	83 bd 74 fc ff ff 00 	cmpl   $0x0,-0x38c(%rbp)
  800421050b:	75 0a                	jne    8004210517 <dwarf_search_die_within_cu+0x103>
                //No more entry
                return (DW_DLE_NO_ENTRY);
  800421050d:	b8 04 00 00 00       	mov    $0x4,%eax
  8004210512:	e9 f4 01 00 00       	jmpq   800421070b <dwarf_search_die_within_cu+0x2f7>
            }
            /*
             * Return to previous DIE level.
             */
            level--;
  8004210517:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
            continue;
  800421051b:	e9 bb 01 00 00       	jmpq   80042106db <dwarf_search_die_within_cu+0x2c7>
        }

        if ((ret = _dwarf_abbrev_find(dbg, cu, abnum, &ab)) != DW_DLE_NONE)
  8004210520:	48 8d 95 b0 fc ff ff 	lea    -0x350(%rbp),%rdx
  8004210527:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421052b:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  8004210532:	48 8b 75 10          	mov    0x10(%rbp),%rsi
  8004210536:	48 89 34 24          	mov    %rsi,(%rsp)
  800421053a:	48 8b 75 18          	mov    0x18(%rbp),%rsi
  800421053e:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
  8004210543:	48 8b 75 20          	mov    0x20(%rbp),%rsi
  8004210547:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
  800421054c:	48 8b 75 28          	mov    0x28(%rbp),%rsi
  8004210550:	48 89 74 24 18       	mov    %rsi,0x18(%rsp)
  8004210555:	48 8b 75 30          	mov    0x30(%rbp),%rsi
  8004210559:	48 89 74 24 20       	mov    %rsi,0x20(%rsp)
  800421055e:	48 8b 75 38          	mov    0x38(%rbp),%rsi
  8004210562:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
  8004210567:	48 8b 75 40          	mov    0x40(%rbp),%rsi
  800421056b:	48 89 74 24 30       	mov    %rsi,0x30(%rsp)
  8004210570:	48 89 ce             	mov    %rcx,%rsi
  8004210573:	48 89 c7             	mov    %rax,%rdi
  8004210576:	48 b8 52 fc 20 04 80 	movabs $0x800420fc52,%rax
  800421057d:	00 00 00 
  8004210580:	ff d0                	callq  *%rax
  8004210582:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  8004210585:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004210589:	74 08                	je     8004210593 <dwarf_search_die_within_cu+0x17f>
            return (ret);
  800421058b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421058e:	e9 78 01 00 00       	jmpq   800421070b <dwarf_search_die_within_cu+0x2f7>
        ret_die->die_offset = die_offset;
  8004210593:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  800421059a:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800421059e:	48 89 10             	mov    %rdx,(%rax)
        ret_die->die_abnum  = abnum;
  80042105a1:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  80042105a8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042105ac:	48 89 50 10          	mov    %rdx,0x10(%rax)
        ret_die->die_ab  = ab;
  80042105b0:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  80042105b7:	48 8d 78 20          	lea    0x20(%rax),%rdi
  80042105bb:	48 8d 95 b0 fc ff ff 	lea    -0x350(%rbp),%rdx
  80042105c2:	b8 66 00 00 00       	mov    $0x66,%eax
  80042105c7:	48 89 d6             	mov    %rdx,%rsi
  80042105ca:	48 89 c1             	mov    %rax,%rcx
  80042105cd:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
        ret_die->die_attr_count = 0;
  80042105d0:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  80042105d7:	c6 80 58 03 00 00 00 	movb   $0x0,0x358(%rax)
        ret_die->die_tag = ab.ab_tag;
  80042105de:	48 8b 95 b8 fc ff ff 	mov    -0x348(%rbp),%rdx
  80042105e5:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  80042105ec:	48 89 50 18          	mov    %rdx,0x18(%rax)
        //ret_die->die_cu  = cu;
        //ret_die->die_dbg = cu->cu_dbg;

        for (i = 0; i < ab.ab_atnum; i++)
  80042105f0:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  80042105f7:	e9 8e 00 00 00       	jmpq   800421068a <dwarf_search_die_within_cu+0x276>
        {
            if ((ret = _dwarf_attr_init(dbg, &offset, &cu, ret_die, &ab.ab_attrdef[i], ab.ab_attrdef[i].ad_form, 0)) != DW_DLE_NONE)
  80042105fc:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042105ff:	48 63 d0             	movslq %eax,%rdx
  8004210602:	48 89 d0             	mov    %rdx,%rax
  8004210605:	48 01 c0             	add    %rax,%rax
  8004210608:	48 01 d0             	add    %rdx,%rax
  800421060b:	48 c1 e0 03          	shl    $0x3,%rax
  800421060f:	48 01 e8             	add    %rbp,%rax
  8004210612:	48 2d 18 03 00 00    	sub    $0x318,%rax
  8004210618:	48 8b 08             	mov    (%rax),%rcx
  800421061b:	48 8d b5 b0 fc ff ff 	lea    -0x350(%rbp),%rsi
  8004210622:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004210625:	48 63 d0             	movslq %eax,%rdx
  8004210628:	48 89 d0             	mov    %rdx,%rax
  800421062b:	48 01 c0             	add    %rax,%rax
  800421062e:	48 01 d0             	add    %rdx,%rax
  8004210631:	48 c1 e0 03          	shl    $0x3,%rax
  8004210635:	48 83 c0 30          	add    $0x30,%rax
  8004210639:	48 8d 3c 06          	lea    (%rsi,%rax,1),%rdi
  800421063d:	48 8b 95 78 fc ff ff 	mov    -0x388(%rbp),%rdx
  8004210644:	48 8d b5 80 fc ff ff 	lea    -0x380(%rbp),%rsi
  800421064b:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  8004210652:	c7 04 24 00 00 00 00 	movl   $0x0,(%rsp)
  8004210659:	49 89 c9             	mov    %rcx,%r9
  800421065c:	49 89 f8             	mov    %rdi,%r8
  800421065f:	48 89 d1             	mov    %rdx,%rcx
  8004210662:	48 8d 55 10          	lea    0x10(%rbp),%rdx
  8004210666:	48 89 c7             	mov    %rax,%rdi
  8004210669:	48 b8 83 fd 20 04 80 	movabs $0x800420fd83,%rax
  8004210670:	00 00 00 
  8004210673:	ff d0                	callq  *%rax
  8004210675:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  8004210678:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800421067c:	74 08                	je     8004210686 <dwarf_search_die_within_cu+0x272>
                return (ret);
  800421067e:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004210681:	e9 85 00 00 00       	jmpq   800421070b <dwarf_search_die_within_cu+0x2f7>
        ret_die->die_attr_count = 0;
        ret_die->die_tag = ab.ab_tag;
        //ret_die->die_cu  = cu;
        //ret_die->die_dbg = cu->cu_dbg;

        for (i = 0; i < ab.ab_atnum; i++)
  8004210686:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  800421068a:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421068d:	48 63 d0             	movslq %eax,%rdx
  8004210690:	48 8b 85 d8 fc ff ff 	mov    -0x328(%rbp),%rax
  8004210697:	48 39 c2             	cmp    %rax,%rdx
  800421069a:	0f 82 5c ff ff ff    	jb     80042105fc <dwarf_search_die_within_cu+0x1e8>
        {
            if ((ret = _dwarf_attr_init(dbg, &offset, &cu, ret_die, &ab.ab_attrdef[i], ab.ab_attrdef[i].ad_form, 0)) != DW_DLE_NONE)
                return (ret);
        }

        ret_die->die_next_off = offset;
  80042106a0:	48 8b 95 80 fc ff ff 	mov    -0x380(%rbp),%rdx
  80042106a7:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  80042106ae:	48 89 50 08          	mov    %rdx,0x8(%rax)
        if (search_sibling && level > 0) {
  80042106b2:	83 bd 74 fc ff ff 00 	cmpl   $0x0,-0x38c(%rbp)
  80042106b9:	74 19                	je     80042106d4 <dwarf_search_die_within_cu+0x2c0>
  80042106bb:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042106bf:	7e 13                	jle    80042106d4 <dwarf_search_die_within_cu+0x2c0>
            //dwarf_dealloc(dbg, die, DW_DLA_DIE);
            if (ab.ab_children == DW_CHILDREN_yes) {
  80042106c1:	0f b6 85 c0 fc ff ff 	movzbl -0x340(%rbp),%eax
  80042106c8:	3c 01                	cmp    $0x1,%al
  80042106ca:	75 06                	jne    80042106d2 <dwarf_search_die_within_cu+0x2be>
                /* Advance to next DIE level. */
                level++;
  80042106cc:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
        }

        ret_die->die_next_off = offset;
        if (search_sibling && level > 0) {
            //dwarf_dealloc(dbg, die, DW_DLA_DIE);
            if (ab.ab_children == DW_CHILDREN_yes) {
  80042106d0:	eb 09                	jmp    80042106db <dwarf_search_die_within_cu+0x2c7>
  80042106d2:	eb 07                	jmp    80042106db <dwarf_search_die_within_cu+0x2c7>
                /* Advance to next DIE level. */
                level++;
            }
        } else {
            //*ret_die = die;
            return (DW_DLE_NONE);
  80042106d4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042106d9:	eb 30                	jmp    800421070b <dwarf_search_die_within_cu+0x2f7>
    //assert(cu);
    assert(ret_die);

    level = 1;

    while (offset < cu.cu_next_offset && offset < dbg->dbg_info_size) {
  80042106db:	48 8b 55 30          	mov    0x30(%rbp),%rdx
  80042106df:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  80042106e6:	48 39 c2             	cmp    %rax,%rdx
  80042106e9:	76 1b                	jbe    8004210706 <dwarf_search_die_within_cu+0x2f2>
  80042106eb:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  80042106f2:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80042106f6:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  80042106fd:	48 39 c2             	cmp    %rax,%rdx
  8004210700:	0f 87 be fd ff ff    	ja     80042104c4 <dwarf_search_die_within_cu+0xb0>
            //*ret_die = die;
            return (DW_DLE_NONE);
        }
    }

    return (DW_DLE_NO_ENTRY);
  8004210706:	b8 04 00 00 00       	mov    $0x4,%eax
}
  800421070b:	c9                   	leaveq 
  800421070c:	c3                   	retq   

000000800421070d <dwarf_offdie>:

//Return 0 on success
int
dwarf_offdie(Dwarf_Debug dbg, uint64_t offset, Dwarf_Die *ret_die, Dwarf_CU cu)
{
  800421070d:	55                   	push   %rbp
  800421070e:	48 89 e5             	mov    %rsp,%rbp
  8004210711:	48 83 ec 60          	sub    $0x60,%rsp
  8004210715:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210719:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800421071d:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
    int ret;

    assert(dbg);
  8004210721:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004210726:	75 35                	jne    800421075d <dwarf_offdie+0x50>
  8004210728:	48 b9 50 81 21 04 80 	movabs $0x8004218150,%rcx
  800421072f:	00 00 00 
  8004210732:	48 ba c2 7f 21 04 80 	movabs $0x8004217fc2,%rdx
  8004210739:	00 00 00 
  800421073c:	be c4 02 00 00       	mov    $0x2c4,%esi
  8004210741:	48 bf d7 7f 21 04 80 	movabs $0x8004217fd7,%rdi
  8004210748:	00 00 00 
  800421074b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210750:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004210757:	00 00 00 
  800421075a:	41 ff d0             	callq  *%r8
    assert(ret_die);
  800421075d:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004210762:	75 35                	jne    8004210799 <dwarf_offdie+0x8c>
  8004210764:	48 b9 54 81 21 04 80 	movabs $0x8004218154,%rcx
  800421076b:	00 00 00 
  800421076e:	48 ba c2 7f 21 04 80 	movabs $0x8004217fc2,%rdx
  8004210775:	00 00 00 
  8004210778:	be c5 02 00 00       	mov    $0x2c5,%esi
  800421077d:	48 bf d7 7f 21 04 80 	movabs $0x8004217fd7,%rdi
  8004210784:	00 00 00 
  8004210787:	b8 00 00 00 00       	mov    $0x0,%eax
  800421078c:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004210793:	00 00 00 
  8004210796:	41 ff d0             	callq  *%r8

    /* First search the current CU. */
	if (offset < cu.cu_next_offset) {
  8004210799:	48 8b 45 30          	mov    0x30(%rbp),%rax
  800421079d:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  80042107a1:	76 66                	jbe    8004210809 <dwarf_offdie+0xfc>
		ret = dwarf_search_die_within_cu(dbg, cu, offset, ret_die, 0);
  80042107a3:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042107a7:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  80042107ab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042107af:	48 8b 4d 10          	mov    0x10(%rbp),%rcx
  80042107b3:	48 89 0c 24          	mov    %rcx,(%rsp)
  80042107b7:	48 8b 4d 18          	mov    0x18(%rbp),%rcx
  80042107bb:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
  80042107c0:	48 8b 4d 20          	mov    0x20(%rbp),%rcx
  80042107c4:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
  80042107c9:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  80042107cd:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
  80042107d2:	48 8b 4d 30          	mov    0x30(%rbp),%rcx
  80042107d6:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
  80042107db:	48 8b 4d 38          	mov    0x38(%rbp),%rcx
  80042107df:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
  80042107e4:	48 8b 4d 40          	mov    0x40(%rbp),%rcx
  80042107e8:	48 89 4c 24 30       	mov    %rcx,0x30(%rsp)
  80042107ed:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042107f2:	48 89 c7             	mov    %rax,%rdi
  80042107f5:	48 b8 14 04 21 04 80 	movabs $0x8004210414,%rax
  80042107fc:	00 00 00 
  80042107ff:	ff d0                	callq  *%rax
  8004210801:	89 45 fc             	mov    %eax,-0x4(%rbp)
		return ret;
  8004210804:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004210807:	eb 05                	jmp    800421080e <dwarf_offdie+0x101>
	}

    /*TODO: Search other CU*/
    return DW_DLV_OK;
  8004210809:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421080e:	c9                   	leaveq 
  800421080f:	c3                   	retq   

0000008004210810 <_dwarf_attr_find>:

Dwarf_Attribute*
_dwarf_attr_find(Dwarf_Die *die, uint16_t attr)
{
  8004210810:	55                   	push   %rbp
  8004210811:	48 89 e5             	mov    %rsp,%rbp
  8004210814:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004210818:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421081c:	89 f0                	mov    %esi,%eax
  800421081e:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
    Dwarf_Attribute *myat = NULL;
  8004210822:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004210829:	00 
    int i;
    
    for (i = 0; i < die->die_attr_count; i++)
  800421082a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004210831:	eb 57                	jmp    800421088a <_dwarf_attr_find+0x7a>
    {
        if (die->die_attr[i].at_attrib == attr)
  8004210833:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004210837:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421083a:	48 63 d0             	movslq %eax,%rdx
  800421083d:	48 89 d0             	mov    %rdx,%rax
  8004210840:	48 01 c0             	add    %rax,%rax
  8004210843:	48 01 d0             	add    %rdx,%rax
  8004210846:	48 c1 e0 05          	shl    $0x5,%rax
  800421084a:	48 01 c8             	add    %rcx,%rax
  800421084d:	48 05 80 03 00 00    	add    $0x380,%rax
  8004210853:	48 8b 10             	mov    (%rax),%rdx
  8004210856:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  800421085a:	48 39 c2             	cmp    %rax,%rdx
  800421085d:	75 27                	jne    8004210886 <_dwarf_attr_find+0x76>
        {
            myat = &(die->die_attr[i]);
  800421085f:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210862:	48 63 d0             	movslq %eax,%rdx
  8004210865:	48 89 d0             	mov    %rdx,%rax
  8004210868:	48 01 c0             	add    %rax,%rax
  800421086b:	48 01 d0             	add    %rdx,%rax
  800421086e:	48 c1 e0 05          	shl    $0x5,%rax
  8004210872:	48 8d 90 70 03 00 00 	lea    0x370(%rax),%rdx
  8004210879:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421087d:	48 01 d0             	add    %rdx,%rax
  8004210880:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
            break;
  8004210884:	eb 17                	jmp    800421089d <_dwarf_attr_find+0x8d>
_dwarf_attr_find(Dwarf_Die *die, uint16_t attr)
{
    Dwarf_Attribute *myat = NULL;
    int i;
    
    for (i = 0; i < die->die_attr_count; i++)
  8004210886:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  800421088a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421088e:	0f b6 80 58 03 00 00 	movzbl 0x358(%rax),%eax
  8004210895:	0f b6 c0             	movzbl %al,%eax
  8004210898:	3b 45 f4             	cmp    -0xc(%rbp),%eax
  800421089b:	7f 96                	jg     8004210833 <_dwarf_attr_find+0x23>
            myat = &(die->die_attr[i]);
            break;
        }
    }

    return myat;
  800421089d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80042108a1:	c9                   	leaveq 
  80042108a2:	c3                   	retq   

00000080042108a3 <dwarf_siblingof>:

//Return 0 on success
int
dwarf_siblingof(Dwarf_Debug dbg, Dwarf_Die *die, Dwarf_Die *ret_die,
    Dwarf_CU *cu)
{
  80042108a3:	55                   	push   %rbp
  80042108a4:	48 89 e5             	mov    %rsp,%rbp
  80042108a7:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  80042108ab:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80042108af:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  80042108b3:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  80042108b7:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
    Dwarf_Attribute *at;
    uint64_t offset;
    int ret, search_sibling;

    assert(dbg);
  80042108bb:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042108c0:	75 35                	jne    80042108f7 <dwarf_siblingof+0x54>
  80042108c2:	48 b9 50 81 21 04 80 	movabs $0x8004218150,%rcx
  80042108c9:	00 00 00 
  80042108cc:	48 ba c2 7f 21 04 80 	movabs $0x8004217fc2,%rdx
  80042108d3:	00 00 00 
  80042108d6:	be ec 02 00 00       	mov    $0x2ec,%esi
  80042108db:	48 bf d7 7f 21 04 80 	movabs $0x8004217fd7,%rdi
  80042108e2:	00 00 00 
  80042108e5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042108ea:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042108f1:	00 00 00 
  80042108f4:	41 ff d0             	callq  *%r8
    assert(ret_die);
  80042108f7:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  80042108fc:	75 35                	jne    8004210933 <dwarf_siblingof+0x90>
  80042108fe:	48 b9 54 81 21 04 80 	movabs $0x8004218154,%rcx
  8004210905:	00 00 00 
  8004210908:	48 ba c2 7f 21 04 80 	movabs $0x8004217fc2,%rdx
  800421090f:	00 00 00 
  8004210912:	be ed 02 00 00       	mov    $0x2ed,%esi
  8004210917:	48 bf d7 7f 21 04 80 	movabs $0x8004217fd7,%rdi
  800421091e:	00 00 00 
  8004210921:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210926:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800421092d:	00 00 00 
  8004210930:	41 ff d0             	callq  *%r8
    assert(cu);
  8004210933:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004210938:	75 35                	jne    800421096f <dwarf_siblingof+0xcc>
  800421093a:	48 b9 5c 81 21 04 80 	movabs $0x800421815c,%rcx
  8004210941:	00 00 00 
  8004210944:	48 ba c2 7f 21 04 80 	movabs $0x8004217fc2,%rdx
  800421094b:	00 00 00 
  800421094e:	be ee 02 00 00       	mov    $0x2ee,%esi
  8004210953:	48 bf d7 7f 21 04 80 	movabs $0x8004217fd7,%rdi
  800421095a:	00 00 00 
  800421095d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210962:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004210969:	00 00 00 
  800421096c:	41 ff d0             	callq  *%r8

    /* Application requests the first DIE in this CU. */
    if (die == NULL)
  800421096f:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004210974:	75 65                	jne    80042109db <dwarf_siblingof+0x138>
        return (dwarf_offdie(dbg, cu->cu_die_offset, ret_die, *cu));
  8004210976:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421097a:	48 8b 70 28          	mov    0x28(%rax),%rsi
  800421097e:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004210982:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004210986:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421098a:	48 8b 38             	mov    (%rax),%rdi
  800421098d:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004210991:	48 8b 78 08          	mov    0x8(%rax),%rdi
  8004210995:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  800421099a:	48 8b 78 10          	mov    0x10(%rax),%rdi
  800421099e:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  80042109a3:	48 8b 78 18          	mov    0x18(%rax),%rdi
  80042109a7:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  80042109ac:	48 8b 78 20          	mov    0x20(%rax),%rdi
  80042109b0:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  80042109b5:	48 8b 78 28          	mov    0x28(%rax),%rdi
  80042109b9:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  80042109be:	48 8b 40 30          	mov    0x30(%rax),%rax
  80042109c2:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  80042109c7:	48 89 cf             	mov    %rcx,%rdi
  80042109ca:	48 b8 0d 07 21 04 80 	movabs $0x800421070d,%rax
  80042109d1:	00 00 00 
  80042109d4:	ff d0                	callq  *%rax
  80042109d6:	e9 0a 01 00 00       	jmpq   8004210ae5 <dwarf_siblingof+0x242>

    /*
     * If the DIE doesn't have any children, its sibling sits next
     * right to it.
     */
    search_sibling = 0;
  80042109db:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
    if (die->die_ab.ab_children == DW_CHILDREN_no)
  80042109e2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042109e6:	0f b6 40 30          	movzbl 0x30(%rax),%eax
  80042109ea:	84 c0                	test   %al,%al
  80042109ec:	75 0e                	jne    80042109fc <dwarf_siblingof+0x159>
        offset = die->die_next_off;
  80042109ee:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042109f2:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042109f6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042109fa:	eb 6b                	jmp    8004210a67 <dwarf_siblingof+0x1c4>
    else {
        /*
         * Look for DW_AT_sibling attribute for the offset of
         * its sibling.
         */
        if ((at = _dwarf_attr_find(die, DW_AT_sibling)) != NULL) {
  80042109fc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210a00:	be 01 00 00 00       	mov    $0x1,%esi
  8004210a05:	48 89 c7             	mov    %rax,%rdi
  8004210a08:	48 b8 10 08 21 04 80 	movabs $0x8004210810,%rax
  8004210a0f:	00 00 00 
  8004210a12:	ff d0                	callq  *%rax
  8004210a14:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004210a18:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004210a1d:	74 35                	je     8004210a54 <dwarf_siblingof+0x1b1>
            if (at->at_form != DW_FORM_ref_addr)
  8004210a1f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210a23:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210a27:	48 83 f8 10          	cmp    $0x10,%rax
  8004210a2b:	74 19                	je     8004210a46 <dwarf_siblingof+0x1a3>
                offset = at->u[0].u64 + cu->cu_offset;
  8004210a2d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210a31:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004210a35:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210a39:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004210a3d:	48 01 d0             	add    %rdx,%rax
  8004210a40:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004210a44:	eb 21                	jmp    8004210a67 <dwarf_siblingof+0x1c4>
            else
                offset = at->u[0].u64;
  8004210a46:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210a4a:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004210a4e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004210a52:	eb 13                	jmp    8004210a67 <dwarf_siblingof+0x1c4>
        } else {
            offset = die->die_next_off;
  8004210a54:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210a58:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004210a5c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
            search_sibling = 1;
  8004210a60:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)
        }
    }

    ret = dwarf_search_die_within_cu(dbg, *cu, offset, ret_die, search_sibling);
  8004210a67:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  8004210a6a:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004210a6e:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  8004210a72:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
  8004210a76:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210a7a:	4c 8b 00             	mov    (%rax),%r8
  8004210a7d:	4c 89 04 24          	mov    %r8,(%rsp)
  8004210a81:	4c 8b 40 08          	mov    0x8(%rax),%r8
  8004210a85:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  8004210a8a:	4c 8b 40 10          	mov    0x10(%rax),%r8
  8004210a8e:	4c 89 44 24 10       	mov    %r8,0x10(%rsp)
  8004210a93:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004210a97:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
  8004210a9c:	4c 8b 40 20          	mov    0x20(%rax),%r8
  8004210aa0:	4c 89 44 24 20       	mov    %r8,0x20(%rsp)
  8004210aa5:	4c 8b 40 28          	mov    0x28(%rax),%r8
  8004210aa9:	4c 89 44 24 28       	mov    %r8,0x28(%rsp)
  8004210aae:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004210ab2:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  8004210ab7:	48 b8 14 04 21 04 80 	movabs $0x8004210414,%rax
  8004210abe:	00 00 00 
  8004210ac1:	ff d0                	callq  *%rax
  8004210ac3:	89 45 e4             	mov    %eax,-0x1c(%rbp)


    if (ret == DW_DLE_NO_ENTRY) {
  8004210ac6:	83 7d e4 04          	cmpl   $0x4,-0x1c(%rbp)
  8004210aca:	75 07                	jne    8004210ad3 <dwarf_siblingof+0x230>
        return (DW_DLV_NO_ENTRY);
  8004210acc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004210ad1:	eb 12                	jmp    8004210ae5 <dwarf_siblingof+0x242>
    } else if (ret != DW_DLE_NONE)
  8004210ad3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004210ad7:	74 07                	je     8004210ae0 <dwarf_siblingof+0x23d>
        return (DW_DLV_ERROR);
  8004210ad9:	b8 01 00 00 00       	mov    $0x1,%eax
  8004210ade:	eb 05                	jmp    8004210ae5 <dwarf_siblingof+0x242>


    return (DW_DLV_OK);
  8004210ae0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004210ae5:	c9                   	leaveq 
  8004210ae6:	c3                   	retq   

0000008004210ae7 <dwarf_child>:

int
dwarf_child(Dwarf_Debug dbg, Dwarf_CU *cu, Dwarf_Die *die, Dwarf_Die *ret_die)
{
  8004210ae7:	55                   	push   %rbp
  8004210ae8:	48 89 e5             	mov    %rsp,%rbp
  8004210aeb:	48 83 ec 70          	sub    $0x70,%rsp
  8004210aef:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210af3:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004210af7:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004210afb:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
    int ret;

    assert(die);
  8004210aff:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004210b04:	75 35                	jne    8004210b3b <dwarf_child+0x54>
  8004210b06:	48 b9 5f 81 21 04 80 	movabs $0x800421815f,%rcx
  8004210b0d:	00 00 00 
  8004210b10:	48 ba c2 7f 21 04 80 	movabs $0x8004217fc2,%rdx
  8004210b17:	00 00 00 
  8004210b1a:	be 1c 03 00 00       	mov    $0x31c,%esi
  8004210b1f:	48 bf d7 7f 21 04 80 	movabs $0x8004217fd7,%rdi
  8004210b26:	00 00 00 
  8004210b29:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210b2e:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004210b35:	00 00 00 
  8004210b38:	41 ff d0             	callq  *%r8
    assert(ret_die);
  8004210b3b:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004210b40:	75 35                	jne    8004210b77 <dwarf_child+0x90>
  8004210b42:	48 b9 54 81 21 04 80 	movabs $0x8004218154,%rcx
  8004210b49:	00 00 00 
  8004210b4c:	48 ba c2 7f 21 04 80 	movabs $0x8004217fc2,%rdx
  8004210b53:	00 00 00 
  8004210b56:	be 1d 03 00 00       	mov    $0x31d,%esi
  8004210b5b:	48 bf d7 7f 21 04 80 	movabs $0x8004217fd7,%rdi
  8004210b62:	00 00 00 
  8004210b65:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210b6a:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004210b71:	00 00 00 
  8004210b74:	41 ff d0             	callq  *%r8
    assert(dbg);
  8004210b77:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004210b7c:	75 35                	jne    8004210bb3 <dwarf_child+0xcc>
  8004210b7e:	48 b9 50 81 21 04 80 	movabs $0x8004218150,%rcx
  8004210b85:	00 00 00 
  8004210b88:	48 ba c2 7f 21 04 80 	movabs $0x8004217fc2,%rdx
  8004210b8f:	00 00 00 
  8004210b92:	be 1e 03 00 00       	mov    $0x31e,%esi
  8004210b97:	48 bf d7 7f 21 04 80 	movabs $0x8004217fd7,%rdi
  8004210b9e:	00 00 00 
  8004210ba1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210ba6:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004210bad:	00 00 00 
  8004210bb0:	41 ff d0             	callq  *%r8
    assert(cu);
  8004210bb3:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004210bb8:	75 35                	jne    8004210bef <dwarf_child+0x108>
  8004210bba:	48 b9 5c 81 21 04 80 	movabs $0x800421815c,%rcx
  8004210bc1:	00 00 00 
  8004210bc4:	48 ba c2 7f 21 04 80 	movabs $0x8004217fc2,%rdx
  8004210bcb:	00 00 00 
  8004210bce:	be 1f 03 00 00       	mov    $0x31f,%esi
  8004210bd3:	48 bf d7 7f 21 04 80 	movabs $0x8004217fd7,%rdi
  8004210bda:	00 00 00 
  8004210bdd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210be2:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004210be9:	00 00 00 
  8004210bec:	41 ff d0             	callq  *%r8

    if (die->die_ab.ab_children == DW_CHILDREN_no)
  8004210bef:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210bf3:	0f b6 40 30          	movzbl 0x30(%rax),%eax
  8004210bf7:	84 c0                	test   %al,%al
  8004210bf9:	75 0a                	jne    8004210c05 <dwarf_child+0x11e>
        return (DW_DLE_NO_ENTRY);
  8004210bfb:	b8 04 00 00 00       	mov    $0x4,%eax
  8004210c00:	e9 84 00 00 00       	jmpq   8004210c89 <dwarf_child+0x1a2>

    ret = dwarf_search_die_within_cu(dbg, *cu, die->die_next_off, ret_die, 0);
  8004210c05:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210c09:	48 8b 70 08          	mov    0x8(%rax),%rsi
  8004210c0d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210c11:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  8004210c15:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210c19:	48 8b 08             	mov    (%rax),%rcx
  8004210c1c:	48 89 0c 24          	mov    %rcx,(%rsp)
  8004210c20:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004210c24:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
  8004210c29:	48 8b 48 10          	mov    0x10(%rax),%rcx
  8004210c2d:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
  8004210c32:	48 8b 48 18          	mov    0x18(%rax),%rcx
  8004210c36:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
  8004210c3b:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004210c3f:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
  8004210c44:	48 8b 48 28          	mov    0x28(%rax),%rcx
  8004210c48:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
  8004210c4d:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004210c51:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  8004210c56:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004210c5b:	48 b8 14 04 21 04 80 	movabs $0x8004210414,%rax
  8004210c62:	00 00 00 
  8004210c65:	ff d0                	callq  *%rax
  8004210c67:	89 45 fc             	mov    %eax,-0x4(%rbp)

    if (ret == DW_DLE_NO_ENTRY) {
  8004210c6a:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  8004210c6e:	75 07                	jne    8004210c77 <dwarf_child+0x190>
        DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
        return (DW_DLV_NO_ENTRY);
  8004210c70:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004210c75:	eb 12                	jmp    8004210c89 <dwarf_child+0x1a2>
    } else if (ret != DW_DLE_NONE)
  8004210c77:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004210c7b:	74 07                	je     8004210c84 <dwarf_child+0x19d>
        return (DW_DLV_ERROR);
  8004210c7d:	b8 01 00 00 00       	mov    $0x1,%eax
  8004210c82:	eb 05                	jmp    8004210c89 <dwarf_child+0x1a2>

    return (DW_DLV_OK);
  8004210c84:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004210c89:	c9                   	leaveq 
  8004210c8a:	c3                   	retq   

0000008004210c8b <_dwarf_find_section_enhanced>:


int  _dwarf_find_section_enhanced(Dwarf_Section *ds)
{
  8004210c8b:	55                   	push   %rbp
  8004210c8c:	48 89 e5             	mov    %rsp,%rbp
  8004210c8f:	48 83 ec 20          	sub    $0x20,%rsp
  8004210c93:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    Dwarf_Section *secthdr = _dwarf_find_section(ds->ds_name);
  8004210c97:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210c9b:	48 8b 00             	mov    (%rax),%rax
  8004210c9e:	48 89 c7             	mov    %rax,%rdi
  8004210ca1:	48 b8 82 3f 21 04 80 	movabs $0x8004213f82,%rax
  8004210ca8:	00 00 00 
  8004210cab:	ff d0                	callq  *%rax
  8004210cad:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    ds->ds_data = secthdr->ds_data;//(Dwarf_Small*)((uint8_t *)elf_base_ptr + secthdr->sh_offset);
  8004210cb1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210cb5:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004210cb9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210cbd:	48 89 50 08          	mov    %rdx,0x8(%rax)
    ds->ds_addr = secthdr->ds_addr;
  8004210cc1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210cc5:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004210cc9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210ccd:	48 89 50 10          	mov    %rdx,0x10(%rax)
    ds->ds_size = secthdr->ds_size;
  8004210cd1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210cd5:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004210cd9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210cdd:	48 89 50 18          	mov    %rdx,0x18(%rax)
    return 0;
  8004210ce1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004210ce6:	c9                   	leaveq 
  8004210ce7:	c3                   	retq   

0000008004210ce8 <_dwarf_frame_params_init>:

extern int  _dwarf_find_section_enhanced(Dwarf_Section *ds);

void
_dwarf_frame_params_init(Dwarf_Debug dbg)
{
  8004210ce8:	55                   	push   %rbp
  8004210ce9:	48 89 e5             	mov    %rsp,%rbp
  8004210cec:	48 83 ec 08          	sub    $0x8,%rsp
  8004210cf0:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
        /* Initialise call frame related parameters. */
        dbg->dbg_frame_rule_table_size = DW_FRAME_LAST_REG_NUM;
  8004210cf4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210cf8:	66 c7 40 48 42 00    	movw   $0x42,0x48(%rax)
        dbg->dbg_frame_rule_initial_value = DW_FRAME_REG_INITIAL_VALUE;
  8004210cfe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210d02:	66 c7 40 4a 0b 04    	movw   $0x40b,0x4a(%rax)
        dbg->dbg_frame_cfa_value = DW_FRAME_CFA_COL3;
  8004210d08:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210d0c:	66 c7 40 4c 9c 05    	movw   $0x59c,0x4c(%rax)
        dbg->dbg_frame_same_value = DW_FRAME_SAME_VAL;
  8004210d12:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210d16:	66 c7 40 4e 0b 04    	movw   $0x40b,0x4e(%rax)
        dbg->dbg_frame_undefined_value = DW_FRAME_UNDEFINED_VAL;
  8004210d1c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210d20:	66 c7 40 50 0a 04    	movw   $0x40a,0x50(%rax)
}
  8004210d26:	c9                   	leaveq 
  8004210d27:	c3                   	retq   

0000008004210d28 <dwarf_get_fde_at_pc>:

int
dwarf_get_fde_at_pc(Dwarf_Debug dbg, Dwarf_Addr pc,
    Dwarf_Fde ret_fde, Dwarf_Cie cie,
    Dwarf_Error *error)
{
  8004210d28:	55                   	push   %rbp
  8004210d29:	48 89 e5             	mov    %rsp,%rbp
  8004210d2c:	48 83 ec 40          	sub    $0x40,%rsp
  8004210d30:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210d34:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004210d38:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004210d3c:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  8004210d40:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
        Dwarf_Fde fde = ret_fde;
  8004210d44:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210d48:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
        memset(fde, 0, sizeof(struct _Dwarf_Fde));
  8004210d4c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210d50:	ba 80 00 00 00       	mov    $0x80,%edx
  8004210d55:	be 00 00 00 00       	mov    $0x0,%esi
  8004210d5a:	48 89 c7             	mov    %rax,%rdi
  8004210d5d:	48 b8 db e8 20 04 80 	movabs $0x800420e8db,%rax
  8004210d64:	00 00 00 
  8004210d67:	ff d0                	callq  *%rax
        fde->fde_cie = cie;
  8004210d69:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210d6d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210d71:	48 89 50 08          	mov    %rdx,0x8(%rax)

        if (ret_fde == NULL)
  8004210d75:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004210d7a:	75 07                	jne    8004210d83 <dwarf_get_fde_at_pc+0x5b>
                return (DW_DLV_ERROR);
  8004210d7c:	b8 01 00 00 00       	mov    $0x1,%eax
  8004210d81:	eb 75                	jmp    8004210df8 <dwarf_get_fde_at_pc+0xd0>

        while (dbg->curr_off_eh < dbg->dbg_eh_size) {
  8004210d83:	eb 59                	jmp    8004210dde <dwarf_get_fde_at_pc+0xb6>
                if (_dwarf_get_next_fde(dbg, true, error, fde) < 0)
  8004210d85:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  8004210d89:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004210d8d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210d91:	be 01 00 00 00       	mov    $0x1,%esi
  8004210d96:	48 89 c7             	mov    %rax,%rdi
  8004210d99:	48 b8 38 2f 21 04 80 	movabs $0x8004212f38,%rax
  8004210da0:	00 00 00 
  8004210da3:	ff d0                	callq  *%rax
  8004210da5:	85 c0                	test   %eax,%eax
  8004210da7:	79 07                	jns    8004210db0 <dwarf_get_fde_at_pc+0x88>
                        return DW_DLV_NO_ENTRY;
  8004210da9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004210dae:	eb 48                	jmp    8004210df8 <dwarf_get_fde_at_pc+0xd0>
                if (pc >= fde->fde_initloc && pc < fde->fde_initloc +
  8004210db0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210db4:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004210db8:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004210dbc:	77 20                	ja     8004210dde <dwarf_get_fde_at_pc+0xb6>
  8004210dbe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210dc2:	48 8b 50 30          	mov    0x30(%rax),%rdx
                    fde->fde_adrange)
  8004210dc6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210dca:	48 8b 40 38          	mov    0x38(%rax),%rax
                return (DW_DLV_ERROR);

        while (dbg->curr_off_eh < dbg->dbg_eh_size) {
                if (_dwarf_get_next_fde(dbg, true, error, fde) < 0)
                        return DW_DLV_NO_ENTRY;
                if (pc >= fde->fde_initloc && pc < fde->fde_initloc +
  8004210dce:	48 01 d0             	add    %rdx,%rax
  8004210dd1:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004210dd5:	76 07                	jbe    8004210dde <dwarf_get_fde_at_pc+0xb6>
                    fde->fde_adrange)
                        return (DW_DLV_OK);
  8004210dd7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210ddc:	eb 1a                	jmp    8004210df8 <dwarf_get_fde_at_pc+0xd0>
        fde->fde_cie = cie;

        if (ret_fde == NULL)
                return (DW_DLV_ERROR);

        while (dbg->curr_off_eh < dbg->dbg_eh_size) {
  8004210dde:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210de2:	48 8b 50 30          	mov    0x30(%rax),%rdx
  8004210de6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210dea:	48 8b 40 40          	mov    0x40(%rax),%rax
  8004210dee:	48 39 c2             	cmp    %rax,%rdx
  8004210df1:	72 92                	jb     8004210d85 <dwarf_get_fde_at_pc+0x5d>
                    fde->fde_adrange)
                        return (DW_DLV_OK);
        }

        DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
        return (DW_DLV_NO_ENTRY);
  8004210df3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  8004210df8:	c9                   	leaveq 
  8004210df9:	c3                   	retq   

0000008004210dfa <_dwarf_frame_regtable_copy>:

int
_dwarf_frame_regtable_copy(Dwarf_Debug dbg, Dwarf_Regtable3 **dest,
    Dwarf_Regtable3 *src, Dwarf_Error *error)
{
  8004210dfa:	55                   	push   %rbp
  8004210dfb:	48 89 e5             	mov    %rsp,%rbp
  8004210dfe:	53                   	push   %rbx
  8004210dff:	48 83 ec 38          	sub    $0x38,%rsp
  8004210e03:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004210e07:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004210e0b:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004210e0f:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
        int i;

        assert(dest != NULL);
  8004210e13:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004210e18:	75 35                	jne    8004210e4f <_dwarf_frame_regtable_copy+0x55>
  8004210e1a:	48 b9 72 81 21 04 80 	movabs $0x8004218172,%rcx
  8004210e21:	00 00 00 
  8004210e24:	48 ba 7f 81 21 04 80 	movabs $0x800421817f,%rdx
  8004210e2b:	00 00 00 
  8004210e2e:	be 55 00 00 00       	mov    $0x55,%esi
  8004210e33:	48 bf 94 81 21 04 80 	movabs $0x8004218194,%rdi
  8004210e3a:	00 00 00 
  8004210e3d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210e42:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004210e49:	00 00 00 
  8004210e4c:	41 ff d0             	callq  *%r8
        assert(src != NULL);
  8004210e4f:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004210e54:	75 35                	jne    8004210e8b <_dwarf_frame_regtable_copy+0x91>
  8004210e56:	48 b9 aa 81 21 04 80 	movabs $0x80042181aa,%rcx
  8004210e5d:	00 00 00 
  8004210e60:	48 ba 7f 81 21 04 80 	movabs $0x800421817f,%rdx
  8004210e67:	00 00 00 
  8004210e6a:	be 56 00 00 00       	mov    $0x56,%esi
  8004210e6f:	48 bf 94 81 21 04 80 	movabs $0x8004218194,%rdi
  8004210e76:	00 00 00 
  8004210e79:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210e7e:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004210e85:	00 00 00 
  8004210e88:	41 ff d0             	callq  *%r8

        if (*dest == NULL) {
  8004210e8b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210e8f:	48 8b 00             	mov    (%rax),%rax
  8004210e92:	48 85 c0             	test   %rax,%rax
  8004210e95:	75 39                	jne    8004210ed0 <_dwarf_frame_regtable_copy+0xd6>
                *dest = &global_rt_table_shadow;
  8004210e97:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210e9b:	48 bb 60 67 49 04 80 	movabs $0x8004496760,%rbx
  8004210ea2:	00 00 00 
  8004210ea5:	48 89 18             	mov    %rbx,(%rax)
                (*dest)->rt3_reg_table_size = src->rt3_reg_table_size;
  8004210ea8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210eac:	48 8b 00             	mov    (%rax),%rax
  8004210eaf:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004210eb3:	0f b7 52 18          	movzwl 0x18(%rdx),%edx
  8004210eb7:	66 89 50 18          	mov    %dx,0x18(%rax)
                (*dest)->rt3_rules = global_rules_shadow;
  8004210ebb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210ebf:	48 8b 00             	mov    (%rax),%rax
  8004210ec2:	48 bb 20 69 49 04 80 	movabs $0x8004496920,%rbx
  8004210ec9:	00 00 00 
  8004210ecc:	48 89 58 20          	mov    %rbx,0x20(%rax)
        }

        memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
  8004210ed0:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  8004210ed4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210ed8:	48 8b 00             	mov    (%rax),%rax
  8004210edb:	ba 18 00 00 00       	mov    $0x18,%edx
  8004210ee0:	48 89 ce             	mov    %rcx,%rsi
  8004210ee3:	48 89 c7             	mov    %rax,%rdi
  8004210ee6:	48 b8 7d ea 20 04 80 	movabs $0x800420ea7d,%rax
  8004210eed:	00 00 00 
  8004210ef0:	ff d0                	callq  *%rax
            sizeof(Dwarf_Regtable_Entry3));

        for (i = 0; i < (*dest)->rt3_reg_table_size &&
  8004210ef2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004210ef9:	eb 5a                	jmp    8004210f55 <_dwarf_frame_regtable_copy+0x15b>
             i < src->rt3_reg_table_size; i++)
                memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
  8004210efb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210eff:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004210f03:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004210f06:	48 63 d0             	movslq %eax,%rdx
  8004210f09:	48 89 d0             	mov    %rdx,%rax
  8004210f0c:	48 01 c0             	add    %rax,%rax
  8004210f0f:	48 01 d0             	add    %rdx,%rax
  8004210f12:	48 c1 e0 03          	shl    $0x3,%rax
  8004210f16:	48 01 c1             	add    %rax,%rcx
  8004210f19:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210f1d:	48 8b 00             	mov    (%rax),%rax
  8004210f20:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004210f24:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004210f27:	48 63 d0             	movslq %eax,%rdx
  8004210f2a:	48 89 d0             	mov    %rdx,%rax
  8004210f2d:	48 01 c0             	add    %rax,%rax
  8004210f30:	48 01 d0             	add    %rdx,%rax
  8004210f33:	48 c1 e0 03          	shl    $0x3,%rax
  8004210f37:	48 01 f0             	add    %rsi,%rax
  8004210f3a:	ba 18 00 00 00       	mov    $0x18,%edx
  8004210f3f:	48 89 ce             	mov    %rcx,%rsi
  8004210f42:	48 89 c7             	mov    %rax,%rdi
  8004210f45:	48 b8 7d ea 20 04 80 	movabs $0x800420ea7d,%rax
  8004210f4c:	00 00 00 
  8004210f4f:	ff d0                	callq  *%rax

        memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
            sizeof(Dwarf_Regtable_Entry3));

        for (i = 0; i < (*dest)->rt3_reg_table_size &&
             i < src->rt3_reg_table_size; i++)
  8004210f51:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
        }

        memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
            sizeof(Dwarf_Regtable_Entry3));

        for (i = 0; i < (*dest)->rt3_reg_table_size &&
  8004210f55:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210f59:	48 8b 00             	mov    (%rax),%rax
  8004210f5c:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004210f60:	0f b7 c0             	movzwl %ax,%eax
  8004210f63:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004210f66:	7e 10                	jle    8004210f78 <_dwarf_frame_regtable_copy+0x17e>
             i < src->rt3_reg_table_size; i++)
  8004210f68:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210f6c:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004210f70:	0f b7 c0             	movzwl %ax,%eax
        }

        memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
            sizeof(Dwarf_Regtable_Entry3));

        for (i = 0; i < (*dest)->rt3_reg_table_size &&
  8004210f73:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004210f76:	7f 83                	jg     8004210efb <_dwarf_frame_regtable_copy+0x101>
             i < src->rt3_reg_table_size; i++)
                memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
                    sizeof(Dwarf_Regtable_Entry3));

        for (; i < (*dest)->rt3_reg_table_size; i++)
  8004210f78:	eb 32                	jmp    8004210fac <_dwarf_frame_regtable_copy+0x1b2>
                (*dest)->rt3_rules[i].dw_regnum =
  8004210f7a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210f7e:	48 8b 00             	mov    (%rax),%rax
  8004210f81:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004210f85:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004210f88:	48 63 d0             	movslq %eax,%rdx
  8004210f8b:	48 89 d0             	mov    %rdx,%rax
  8004210f8e:	48 01 c0             	add    %rax,%rax
  8004210f91:	48 01 d0             	add    %rdx,%rax
  8004210f94:	48 c1 e0 03          	shl    $0x3,%rax
  8004210f98:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
                    dbg->dbg_frame_undefined_value;
  8004210f9c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210fa0:	0f b7 40 50          	movzwl 0x50(%rax),%eax
             i < src->rt3_reg_table_size; i++)
                memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
                    sizeof(Dwarf_Regtable_Entry3));

        for (; i < (*dest)->rt3_reg_table_size; i++)
                (*dest)->rt3_rules[i].dw_regnum =
  8004210fa4:	66 89 42 02          	mov    %ax,0x2(%rdx)
        for (i = 0; i < (*dest)->rt3_reg_table_size &&
             i < src->rt3_reg_table_size; i++)
                memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
                    sizeof(Dwarf_Regtable_Entry3));

        for (; i < (*dest)->rt3_reg_table_size; i++)
  8004210fa8:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004210fac:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210fb0:	48 8b 00             	mov    (%rax),%rax
  8004210fb3:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004210fb7:	0f b7 c0             	movzwl %ax,%eax
  8004210fba:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004210fbd:	7f bb                	jg     8004210f7a <_dwarf_frame_regtable_copy+0x180>
                (*dest)->rt3_rules[i].dw_regnum =
                    dbg->dbg_frame_undefined_value;

        return (DW_DLE_NONE);
  8004210fbf:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004210fc4:	48 83 c4 38          	add    $0x38,%rsp
  8004210fc8:	5b                   	pop    %rbx
  8004210fc9:	5d                   	pop    %rbp
  8004210fca:	c3                   	retq   

0000008004210fcb <_dwarf_frame_run_inst>:

static int
_dwarf_frame_run_inst(Dwarf_Debug dbg, Dwarf_Regtable3 *rt, uint8_t *insts,
    Dwarf_Unsigned len, Dwarf_Unsigned caf, Dwarf_Signed daf, Dwarf_Addr pc,
    Dwarf_Addr pc_req, Dwarf_Addr *row_pc, Dwarf_Error *error)
{
  8004210fcb:	55                   	push   %rbp
  8004210fcc:	48 89 e5             	mov    %rsp,%rbp
  8004210fcf:	53                   	push   %rbx
  8004210fd0:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
  8004210fd7:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  8004210fdb:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
  8004210fdf:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
  8004210fe3:	48 89 4d 80          	mov    %rcx,-0x80(%rbp)
  8004210fe7:	4c 89 85 78 ff ff ff 	mov    %r8,-0x88(%rbp)
  8004210fee:	4c 89 8d 70 ff ff ff 	mov    %r9,-0x90(%rbp)
                        ret = DW_DLE_DF_REG_NUM_TOO_HIGH;               \
                        goto program_done;                              \
                }                                                       \
        } while (0)

        ret = DW_DLE_NONE;
  8004210ff5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
        init_rt = saved_rt = NULL;
  8004210ffc:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  8004211003:	00 
  8004211004:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004211008:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
        *row_pc = pc;
  800421100c:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211010:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211014:	48 89 10             	mov    %rdx,(%rax)

        /* Save a copy of the table as initial state. */
        _dwarf_frame_regtable_copy(dbg, &init_rt, rt, error);
  8004211017:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  800421101b:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  800421101f:	48 8d 75 b0          	lea    -0x50(%rbp),%rsi
  8004211023:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211027:	48 89 c7             	mov    %rax,%rdi
  800421102a:	48 b8 fa 0d 21 04 80 	movabs $0x8004210dfa,%rax
  8004211031:	00 00 00 
  8004211034:	ff d0                	callq  *%rax
        p = insts;
  8004211036:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800421103a:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
        pe = p + len;
  800421103e:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004211042:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004211046:	48 01 d0             	add    %rdx,%rax
  8004211049:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

        while (p < pe) {
  800421104d:	e9 3a 0d 00 00       	jmpq   8004211d8c <_dwarf_frame_run_inst+0xdc1>
                if (*p == DW_CFA_nop) {
  8004211052:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004211056:	0f b6 00             	movzbl (%rax),%eax
  8004211059:	84 c0                	test   %al,%al
  800421105b:	75 11                	jne    800421106e <_dwarf_frame_run_inst+0xa3>
                        p++;
  800421105d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004211061:	48 83 c0 01          	add    $0x1,%rax
  8004211065:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
                        continue;
  8004211069:	e9 1e 0d 00 00       	jmpq   8004211d8c <_dwarf_frame_run_inst+0xdc1>
                }

                high2 = *p & 0xc0;
  800421106e:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004211072:	0f b6 00             	movzbl (%rax),%eax
  8004211075:	83 e0 c0             	and    $0xffffffc0,%eax
  8004211078:	88 45 df             	mov    %al,-0x21(%rbp)
                low6 = *p & 0x3f;
  800421107b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421107f:	0f b6 00             	movzbl (%rax),%eax
  8004211082:	83 e0 3f             	and    $0x3f,%eax
  8004211085:	88 45 de             	mov    %al,-0x22(%rbp)
                p++;
  8004211088:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421108c:	48 83 c0 01          	add    $0x1,%rax
  8004211090:	48 89 45 a0          	mov    %rax,-0x60(%rbp)

                if (high2 > 0) {
  8004211094:	80 7d df 00          	cmpb   $0x0,-0x21(%rbp)
  8004211098:	0f 84 a1 01 00 00    	je     800421123f <_dwarf_frame_run_inst+0x274>
                        switch (high2) {
  800421109e:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  80042110a2:	3d 80 00 00 00       	cmp    $0x80,%eax
  80042110a7:	74 38                	je     80042110e1 <_dwarf_frame_run_inst+0x116>
  80042110a9:	3d c0 00 00 00       	cmp    $0xc0,%eax
  80042110ae:	0f 84 01 01 00 00    	je     80042111b5 <_dwarf_frame_run_inst+0x1ea>
  80042110b4:	83 f8 40             	cmp    $0x40,%eax
  80042110b7:	0f 85 71 01 00 00    	jne    800421122e <_dwarf_frame_run_inst+0x263>
                        case DW_CFA_advance_loc:
                                pc += low6 * caf;
  80042110bd:	0f b6 45 de          	movzbl -0x22(%rbp),%eax
  80042110c1:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  80042110c8:	ff 
  80042110c9:	48 01 45 10          	add    %rax,0x10(%rbp)
                                if (pc_req < pc)
  80042110cd:	48 8b 45 18          	mov    0x18(%rbp),%rax
  80042110d1:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  80042110d5:	73 05                	jae    80042110dc <_dwarf_frame_run_inst+0x111>
                                        goto program_done;
  80042110d7:	e9 be 0c 00 00       	jmpq   8004211d9a <_dwarf_frame_run_inst+0xdcf>
                                break;
  80042110dc:	e9 59 01 00 00       	jmpq   800421123a <_dwarf_frame_run_inst+0x26f>
                        case DW_CFA_offset:
                                *row_pc = pc;
  80042110e1:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042110e5:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042110e9:	48 89 10             	mov    %rdx,(%rax)
                                CHECK_TABLE_SIZE(low6);
  80042110ec:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  80042110f0:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042110f4:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042110f8:	66 39 c2             	cmp    %ax,%dx
  80042110fb:	72 0c                	jb     8004211109 <_dwarf_frame_run_inst+0x13e>
  80042110fd:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004211104:	e9 91 0c 00 00       	jmpq   8004211d9a <_dwarf_frame_run_inst+0xdcf>
                                RL[low6].dw_offset_relevant = 1;
  8004211109:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421110d:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211111:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004211115:	48 89 d0             	mov    %rdx,%rax
  8004211118:	48 01 c0             	add    %rax,%rax
  800421111b:	48 01 d0             	add    %rdx,%rax
  800421111e:	48 c1 e0 03          	shl    $0x3,%rax
  8004211122:	48 01 c8             	add    %rcx,%rax
  8004211125:	c6 00 01             	movb   $0x1,(%rax)
                                RL[low6].dw_value_type = DW_EXPR_OFFSET;
  8004211128:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421112c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211130:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004211134:	48 89 d0             	mov    %rdx,%rax
  8004211137:	48 01 c0             	add    %rax,%rax
  800421113a:	48 01 d0             	add    %rdx,%rax
  800421113d:	48 c1 e0 03          	shl    $0x3,%rax
  8004211141:	48 01 c8             	add    %rcx,%rax
  8004211144:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                                RL[low6].dw_regnum = dbg->dbg_frame_cfa_value;
  8004211148:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421114c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211150:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004211154:	48 89 d0             	mov    %rdx,%rax
  8004211157:	48 01 c0             	add    %rax,%rax
  800421115a:	48 01 d0             	add    %rdx,%rax
  800421115d:	48 c1 e0 03          	shl    $0x3,%rax
  8004211161:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211165:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211169:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  800421116d:	66 89 42 02          	mov    %ax,0x2(%rdx)
                                RL[low6].dw_offset_or_block_len =
  8004211171:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211175:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211179:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800421117d:	48 89 d0             	mov    %rdx,%rax
  8004211180:	48 01 c0             	add    %rax,%rax
  8004211183:	48 01 d0             	add    %rdx,%rax
  8004211186:	48 c1 e0 03          	shl    $0x3,%rax
  800421118a:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
                                    _dwarf_decode_uleb128(&p) * daf;
  800421118e:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211192:	48 89 c7             	mov    %rax,%rdi
  8004211195:	48 b8 fe f4 20 04 80 	movabs $0x800420f4fe,%rax
  800421119c:	00 00 00 
  800421119f:	ff d0                	callq  *%rax
  80042111a1:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  80042111a8:	48 0f af c2          	imul   %rdx,%rax
                                *row_pc = pc;
                                CHECK_TABLE_SIZE(low6);
                                RL[low6].dw_offset_relevant = 1;
                                RL[low6].dw_value_type = DW_EXPR_OFFSET;
                                RL[low6].dw_regnum = dbg->dbg_frame_cfa_value;
                                RL[low6].dw_offset_or_block_len =
  80042111ac:	48 89 43 08          	mov    %rax,0x8(%rbx)
                                    _dwarf_decode_uleb128(&p) * daf;
                                break;
  80042111b0:	e9 85 00 00 00       	jmpq   800421123a <_dwarf_frame_run_inst+0x26f>
                        case DW_CFA_restore:
                                *row_pc = pc;
  80042111b5:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042111b9:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042111bd:	48 89 10             	mov    %rdx,(%rax)
                                CHECK_TABLE_SIZE(low6);
  80042111c0:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  80042111c4:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042111c8:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042111cc:	66 39 c2             	cmp    %ax,%dx
  80042111cf:	72 0c                	jb     80042111dd <_dwarf_frame_run_inst+0x212>
  80042111d1:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042111d8:	e9 bd 0b 00 00       	jmpq   8004211d9a <_dwarf_frame_run_inst+0xdcf>
                                memcpy(&RL[low6], &INITRL[low6],
  80042111dd:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042111e1:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042111e5:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  80042111e9:	48 89 d0             	mov    %rdx,%rax
  80042111ec:	48 01 c0             	add    %rax,%rax
  80042111ef:	48 01 d0             	add    %rdx,%rax
  80042111f2:	48 c1 e0 03          	shl    $0x3,%rax
  80042111f6:	48 01 c1             	add    %rax,%rcx
  80042111f9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042111fd:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004211201:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004211205:	48 89 d0             	mov    %rdx,%rax
  8004211208:	48 01 c0             	add    %rax,%rax
  800421120b:	48 01 d0             	add    %rdx,%rax
  800421120e:	48 c1 e0 03          	shl    $0x3,%rax
  8004211212:	48 01 f0             	add    %rsi,%rax
  8004211215:	ba 18 00 00 00       	mov    $0x18,%edx
  800421121a:	48 89 ce             	mov    %rcx,%rsi
  800421121d:	48 89 c7             	mov    %rax,%rdi
  8004211220:	48 b8 7d ea 20 04 80 	movabs $0x800420ea7d,%rax
  8004211227:	00 00 00 
  800421122a:	ff d0                	callq  *%rax
                                    sizeof(Dwarf_Regtable_Entry3));
                                break;
  800421122c:	eb 0c                	jmp    800421123a <_dwarf_frame_run_inst+0x26f>
                        default:
                                DWARF_SET_ERROR(dbg, error,
                                    DW_DLE_FRAME_INSTR_EXEC_ERROR);
                                ret = DW_DLE_FRAME_INSTR_EXEC_ERROR;
  800421122e:	c7 45 ec 15 00 00 00 	movl   $0x15,-0x14(%rbp)
                                goto program_done;
  8004211235:	e9 60 0b 00 00       	jmpq   8004211d9a <_dwarf_frame_run_inst+0xdcf>
                        }

                        continue;
  800421123a:	e9 4d 0b 00 00       	jmpq   8004211d8c <_dwarf_frame_run_inst+0xdc1>
                }

                switch (low6) {
  800421123f:	0f b6 45 de          	movzbl -0x22(%rbp),%eax
  8004211243:	83 f8 16             	cmp    $0x16,%eax
  8004211246:	0f 87 37 0b 00 00    	ja     8004211d83 <_dwarf_frame_run_inst+0xdb8>
  800421124c:	89 c0                	mov    %eax,%eax
  800421124e:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004211255:	00 
  8004211256:	48 b8 b8 81 21 04 80 	movabs $0x80042181b8,%rax
  800421125d:	00 00 00 
  8004211260:	48 01 d0             	add    %rdx,%rax
  8004211263:	48 8b 00             	mov    (%rax),%rax
  8004211266:	ff e0                	jmpq   *%rax
                case DW_CFA_set_loc:
                        pc = dbg->decode(&p, dbg->dbg_pointer_size);
  8004211268:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421126c:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004211270:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004211274:	8b 4a 28             	mov    0x28(%rdx),%ecx
  8004211277:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  800421127b:	89 ce                	mov    %ecx,%esi
  800421127d:	48 89 d7             	mov    %rdx,%rdi
  8004211280:	ff d0                	callq  *%rax
  8004211282:	48 89 45 10          	mov    %rax,0x10(%rbp)
                        if (pc_req < pc)
  8004211286:	48 8b 45 18          	mov    0x18(%rbp),%rax
  800421128a:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  800421128e:	73 05                	jae    8004211295 <_dwarf_frame_run_inst+0x2ca>
                                goto program_done;
  8004211290:	e9 05 0b 00 00       	jmpq   8004211d9a <_dwarf_frame_run_inst+0xdcf>
                        break;
  8004211295:	e9 f2 0a 00 00       	jmpq   8004211d8c <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_advance_loc1:
                        pc += dbg->decode(&p, 1) * caf;
  800421129a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421129e:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042112a2:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  80042112a6:	be 01 00 00 00       	mov    $0x1,%esi
  80042112ab:	48 89 d7             	mov    %rdx,%rdi
  80042112ae:	ff d0                	callq  *%rax
  80042112b0:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  80042112b7:	ff 
  80042112b8:	48 01 45 10          	add    %rax,0x10(%rbp)
                        if (pc_req < pc)
  80042112bc:	48 8b 45 18          	mov    0x18(%rbp),%rax
  80042112c0:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  80042112c4:	73 05                	jae    80042112cb <_dwarf_frame_run_inst+0x300>
                                goto program_done;
  80042112c6:	e9 cf 0a 00 00       	jmpq   8004211d9a <_dwarf_frame_run_inst+0xdcf>
                        break;
  80042112cb:	e9 bc 0a 00 00       	jmpq   8004211d8c <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_advance_loc2:
                        pc += dbg->decode(&p, 2) * caf;
  80042112d0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042112d4:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042112d8:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  80042112dc:	be 02 00 00 00       	mov    $0x2,%esi
  80042112e1:	48 89 d7             	mov    %rdx,%rdi
  80042112e4:	ff d0                	callq  *%rax
  80042112e6:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  80042112ed:	ff 
  80042112ee:	48 01 45 10          	add    %rax,0x10(%rbp)
                        if (pc_req < pc)
  80042112f2:	48 8b 45 18          	mov    0x18(%rbp),%rax
  80042112f6:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  80042112fa:	73 05                	jae    8004211301 <_dwarf_frame_run_inst+0x336>
                                goto program_done;
  80042112fc:	e9 99 0a 00 00       	jmpq   8004211d9a <_dwarf_frame_run_inst+0xdcf>
                        break;
  8004211301:	e9 86 0a 00 00       	jmpq   8004211d8c <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_advance_loc4:
                        pc += dbg->decode(&p, 4) * caf;
  8004211306:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421130a:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421130e:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  8004211312:	be 04 00 00 00       	mov    $0x4,%esi
  8004211317:	48 89 d7             	mov    %rdx,%rdi
  800421131a:	ff d0                	callq  *%rax
  800421131c:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  8004211323:	ff 
  8004211324:	48 01 45 10          	add    %rax,0x10(%rbp)
                        if (pc_req < pc)
  8004211328:	48 8b 45 18          	mov    0x18(%rbp),%rax
  800421132c:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  8004211330:	73 05                	jae    8004211337 <_dwarf_frame_run_inst+0x36c>
                                goto program_done;
  8004211332:	e9 63 0a 00 00       	jmpq   8004211d9a <_dwarf_frame_run_inst+0xdcf>
                        break;
  8004211337:	e9 50 0a 00 00       	jmpq   8004211d8c <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_offset_extended:
                        *row_pc = pc;
  800421133c:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211340:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211344:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004211347:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421134b:	48 89 c7             	mov    %rax,%rdi
  800421134e:	48 b8 fe f4 20 04 80 	movabs $0x800420f4fe,%rax
  8004211355:	00 00 00 
  8004211358:	ff d0                	callq  *%rax
  800421135a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        uoff = _dwarf_decode_uleb128(&p);
  800421135e:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211362:	48 89 c7             	mov    %rax,%rdi
  8004211365:	48 b8 fe f4 20 04 80 	movabs $0x800420f4fe,%rax
  800421136c:	00 00 00 
  800421136f:	ff d0                	callq  *%rax
  8004211371:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004211375:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211379:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800421137d:	0f b7 c0             	movzwl %ax,%eax
  8004211380:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004211384:	77 0c                	ja     8004211392 <_dwarf_frame_run_inst+0x3c7>
  8004211386:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800421138d:	e9 08 0a 00 00       	jmpq   8004211d9a <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 1;
  8004211392:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211396:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421139a:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421139e:	48 89 d0             	mov    %rdx,%rax
  80042113a1:	48 01 c0             	add    %rax,%rax
  80042113a4:	48 01 d0             	add    %rdx,%rax
  80042113a7:	48 c1 e0 03          	shl    $0x3,%rax
  80042113ab:	48 01 c8             	add    %rcx,%rax
  80042113ae:	c6 00 01             	movb   $0x1,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_OFFSET;
  80042113b1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042113b5:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042113b9:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042113bd:	48 89 d0             	mov    %rdx,%rax
  80042113c0:	48 01 c0             	add    %rax,%rax
  80042113c3:	48 01 d0             	add    %rdx,%rax
  80042113c6:	48 c1 e0 03          	shl    $0x3,%rax
  80042113ca:	48 01 c8             	add    %rcx,%rax
  80042113cd:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  80042113d1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042113d5:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042113d9:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042113dd:	48 89 d0             	mov    %rdx,%rax
  80042113e0:	48 01 c0             	add    %rax,%rax
  80042113e3:	48 01 d0             	add    %rdx,%rax
  80042113e6:	48 c1 e0 03          	shl    $0x3,%rax
  80042113ea:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042113ee:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042113f2:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  80042113f6:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        RL[reg].dw_offset_or_block_len = uoff * daf;
  80042113fa:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042113fe:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211402:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211406:	48 89 d0             	mov    %rdx,%rax
  8004211409:	48 01 c0             	add    %rax,%rax
  800421140c:	48 01 d0             	add    %rdx,%rax
  800421140f:	48 c1 e0 03          	shl    $0x3,%rax
  8004211413:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211417:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  800421141e:	48 0f af 45 c8       	imul   -0x38(%rbp),%rax
  8004211423:	48 89 42 08          	mov    %rax,0x8(%rdx)
                        break;
  8004211427:	e9 60 09 00 00       	jmpq   8004211d8c <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_restore_extended:
                        *row_pc = pc;
  800421142c:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211430:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211434:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004211437:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421143b:	48 89 c7             	mov    %rax,%rdi
  800421143e:	48 b8 fe f4 20 04 80 	movabs $0x800420f4fe,%rax
  8004211445:	00 00 00 
  8004211448:	ff d0                	callq  *%rax
  800421144a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CHECK_TABLE_SIZE(reg);
  800421144e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211452:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211456:	0f b7 c0             	movzwl %ax,%eax
  8004211459:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800421145d:	77 0c                	ja     800421146b <_dwarf_frame_run_inst+0x4a0>
  800421145f:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004211466:	e9 2f 09 00 00       	jmpq   8004211d9a <_dwarf_frame_run_inst+0xdcf>
                        memcpy(&RL[reg], &INITRL[reg],
  800421146b:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421146f:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211473:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211477:	48 89 d0             	mov    %rdx,%rax
  800421147a:	48 01 c0             	add    %rax,%rax
  800421147d:	48 01 d0             	add    %rdx,%rax
  8004211480:	48 c1 e0 03          	shl    $0x3,%rax
  8004211484:	48 01 c1             	add    %rax,%rcx
  8004211487:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421148b:	48 8b 70 20          	mov    0x20(%rax),%rsi
  800421148f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211493:	48 89 d0             	mov    %rdx,%rax
  8004211496:	48 01 c0             	add    %rax,%rax
  8004211499:	48 01 d0             	add    %rdx,%rax
  800421149c:	48 c1 e0 03          	shl    $0x3,%rax
  80042114a0:	48 01 f0             	add    %rsi,%rax
  80042114a3:	ba 18 00 00 00       	mov    $0x18,%edx
  80042114a8:	48 89 ce             	mov    %rcx,%rsi
  80042114ab:	48 89 c7             	mov    %rax,%rdi
  80042114ae:	48 b8 7d ea 20 04 80 	movabs $0x800420ea7d,%rax
  80042114b5:	00 00 00 
  80042114b8:	ff d0                	callq  *%rax
                        sizeof(Dwarf_Regtable_Entry3));
                        break;
  80042114ba:	e9 cd 08 00 00       	jmpq   8004211d8c <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_undefined:
                        *row_pc = pc;
  80042114bf:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042114c3:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042114c7:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  80042114ca:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042114ce:	48 89 c7             	mov    %rax,%rdi
  80042114d1:	48 b8 fe f4 20 04 80 	movabs $0x800420f4fe,%rax
  80042114d8:	00 00 00 
  80042114db:	ff d0                	callq  *%rax
  80042114dd:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CHECK_TABLE_SIZE(reg);
  80042114e1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042114e5:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042114e9:	0f b7 c0             	movzwl %ax,%eax
  80042114ec:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042114f0:	77 0c                	ja     80042114fe <_dwarf_frame_run_inst+0x533>
  80042114f2:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042114f9:	e9 9c 08 00 00       	jmpq   8004211d9a <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 0;
  80042114fe:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211502:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211506:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421150a:	48 89 d0             	mov    %rdx,%rax
  800421150d:	48 01 c0             	add    %rax,%rax
  8004211510:	48 01 d0             	add    %rdx,%rax
  8004211513:	48 c1 e0 03          	shl    $0x3,%rax
  8004211517:	48 01 c8             	add    %rcx,%rax
  800421151a:	c6 00 00             	movb   $0x0,(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_undefined_value;
  800421151d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211521:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211525:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211529:	48 89 d0             	mov    %rdx,%rax
  800421152c:	48 01 c0             	add    %rax,%rax
  800421152f:	48 01 d0             	add    %rdx,%rax
  8004211532:	48 c1 e0 03          	shl    $0x3,%rax
  8004211536:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800421153a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421153e:	0f b7 40 50          	movzwl 0x50(%rax),%eax
  8004211542:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        break;
  8004211546:	e9 41 08 00 00       	jmpq   8004211d8c <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_same_value:
                        reg = _dwarf_decode_uleb128(&p);
  800421154b:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421154f:	48 89 c7             	mov    %rax,%rdi
  8004211552:	48 b8 fe f4 20 04 80 	movabs $0x800420f4fe,%rax
  8004211559:	00 00 00 
  800421155c:	ff d0                	callq  *%rax
  800421155e:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004211562:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211566:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800421156a:	0f b7 c0             	movzwl %ax,%eax
  800421156d:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004211571:	77 0c                	ja     800421157f <_dwarf_frame_run_inst+0x5b4>
  8004211573:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800421157a:	e9 1b 08 00 00       	jmpq   8004211d9a <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 0;
  800421157f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211583:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211587:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421158b:	48 89 d0             	mov    %rdx,%rax
  800421158e:	48 01 c0             	add    %rax,%rax
  8004211591:	48 01 d0             	add    %rdx,%rax
  8004211594:	48 c1 e0 03          	shl    $0x3,%rax
  8004211598:	48 01 c8             	add    %rcx,%rax
  800421159b:	c6 00 00             	movb   $0x0,(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_same_value;
  800421159e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042115a2:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042115a6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042115aa:	48 89 d0             	mov    %rdx,%rax
  80042115ad:	48 01 c0             	add    %rax,%rax
  80042115b0:	48 01 d0             	add    %rdx,%rax
  80042115b3:	48 c1 e0 03          	shl    $0x3,%rax
  80042115b7:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042115bb:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042115bf:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  80042115c3:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        break;
  80042115c7:	e9 c0 07 00 00       	jmpq   8004211d8c <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_register:
                        *row_pc = pc;
  80042115cc:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042115d0:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042115d4:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  80042115d7:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042115db:	48 89 c7             	mov    %rax,%rdi
  80042115de:	48 b8 fe f4 20 04 80 	movabs $0x800420f4fe,%rax
  80042115e5:	00 00 00 
  80042115e8:	ff d0                	callq  *%rax
  80042115ea:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        reg2 = _dwarf_decode_uleb128(&p);
  80042115ee:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042115f2:	48 89 c7             	mov    %rax,%rdi
  80042115f5:	48 b8 fe f4 20 04 80 	movabs $0x800420f4fe,%rax
  80042115fc:	00 00 00 
  80042115ff:	ff d0                	callq  *%rax
  8004211601:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004211605:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211609:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800421160d:	0f b7 c0             	movzwl %ax,%eax
  8004211610:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004211614:	77 0c                	ja     8004211622 <_dwarf_frame_run_inst+0x657>
  8004211616:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800421161d:	e9 78 07 00 00       	jmpq   8004211d9a <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 0;
  8004211622:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211626:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421162a:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421162e:	48 89 d0             	mov    %rdx,%rax
  8004211631:	48 01 c0             	add    %rax,%rax
  8004211634:	48 01 d0             	add    %rdx,%rax
  8004211637:	48 c1 e0 03          	shl    $0x3,%rax
  800421163b:	48 01 c8             	add    %rcx,%rax
  800421163e:	c6 00 00             	movb   $0x0,(%rax)
                        RL[reg].dw_regnum = reg2;
  8004211641:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211645:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211649:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421164d:	48 89 d0             	mov    %rdx,%rax
  8004211650:	48 01 c0             	add    %rax,%rax
  8004211653:	48 01 d0             	add    %rdx,%rax
  8004211656:	48 c1 e0 03          	shl    $0x3,%rax
  800421165a:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800421165e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004211662:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        break;
  8004211666:	e9 21 07 00 00       	jmpq   8004211d8c <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_remember_state:
                        _dwarf_frame_regtable_copy(dbg, &saved_rt, rt, error);
  800421166b:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  800421166f:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  8004211673:	48 8d 75 a8          	lea    -0x58(%rbp),%rsi
  8004211677:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421167b:	48 89 c7             	mov    %rax,%rdi
  800421167e:	48 b8 fa 0d 21 04 80 	movabs $0x8004210dfa,%rax
  8004211685:	00 00 00 
  8004211688:	ff d0                	callq  *%rax
                        break;
  800421168a:	e9 fd 06 00 00       	jmpq   8004211d8c <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_restore_state:
                        *row_pc = pc;
  800421168f:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211693:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211697:	48 89 10             	mov    %rdx,(%rax)
                        _dwarf_frame_regtable_copy(dbg, &rt, saved_rt, error);
  800421169a:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  800421169e:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  80042116a2:	48 8d 75 90          	lea    -0x70(%rbp),%rsi
  80042116a6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042116aa:	48 89 c7             	mov    %rax,%rdi
  80042116ad:	48 b8 fa 0d 21 04 80 	movabs $0x8004210dfa,%rax
  80042116b4:	00 00 00 
  80042116b7:	ff d0                	callq  *%rax
                        break;
  80042116b9:	e9 ce 06 00 00       	jmpq   8004211d8c <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_def_cfa:
                        *row_pc = pc;
  80042116be:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042116c2:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042116c6:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  80042116c9:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042116cd:	48 89 c7             	mov    %rax,%rdi
  80042116d0:	48 b8 fe f4 20 04 80 	movabs $0x800420f4fe,%rax
  80042116d7:	00 00 00 
  80042116da:	ff d0                	callq  *%rax
  80042116dc:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        uoff = _dwarf_decode_uleb128(&p);
  80042116e0:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042116e4:	48 89 c7             	mov    %rax,%rdi
  80042116e7:	48 b8 fe f4 20 04 80 	movabs $0x800420f4fe,%rax
  80042116ee:	00 00 00 
  80042116f1:	ff d0                	callq  *%rax
  80042116f3:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                        CFA.dw_offset_relevant = 1;
  80042116f7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042116fb:	c6 00 01             	movb   $0x1,(%rax)
                        CFA.dw_value_type = DW_EXPR_OFFSET;
  80042116fe:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211702:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        CFA.dw_regnum = reg;
  8004211706:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421170a:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421170e:	66 89 50 02          	mov    %dx,0x2(%rax)
                        CFA.dw_offset_or_block_len = uoff;
  8004211712:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211716:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421171a:	48 89 50 08          	mov    %rdx,0x8(%rax)
                        break;
  800421171e:	e9 69 06 00 00       	jmpq   8004211d8c <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_def_cfa_register:
                        *row_pc = pc;
  8004211723:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211727:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421172b:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  800421172e:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211732:	48 89 c7             	mov    %rax,%rdi
  8004211735:	48 b8 fe f4 20 04 80 	movabs $0x800420f4fe,%rax
  800421173c:	00 00 00 
  800421173f:	ff d0                	callq  *%rax
  8004211741:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CFA.dw_regnum = reg;
  8004211745:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211749:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421174d:	66 89 50 02          	mov    %dx,0x2(%rax)
                         * Note that DW_CFA_def_cfa_register change the CFA
                         * rule register while keep the old offset. So we
                         * should not touch the CFA.dw_offset_relevant flag
                         * here.
                         */
                        break;
  8004211751:	e9 36 06 00 00       	jmpq   8004211d8c <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_def_cfa_offset:
                        *row_pc = pc;
  8004211756:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421175a:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421175e:	48 89 10             	mov    %rdx,(%rax)
                        uoff = _dwarf_decode_uleb128(&p);
  8004211761:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211765:	48 89 c7             	mov    %rax,%rdi
  8004211768:	48 b8 fe f4 20 04 80 	movabs $0x800420f4fe,%rax
  800421176f:	00 00 00 
  8004211772:	ff d0                	callq  *%rax
  8004211774:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                        CFA.dw_offset_relevant = 1;
  8004211778:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421177c:	c6 00 01             	movb   $0x1,(%rax)
                        CFA.dw_value_type = DW_EXPR_OFFSET;
  800421177f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211783:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        CFA.dw_offset_or_block_len = uoff;
  8004211787:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421178b:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421178f:	48 89 50 08          	mov    %rdx,0x8(%rax)
                        break;
  8004211793:	e9 f4 05 00 00       	jmpq   8004211d8c <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_def_cfa_expression:
                        *row_pc = pc;
  8004211798:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421179c:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042117a0:	48 89 10             	mov    %rdx,(%rax)
                        CFA.dw_offset_relevant = 0;
  80042117a3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042117a7:	c6 00 00             	movb   $0x0,(%rax)
                        CFA.dw_value_type = DW_EXPR_EXPRESSION;
  80042117aa:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042117ae:	c6 40 01 02          	movb   $0x2,0x1(%rax)
                        CFA.dw_offset_or_block_len = _dwarf_decode_uleb128(&p);
  80042117b2:	48 8b 5d 90          	mov    -0x70(%rbp),%rbx
  80042117b6:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042117ba:	48 89 c7             	mov    %rax,%rdi
  80042117bd:	48 b8 fe f4 20 04 80 	movabs $0x800420f4fe,%rax
  80042117c4:	00 00 00 
  80042117c7:	ff d0                	callq  *%rax
  80042117c9:	48 89 43 08          	mov    %rax,0x8(%rbx)
                        CFA.dw_block_ptr = p;
  80042117cd:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042117d1:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042117d5:	48 89 50 10          	mov    %rdx,0x10(%rax)
                        p += CFA.dw_offset_or_block_len;
  80042117d9:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042117dd:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042117e1:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042117e5:	48 01 d0             	add    %rdx,%rax
  80042117e8:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
                        break;
  80042117ec:	e9 9b 05 00 00       	jmpq   8004211d8c <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_expression:
                        *row_pc = pc;
  80042117f1:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042117f5:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042117f9:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  80042117fc:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211800:	48 89 c7             	mov    %rax,%rdi
  8004211803:	48 b8 fe f4 20 04 80 	movabs $0x800420f4fe,%rax
  800421180a:	00 00 00 
  800421180d:	ff d0                	callq  *%rax
  800421180f:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004211813:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211817:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800421181b:	0f b7 c0             	movzwl %ax,%eax
  800421181e:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004211822:	77 0c                	ja     8004211830 <_dwarf_frame_run_inst+0x865>
  8004211824:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800421182b:	e9 6a 05 00 00       	jmpq   8004211d9a <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 0;
  8004211830:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211834:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211838:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421183c:	48 89 d0             	mov    %rdx,%rax
  800421183f:	48 01 c0             	add    %rax,%rax
  8004211842:	48 01 d0             	add    %rdx,%rax
  8004211845:	48 c1 e0 03          	shl    $0x3,%rax
  8004211849:	48 01 c8             	add    %rcx,%rax
  800421184c:	c6 00 00             	movb   $0x0,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_EXPRESSION;
  800421184f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211853:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211857:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421185b:	48 89 d0             	mov    %rdx,%rax
  800421185e:	48 01 c0             	add    %rax,%rax
  8004211861:	48 01 d0             	add    %rdx,%rax
  8004211864:	48 c1 e0 03          	shl    $0x3,%rax
  8004211868:	48 01 c8             	add    %rcx,%rax
  800421186b:	c6 40 01 02          	movb   $0x2,0x1(%rax)
                        RL[reg].dw_offset_or_block_len =
  800421186f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211873:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211877:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421187b:	48 89 d0             	mov    %rdx,%rax
  800421187e:	48 01 c0             	add    %rax,%rax
  8004211881:	48 01 d0             	add    %rdx,%rax
  8004211884:	48 c1 e0 03          	shl    $0x3,%rax
  8004211888:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
                            _dwarf_decode_uleb128(&p);
  800421188c:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211890:	48 89 c7             	mov    %rax,%rdi
  8004211893:	48 b8 fe f4 20 04 80 	movabs $0x800420f4fe,%rax
  800421189a:	00 00 00 
  800421189d:	ff d0                	callq  *%rax
                        *row_pc = pc;
                        reg = _dwarf_decode_uleb128(&p);
                        CHECK_TABLE_SIZE(reg);
                        RL[reg].dw_offset_relevant = 0;
                        RL[reg].dw_value_type = DW_EXPR_EXPRESSION;
                        RL[reg].dw_offset_or_block_len =
  800421189f:	48 89 43 08          	mov    %rax,0x8(%rbx)
                            _dwarf_decode_uleb128(&p);
                        RL[reg].dw_block_ptr = p;
  80042118a3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042118a7:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042118ab:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042118af:	48 89 d0             	mov    %rdx,%rax
  80042118b2:	48 01 c0             	add    %rax,%rax
  80042118b5:	48 01 d0             	add    %rdx,%rax
  80042118b8:	48 c1 e0 03          	shl    $0x3,%rax
  80042118bc:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042118c0:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042118c4:	48 89 42 10          	mov    %rax,0x10(%rdx)
                        p += RL[reg].dw_offset_or_block_len;
  80042118c8:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  80042118cc:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042118d0:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80042118d4:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042118d8:	48 89 d0             	mov    %rdx,%rax
  80042118db:	48 01 c0             	add    %rax,%rax
  80042118de:	48 01 d0             	add    %rdx,%rax
  80042118e1:	48 c1 e0 03          	shl    $0x3,%rax
  80042118e5:	48 01 f0             	add    %rsi,%rax
  80042118e8:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042118ec:	48 01 c8             	add    %rcx,%rax
  80042118ef:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
                        break;
  80042118f3:	e9 94 04 00 00       	jmpq   8004211d8c <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_offset_extended_sf:
                        *row_pc = pc;
  80042118f8:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042118fc:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211900:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004211903:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211907:	48 89 c7             	mov    %rax,%rdi
  800421190a:	48 b8 fe f4 20 04 80 	movabs $0x800420f4fe,%rax
  8004211911:	00 00 00 
  8004211914:	ff d0                	callq  *%rax
  8004211916:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        soff = _dwarf_decode_sleb128(&p);
  800421191a:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421191e:	48 89 c7             	mov    %rax,%rdi
  8004211921:	48 b8 6c f4 20 04 80 	movabs $0x800420f46c,%rax
  8004211928:	00 00 00 
  800421192b:	ff d0                	callq  *%rax
  800421192d:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004211931:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211935:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211939:	0f b7 c0             	movzwl %ax,%eax
  800421193c:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004211940:	77 0c                	ja     800421194e <_dwarf_frame_run_inst+0x983>
  8004211942:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004211949:	e9 4c 04 00 00       	jmpq   8004211d9a <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 1;
  800421194e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211952:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211956:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421195a:	48 89 d0             	mov    %rdx,%rax
  800421195d:	48 01 c0             	add    %rax,%rax
  8004211960:	48 01 d0             	add    %rdx,%rax
  8004211963:	48 c1 e0 03          	shl    $0x3,%rax
  8004211967:	48 01 c8             	add    %rcx,%rax
  800421196a:	c6 00 01             	movb   $0x1,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_OFFSET;
  800421196d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211971:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211975:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211979:	48 89 d0             	mov    %rdx,%rax
  800421197c:	48 01 c0             	add    %rax,%rax
  800421197f:	48 01 d0             	add    %rdx,%rax
  8004211982:	48 c1 e0 03          	shl    $0x3,%rax
  8004211986:	48 01 c8             	add    %rcx,%rax
  8004211989:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  800421198d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211991:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211995:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211999:	48 89 d0             	mov    %rdx,%rax
  800421199c:	48 01 c0             	add    %rax,%rax
  800421199f:	48 01 d0             	add    %rdx,%rax
  80042119a2:	48 c1 e0 03          	shl    $0x3,%rax
  80042119a6:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042119aa:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042119ae:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  80042119b2:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        RL[reg].dw_offset_or_block_len = soff * daf;
  80042119b6:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042119ba:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042119be:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042119c2:	48 89 d0             	mov    %rdx,%rax
  80042119c5:	48 01 c0             	add    %rax,%rax
  80042119c8:	48 01 d0             	add    %rdx,%rax
  80042119cb:	48 c1 e0 03          	shl    $0x3,%rax
  80042119cf:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042119d3:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80042119da:	48 0f af 45 b8       	imul   -0x48(%rbp),%rax
  80042119df:	48 89 42 08          	mov    %rax,0x8(%rdx)
                        break;
  80042119e3:	e9 a4 03 00 00       	jmpq   8004211d8c <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_def_cfa_sf:
                        *row_pc = pc;
  80042119e8:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042119ec:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042119f0:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  80042119f3:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042119f7:	48 89 c7             	mov    %rax,%rdi
  80042119fa:	48 b8 fe f4 20 04 80 	movabs $0x800420f4fe,%rax
  8004211a01:	00 00 00 
  8004211a04:	ff d0                	callq  *%rax
  8004211a06:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        soff = _dwarf_decode_sleb128(&p);
  8004211a0a:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211a0e:	48 89 c7             	mov    %rax,%rdi
  8004211a11:	48 b8 6c f4 20 04 80 	movabs $0x800420f46c,%rax
  8004211a18:	00 00 00 
  8004211a1b:	ff d0                	callq  *%rax
  8004211a1d:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
                        CFA.dw_offset_relevant = 1;
  8004211a21:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211a25:	c6 00 01             	movb   $0x1,(%rax)
                        CFA.dw_value_type = DW_EXPR_OFFSET;
  8004211a28:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211a2c:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        CFA.dw_regnum = reg;
  8004211a30:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211a34:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211a38:	66 89 50 02          	mov    %dx,0x2(%rax)
                        CFA.dw_offset_or_block_len = soff * daf;
  8004211a3c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211a40:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004211a47:	48 0f af 55 b8       	imul   -0x48(%rbp),%rdx
  8004211a4c:	48 89 50 08          	mov    %rdx,0x8(%rax)
                        break;
  8004211a50:	e9 37 03 00 00       	jmpq   8004211d8c <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_def_cfa_offset_sf:
                        *row_pc = pc;
  8004211a55:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211a59:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211a5d:	48 89 10             	mov    %rdx,(%rax)
                        soff = _dwarf_decode_sleb128(&p);
  8004211a60:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211a64:	48 89 c7             	mov    %rax,%rdi
  8004211a67:	48 b8 6c f4 20 04 80 	movabs $0x800420f46c,%rax
  8004211a6e:	00 00 00 
  8004211a71:	ff d0                	callq  *%rax
  8004211a73:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
                        CFA.dw_offset_relevant = 1;
  8004211a77:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211a7b:	c6 00 01             	movb   $0x1,(%rax)
                        CFA.dw_value_type = DW_EXPR_OFFSET;
  8004211a7e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211a82:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        CFA.dw_offset_or_block_len = soff * daf;
  8004211a86:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211a8a:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004211a91:	48 0f af 55 b8       	imul   -0x48(%rbp),%rdx
  8004211a96:	48 89 50 08          	mov    %rdx,0x8(%rax)
                        break;
  8004211a9a:	e9 ed 02 00 00       	jmpq   8004211d8c <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_val_offset:
                        *row_pc = pc;
  8004211a9f:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211aa3:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211aa7:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004211aaa:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211aae:	48 89 c7             	mov    %rax,%rdi
  8004211ab1:	48 b8 fe f4 20 04 80 	movabs $0x800420f4fe,%rax
  8004211ab8:	00 00 00 
  8004211abb:	ff d0                	callq  *%rax
  8004211abd:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        uoff = _dwarf_decode_uleb128(&p);
  8004211ac1:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211ac5:	48 89 c7             	mov    %rax,%rdi
  8004211ac8:	48 b8 fe f4 20 04 80 	movabs $0x800420f4fe,%rax
  8004211acf:	00 00 00 
  8004211ad2:	ff d0                	callq  *%rax
  8004211ad4:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004211ad8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211adc:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211ae0:	0f b7 c0             	movzwl %ax,%eax
  8004211ae3:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004211ae7:	77 0c                	ja     8004211af5 <_dwarf_frame_run_inst+0xb2a>
  8004211ae9:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004211af0:	e9 a5 02 00 00       	jmpq   8004211d9a <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 1;
  8004211af5:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211af9:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211afd:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211b01:	48 89 d0             	mov    %rdx,%rax
  8004211b04:	48 01 c0             	add    %rax,%rax
  8004211b07:	48 01 d0             	add    %rdx,%rax
  8004211b0a:	48 c1 e0 03          	shl    $0x3,%rax
  8004211b0e:	48 01 c8             	add    %rcx,%rax
  8004211b11:	c6 00 01             	movb   $0x1,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_VAL_OFFSET;
  8004211b14:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211b18:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211b1c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211b20:	48 89 d0             	mov    %rdx,%rax
  8004211b23:	48 01 c0             	add    %rax,%rax
  8004211b26:	48 01 d0             	add    %rdx,%rax
  8004211b29:	48 c1 e0 03          	shl    $0x3,%rax
  8004211b2d:	48 01 c8             	add    %rcx,%rax
  8004211b30:	c6 40 01 01          	movb   $0x1,0x1(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004211b34:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211b38:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211b3c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211b40:	48 89 d0             	mov    %rdx,%rax
  8004211b43:	48 01 c0             	add    %rax,%rax
  8004211b46:	48 01 d0             	add    %rdx,%rax
  8004211b49:	48 c1 e0 03          	shl    $0x3,%rax
  8004211b4d:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211b51:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211b55:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004211b59:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        RL[reg].dw_offset_or_block_len = uoff * daf;
  8004211b5d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211b61:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211b65:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211b69:	48 89 d0             	mov    %rdx,%rax
  8004211b6c:	48 01 c0             	add    %rax,%rax
  8004211b6f:	48 01 d0             	add    %rdx,%rax
  8004211b72:	48 c1 e0 03          	shl    $0x3,%rax
  8004211b76:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211b7a:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004211b81:	48 0f af 45 c8       	imul   -0x38(%rbp),%rax
  8004211b86:	48 89 42 08          	mov    %rax,0x8(%rdx)
                        break;
  8004211b8a:	e9 fd 01 00 00       	jmpq   8004211d8c <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_val_offset_sf:
                        *row_pc = pc;
  8004211b8f:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211b93:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211b97:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004211b9a:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211b9e:	48 89 c7             	mov    %rax,%rdi
  8004211ba1:	48 b8 fe f4 20 04 80 	movabs $0x800420f4fe,%rax
  8004211ba8:	00 00 00 
  8004211bab:	ff d0                	callq  *%rax
  8004211bad:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        soff = _dwarf_decode_sleb128(&p);
  8004211bb1:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211bb5:	48 89 c7             	mov    %rax,%rdi
  8004211bb8:	48 b8 6c f4 20 04 80 	movabs $0x800420f46c,%rax
  8004211bbf:	00 00 00 
  8004211bc2:	ff d0                	callq  *%rax
  8004211bc4:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004211bc8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211bcc:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211bd0:	0f b7 c0             	movzwl %ax,%eax
  8004211bd3:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004211bd7:	77 0c                	ja     8004211be5 <_dwarf_frame_run_inst+0xc1a>
  8004211bd9:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004211be0:	e9 b5 01 00 00       	jmpq   8004211d9a <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 1;
  8004211be5:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211be9:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211bed:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211bf1:	48 89 d0             	mov    %rdx,%rax
  8004211bf4:	48 01 c0             	add    %rax,%rax
  8004211bf7:	48 01 d0             	add    %rdx,%rax
  8004211bfa:	48 c1 e0 03          	shl    $0x3,%rax
  8004211bfe:	48 01 c8             	add    %rcx,%rax
  8004211c01:	c6 00 01             	movb   $0x1,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_VAL_OFFSET;
  8004211c04:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211c08:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211c0c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211c10:	48 89 d0             	mov    %rdx,%rax
  8004211c13:	48 01 c0             	add    %rax,%rax
  8004211c16:	48 01 d0             	add    %rdx,%rax
  8004211c19:	48 c1 e0 03          	shl    $0x3,%rax
  8004211c1d:	48 01 c8             	add    %rcx,%rax
  8004211c20:	c6 40 01 01          	movb   $0x1,0x1(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004211c24:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211c28:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211c2c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211c30:	48 89 d0             	mov    %rdx,%rax
  8004211c33:	48 01 c0             	add    %rax,%rax
  8004211c36:	48 01 d0             	add    %rdx,%rax
  8004211c39:	48 c1 e0 03          	shl    $0x3,%rax
  8004211c3d:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211c41:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211c45:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004211c49:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        RL[reg].dw_offset_or_block_len = soff * daf;
  8004211c4d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211c51:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211c55:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211c59:	48 89 d0             	mov    %rdx,%rax
  8004211c5c:	48 01 c0             	add    %rax,%rax
  8004211c5f:	48 01 d0             	add    %rdx,%rax
  8004211c62:	48 c1 e0 03          	shl    $0x3,%rax
  8004211c66:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211c6a:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004211c71:	48 0f af 45 b8       	imul   -0x48(%rbp),%rax
  8004211c76:	48 89 42 08          	mov    %rax,0x8(%rdx)
                        break;
  8004211c7a:	e9 0d 01 00 00       	jmpq   8004211d8c <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_val_expression:
                        *row_pc = pc;
  8004211c7f:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211c83:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211c87:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004211c8a:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211c8e:	48 89 c7             	mov    %rax,%rdi
  8004211c91:	48 b8 fe f4 20 04 80 	movabs $0x800420f4fe,%rax
  8004211c98:	00 00 00 
  8004211c9b:	ff d0                	callq  *%rax
  8004211c9d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004211ca1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211ca5:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211ca9:	0f b7 c0             	movzwl %ax,%eax
  8004211cac:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004211cb0:	77 0c                	ja     8004211cbe <_dwarf_frame_run_inst+0xcf3>
  8004211cb2:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004211cb9:	e9 dc 00 00 00       	jmpq   8004211d9a <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 0;
  8004211cbe:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211cc2:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211cc6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211cca:	48 89 d0             	mov    %rdx,%rax
  8004211ccd:	48 01 c0             	add    %rax,%rax
  8004211cd0:	48 01 d0             	add    %rdx,%rax
  8004211cd3:	48 c1 e0 03          	shl    $0x3,%rax
  8004211cd7:	48 01 c8             	add    %rcx,%rax
  8004211cda:	c6 00 00             	movb   $0x0,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_VAL_EXPRESSION;
  8004211cdd:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211ce1:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211ce5:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211ce9:	48 89 d0             	mov    %rdx,%rax
  8004211cec:	48 01 c0             	add    %rax,%rax
  8004211cef:	48 01 d0             	add    %rdx,%rax
  8004211cf2:	48 c1 e0 03          	shl    $0x3,%rax
  8004211cf6:	48 01 c8             	add    %rcx,%rax
  8004211cf9:	c6 40 01 03          	movb   $0x3,0x1(%rax)
                        RL[reg].dw_offset_or_block_len =
  8004211cfd:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211d01:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211d05:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211d09:	48 89 d0             	mov    %rdx,%rax
  8004211d0c:	48 01 c0             	add    %rax,%rax
  8004211d0f:	48 01 d0             	add    %rdx,%rax
  8004211d12:	48 c1 e0 03          	shl    $0x3,%rax
  8004211d16:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
                            _dwarf_decode_uleb128(&p);
  8004211d1a:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211d1e:	48 89 c7             	mov    %rax,%rdi
  8004211d21:	48 b8 fe f4 20 04 80 	movabs $0x800420f4fe,%rax
  8004211d28:	00 00 00 
  8004211d2b:	ff d0                	callq  *%rax
                        *row_pc = pc;
                        reg = _dwarf_decode_uleb128(&p);
                        CHECK_TABLE_SIZE(reg);
                        RL[reg].dw_offset_relevant = 0;
                        RL[reg].dw_value_type = DW_EXPR_VAL_EXPRESSION;
                        RL[reg].dw_offset_or_block_len =
  8004211d2d:	48 89 43 08          	mov    %rax,0x8(%rbx)
                            _dwarf_decode_uleb128(&p);
                        RL[reg].dw_block_ptr = p;
  8004211d31:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211d35:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211d39:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211d3d:	48 89 d0             	mov    %rdx,%rax
  8004211d40:	48 01 c0             	add    %rax,%rax
  8004211d43:	48 01 d0             	add    %rdx,%rax
  8004211d46:	48 c1 e0 03          	shl    $0x3,%rax
  8004211d4a:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211d4e:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004211d52:	48 89 42 10          	mov    %rax,0x10(%rdx)
                        p += RL[reg].dw_offset_or_block_len;
  8004211d56:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8004211d5a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211d5e:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004211d62:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211d66:	48 89 d0             	mov    %rdx,%rax
  8004211d69:	48 01 c0             	add    %rax,%rax
  8004211d6c:	48 01 d0             	add    %rdx,%rax
  8004211d6f:	48 c1 e0 03          	shl    $0x3,%rax
  8004211d73:	48 01 f0             	add    %rsi,%rax
  8004211d76:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004211d7a:	48 01 c8             	add    %rcx,%rax
  8004211d7d:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
                        break;
  8004211d81:	eb 09                	jmp    8004211d8c <_dwarf_frame_run_inst+0xdc1>
                default:
                        DWARF_SET_ERROR(dbg, error,
                            DW_DLE_FRAME_INSTR_EXEC_ERROR);
                        ret = DW_DLE_FRAME_INSTR_EXEC_ERROR;
  8004211d83:	c7 45 ec 15 00 00 00 	movl   $0x15,-0x14(%rbp)
                        goto program_done;
  8004211d8a:	eb 0e                	jmp    8004211d9a <_dwarf_frame_run_inst+0xdcf>
        /* Save a copy of the table as initial state. */
        _dwarf_frame_regtable_copy(dbg, &init_rt, rt, error);
        p = insts;
        pe = p + len;

        while (p < pe) {
  8004211d8c:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004211d90:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004211d94:	0f 82 b8 f2 ff ff    	jb     8004211052 <_dwarf_frame_run_inst+0x87>
                        goto program_done;
                }
        }

program_done:
        return (ret);
  8004211d9a:	8b 45 ec             	mov    -0x14(%rbp),%eax
#undef  CFA
#undef  INITCFA
#undef  RL
#undef  INITRL
#undef  CHECK_TABLE_SIZE
}
  8004211d9d:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
  8004211da4:	5b                   	pop    %rbx
  8004211da5:	5d                   	pop    %rbp
  8004211da6:	c3                   	retq   

0000008004211da7 <_dwarf_frame_get_internal_table>:

int
_dwarf_frame_get_internal_table(Dwarf_Debug dbg, Dwarf_Fde fde,
    Dwarf_Addr pc_req, Dwarf_Regtable3 **ret_rt, Dwarf_Addr *ret_row_pc,
    Dwarf_Error *error)
{
  8004211da7:	55                   	push   %rbp
  8004211da8:	48 89 e5             	mov    %rsp,%rbp
  8004211dab:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  8004211daf:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004211db3:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004211db7:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004211dbb:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  8004211dbf:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
  8004211dc3:	4c 89 4d a0          	mov    %r9,-0x60(%rbp)
        Dwarf_Cie cie;
        Dwarf_Regtable3 *rt;
        Dwarf_Addr row_pc;
        int i, ret;

        assert(ret_rt != NULL);
  8004211dc7:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  8004211dcc:	75 35                	jne    8004211e03 <_dwarf_frame_get_internal_table+0x5c>
  8004211dce:	48 b9 70 82 21 04 80 	movabs $0x8004218270,%rcx
  8004211dd5:	00 00 00 
  8004211dd8:	48 ba 7f 81 21 04 80 	movabs $0x800421817f,%rdx
  8004211ddf:	00 00 00 
  8004211de2:	be 80 01 00 00       	mov    $0x180,%esi
  8004211de7:	48 bf 94 81 21 04 80 	movabs $0x8004218194,%rdi
  8004211dee:	00 00 00 
  8004211df1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211df6:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004211dfd:	00 00 00 
  8004211e00:	41 ff d0             	callq  *%r8

        //dbg = fde->fde_dbg;
        assert(dbg != NULL);
  8004211e03:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004211e08:	75 35                	jne    8004211e3f <_dwarf_frame_get_internal_table+0x98>
  8004211e0a:	48 b9 7f 82 21 04 80 	movabs $0x800421827f,%rcx
  8004211e11:	00 00 00 
  8004211e14:	48 ba 7f 81 21 04 80 	movabs $0x800421817f,%rdx
  8004211e1b:	00 00 00 
  8004211e1e:	be 83 01 00 00       	mov    $0x183,%esi
  8004211e23:	48 bf 94 81 21 04 80 	movabs $0x8004218194,%rdi
  8004211e2a:	00 00 00 
  8004211e2d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211e32:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004211e39:	00 00 00 
  8004211e3c:	41 ff d0             	callq  *%r8

        rt = dbg->dbg_internal_reg_table;
  8004211e3f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211e43:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004211e47:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

        /* Clear the content of regtable from previous run. */
        memset(&rt->rt3_cfa_rule, 0, sizeof(Dwarf_Regtable_Entry3));
  8004211e4b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211e4f:	ba 18 00 00 00       	mov    $0x18,%edx
  8004211e54:	be 00 00 00 00       	mov    $0x0,%esi
  8004211e59:	48 89 c7             	mov    %rax,%rdi
  8004211e5c:	48 b8 db e8 20 04 80 	movabs $0x800420e8db,%rax
  8004211e63:	00 00 00 
  8004211e66:	ff d0                	callq  *%rax
        memset(rt->rt3_rules, 0, rt->rt3_reg_table_size *
  8004211e68:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211e6c:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211e70:	0f b7 d0             	movzwl %ax,%edx
  8004211e73:	48 89 d0             	mov    %rdx,%rax
  8004211e76:	48 01 c0             	add    %rax,%rax
  8004211e79:	48 01 d0             	add    %rdx,%rax
  8004211e7c:	48 c1 e0 03          	shl    $0x3,%rax
  8004211e80:	48 89 c2             	mov    %rax,%rdx
  8004211e83:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211e87:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004211e8b:	be 00 00 00 00       	mov    $0x0,%esi
  8004211e90:	48 89 c7             	mov    %rax,%rdi
  8004211e93:	48 b8 db e8 20 04 80 	movabs $0x800420e8db,%rax
  8004211e9a:	00 00 00 
  8004211e9d:	ff d0                	callq  *%rax
            sizeof(Dwarf_Regtable_Entry3));

        /* Set rules to initial values. */
        for (i = 0; i < rt->rt3_reg_table_size; i++)
  8004211e9f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004211ea6:	eb 2f                	jmp    8004211ed7 <_dwarf_frame_get_internal_table+0x130>
                rt->rt3_rules[i].dw_regnum = dbg->dbg_frame_rule_initial_value;
  8004211ea8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211eac:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211eb0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004211eb3:	48 63 d0             	movslq %eax,%rdx
  8004211eb6:	48 89 d0             	mov    %rdx,%rax
  8004211eb9:	48 01 c0             	add    %rax,%rax
  8004211ebc:	48 01 d0             	add    %rdx,%rax
  8004211ebf:	48 c1 e0 03          	shl    $0x3,%rax
  8004211ec3:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211ec7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211ecb:	0f b7 40 4a          	movzwl 0x4a(%rax),%eax
  8004211ecf:	66 89 42 02          	mov    %ax,0x2(%rdx)
        memset(&rt->rt3_cfa_rule, 0, sizeof(Dwarf_Regtable_Entry3));
        memset(rt->rt3_rules, 0, rt->rt3_reg_table_size *
            sizeof(Dwarf_Regtable_Entry3));

        /* Set rules to initial values. */
        for (i = 0; i < rt->rt3_reg_table_size; i++)
  8004211ed3:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004211ed7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211edb:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211edf:	0f b7 c0             	movzwl %ax,%eax
  8004211ee2:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8004211ee5:	7f c1                	jg     8004211ea8 <_dwarf_frame_get_internal_table+0x101>
                rt->rt3_rules[i].dw_regnum = dbg->dbg_frame_rule_initial_value;

        /* Run initial instructions in CIE. */
        cie = fde->fde_cie;
  8004211ee7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004211eeb:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004211eef:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        assert(cie != NULL);
  8004211ef3:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004211ef8:	75 35                	jne    8004211f2f <_dwarf_frame_get_internal_table+0x188>
  8004211efa:	48 b9 8b 82 21 04 80 	movabs $0x800421828b,%rcx
  8004211f01:	00 00 00 
  8004211f04:	48 ba 7f 81 21 04 80 	movabs $0x800421817f,%rdx
  8004211f0b:	00 00 00 
  8004211f0e:	be 92 01 00 00       	mov    $0x192,%esi
  8004211f13:	48 bf 94 81 21 04 80 	movabs $0x8004218194,%rdi
  8004211f1a:	00 00 00 
  8004211f1d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211f22:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004211f29:	00 00 00 
  8004211f2c:	41 ff d0             	callq  *%r8
        ret = _dwarf_frame_run_inst(dbg, rt, cie->cie_initinst,
  8004211f2f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211f33:	4c 8b 48 40          	mov    0x40(%rax),%r9
  8004211f37:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211f3b:	4c 8b 40 38          	mov    0x38(%rax),%r8
  8004211f3f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211f43:	48 8b 48 70          	mov    0x70(%rax),%rcx
  8004211f47:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211f4b:	48 8b 50 68          	mov    0x68(%rax),%rdx
  8004211f4f:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8004211f53:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211f57:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
  8004211f5b:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  8004211f60:	48 8d 7d d8          	lea    -0x28(%rbp),%rdi
  8004211f64:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  8004211f69:	48 c7 44 24 08 ff ff 	movq   $0xffffffffffffffff,0x8(%rsp)
  8004211f70:	ff ff 
  8004211f72:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  8004211f79:	00 
  8004211f7a:	48 89 c7             	mov    %rax,%rdi
  8004211f7d:	48 b8 cb 0f 21 04 80 	movabs $0x8004210fcb,%rax
  8004211f84:	00 00 00 
  8004211f87:	ff d0                	callq  *%rax
  8004211f89:	89 45 e4             	mov    %eax,-0x1c(%rbp)
            cie->cie_instlen, cie->cie_caf, cie->cie_daf, 0, ~0ULL,
            &row_pc, error);
        if (ret != DW_DLE_NONE)
  8004211f8c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004211f90:	74 08                	je     8004211f9a <_dwarf_frame_get_internal_table+0x1f3>
                return (ret);
  8004211f92:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004211f95:	e9 98 00 00 00       	jmpq   8004212032 <_dwarf_frame_get_internal_table+0x28b>
        /* Run instructions in FDE. */
        if (pc_req >= fde->fde_initloc) {
  8004211f9a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004211f9e:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004211fa2:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004211fa6:	77 6f                	ja     8004212017 <_dwarf_frame_get_internal_table+0x270>
                ret = _dwarf_frame_run_inst(dbg, rt, fde->fde_inst,
  8004211fa8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004211fac:	48 8b 78 30          	mov    0x30(%rax),%rdi
  8004211fb0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211fb4:	4c 8b 48 40          	mov    0x40(%rax),%r9
  8004211fb8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211fbc:	4c 8b 50 38          	mov    0x38(%rax),%r10
  8004211fc0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004211fc4:	48 8b 48 58          	mov    0x58(%rax),%rcx
  8004211fc8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004211fcc:	48 8b 50 50          	mov    0x50(%rax),%rdx
  8004211fd0:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8004211fd4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211fd8:	4c 8b 45 a0          	mov    -0x60(%rbp),%r8
  8004211fdc:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
  8004211fe1:	4c 8d 45 d8          	lea    -0x28(%rbp),%r8
  8004211fe5:	4c 89 44 24 10       	mov    %r8,0x10(%rsp)
  8004211fea:	4c 8b 45 b8          	mov    -0x48(%rbp),%r8
  8004211fee:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  8004211ff3:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004211ff7:	4d 89 d0             	mov    %r10,%r8
  8004211ffa:	48 89 c7             	mov    %rax,%rdi
  8004211ffd:	48 b8 cb 0f 21 04 80 	movabs $0x8004210fcb,%rax
  8004212004:	00 00 00 
  8004212007:	ff d0                	callq  *%rax
  8004212009:	89 45 e4             	mov    %eax,-0x1c(%rbp)
                    fde->fde_instlen, cie->cie_caf, cie->cie_daf,
                    fde->fde_initloc, pc_req, &row_pc, error);
                if (ret != DW_DLE_NONE)
  800421200c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004212010:	74 05                	je     8004212017 <_dwarf_frame_get_internal_table+0x270>
                        return (ret);
  8004212012:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004212015:	eb 1b                	jmp    8004212032 <_dwarf_frame_get_internal_table+0x28b>
        }

        *ret_rt = rt;
  8004212017:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421201b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800421201f:	48 89 10             	mov    %rdx,(%rax)
        *ret_row_pc = row_pc;
  8004212022:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004212026:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421202a:	48 89 10             	mov    %rdx,(%rax)

        return (DW_DLE_NONE);
  800421202d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004212032:	c9                   	leaveq 
  8004212033:	c3                   	retq   

0000008004212034 <dwarf_get_fde_info_for_all_regs>:

int
dwarf_get_fde_info_for_all_regs(Dwarf_Debug dbg, Dwarf_Fde fde,
    Dwarf_Addr pc_requested, Dwarf_Regtable *reg_table, Dwarf_Addr *row_pc,
    Dwarf_Error *error)
{
  8004212034:	55                   	push   %rbp
  8004212035:	48 89 e5             	mov    %rsp,%rbp
  8004212038:	48 83 ec 50          	sub    $0x50,%rsp
  800421203c:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004212040:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004212044:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004212048:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  800421204c:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
  8004212050:	4c 89 4d b0          	mov    %r9,-0x50(%rbp)
        Dwarf_Regtable3 *rt;
        Dwarf_Addr pc;
        Dwarf_Half cfa;
        int i, ret;

        if (fde == NULL || reg_table == NULL) {
  8004212054:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004212059:	74 07                	je     8004212062 <dwarf_get_fde_info_for_all_regs+0x2e>
  800421205b:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004212060:	75 0a                	jne    800421206c <dwarf_get_fde_info_for_all_regs+0x38>
                DWARF_SET_ERROR(dbg, error, DW_DLE_ARGUMENT);
                return (DW_DLV_ERROR);
  8004212062:	b8 01 00 00 00       	mov    $0x1,%eax
  8004212067:	e9 eb 02 00 00       	jmpq   8004212357 <dwarf_get_fde_info_for_all_regs+0x323>
        }

        assert(dbg != NULL);
  800421206c:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004212071:	75 35                	jne    80042120a8 <dwarf_get_fde_info_for_all_regs+0x74>
  8004212073:	48 b9 7f 82 21 04 80 	movabs $0x800421827f,%rcx
  800421207a:	00 00 00 
  800421207d:	48 ba 7f 81 21 04 80 	movabs $0x800421817f,%rdx
  8004212084:	00 00 00 
  8004212087:	be b8 01 00 00       	mov    $0x1b8,%esi
  800421208c:	48 bf 94 81 21 04 80 	movabs $0x8004218194,%rdi
  8004212093:	00 00 00 
  8004212096:	b8 00 00 00 00       	mov    $0x0,%eax
  800421209b:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042120a2:	00 00 00 
  80042120a5:	41 ff d0             	callq  *%r8

        if (pc_requested < fde->fde_initloc ||
  80042120a8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042120ac:	48 8b 40 30          	mov    0x30(%rax),%rax
  80042120b0:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  80042120b4:	77 19                	ja     80042120cf <dwarf_get_fde_info_for_all_regs+0x9b>
            pc_requested >= fde->fde_initloc + fde->fde_adrange) {
  80042120b6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042120ba:	48 8b 50 30          	mov    0x30(%rax),%rdx
  80042120be:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042120c2:	48 8b 40 38          	mov    0x38(%rax),%rax
  80042120c6:	48 01 d0             	add    %rdx,%rax
                return (DW_DLV_ERROR);
        }

        assert(dbg != NULL);

        if (pc_requested < fde->fde_initloc ||
  80042120c9:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  80042120cd:	77 0a                	ja     80042120d9 <dwarf_get_fde_info_for_all_regs+0xa5>
            pc_requested >= fde->fde_initloc + fde->fde_adrange) {
                DWARF_SET_ERROR(dbg, error, DW_DLE_PC_NOT_IN_FDE_RANGE);
                return (DW_DLV_ERROR);
  80042120cf:	b8 01 00 00 00       	mov    $0x1,%eax
  80042120d4:	e9 7e 02 00 00       	jmpq   8004212357 <dwarf_get_fde_info_for_all_regs+0x323>
        }

        ret = _dwarf_frame_get_internal_table(dbg, fde, pc_requested, &rt, &pc,
  80042120d9:	4c 8b 45 b0          	mov    -0x50(%rbp),%r8
  80042120dd:	48 8d 7d e0          	lea    -0x20(%rbp),%rdi
  80042120e1:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  80042120e5:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042120e9:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042120ed:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042120f1:	4d 89 c1             	mov    %r8,%r9
  80042120f4:	49 89 f8             	mov    %rdi,%r8
  80042120f7:	48 89 c7             	mov    %rax,%rdi
  80042120fa:	48 b8 a7 1d 21 04 80 	movabs $0x8004211da7,%rax
  8004212101:	00 00 00 
  8004212104:	ff d0                	callq  *%rax
  8004212106:	89 45 f8             	mov    %eax,-0x8(%rbp)
                                              error);
        if (ret != DW_DLE_NONE)
  8004212109:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800421210d:	74 0a                	je     8004212119 <dwarf_get_fde_info_for_all_regs+0xe5>
                return (DW_DLV_ERROR);
  800421210f:	b8 01 00 00 00       	mov    $0x1,%eax
  8004212114:	e9 3e 02 00 00       	jmpq   8004212357 <dwarf_get_fde_info_for_all_regs+0x323>
        /*
         * Copy the CFA rule to the column intended for holding the CFA,
         * if it's within the range of regtable.
         */
#define CFA rt->rt3_cfa_rule
        cfa = dbg->dbg_frame_cfa_value;
  8004212119:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421211d:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004212121:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
        if (cfa < DW_REG_TABLE_SIZE) {
  8004212125:	66 83 7d f6 41       	cmpw   $0x41,-0xa(%rbp)
  800421212a:	0f 87 b1 00 00 00    	ja     80042121e1 <dwarf_get_fde_info_for_all_regs+0x1ad>
                reg_table->rules[cfa].dw_offset_relevant =
  8004212130:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
                    CFA.dw_offset_relevant;
  8004212134:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212138:	0f b6 00             	movzbl (%rax),%eax
         * if it's within the range of regtable.
         */
#define CFA rt->rt3_cfa_rule
        cfa = dbg->dbg_frame_cfa_value;
        if (cfa < DW_REG_TABLE_SIZE) {
                reg_table->rules[cfa].dw_offset_relevant =
  800421213b:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421213f:	48 63 c9             	movslq %ecx,%rcx
  8004212142:	48 83 c1 01          	add    $0x1,%rcx
  8004212146:	48 c1 e1 04          	shl    $0x4,%rcx
  800421214a:	48 01 ca             	add    %rcx,%rdx
  800421214d:	88 02                	mov    %al,(%rdx)
                    CFA.dw_offset_relevant;
                reg_table->rules[cfa].dw_value_type = CFA.dw_value_type;
  800421214f:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  8004212153:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212157:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  800421215b:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421215f:	48 63 c9             	movslq %ecx,%rcx
  8004212162:	48 83 c1 01          	add    $0x1,%rcx
  8004212166:	48 c1 e1 04          	shl    $0x4,%rcx
  800421216a:	48 01 ca             	add    %rcx,%rdx
  800421216d:	88 42 01             	mov    %al,0x1(%rdx)
                reg_table->rules[cfa].dw_regnum = CFA.dw_regnum;
  8004212170:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  8004212174:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212178:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  800421217c:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004212180:	48 63 c9             	movslq %ecx,%rcx
  8004212183:	48 83 c1 01          	add    $0x1,%rcx
  8004212187:	48 c1 e1 04          	shl    $0x4,%rcx
  800421218b:	48 01 ca             	add    %rcx,%rdx
  800421218e:	66 89 42 02          	mov    %ax,0x2(%rdx)
                reg_table->rules[cfa].dw_offset = CFA.dw_offset_or_block_len;
  8004212192:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  8004212196:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421219a:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421219e:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042121a2:	48 63 c9             	movslq %ecx,%rcx
  80042121a5:	48 83 c1 01          	add    $0x1,%rcx
  80042121a9:	48 c1 e1 04          	shl    $0x4,%rcx
  80042121ad:	48 01 ca             	add    %rcx,%rdx
  80042121b0:	48 83 c2 08          	add    $0x8,%rdx
  80042121b4:	48 89 02             	mov    %rax,(%rdx)
                reg_table->cfa_rule = reg_table->rules[cfa];
  80042121b7:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80042121bb:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  80042121bf:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042121c3:	48 63 d2             	movslq %edx,%rdx
  80042121c6:	48 83 c2 01          	add    $0x1,%rdx
  80042121ca:	48 c1 e2 04          	shl    $0x4,%rdx
  80042121ce:	48 01 d0             	add    %rdx,%rax
  80042121d1:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80042121d5:	48 8b 00             	mov    (%rax),%rax
  80042121d8:	48 89 01             	mov    %rax,(%rcx)
  80042121db:	48 89 51 08          	mov    %rdx,0x8(%rcx)
  80042121df:	eb 3c                	jmp    800421221d <dwarf_get_fde_info_for_all_regs+0x1e9>
        } else {
                reg_table->cfa_rule.dw_offset_relevant =
                    CFA.dw_offset_relevant;
  80042121e1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042121e5:	0f b6 10             	movzbl (%rax),%edx
                reg_table->rules[cfa].dw_value_type = CFA.dw_value_type;
                reg_table->rules[cfa].dw_regnum = CFA.dw_regnum;
                reg_table->rules[cfa].dw_offset = CFA.dw_offset_or_block_len;
                reg_table->cfa_rule = reg_table->rules[cfa];
        } else {
                reg_table->cfa_rule.dw_offset_relevant =
  80042121e8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042121ec:	88 10                	mov    %dl,(%rax)
                    CFA.dw_offset_relevant;
                reg_table->cfa_rule.dw_value_type = CFA.dw_value_type;
  80042121ee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042121f2:	0f b6 50 01          	movzbl 0x1(%rax),%edx
  80042121f6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042121fa:	88 50 01             	mov    %dl,0x1(%rax)
                reg_table->cfa_rule.dw_regnum = CFA.dw_regnum;
  80042121fd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212201:	0f b7 50 02          	movzwl 0x2(%rax),%edx
  8004212205:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212209:	66 89 50 02          	mov    %dx,0x2(%rax)
                reg_table->cfa_rule.dw_offset = CFA.dw_offset_or_block_len;
  800421220d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212211:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004212215:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212219:	48 89 50 08          	mov    %rdx,0x8(%rax)
        }

        /*
         * Copy other columns.
         */
        for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
  800421221d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004212224:	e9 fd 00 00 00       	jmpq   8004212326 <dwarf_get_fde_info_for_all_regs+0x2f2>
             i++) {

                /* Do not overwrite CFA column */
                if (i == cfa)
  8004212229:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  800421222d:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8004212230:	75 05                	jne    8004212237 <dwarf_get_fde_info_for_all_regs+0x203>
                        continue;
  8004212232:	e9 eb 00 00 00       	jmpq   8004212322 <dwarf_get_fde_info_for_all_regs+0x2ee>

                reg_table->rules[i].dw_offset_relevant =
                    rt->rt3_rules[i].dw_offset_relevant;
  8004212237:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421223b:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421223f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004212242:	48 63 d0             	movslq %eax,%rdx
  8004212245:	48 89 d0             	mov    %rdx,%rax
  8004212248:	48 01 c0             	add    %rax,%rax
  800421224b:	48 01 d0             	add    %rdx,%rax
  800421224e:	48 c1 e0 03          	shl    $0x3,%rax
  8004212252:	48 01 c8             	add    %rcx,%rax
  8004212255:	0f b6 00             	movzbl (%rax),%eax

                /* Do not overwrite CFA column */
                if (i == cfa)
                        continue;

                reg_table->rules[i].dw_offset_relevant =
  8004212258:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421225c:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  800421225f:	48 63 c9             	movslq %ecx,%rcx
  8004212262:	48 83 c1 01          	add    $0x1,%rcx
  8004212266:	48 c1 e1 04          	shl    $0x4,%rcx
  800421226a:	48 01 ca             	add    %rcx,%rdx
  800421226d:	88 02                	mov    %al,(%rdx)
                    rt->rt3_rules[i].dw_offset_relevant;
                reg_table->rules[i].dw_value_type =
                    rt->rt3_rules[i].dw_value_type;
  800421226f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212273:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212277:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421227a:	48 63 d0             	movslq %eax,%rdx
  800421227d:	48 89 d0             	mov    %rdx,%rax
  8004212280:	48 01 c0             	add    %rax,%rax
  8004212283:	48 01 d0             	add    %rdx,%rax
  8004212286:	48 c1 e0 03          	shl    $0x3,%rax
  800421228a:	48 01 c8             	add    %rcx,%rax
  800421228d:	0f b6 40 01          	movzbl 0x1(%rax),%eax
                if (i == cfa)
                        continue;

                reg_table->rules[i].dw_offset_relevant =
                    rt->rt3_rules[i].dw_offset_relevant;
                reg_table->rules[i].dw_value_type =
  8004212291:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004212295:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004212298:	48 63 c9             	movslq %ecx,%rcx
  800421229b:	48 83 c1 01          	add    $0x1,%rcx
  800421229f:	48 c1 e1 04          	shl    $0x4,%rcx
  80042122a3:	48 01 ca             	add    %rcx,%rdx
  80042122a6:	88 42 01             	mov    %al,0x1(%rdx)
                    rt->rt3_rules[i].dw_value_type;
                reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
  80042122a9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042122ad:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042122b1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042122b4:	48 63 d0             	movslq %eax,%rdx
  80042122b7:	48 89 d0             	mov    %rdx,%rax
  80042122ba:	48 01 c0             	add    %rax,%rax
  80042122bd:	48 01 d0             	add    %rdx,%rax
  80042122c0:	48 c1 e0 03          	shl    $0x3,%rax
  80042122c4:	48 01 c8             	add    %rcx,%rax
  80042122c7:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  80042122cb:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042122cf:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  80042122d2:	48 63 c9             	movslq %ecx,%rcx
  80042122d5:	48 83 c1 01          	add    $0x1,%rcx
  80042122d9:	48 c1 e1 04          	shl    $0x4,%rcx
  80042122dd:	48 01 ca             	add    %rcx,%rdx
  80042122e0:	66 89 42 02          	mov    %ax,0x2(%rdx)
                reg_table->rules[i].dw_offset =
                    rt->rt3_rules[i].dw_offset_or_block_len;
  80042122e4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042122e8:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042122ec:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042122ef:	48 63 d0             	movslq %eax,%rdx
  80042122f2:	48 89 d0             	mov    %rdx,%rax
  80042122f5:	48 01 c0             	add    %rax,%rax
  80042122f8:	48 01 d0             	add    %rdx,%rax
  80042122fb:	48 c1 e0 03          	shl    $0x3,%rax
  80042122ff:	48 01 c8             	add    %rcx,%rax
  8004212302:	48 8b 40 08          	mov    0x8(%rax),%rax
                reg_table->rules[i].dw_offset_relevant =
                    rt->rt3_rules[i].dw_offset_relevant;
                reg_table->rules[i].dw_value_type =
                    rt->rt3_rules[i].dw_value_type;
                reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
                reg_table->rules[i].dw_offset =
  8004212306:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421230a:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  800421230d:	48 63 c9             	movslq %ecx,%rcx
  8004212310:	48 83 c1 01          	add    $0x1,%rcx
  8004212314:	48 c1 e1 04          	shl    $0x4,%rcx
  8004212318:	48 01 ca             	add    %rcx,%rdx
  800421231b:	48 83 c2 08          	add    $0x8,%rdx
  800421231f:	48 89 02             	mov    %rax,(%rdx)

        /*
         * Copy other columns.
         */
        for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
             i++) {
  8004212322:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
        }

        /*
         * Copy other columns.
         */
        for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
  8004212326:	83 7d fc 41          	cmpl   $0x41,-0x4(%rbp)
  800421232a:	7f 14                	jg     8004212340 <dwarf_get_fde_info_for_all_regs+0x30c>
  800421232c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004212330:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  8004212334:	0f b7 c0             	movzwl %ax,%eax
  8004212337:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  800421233a:	0f 8f e9 fe ff ff    	jg     8004212229 <dwarf_get_fde_info_for_all_regs+0x1f5>
                reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
                reg_table->rules[i].dw_offset =
                    rt->rt3_rules[i].dw_offset_or_block_len;
        }

        if (row_pc) *row_pc = pc;
  8004212340:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004212345:	74 0b                	je     8004212352 <dwarf_get_fde_info_for_all_regs+0x31e>
  8004212347:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421234b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421234f:	48 89 10             	mov    %rdx,(%rax)
        return (DW_DLV_OK);
  8004212352:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004212357:	c9                   	leaveq 
  8004212358:	c3                   	retq   

0000008004212359 <_dwarf_frame_read_lsb_encoded>:

static int
_dwarf_frame_read_lsb_encoded(Dwarf_Debug dbg, uint64_t *val, uint8_t *data,
    uint64_t *offsetp, uint8_t encode, Dwarf_Addr pc, Dwarf_Error *error)
{
  8004212359:	55                   	push   %rbp
  800421235a:	48 89 e5             	mov    %rsp,%rbp
  800421235d:	48 83 ec 40          	sub    $0x40,%rsp
  8004212361:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004212365:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004212369:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800421236d:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  8004212371:	44 89 c0             	mov    %r8d,%eax
  8004212374:	4c 89 4d c0          	mov    %r9,-0x40(%rbp)
  8004212378:	88 45 cc             	mov    %al,-0x34(%rbp)
	uint8_t application;

	if (encode == DW_EH_PE_omit)
  800421237b:	80 7d cc ff          	cmpb   $0xff,-0x34(%rbp)
  800421237f:	75 0a                	jne    800421238b <_dwarf_frame_read_lsb_encoded+0x32>
		return (DW_DLE_NONE);
  8004212381:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212386:	e9 e6 01 00 00       	jmpq   8004212571 <_dwarf_frame_read_lsb_encoded+0x218>

	application = encode & 0xf0;
  800421238b:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  800421238f:	83 e0 f0             	and    $0xfffffff0,%eax
  8004212392:	88 45 ff             	mov    %al,-0x1(%rbp)
	encode &= 0x0f;
  8004212395:	80 65 cc 0f          	andb   $0xf,-0x34(%rbp)

	switch (encode) {
  8004212399:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  800421239d:	83 f8 0c             	cmp    $0xc,%eax
  80042123a0:	0f 87 72 01 00 00    	ja     8004212518 <_dwarf_frame_read_lsb_encoded+0x1bf>
  80042123a6:	89 c0                	mov    %eax,%eax
  80042123a8:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042123af:	00 
  80042123b0:	48 b8 98 82 21 04 80 	movabs $0x8004218298,%rax
  80042123b7:	00 00 00 
  80042123ba:	48 01 d0             	add    %rdx,%rax
  80042123bd:	48 8b 00             	mov    (%rax),%rax
  80042123c0:	ff e0                	jmpq   *%rax
	case DW_EH_PE_absptr:
		*val = dbg->read(data, offsetp, dbg->dbg_pointer_size);
  80042123c2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042123c6:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042123ca:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042123ce:	8b 52 28             	mov    0x28(%rdx),%edx
  80042123d1:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042123d5:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042123d9:	48 89 cf             	mov    %rcx,%rdi
  80042123dc:	ff d0                	callq  *%rax
  80042123de:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042123e2:	48 89 02             	mov    %rax,(%rdx)
		break;
  80042123e5:	e9 35 01 00 00       	jmpq   800421251f <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_uleb128:
		*val = _dwarf_read_uleb128(data, offsetp);
  80042123ea:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042123ee:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042123f2:	48 89 d6             	mov    %rdx,%rsi
  80042123f5:	48 89 c7             	mov    %rax,%rdi
  80042123f8:	48 b8 ed f3 20 04 80 	movabs $0x800420f3ed,%rax
  80042123ff:	00 00 00 
  8004212402:	ff d0                	callq  *%rax
  8004212404:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004212408:	48 89 02             	mov    %rax,(%rdx)
		break;
  800421240b:	e9 0f 01 00 00       	jmpq   800421251f <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_udata2:
		*val = dbg->read(data, offsetp, 2);
  8004212410:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212414:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212418:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800421241c:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004212420:	ba 02 00 00 00       	mov    $0x2,%edx
  8004212425:	48 89 cf             	mov    %rcx,%rdi
  8004212428:	ff d0                	callq  *%rax
  800421242a:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421242e:	48 89 02             	mov    %rax,(%rdx)
		break;
  8004212431:	e9 e9 00 00 00       	jmpq   800421251f <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_udata4:
		*val = dbg->read(data, offsetp, 4);
  8004212436:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421243a:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421243e:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004212442:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004212446:	ba 04 00 00 00       	mov    $0x4,%edx
  800421244b:	48 89 cf             	mov    %rcx,%rdi
  800421244e:	ff d0                	callq  *%rax
  8004212450:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004212454:	48 89 02             	mov    %rax,(%rdx)
		break;
  8004212457:	e9 c3 00 00 00       	jmpq   800421251f <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_udata8:
		*val = dbg->read(data, offsetp, 8);
  800421245c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212460:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212464:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004212468:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800421246c:	ba 08 00 00 00       	mov    $0x8,%edx
  8004212471:	48 89 cf             	mov    %rcx,%rdi
  8004212474:	ff d0                	callq  *%rax
  8004212476:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421247a:	48 89 02             	mov    %rax,(%rdx)
		break;
  800421247d:	e9 9d 00 00 00       	jmpq   800421251f <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sleb128:
		*val = _dwarf_read_sleb128(data, offsetp);
  8004212482:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212486:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421248a:	48 89 d6             	mov    %rdx,%rsi
  800421248d:	48 89 c7             	mov    %rax,%rdi
  8004212490:	48 b8 49 f3 20 04 80 	movabs $0x800420f349,%rax
  8004212497:	00 00 00 
  800421249a:	ff d0                	callq  *%rax
  800421249c:	48 89 c2             	mov    %rax,%rdx
  800421249f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042124a3:	48 89 10             	mov    %rdx,(%rax)
		break;
  80042124a6:	eb 77                	jmp    800421251f <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sdata2:
		*val = (int16_t) dbg->read(data, offsetp, 2);
  80042124a8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042124ac:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042124b0:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042124b4:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042124b8:	ba 02 00 00 00       	mov    $0x2,%edx
  80042124bd:	48 89 cf             	mov    %rcx,%rdi
  80042124c0:	ff d0                	callq  *%rax
  80042124c2:	48 0f bf d0          	movswq %ax,%rdx
  80042124c6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042124ca:	48 89 10             	mov    %rdx,(%rax)
		break;
  80042124cd:	eb 50                	jmp    800421251f <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sdata4:
		*val = (int32_t) dbg->read(data, offsetp, 4);
  80042124cf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042124d3:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042124d7:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042124db:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042124df:	ba 04 00 00 00       	mov    $0x4,%edx
  80042124e4:	48 89 cf             	mov    %rcx,%rdi
  80042124e7:	ff d0                	callq  *%rax
  80042124e9:	48 63 d0             	movslq %eax,%rdx
  80042124ec:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042124f0:	48 89 10             	mov    %rdx,(%rax)
		break;
  80042124f3:	eb 2a                	jmp    800421251f <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sdata8:
		*val = dbg->read(data, offsetp, 8);
  80042124f5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042124f9:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042124fd:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004212501:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004212505:	ba 08 00 00 00       	mov    $0x8,%edx
  800421250a:	48 89 cf             	mov    %rcx,%rdi
  800421250d:	ff d0                	callq  *%rax
  800421250f:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004212513:	48 89 02             	mov    %rax,(%rdx)
		break;
  8004212516:	eb 07                	jmp    800421251f <_dwarf_frame_read_lsb_encoded+0x1c6>
	default:
		DWARF_SET_ERROR(dbg, error, DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
		return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
  8004212518:	b8 14 00 00 00       	mov    $0x14,%eax
  800421251d:	eb 52                	jmp    8004212571 <_dwarf_frame_read_lsb_encoded+0x218>
	}

	if (application == DW_EH_PE_pcrel) {
  800421251f:	80 7d ff 10          	cmpb   $0x10,-0x1(%rbp)
  8004212523:	75 47                	jne    800421256c <_dwarf_frame_read_lsb_encoded+0x213>
		/*
		 * Value is relative to .eh_frame section virtual addr.
		 */
		switch (encode) {
  8004212525:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004212529:	83 f8 01             	cmp    $0x1,%eax
  800421252c:	7c 3d                	jl     800421256b <_dwarf_frame_read_lsb_encoded+0x212>
  800421252e:	83 f8 04             	cmp    $0x4,%eax
  8004212531:	7e 0a                	jle    800421253d <_dwarf_frame_read_lsb_encoded+0x1e4>
  8004212533:	83 e8 09             	sub    $0x9,%eax
  8004212536:	83 f8 03             	cmp    $0x3,%eax
  8004212539:	77 30                	ja     800421256b <_dwarf_frame_read_lsb_encoded+0x212>
  800421253b:	eb 17                	jmp    8004212554 <_dwarf_frame_read_lsb_encoded+0x1fb>
		case DW_EH_PE_uleb128:
		case DW_EH_PE_udata2:
		case DW_EH_PE_udata4:
		case DW_EH_PE_udata8:
			*val += pc;
  800421253d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212541:	48 8b 10             	mov    (%rax),%rdx
  8004212544:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212548:	48 01 c2             	add    %rax,%rdx
  800421254b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421254f:	48 89 10             	mov    %rdx,(%rax)
			break;
  8004212552:	eb 18                	jmp    800421256c <_dwarf_frame_read_lsb_encoded+0x213>
		case DW_EH_PE_sleb128:
		case DW_EH_PE_sdata2:
		case DW_EH_PE_sdata4:
		case DW_EH_PE_sdata8:
			*val = pc + (int64_t) *val;
  8004212554:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212558:	48 8b 10             	mov    (%rax),%rdx
  800421255b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421255f:	48 01 c2             	add    %rax,%rdx
  8004212562:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212566:	48 89 10             	mov    %rdx,(%rax)
			break;
  8004212569:	eb 01                	jmp    800421256c <_dwarf_frame_read_lsb_encoded+0x213>
		default:
			/* DW_EH_PE_absptr is absolute value. */
			break;
  800421256b:	90                   	nop
		}
	}

	/* XXX Applications other than DW_EH_PE_pcrel are not handled. */

	return (DW_DLE_NONE);
  800421256c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004212571:	c9                   	leaveq 
  8004212572:	c3                   	retq   

0000008004212573 <_dwarf_frame_parse_lsb_cie_augment>:

static int
_dwarf_frame_parse_lsb_cie_augment(Dwarf_Debug dbg, Dwarf_Cie cie,
    Dwarf_Error *error)
{
  8004212573:	55                   	push   %rbp
  8004212574:	48 89 e5             	mov    %rsp,%rbp
  8004212577:	48 83 ec 50          	sub    $0x50,%rsp
  800421257b:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800421257f:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004212583:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
	uint8_t *aug_p, *augdata_p;
	uint64_t val, offset;
	uint8_t encode;
	int ret;

	assert(cie->cie_augment != NULL && *cie->cie_augment == 'z');
  8004212587:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421258b:	48 8b 40 28          	mov    0x28(%rax),%rax
  800421258f:	48 85 c0             	test   %rax,%rax
  8004212592:	74 0f                	je     80042125a3 <_dwarf_frame_parse_lsb_cie_augment+0x30>
  8004212594:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212598:	48 8b 40 28          	mov    0x28(%rax),%rax
  800421259c:	0f b6 00             	movzbl (%rax),%eax
  800421259f:	3c 7a                	cmp    $0x7a,%al
  80042125a1:	74 35                	je     80042125d8 <_dwarf_frame_parse_lsb_cie_augment+0x65>
  80042125a3:	48 b9 00 83 21 04 80 	movabs $0x8004218300,%rcx
  80042125aa:	00 00 00 
  80042125ad:	48 ba 7f 81 21 04 80 	movabs $0x800421817f,%rdx
  80042125b4:	00 00 00 
  80042125b7:	be 43 02 00 00       	mov    $0x243,%esi
  80042125bc:	48 bf 94 81 21 04 80 	movabs $0x8004218194,%rdi
  80042125c3:	00 00 00 
  80042125c6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042125cb:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042125d2:	00 00 00 
  80042125d5:	41 ff d0             	callq  *%r8
	/*
	 * Here we're only interested in the presence of augment 'R'
	 * and associated CIE augment data, which describes the
	 * encoding scheme of FDE PC begin and range.
	 */
	aug_p = &cie->cie_augment[1];
  80042125d8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042125dc:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042125e0:	48 83 c0 01          	add    $0x1,%rax
  80042125e4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	augdata_p = cie->cie_augdata;
  80042125e8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042125ec:	48 8b 40 58          	mov    0x58(%rax),%rax
  80042125f0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	while (*aug_p != '\0') {
  80042125f4:	e9 af 00 00 00       	jmpq   80042126a8 <_dwarf_frame_parse_lsb_cie_augment+0x135>
		switch (*aug_p) {
  80042125f9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042125fd:	0f b6 00             	movzbl (%rax),%eax
  8004212600:	0f b6 c0             	movzbl %al,%eax
  8004212603:	83 f8 50             	cmp    $0x50,%eax
  8004212606:	74 18                	je     8004212620 <_dwarf_frame_parse_lsb_cie_augment+0xad>
  8004212608:	83 f8 52             	cmp    $0x52,%eax
  800421260b:	74 77                	je     8004212684 <_dwarf_frame_parse_lsb_cie_augment+0x111>
  800421260d:	83 f8 4c             	cmp    $0x4c,%eax
  8004212610:	0f 85 86 00 00 00    	jne    800421269c <_dwarf_frame_parse_lsb_cie_augment+0x129>
		case 'L':
			/* Skip one augment in augment data. */
			augdata_p++;
  8004212616:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
			break;
  800421261b:	e9 83 00 00 00       	jmpq   80042126a3 <_dwarf_frame_parse_lsb_cie_augment+0x130>
		case 'P':
			/* Skip two augments in augment data. */
			encode = *augdata_p++;
  8004212620:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212624:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004212628:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  800421262c:	0f b6 00             	movzbl (%rax),%eax
  800421262f:	88 45 ef             	mov    %al,-0x11(%rbp)
			offset = 0;
  8004212632:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  8004212639:	00 
			ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  800421263a:	44 0f b6 45 ef       	movzbl -0x11(%rbp),%r8d
  800421263f:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  8004212643:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004212647:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  800421264b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421264f:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8004212653:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004212657:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  800421265d:	48 89 c7             	mov    %rax,%rdi
  8004212660:	48 b8 59 23 21 04 80 	movabs $0x8004212359,%rax
  8004212667:	00 00 00 
  800421266a:	ff d0                	callq  *%rax
  800421266c:	89 45 e8             	mov    %eax,-0x18(%rbp)
			    augdata_p, &offset, encode, 0, error);
			if (ret != DW_DLE_NONE)
  800421266f:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  8004212673:	74 05                	je     800421267a <_dwarf_frame_parse_lsb_cie_augment+0x107>
				return (ret);
  8004212675:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004212678:	eb 42                	jmp    80042126bc <_dwarf_frame_parse_lsb_cie_augment+0x149>
			augdata_p += offset;
  800421267a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421267e:	48 01 45 f0          	add    %rax,-0x10(%rbp)
			break;
  8004212682:	eb 1f                	jmp    80042126a3 <_dwarf_frame_parse_lsb_cie_augment+0x130>
		case 'R':
			cie->cie_fde_encode = *augdata_p++;
  8004212684:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212688:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800421268c:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  8004212690:	0f b6 10             	movzbl (%rax),%edx
  8004212693:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212697:	88 50 60             	mov    %dl,0x60(%rax)
			break;
  800421269a:	eb 07                	jmp    80042126a3 <_dwarf_frame_parse_lsb_cie_augment+0x130>
		default:
			DWARF_SET_ERROR(dbg, error,
			    DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
			return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
  800421269c:	b8 14 00 00 00       	mov    $0x14,%eax
  80042126a1:	eb 19                	jmp    80042126bc <_dwarf_frame_parse_lsb_cie_augment+0x149>
		}
		aug_p++;
  80042126a3:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
	 * and associated CIE augment data, which describes the
	 * encoding scheme of FDE PC begin and range.
	 */
	aug_p = &cie->cie_augment[1];
	augdata_p = cie->cie_augdata;
	while (*aug_p != '\0') {
  80042126a8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042126ac:	0f b6 00             	movzbl (%rax),%eax
  80042126af:	84 c0                	test   %al,%al
  80042126b1:	0f 85 42 ff ff ff    	jne    80042125f9 <_dwarf_frame_parse_lsb_cie_augment+0x86>
			return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
		}
		aug_p++;
	}

	return (DW_DLE_NONE);
  80042126b7:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042126bc:	c9                   	leaveq 
  80042126bd:	c3                   	retq   

00000080042126be <_dwarf_frame_set_cie>:


static int
_dwarf_frame_set_cie(Dwarf_Debug dbg, Dwarf_Unsigned *off, Dwarf_Cie ret_cie,
		     Dwarf_Error *error)
{
  80042126be:	55                   	push   %rbp
  80042126bf:	48 89 e5             	mov    %rsp,%rbp
  80042126c2:	48 83 ec 50          	sub    $0x50,%rsp
  80042126c6:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80042126ca:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  80042126ce:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  80042126d2:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	Dwarf_Cie cie;
	uint64_t length;
	int dwarf_size, ret;
	char *p;

	assert(ret_cie);
  80042126d6:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  80042126db:	75 35                	jne    8004212712 <_dwarf_frame_set_cie+0x54>
  80042126dd:	48 b9 35 83 21 04 80 	movabs $0x8004218335,%rcx
  80042126e4:	00 00 00 
  80042126e7:	48 ba 7f 81 21 04 80 	movabs $0x800421817f,%rdx
  80042126ee:	00 00 00 
  80042126f1:	be 74 02 00 00       	mov    $0x274,%esi
  80042126f6:	48 bf 94 81 21 04 80 	movabs $0x8004218194,%rdi
  80042126fd:	00 00 00 
  8004212700:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212705:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800421270c:	00 00 00 
  800421270f:	41 ff d0             	callq  *%r8
	cie = ret_cie;
  8004212712:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212716:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	cie->cie_dbg = dbg;
  800421271a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421271e:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212722:	48 89 10             	mov    %rdx,(%rax)
	cie->cie_offset = *off;
  8004212725:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212729:	48 8b 10             	mov    (%rax),%rdx
  800421272c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212730:	48 89 50 10          	mov    %rdx,0x10(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  8004212734:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212738:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421273c:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212740:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004212744:	48 89 d1             	mov    %rdx,%rcx
  8004212747:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800421274b:	ba 04 00 00 00       	mov    $0x4,%edx
  8004212750:	48 89 cf             	mov    %rcx,%rdi
  8004212753:	ff d0                	callq  *%rax
  8004212755:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (length == 0xffffffff) {
  8004212759:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800421275e:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004212762:	75 2e                	jne    8004212792 <_dwarf_frame_set_cie+0xd4>
		dwarf_size = 8;
  8004212764:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 8);
  800421276b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421276f:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212773:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212777:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  800421277b:	48 89 d1             	mov    %rdx,%rcx
  800421277e:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004212782:	ba 08 00 00 00       	mov    $0x8,%edx
  8004212787:	48 89 cf             	mov    %rcx,%rdi
  800421278a:	ff d0                	callq  *%rax
  800421278c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004212790:	eb 07                	jmp    8004212799 <_dwarf_frame_set_cie+0xdb>
	} else
		dwarf_size = 4;
  8004212792:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

	if (length > dbg->dbg_eh_size - *off) {
  8004212799:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421279d:	48 8b 50 40          	mov    0x40(%rax),%rdx
  80042127a1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042127a5:	48 8b 00             	mov    (%rax),%rax
  80042127a8:	48 29 c2             	sub    %rax,%rdx
  80042127ab:	48 89 d0             	mov    %rdx,%rax
  80042127ae:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042127b2:	73 0a                	jae    80042127be <_dwarf_frame_set_cie+0x100>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_FRAME_LENGTH_BAD);
		return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  80042127b4:	b8 12 00 00 00       	mov    $0x12,%eax
  80042127b9:	e9 5d 03 00 00       	jmpq   8004212b1b <_dwarf_frame_set_cie+0x45d>
	}

	(void) dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size); /* Skip CIE id. */
  80042127be:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042127c2:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042127c6:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042127ca:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  80042127ce:	48 89 d1             	mov    %rdx,%rcx
  80042127d1:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042127d4:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  80042127d8:	48 89 cf             	mov    %rcx,%rdi
  80042127db:	ff d0                	callq  *%rax
	cie->cie_length = length;
  80042127dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042127e1:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042127e5:	48 89 50 18          	mov    %rdx,0x18(%rax)

	cie->cie_version = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
  80042127e9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042127ed:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042127f1:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042127f5:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  80042127f9:	48 89 d1             	mov    %rdx,%rcx
  80042127fc:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004212800:	ba 01 00 00 00       	mov    $0x1,%edx
  8004212805:	48 89 cf             	mov    %rcx,%rdi
  8004212808:	ff d0                	callq  *%rax
  800421280a:	89 c2                	mov    %eax,%edx
  800421280c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212810:	66 89 50 20          	mov    %dx,0x20(%rax)
	if (cie->cie_version != 1 && cie->cie_version != 3 &&
  8004212814:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212818:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  800421281c:	66 83 f8 01          	cmp    $0x1,%ax
  8004212820:	74 26                	je     8004212848 <_dwarf_frame_set_cie+0x18a>
  8004212822:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212826:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  800421282a:	66 83 f8 03          	cmp    $0x3,%ax
  800421282e:	74 18                	je     8004212848 <_dwarf_frame_set_cie+0x18a>
	    cie->cie_version != 4) {
  8004212830:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212834:	0f b7 40 20          	movzwl 0x20(%rax),%eax

	(void) dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size); /* Skip CIE id. */
	cie->cie_length = length;

	cie->cie_version = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
	if (cie->cie_version != 1 && cie->cie_version != 3 &&
  8004212838:	66 83 f8 04          	cmp    $0x4,%ax
  800421283c:	74 0a                	je     8004212848 <_dwarf_frame_set_cie+0x18a>
	    cie->cie_version != 4) {
		DWARF_SET_ERROR(dbg, error, DW_DLE_FRAME_VERSION_BAD);
		return (DW_DLE_FRAME_VERSION_BAD);
  800421283e:	b8 16 00 00 00       	mov    $0x16,%eax
  8004212843:	e9 d3 02 00 00       	jmpq   8004212b1b <_dwarf_frame_set_cie+0x45d>
	}

	cie->cie_augment = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004212848:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421284c:	48 8b 10             	mov    (%rax),%rdx
  800421284f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212853:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212857:	48 01 d0             	add    %rdx,%rax
  800421285a:	48 89 c2             	mov    %rax,%rdx
  800421285d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212861:	48 89 50 28          	mov    %rdx,0x28(%rax)
	p = (char *)dbg->dbg_eh_offset;
  8004212865:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212869:	48 8b 40 38          	mov    0x38(%rax),%rax
  800421286d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	while (p[(*off)++] != '\0')
  8004212871:	90                   	nop
  8004212872:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212876:	48 8b 00             	mov    (%rax),%rax
  8004212879:	48 8d 48 01          	lea    0x1(%rax),%rcx
  800421287d:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004212881:	48 89 0a             	mov    %rcx,(%rdx)
  8004212884:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004212888:	48 01 d0             	add    %rdx,%rax
  800421288b:	0f b6 00             	movzbl (%rax),%eax
  800421288e:	84 c0                	test   %al,%al
  8004212890:	75 e0                	jne    8004212872 <_dwarf_frame_set_cie+0x1b4>
		;

	/* We only recognize normal .dwarf_frame and GNU .eh_frame sections. */
	if (*cie->cie_augment != 0 && *cie->cie_augment != 'z') {
  8004212892:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212896:	48 8b 40 28          	mov    0x28(%rax),%rax
  800421289a:	0f b6 00             	movzbl (%rax),%eax
  800421289d:	84 c0                	test   %al,%al
  800421289f:	74 48                	je     80042128e9 <_dwarf_frame_set_cie+0x22b>
  80042128a1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042128a5:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042128a9:	0f b6 00             	movzbl (%rax),%eax
  80042128ac:	3c 7a                	cmp    $0x7a,%al
  80042128ae:	74 39                	je     80042128e9 <_dwarf_frame_set_cie+0x22b>
		*off = cie->cie_offset + ((dwarf_size == 4) ? 4 : 12) +
  80042128b0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042128b4:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80042128b8:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  80042128bc:	75 07                	jne    80042128c5 <_dwarf_frame_set_cie+0x207>
  80042128be:	b8 04 00 00 00       	mov    $0x4,%eax
  80042128c3:	eb 05                	jmp    80042128ca <_dwarf_frame_set_cie+0x20c>
  80042128c5:	b8 0c 00 00 00       	mov    $0xc,%eax
  80042128ca:	48 01 c2             	add    %rax,%rdx
		    cie->cie_length;
  80042128cd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042128d1:	48 8b 40 18          	mov    0x18(%rax),%rax
	while (p[(*off)++] != '\0')
		;

	/* We only recognize normal .dwarf_frame and GNU .eh_frame sections. */
	if (*cie->cie_augment != 0 && *cie->cie_augment != 'z') {
		*off = cie->cie_offset + ((dwarf_size == 4) ? 4 : 12) +
  80042128d5:	48 01 c2             	add    %rax,%rdx
  80042128d8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042128dc:	48 89 10             	mov    %rdx,(%rax)
		    cie->cie_length;
		return (DW_DLE_NONE);
  80042128df:	b8 00 00 00 00       	mov    $0x0,%eax
  80042128e4:	e9 32 02 00 00       	jmpq   8004212b1b <_dwarf_frame_set_cie+0x45d>
	}

	/* Optional EH Data field for .eh_frame section. */
	if (strstr((char *)cie->cie_augment, "eh") != NULL)
  80042128e9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042128ed:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042128f1:	48 be 3d 83 21 04 80 	movabs $0x800421833d,%rsi
  80042128f8:	00 00 00 
  80042128fb:	48 89 c7             	mov    %rax,%rdi
  80042128fe:	48 b8 00 ed 20 04 80 	movabs $0x800420ed00,%rax
  8004212905:	00 00 00 
  8004212908:	ff d0                	callq  *%rax
  800421290a:	48 85 c0             	test   %rax,%rax
  800421290d:	74 28                	je     8004212937 <_dwarf_frame_set_cie+0x279>
		cie->cie_ehdata = dbg->read((uint8_t *)dbg->dbg_eh_offset, off,
  800421290f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212913:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212917:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421291b:	8b 52 28             	mov    0x28(%rdx),%edx
  800421291e:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  8004212922:	48 8b 49 38          	mov    0x38(%rcx),%rcx
  8004212926:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800421292a:	48 89 cf             	mov    %rcx,%rdi
  800421292d:	ff d0                	callq  *%rax
  800421292f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212933:	48 89 42 30          	mov    %rax,0x30(%rdx)
					    dbg->dbg_pointer_size);

	cie->cie_caf = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004212937:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421293b:	48 8b 40 38          	mov    0x38(%rax),%rax
  800421293f:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004212943:	48 89 d6             	mov    %rdx,%rsi
  8004212946:	48 89 c7             	mov    %rax,%rdi
  8004212949:	48 b8 ed f3 20 04 80 	movabs $0x800420f3ed,%rax
  8004212950:	00 00 00 
  8004212953:	ff d0                	callq  *%rax
  8004212955:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212959:	48 89 42 38          	mov    %rax,0x38(%rdx)
	cie->cie_daf = _dwarf_read_sleb128((uint8_t *)dbg->dbg_eh_offset, off);
  800421295d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212961:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212965:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004212969:	48 89 d6             	mov    %rdx,%rsi
  800421296c:	48 89 c7             	mov    %rax,%rdi
  800421296f:	48 b8 49 f3 20 04 80 	movabs $0x800420f349,%rax
  8004212976:	00 00 00 
  8004212979:	ff d0                	callq  *%rax
  800421297b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421297f:	48 89 42 40          	mov    %rax,0x40(%rdx)

	/* Return address register. */
	if (cie->cie_version == 1)
  8004212983:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212987:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  800421298b:	66 83 f8 01          	cmp    $0x1,%ax
  800421298f:	75 2b                	jne    80042129bc <_dwarf_frame_set_cie+0x2fe>
		cie->cie_ra = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
  8004212991:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212995:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212999:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421299d:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  80042129a1:	48 89 d1             	mov    %rdx,%rcx
  80042129a4:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  80042129a8:	ba 01 00 00 00       	mov    $0x1,%edx
  80042129ad:	48 89 cf             	mov    %rcx,%rdi
  80042129b0:	ff d0                	callq  *%rax
  80042129b2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042129b6:	48 89 42 48          	mov    %rax,0x48(%rdx)
  80042129ba:	eb 26                	jmp    80042129e2 <_dwarf_frame_set_cie+0x324>
	else
		cie->cie_ra = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  80042129bc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042129c0:	48 8b 40 38          	mov    0x38(%rax),%rax
  80042129c4:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042129c8:	48 89 d6             	mov    %rdx,%rsi
  80042129cb:	48 89 c7             	mov    %rax,%rdi
  80042129ce:	48 b8 ed f3 20 04 80 	movabs $0x800420f3ed,%rax
  80042129d5:	00 00 00 
  80042129d8:	ff d0                	callq  *%rax
  80042129da:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042129de:	48 89 42 48          	mov    %rax,0x48(%rdx)

	/* Optional CIE augmentation data for .eh_frame section. */
	if (*cie->cie_augment == 'z') {
  80042129e2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042129e6:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042129ea:	0f b6 00             	movzbl (%rax),%eax
  80042129ed:	3c 7a                	cmp    $0x7a,%al
  80042129ef:	0f 85 93 00 00 00    	jne    8004212a88 <_dwarf_frame_set_cie+0x3ca>
		cie->cie_auglen = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  80042129f5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042129f9:	48 8b 40 38          	mov    0x38(%rax),%rax
  80042129fd:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004212a01:	48 89 d6             	mov    %rdx,%rsi
  8004212a04:	48 89 c7             	mov    %rax,%rdi
  8004212a07:	48 b8 ed f3 20 04 80 	movabs $0x800420f3ed,%rax
  8004212a0e:	00 00 00 
  8004212a11:	ff d0                	callq  *%rax
  8004212a13:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212a17:	48 89 42 50          	mov    %rax,0x50(%rdx)
		cie->cie_augdata = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004212a1b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212a1f:	48 8b 10             	mov    (%rax),%rdx
  8004212a22:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212a26:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212a2a:	48 01 d0             	add    %rdx,%rax
  8004212a2d:	48 89 c2             	mov    %rax,%rdx
  8004212a30:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212a34:	48 89 50 58          	mov    %rdx,0x58(%rax)
		*off += cie->cie_auglen;
  8004212a38:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212a3c:	48 8b 10             	mov    (%rax),%rdx
  8004212a3f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212a43:	48 8b 40 50          	mov    0x50(%rax),%rax
  8004212a47:	48 01 c2             	add    %rax,%rdx
  8004212a4a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212a4e:	48 89 10             	mov    %rdx,(%rax)
		/*
		 * XXX Use DW_EH_PE_absptr for default FDE PC start/range,
		 * in case _dwarf_frame_parse_lsb_cie_augment fails to
		 * find out the real encode.
		 */
		cie->cie_fde_encode = DW_EH_PE_absptr;
  8004212a51:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212a55:	c6 40 60 00          	movb   $0x0,0x60(%rax)
		ret = _dwarf_frame_parse_lsb_cie_augment(dbg, cie, error);
  8004212a59:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004212a5d:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004212a61:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212a65:	48 89 ce             	mov    %rcx,%rsi
  8004212a68:	48 89 c7             	mov    %rax,%rdi
  8004212a6b:	48 b8 73 25 21 04 80 	movabs $0x8004212573,%rax
  8004212a72:	00 00 00 
  8004212a75:	ff d0                	callq  *%rax
  8004212a77:	89 45 dc             	mov    %eax,-0x24(%rbp)
		if (ret != DW_DLE_NONE)
  8004212a7a:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004212a7e:	74 08                	je     8004212a88 <_dwarf_frame_set_cie+0x3ca>
			return (ret);
  8004212a80:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004212a83:	e9 93 00 00 00       	jmpq   8004212b1b <_dwarf_frame_set_cie+0x45d>
	}

	/* CIE Initial instructions. */
	cie->cie_initinst = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004212a88:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212a8c:	48 8b 10             	mov    (%rax),%rdx
  8004212a8f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212a93:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212a97:	48 01 d0             	add    %rdx,%rax
  8004212a9a:	48 89 c2             	mov    %rax,%rdx
  8004212a9d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212aa1:	48 89 50 68          	mov    %rdx,0x68(%rax)
	if (dwarf_size == 4)
  8004212aa5:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004212aa9:	75 2a                	jne    8004212ad5 <_dwarf_frame_set_cie+0x417>
		cie->cie_instlen = cie->cie_offset + 4 + length - *off;
  8004212aab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212aaf:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004212ab3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212ab7:	48 01 c2             	add    %rax,%rdx
  8004212aba:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212abe:	48 8b 00             	mov    (%rax),%rax
  8004212ac1:	48 29 c2             	sub    %rax,%rdx
  8004212ac4:	48 89 d0             	mov    %rdx,%rax
  8004212ac7:	48 8d 50 04          	lea    0x4(%rax),%rdx
  8004212acb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212acf:	48 89 50 70          	mov    %rdx,0x70(%rax)
  8004212ad3:	eb 28                	jmp    8004212afd <_dwarf_frame_set_cie+0x43f>
	else
		cie->cie_instlen = cie->cie_offset + 12 + length - *off;
  8004212ad5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212ad9:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004212add:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212ae1:	48 01 c2             	add    %rax,%rdx
  8004212ae4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212ae8:	48 8b 00             	mov    (%rax),%rax
  8004212aeb:	48 29 c2             	sub    %rax,%rdx
  8004212aee:	48 89 d0             	mov    %rdx,%rax
  8004212af1:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  8004212af5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212af9:	48 89 50 70          	mov    %rdx,0x70(%rax)

	*off += cie->cie_instlen;
  8004212afd:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212b01:	48 8b 10             	mov    (%rax),%rdx
  8004212b04:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212b08:	48 8b 40 70          	mov    0x70(%rax),%rax
  8004212b0c:	48 01 c2             	add    %rax,%rdx
  8004212b0f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212b13:	48 89 10             	mov    %rdx,(%rax)
	return (DW_DLE_NONE);
  8004212b16:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004212b1b:	c9                   	leaveq 
  8004212b1c:	c3                   	retq   

0000008004212b1d <_dwarf_frame_set_fde>:

static int
_dwarf_frame_set_fde(Dwarf_Debug dbg, Dwarf_Fde ret_fde,
    Dwarf_Unsigned *off, int eh_frame, Dwarf_Cie cie, Dwarf_Error *error)
{
  8004212b1d:	55                   	push   %rbp
  8004212b1e:	48 89 e5             	mov    %rsp,%rbp
  8004212b21:	48 83 ec 70          	sub    $0x70,%rsp
  8004212b25:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004212b29:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004212b2d:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004212b31:	89 4d b4             	mov    %ecx,-0x4c(%rbp)
  8004212b34:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
  8004212b38:	4c 89 4d a0          	mov    %r9,-0x60(%rbp)
	Dwarf_Fde fde;
	Dwarf_Unsigned cieoff;
	uint64_t length, val;
	int dwarf_size, ret;

	fde = ret_fde;
  8004212b3c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212b40:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	fde->fde_dbg = dbg;
  8004212b44:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212b48:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212b4c:	48 89 10             	mov    %rdx,(%rax)
	fde->fde_addr = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004212b4f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212b53:	48 8b 10             	mov    (%rax),%rdx
  8004212b56:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212b5a:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212b5e:	48 01 d0             	add    %rdx,%rax
  8004212b61:	48 89 c2             	mov    %rax,%rdx
  8004212b64:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212b68:	48 89 50 10          	mov    %rdx,0x10(%rax)
	fde->fde_offset = *off;
  8004212b6c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212b70:	48 8b 10             	mov    (%rax),%rdx
  8004212b73:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212b77:	48 89 50 18          	mov    %rdx,0x18(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  8004212b7b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212b7f:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212b83:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212b87:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004212b8b:	48 89 d1             	mov    %rdx,%rcx
  8004212b8e:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004212b92:	ba 04 00 00 00       	mov    $0x4,%edx
  8004212b97:	48 89 cf             	mov    %rcx,%rdi
  8004212b9a:	ff d0                	callq  *%rax
  8004212b9c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (length == 0xffffffff) {
  8004212ba0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004212ba5:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004212ba9:	75 2e                	jne    8004212bd9 <_dwarf_frame_set_fde+0xbc>
		dwarf_size = 8;
  8004212bab:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 8);
  8004212bb2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212bb6:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212bba:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212bbe:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004212bc2:	48 89 d1             	mov    %rdx,%rcx
  8004212bc5:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004212bc9:	ba 08 00 00 00       	mov    $0x8,%edx
  8004212bce:	48 89 cf             	mov    %rcx,%rdi
  8004212bd1:	ff d0                	callq  *%rax
  8004212bd3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004212bd7:	eb 07                	jmp    8004212be0 <_dwarf_frame_set_fde+0xc3>
	} else
		dwarf_size = 4;
  8004212bd9:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

	if (length > dbg->dbg_eh_size - *off) {
  8004212be0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212be4:	48 8b 50 40          	mov    0x40(%rax),%rdx
  8004212be8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212bec:	48 8b 00             	mov    (%rax),%rax
  8004212bef:	48 29 c2             	sub    %rax,%rdx
  8004212bf2:	48 89 d0             	mov    %rdx,%rax
  8004212bf5:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004212bf9:	73 0a                	jae    8004212c05 <_dwarf_frame_set_fde+0xe8>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_FRAME_LENGTH_BAD);
		return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  8004212bfb:	b8 12 00 00 00       	mov    $0x12,%eax
  8004212c00:	e9 ca 02 00 00       	jmpq   8004212ecf <_dwarf_frame_set_fde+0x3b2>
	}

	fde->fde_length = length;
  8004212c05:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212c09:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004212c0d:	48 89 50 20          	mov    %rdx,0x20(%rax)

	if (eh_frame) {
  8004212c11:	83 7d b4 00          	cmpl   $0x0,-0x4c(%rbp)
  8004212c15:	74 5e                	je     8004212c75 <_dwarf_frame_set_fde+0x158>
		fde->fde_cieoff = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  8004212c17:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212c1b:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212c1f:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212c23:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004212c27:	48 89 d1             	mov    %rdx,%rcx
  8004212c2a:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004212c2e:	ba 04 00 00 00       	mov    $0x4,%edx
  8004212c33:	48 89 cf             	mov    %rcx,%rdi
  8004212c36:	ff d0                	callq  *%rax
  8004212c38:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212c3c:	48 89 42 28          	mov    %rax,0x28(%rdx)
		cieoff = *off - (4 + fde->fde_cieoff);
  8004212c40:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212c44:	48 8b 10             	mov    (%rax),%rdx
  8004212c47:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212c4b:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004212c4f:	48 29 c2             	sub    %rax,%rdx
  8004212c52:	48 89 d0             	mov    %rdx,%rax
  8004212c55:	48 83 e8 04          	sub    $0x4,%rax
  8004212c59:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		/* This delta should never be 0. */
		if (cieoff == fde->fde_offset) {
  8004212c5d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212c61:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212c65:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004212c69:	75 3d                	jne    8004212ca8 <_dwarf_frame_set_fde+0x18b>
			DWARF_SET_ERROR(dbg, error, DW_DLE_NO_CIE_FOR_FDE);
			return (DW_DLE_NO_CIE_FOR_FDE);
  8004212c6b:	b8 13 00 00 00       	mov    $0x13,%eax
  8004212c70:	e9 5a 02 00 00       	jmpq   8004212ecf <_dwarf_frame_set_fde+0x3b2>
		}
	} else {
		fde->fde_cieoff = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size);
  8004212c75:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212c79:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212c7d:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212c81:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004212c85:	48 89 d1             	mov    %rdx,%rcx
  8004212c88:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004212c8b:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004212c8f:	48 89 cf             	mov    %rcx,%rdi
  8004212c92:	ff d0                	callq  *%rax
  8004212c94:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212c98:	48 89 42 28          	mov    %rax,0x28(%rdx)
		cieoff = fde->fde_cieoff;
  8004212c9c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212ca0:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004212ca4:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	}

	if (eh_frame) {
  8004212ca8:	83 7d b4 00          	cmpl   $0x0,-0x4c(%rbp)
  8004212cac:	0f 84 c9 00 00 00    	je     8004212d7b <_dwarf_frame_set_fde+0x25e>
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val, (uint8_t *)dbg->dbg_eh_offset,
		    off, cie->cie_fde_encode, dbg->dbg_eh_offset + *off, error);
  8004212cb2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212cb6:	48 8b 50 38          	mov    0x38(%rax),%rdx
  8004212cba:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212cbe:	48 8b 00             	mov    (%rax),%rax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val, (uint8_t *)dbg->dbg_eh_offset,
  8004212cc1:	4c 8d 0c 02          	lea    (%rdx,%rax,1),%r9
		    off, cie->cie_fde_encode, dbg->dbg_eh_offset + *off, error);
  8004212cc5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004212cc9:	0f b6 40 60          	movzbl 0x60(%rax),%eax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val, (uint8_t *)dbg->dbg_eh_offset,
  8004212ccd:	44 0f b6 c0          	movzbl %al,%r8d
  8004212cd1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212cd5:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212cd9:	48 89 c2             	mov    %rax,%rdx
  8004212cdc:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8004212ce0:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8004212ce4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212ce8:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
  8004212cec:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004212cf0:	48 89 c7             	mov    %rax,%rdi
  8004212cf3:	48 b8 59 23 21 04 80 	movabs $0x8004212359,%rax
  8004212cfa:	00 00 00 
  8004212cfd:	ff d0                	callq  *%rax
  8004212cff:	89 45 dc             	mov    %eax,-0x24(%rbp)
		    off, cie->cie_fde_encode, dbg->dbg_eh_offset + *off, error);
		if (ret != DW_DLE_NONE)
  8004212d02:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004212d06:	74 08                	je     8004212d10 <_dwarf_frame_set_fde+0x1f3>
			return (ret);
  8004212d08:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004212d0b:	e9 bf 01 00 00       	jmpq   8004212ecf <_dwarf_frame_set_fde+0x3b2>
		fde->fde_initloc = val;
  8004212d10:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212d14:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212d18:	48 89 50 30          	mov    %rdx,0x30(%rax)
		/*
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val, (uint8_t *)dbg->dbg_eh_offset,
		    off, cie->cie_fde_encode, 0, error);
  8004212d1c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004212d20:	0f b6 40 60          	movzbl 0x60(%rax),%eax
		fde->fde_initloc = val;
		/*
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val, (uint8_t *)dbg->dbg_eh_offset,
  8004212d24:	44 0f b6 c0          	movzbl %al,%r8d
  8004212d28:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212d2c:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212d30:	48 89 c2             	mov    %rax,%rdx
  8004212d33:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8004212d37:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8004212d3b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212d3f:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
  8004212d43:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004212d47:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8004212d4d:	48 89 c7             	mov    %rax,%rdi
  8004212d50:	48 b8 59 23 21 04 80 	movabs $0x8004212359,%rax
  8004212d57:	00 00 00 
  8004212d5a:	ff d0                	callq  *%rax
  8004212d5c:	89 45 dc             	mov    %eax,-0x24(%rbp)
		    off, cie->cie_fde_encode, 0, error);
		if (ret != DW_DLE_NONE)
  8004212d5f:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004212d63:	74 08                	je     8004212d6d <_dwarf_frame_set_fde+0x250>
			return (ret);
  8004212d65:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004212d68:	e9 62 01 00 00       	jmpq   8004212ecf <_dwarf_frame_set_fde+0x3b2>
		fde->fde_adrange = val;
  8004212d6d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212d71:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212d75:	48 89 50 38          	mov    %rdx,0x38(%rax)
  8004212d79:	eb 50                	jmp    8004212dcb <_dwarf_frame_set_fde+0x2ae>
	} else {
		fde->fde_initloc = dbg->read((uint8_t *)dbg->dbg_eh_offset, off,
  8004212d7b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212d7f:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212d83:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212d87:	8b 52 28             	mov    0x28(%rdx),%edx
  8004212d8a:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  8004212d8e:	48 8b 49 38          	mov    0x38(%rcx),%rcx
  8004212d92:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004212d96:	48 89 cf             	mov    %rcx,%rdi
  8004212d99:	ff d0                	callq  *%rax
  8004212d9b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212d9f:	48 89 42 30          	mov    %rax,0x30(%rdx)
		    dbg->dbg_pointer_size);
		fde->fde_adrange = dbg->read((uint8_t *)dbg->dbg_eh_offset, off,
  8004212da3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212da7:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212dab:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212daf:	8b 52 28             	mov    0x28(%rdx),%edx
  8004212db2:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  8004212db6:	48 8b 49 38          	mov    0x38(%rcx),%rcx
  8004212dba:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004212dbe:	48 89 cf             	mov    %rcx,%rdi
  8004212dc1:	ff d0                	callq  *%rax
  8004212dc3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212dc7:	48 89 42 38          	mov    %rax,0x38(%rdx)
		    dbg->dbg_pointer_size);
	}

	/* Optional FDE augmentation data for .eh_frame section. (ignored) */
	if (eh_frame && *cie->cie_augment == 'z') {
  8004212dcb:	83 7d b4 00          	cmpl   $0x0,-0x4c(%rbp)
  8004212dcf:	74 6b                	je     8004212e3c <_dwarf_frame_set_fde+0x31f>
  8004212dd1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004212dd5:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004212dd9:	0f b6 00             	movzbl (%rax),%eax
  8004212ddc:	3c 7a                	cmp    $0x7a,%al
  8004212dde:	75 5c                	jne    8004212e3c <_dwarf_frame_set_fde+0x31f>
		fde->fde_auglen = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004212de0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212de4:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212de8:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004212dec:	48 89 d6             	mov    %rdx,%rsi
  8004212def:	48 89 c7             	mov    %rax,%rdi
  8004212df2:	48 b8 ed f3 20 04 80 	movabs $0x800420f3ed,%rax
  8004212df9:	00 00 00 
  8004212dfc:	ff d0                	callq  *%rax
  8004212dfe:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212e02:	48 89 42 40          	mov    %rax,0x40(%rdx)
		fde->fde_augdata = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004212e06:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212e0a:	48 8b 10             	mov    (%rax),%rdx
  8004212e0d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212e11:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212e15:	48 01 d0             	add    %rdx,%rax
  8004212e18:	48 89 c2             	mov    %rax,%rdx
  8004212e1b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212e1f:	48 89 50 48          	mov    %rdx,0x48(%rax)
		*off += fde->fde_auglen;
  8004212e23:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212e27:	48 8b 10             	mov    (%rax),%rdx
  8004212e2a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212e2e:	48 8b 40 40          	mov    0x40(%rax),%rax
  8004212e32:	48 01 c2             	add    %rax,%rdx
  8004212e35:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212e39:	48 89 10             	mov    %rdx,(%rax)
	}

	fde->fde_inst = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004212e3c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212e40:	48 8b 10             	mov    (%rax),%rdx
  8004212e43:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212e47:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212e4b:	48 01 d0             	add    %rdx,%rax
  8004212e4e:	48 89 c2             	mov    %rax,%rdx
  8004212e51:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212e55:	48 89 50 50          	mov    %rdx,0x50(%rax)
	if (dwarf_size == 4)
  8004212e59:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004212e5d:	75 2a                	jne    8004212e89 <_dwarf_frame_set_fde+0x36c>
		fde->fde_instlen = fde->fde_offset + 4 + length - *off;
  8004212e5f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212e63:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004212e67:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212e6b:	48 01 c2             	add    %rax,%rdx
  8004212e6e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212e72:	48 8b 00             	mov    (%rax),%rax
  8004212e75:	48 29 c2             	sub    %rax,%rdx
  8004212e78:	48 89 d0             	mov    %rdx,%rax
  8004212e7b:	48 8d 50 04          	lea    0x4(%rax),%rdx
  8004212e7f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212e83:	48 89 50 58          	mov    %rdx,0x58(%rax)
  8004212e87:	eb 28                	jmp    8004212eb1 <_dwarf_frame_set_fde+0x394>
	else
		fde->fde_instlen = fde->fde_offset + 12 + length - *off;
  8004212e89:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212e8d:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004212e91:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212e95:	48 01 c2             	add    %rax,%rdx
  8004212e98:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212e9c:	48 8b 00             	mov    (%rax),%rax
  8004212e9f:	48 29 c2             	sub    %rax,%rdx
  8004212ea2:	48 89 d0             	mov    %rdx,%rax
  8004212ea5:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  8004212ea9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212ead:	48 89 50 58          	mov    %rdx,0x58(%rax)

	*off += fde->fde_instlen;
  8004212eb1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212eb5:	48 8b 10             	mov    (%rax),%rdx
  8004212eb8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212ebc:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004212ec0:	48 01 c2             	add    %rax,%rdx
  8004212ec3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212ec7:	48 89 10             	mov    %rdx,(%rax)
	return (DW_DLE_NONE);
  8004212eca:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004212ecf:	c9                   	leaveq 
  8004212ed0:	c3                   	retq   

0000008004212ed1 <_dwarf_frame_interal_table_init>:


int
_dwarf_frame_interal_table_init(Dwarf_Debug dbg, Dwarf_Error *error)
{
  8004212ed1:	55                   	push   %rbp
  8004212ed2:	48 89 e5             	mov    %rsp,%rbp
  8004212ed5:	48 83 ec 20          	sub    $0x20,%rsp
  8004212ed9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004212edd:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
        Dwarf_Regtable3 *rt = &global_rt_table;
  8004212ee1:	48 b8 20 67 49 04 80 	movabs $0x8004496720,%rax
  8004212ee8:	00 00 00 
  8004212eeb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

        if (dbg->dbg_internal_reg_table != NULL)
  8004212eef:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212ef3:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004212ef7:	48 85 c0             	test   %rax,%rax
  8004212efa:	74 07                	je     8004212f03 <_dwarf_frame_interal_table_init+0x32>
                return (DW_DLE_NONE);
  8004212efc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212f01:	eb 33                	jmp    8004212f36 <_dwarf_frame_interal_table_init+0x65>

        rt->rt3_reg_table_size = dbg->dbg_frame_rule_table_size;
  8004212f03:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212f07:	0f b7 50 48          	movzwl 0x48(%rax),%edx
  8004212f0b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212f0f:	66 89 50 18          	mov    %dx,0x18(%rax)
        rt->rt3_rules = global_rules;
  8004212f13:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212f17:	48 b9 60 6f 49 04 80 	movabs $0x8004496f60,%rcx
  8004212f1e:	00 00 00 
  8004212f21:	48 89 48 20          	mov    %rcx,0x20(%rax)
        dbg->dbg_internal_reg_table = rt;
  8004212f25:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212f29:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004212f2d:	48 89 50 58          	mov    %rdx,0x58(%rax)

        return (DW_DLE_NONE);
  8004212f31:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004212f36:	c9                   	leaveq 
  8004212f37:	c3                   	retq   

0000008004212f38 <_dwarf_get_next_fde>:

static int
_dwarf_get_next_fde(Dwarf_Debug dbg,
                    int eh_frame, Dwarf_Error *error, Dwarf_Fde ret_fde)
{
  8004212f38:	55                   	push   %rbp
  8004212f39:	48 89 e5             	mov    %rsp,%rbp
  8004212f3c:	48 83 ec 50          	sub    $0x50,%rsp
  8004212f40:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004212f44:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  8004212f47:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004212f4b:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	uint64_t length, offset, cie_id, entry_off;
	int dwarf_size, i, ret=-1;
  8004212f4f:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%rbp)

	offset = dbg->curr_off_eh;
  8004212f56:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212f5a:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004212f5e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if (offset < dbg->dbg_eh_size) {
  8004212f62:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212f66:	48 8b 50 40          	mov    0x40(%rax),%rdx
  8004212f6a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212f6e:	48 39 c2             	cmp    %rax,%rdx
  8004212f71:	0f 86 e1 01 00 00    	jbe    8004213158 <_dwarf_get_next_fde+0x220>
		entry_off = offset;
  8004212f77:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212f7b:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, 4);
  8004212f7f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212f83:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212f87:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212f8b:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004212f8f:	48 89 d1             	mov    %rdx,%rcx
  8004212f92:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  8004212f96:	ba 04 00 00 00       	mov    $0x4,%edx
  8004212f9b:	48 89 cf             	mov    %rcx,%rdi
  8004212f9e:	ff d0                	callq  *%rax
  8004212fa0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (length == 0xffffffff) {
  8004212fa4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004212fa9:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004212fad:	75 2e                	jne    8004212fdd <_dwarf_get_next_fde+0xa5>
			dwarf_size = 8;
  8004212faf:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
			length = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, 8);
  8004212fb6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212fba:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212fbe:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212fc2:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004212fc6:	48 89 d1             	mov    %rdx,%rcx
  8004212fc9:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  8004212fcd:	ba 08 00 00 00       	mov    $0x8,%edx
  8004212fd2:	48 89 cf             	mov    %rcx,%rdi
  8004212fd5:	ff d0                	callq  *%rax
  8004212fd7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004212fdb:	eb 07                	jmp    8004212fe4 <_dwarf_get_next_fde+0xac>
		} else
			dwarf_size = 4;
  8004212fdd:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

		if (length > dbg->dbg_eh_size - offset || (length == 0 && !eh_frame)) {
  8004212fe4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212fe8:	48 8b 50 40          	mov    0x40(%rax),%rdx
  8004212fec:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212ff0:	48 29 c2             	sub    %rax,%rdx
  8004212ff3:	48 89 d0             	mov    %rdx,%rax
  8004212ff6:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004212ffa:	72 0d                	jb     8004213009 <_dwarf_get_next_fde+0xd1>
  8004212ffc:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004213001:	75 10                	jne    8004213013 <_dwarf_get_next_fde+0xdb>
  8004213003:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  8004213007:	75 0a                	jne    8004213013 <_dwarf_get_next_fde+0xdb>
			DWARF_SET_ERROR(dbg, error,
					DW_DLE_DEBUG_FRAME_LENGTH_BAD);
			return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  8004213009:	b8 12 00 00 00       	mov    $0x12,%eax
  800421300e:	e9 4a 01 00 00       	jmpq   800421315d <_dwarf_get_next_fde+0x225>
		}

		/* Check terminator for .eh_frame */
		if (eh_frame && length == 0)
  8004213013:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  8004213017:	74 11                	je     800421302a <_dwarf_get_next_fde+0xf2>
  8004213019:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800421301e:	75 0a                	jne    800421302a <_dwarf_get_next_fde+0xf2>
			return(-1);
  8004213020:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004213025:	e9 33 01 00 00       	jmpq   800421315d <_dwarf_get_next_fde+0x225>

		cie_id = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, dwarf_size);
  800421302a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421302e:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213032:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213036:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  800421303a:	48 89 d1             	mov    %rdx,%rcx
  800421303d:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004213040:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  8004213044:	48 89 cf             	mov    %rcx,%rdi
  8004213047:	ff d0                	callq  *%rax
  8004213049:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

		if (eh_frame) {
  800421304d:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  8004213051:	74 69                	je     80042130bc <_dwarf_get_next_fde+0x184>
			/* GNU .eh_frame use CIE id 0. */
			if (cie_id == 0)
  8004213053:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004213058:	75 2b                	jne    8004213085 <_dwarf_get_next_fde+0x14d>
				ret = _dwarf_frame_set_cie(dbg,
  800421305a:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421305e:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004213062:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8004213066:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  800421306a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421306e:	48 89 c7             	mov    %rax,%rdi
  8004213071:	48 b8 be 26 21 04 80 	movabs $0x80042126be,%rax
  8004213078:	00 00 00 
  800421307b:	ff d0                	callq  *%rax
  800421307d:	89 45 f0             	mov    %eax,-0x10(%rbp)
  8004213080:	e9 b2 00 00 00       	jmpq   8004213137 <_dwarf_get_next_fde+0x1ff>
				    &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg, ret_fde,
  8004213085:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213089:	48 8b 48 08          	mov    0x8(%rax),%rcx
  800421308d:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8004213091:	48 8d 55 d8          	lea    -0x28(%rbp),%rdx
  8004213095:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004213099:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421309d:	49 89 f9             	mov    %rdi,%r9
  80042130a0:	49 89 c8             	mov    %rcx,%r8
  80042130a3:	b9 01 00 00 00       	mov    $0x1,%ecx
  80042130a8:	48 89 c7             	mov    %rax,%rdi
  80042130ab:	48 b8 1d 2b 21 04 80 	movabs $0x8004212b1d,%rax
  80042130b2:	00 00 00 
  80042130b5:	ff d0                	callq  *%rax
  80042130b7:	89 45 f0             	mov    %eax,-0x10(%rbp)
  80042130ba:	eb 7b                	jmp    8004213137 <_dwarf_get_next_fde+0x1ff>
				    &entry_off, 1, ret_fde->fde_cie, error);
		} else {
			/* .dwarf_frame use CIE id ~0 */
			if ((dwarf_size == 4 && cie_id == ~0U) ||
  80042130bc:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  80042130c0:	75 0b                	jne    80042130cd <_dwarf_get_next_fde+0x195>
  80042130c2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042130c7:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80042130cb:	74 0d                	je     80042130da <_dwarf_get_next_fde+0x1a2>
  80042130cd:	83 7d f4 08          	cmpl   $0x8,-0xc(%rbp)
  80042130d1:	75 2f                	jne    8004213102 <_dwarf_get_next_fde+0x1ca>
			    (dwarf_size == 8 && cie_id == ~0ULL))
  80042130d3:	48 83 7d e8 ff       	cmpq   $0xffffffffffffffff,-0x18(%rbp)
  80042130d8:	75 28                	jne    8004213102 <_dwarf_get_next_fde+0x1ca>
				ret = _dwarf_frame_set_cie(dbg,
  80042130da:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042130de:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80042130e2:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  80042130e6:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  80042130ea:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042130ee:	48 89 c7             	mov    %rax,%rdi
  80042130f1:	48 b8 be 26 21 04 80 	movabs $0x80042126be,%rax
  80042130f8:	00 00 00 
  80042130fb:	ff d0                	callq  *%rax
  80042130fd:	89 45 f0             	mov    %eax,-0x10(%rbp)
  8004213100:	eb 35                	jmp    8004213137 <_dwarf_get_next_fde+0x1ff>
				    &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg, ret_fde,
  8004213102:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213106:	48 8b 48 08          	mov    0x8(%rax),%rcx
  800421310a:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  800421310e:	48 8d 55 d8          	lea    -0x28(%rbp),%rdx
  8004213112:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004213116:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421311a:	49 89 f9             	mov    %rdi,%r9
  800421311d:	49 89 c8             	mov    %rcx,%r8
  8004213120:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004213125:	48 89 c7             	mov    %rax,%rdi
  8004213128:	48 b8 1d 2b 21 04 80 	movabs $0x8004212b1d,%rax
  800421312f:	00 00 00 
  8004213132:	ff d0                	callq  *%rax
  8004213134:	89 45 f0             	mov    %eax,-0x10(%rbp)
				    &entry_off, 0, ret_fde->fde_cie, error);
		}

		if (ret != DW_DLE_NONE)
  8004213137:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  800421313b:	74 07                	je     8004213144 <_dwarf_get_next_fde+0x20c>
			return(-1);
  800421313d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004213142:	eb 19                	jmp    800421315d <_dwarf_get_next_fde+0x225>

		offset = entry_off;
  8004213144:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213148:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		dbg->curr_off_eh = offset;
  800421314c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004213150:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213154:	48 89 50 30          	mov    %rdx,0x30(%rax)
	}

	return (0);
  8004213158:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421315d:	c9                   	leaveq 
  800421315e:	c3                   	retq   

000000800421315f <dwarf_set_frame_cfa_value>:

Dwarf_Half
dwarf_set_frame_cfa_value(Dwarf_Debug dbg, Dwarf_Half value)
{
  800421315f:	55                   	push   %rbp
  8004213160:	48 89 e5             	mov    %rsp,%rbp
  8004213163:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004213167:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421316b:	89 f0                	mov    %esi,%eax
  800421316d:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
        Dwarf_Half old_value;

        old_value = dbg->dbg_frame_cfa_value;
  8004213171:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213175:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004213179:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
        dbg->dbg_frame_cfa_value = value;
  800421317d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213181:	0f b7 55 e4          	movzwl -0x1c(%rbp),%edx
  8004213185:	66 89 50 4c          	mov    %dx,0x4c(%rax)

        return (old_value);
  8004213189:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
}
  800421318d:	c9                   	leaveq 
  800421318e:	c3                   	retq   

000000800421318f <dwarf_init_eh_section>:

int dwarf_init_eh_section(Dwarf_Debug dbg, Dwarf_Error *error)
{
  800421318f:	55                   	push   %rbp
  8004213190:	48 89 e5             	mov    %rsp,%rbp
  8004213193:	48 83 ec 10          	sub    $0x10,%rsp
  8004213197:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800421319b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	Dwarf_Section *section;

	if (dbg == NULL) {
  800421319f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042131a4:	75 0a                	jne    80042131b0 <dwarf_init_eh_section+0x21>
		DWARF_SET_ERROR(dbg, error, DW_DLE_ARGUMENT);
		return (DW_DLV_ERROR);
  80042131a6:	b8 01 00 00 00       	mov    $0x1,%eax
  80042131ab:	e9 85 00 00 00       	jmpq   8004213235 <dwarf_init_eh_section+0xa6>
	}

	if (dbg->dbg_internal_reg_table == NULL) {
  80042131b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042131b4:	48 8b 40 58          	mov    0x58(%rax),%rax
  80042131b8:	48 85 c0             	test   %rax,%rax
  80042131bb:	75 25                	jne    80042131e2 <dwarf_init_eh_section+0x53>
		if (_dwarf_frame_interal_table_init(dbg, error) != DW_DLE_NONE)
  80042131bd:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042131c1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042131c5:	48 89 d6             	mov    %rdx,%rsi
  80042131c8:	48 89 c7             	mov    %rax,%rdi
  80042131cb:	48 b8 d1 2e 21 04 80 	movabs $0x8004212ed1,%rax
  80042131d2:	00 00 00 
  80042131d5:	ff d0                	callq  *%rax
  80042131d7:	85 c0                	test   %eax,%eax
  80042131d9:	74 07                	je     80042131e2 <dwarf_init_eh_section+0x53>
			return (DW_DLV_ERROR);
  80042131db:	b8 01 00 00 00       	mov    $0x1,%eax
  80042131e0:	eb 53                	jmp    8004213235 <dwarf_init_eh_section+0xa6>
	}

	_dwarf_find_section_enhanced(&debug_frame_sec);
  80042131e2:	48 bf c0 b6 22 04 80 	movabs $0x800422b6c0,%rdi
  80042131e9:	00 00 00 
  80042131ec:	48 b8 8b 0c 21 04 80 	movabs $0x8004210c8b,%rax
  80042131f3:	00 00 00 
  80042131f6:	ff d0                	callq  *%rax

	dbg->curr_off_eh = 0;
  80042131f8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042131fc:	48 c7 40 30 00 00 00 	movq   $0x0,0x30(%rax)
  8004213203:	00 
	dbg->dbg_eh_offset = debug_frame_sec.ds_addr;
  8004213204:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  800421320b:	00 00 00 
  800421320e:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004213212:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213216:	48 89 50 38          	mov    %rdx,0x38(%rax)
	dbg->dbg_eh_size = debug_frame_sec.ds_size;
  800421321a:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004213221:	00 00 00 
  8004213224:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004213228:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421322c:	48 89 50 40          	mov    %rdx,0x40(%rax)

	return (DW_DLV_OK);
  8004213230:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004213235:	c9                   	leaveq 
  8004213236:	c3                   	retq   

0000008004213237 <_dwarf_lineno_run_program>:


static int
_dwarf_lineno_run_program(Dwarf_CU *cu, Dwarf_LineInfo li, uint8_t *p,
    uint8_t *pe, Dwarf_Addr pc, Dwarf_Error *error)
{
  8004213237:	55                   	push   %rbp
  8004213238:	48 89 e5             	mov    %rsp,%rbp
  800421323b:	53                   	push   %rbx
  800421323c:	48 81 ec 98 00 00 00 	sub    $0x98,%rsp
  8004213243:	48 89 7d 88          	mov    %rdi,-0x78(%rbp)
  8004213247:	48 89 75 80          	mov    %rsi,-0x80(%rbp)
  800421324b:	48 89 95 78 ff ff ff 	mov    %rdx,-0x88(%rbp)
  8004213252:	48 89 8d 70 ff ff ff 	mov    %rcx,-0x90(%rbp)
  8004213259:	4c 89 85 68 ff ff ff 	mov    %r8,-0x98(%rbp)
  8004213260:	4c 89 8d 60 ff ff ff 	mov    %r9,-0xa0(%rbp)
    uint64_t address, file, line, column, isa, opsize;
    int is_stmt, basic_block, end_sequence;
    int prologue_end, epilogue_begin;
    int ret;

	ln = &li->li_line;
  8004213267:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421326b:	48 83 c0 48          	add    $0x48,%rax
  800421326f:	48 89 45 b8          	mov    %rax,-0x48(%rbp)

    /*
     *   ln->ln_li     = li;             \
     * Set registers to their default values.
     */
    RESET_REGISTERS;
  8004213273:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  800421327a:	00 
  800421327b:	48 c7 45 e0 01 00 00 	movq   $0x1,-0x20(%rbp)
  8004213282:	00 
  8004213283:	48 c7 45 d8 01 00 00 	movq   $0x1,-0x28(%rbp)
  800421328a:	00 
  800421328b:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  8004213292:	00 
  8004213293:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213297:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  800421329b:	0f b6 c0             	movzbl %al,%eax
  800421329e:	89 45 cc             	mov    %eax,-0x34(%rbp)
  80042132a1:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
  80042132a8:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
  80042132af:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
  80042132b6:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)

    /*
     * Start line number program.
     */
    while (p < pe) {
  80042132bd:	e9 0a 05 00 00       	jmpq   80042137cc <_dwarf_lineno_run_program+0x595>
        if (*p == 0) {
  80042132c2:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042132c9:	0f b6 00             	movzbl (%rax),%eax
  80042132cc:	84 c0                	test   %al,%al
  80042132ce:	0f 85 78 01 00 00    	jne    800421344c <_dwarf_lineno_run_program+0x215>

            /*
             * Extended Opcodes.
             */

            p++;
  80042132d4:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042132db:	48 83 c0 01          	add    $0x1,%rax
  80042132df:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
            opsize = _dwarf_decode_uleb128(&p);
  80042132e6:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  80042132ed:	48 89 c7             	mov    %rax,%rdi
  80042132f0:	48 b8 fe f4 20 04 80 	movabs $0x800420f4fe,%rax
  80042132f7:	00 00 00 
  80042132fa:	ff d0                	callq  *%rax
  80042132fc:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
            switch (*p) {
  8004213300:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004213307:	0f b6 00             	movzbl (%rax),%eax
  800421330a:	0f b6 c0             	movzbl %al,%eax
  800421330d:	83 f8 02             	cmp    $0x2,%eax
  8004213310:	74 7a                	je     800421338c <_dwarf_lineno_run_program+0x155>
  8004213312:	83 f8 03             	cmp    $0x3,%eax
  8004213315:	0f 84 b3 00 00 00    	je     80042133ce <_dwarf_lineno_run_program+0x197>
  800421331b:	83 f8 01             	cmp    $0x1,%eax
  800421331e:	0f 85 09 01 00 00    	jne    800421342d <_dwarf_lineno_run_program+0x1f6>
            case DW_LNE_end_sequence:
                p++;
  8004213324:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800421332b:	48 83 c0 01          	add    $0x1,%rax
  800421332f:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
                end_sequence = 1;
  8004213336:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%rbp)
                RESET_REGISTERS;
  800421333d:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004213344:	00 
  8004213345:	48 c7 45 e0 01 00 00 	movq   $0x1,-0x20(%rbp)
  800421334c:	00 
  800421334d:	48 c7 45 d8 01 00 00 	movq   $0x1,-0x28(%rbp)
  8004213354:	00 
  8004213355:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  800421335c:	00 
  800421335d:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213361:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  8004213365:	0f b6 c0             	movzbl %al,%eax
  8004213368:	89 45 cc             	mov    %eax,-0x34(%rbp)
  800421336b:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
  8004213372:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
  8004213379:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
  8004213380:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)
                break;
  8004213387:	e9 bb 00 00 00       	jmpq   8004213447 <_dwarf_lineno_run_program+0x210>
            case DW_LNE_set_address:
                p++;
  800421338c:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004213393:	48 83 c0 01          	add    $0x1,%rax
  8004213397:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
                address = dbg->decode(&p, cu->addr_size);
  800421339e:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  80042133a5:	00 00 00 
  80042133a8:	48 8b 00             	mov    (%rax),%rax
  80042133ab:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042133af:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  80042133b3:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  80042133b7:	0f b6 ca             	movzbl %dl,%ecx
  80042133ba:	48 8d 95 78 ff ff ff 	lea    -0x88(%rbp),%rdx
  80042133c1:	89 ce                	mov    %ecx,%esi
  80042133c3:	48 89 d7             	mov    %rdx,%rdi
  80042133c6:	ff d0                	callq  *%rax
  80042133c8:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
                break;
  80042133cc:	eb 79                	jmp    8004213447 <_dwarf_lineno_run_program+0x210>
            case DW_LNE_define_file:
                p++;
  80042133ce:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042133d5:	48 83 c0 01          	add    $0x1,%rax
  80042133d9:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
                ret = _dwarf_lineno_add_file(li, &p, NULL,
  80042133e0:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  80042133e7:	00 00 00 
  80042133ea:	48 8b 08             	mov    (%rax),%rcx
  80042133ed:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  80042133f4:	48 8d b5 78 ff ff ff 	lea    -0x88(%rbp),%rsi
  80042133fb:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042133ff:	49 89 c8             	mov    %rcx,%r8
  8004213402:	48 89 d1             	mov    %rdx,%rcx
  8004213405:	ba 00 00 00 00       	mov    $0x0,%edx
  800421340a:	48 89 c7             	mov    %rax,%rdi
  800421340d:	48 b8 ef 37 21 04 80 	movabs $0x80042137ef,%rax
  8004213414:	00 00 00 
  8004213417:	ff d0                	callq  *%rax
  8004213419:	89 45 a4             	mov    %eax,-0x5c(%rbp)
                    error, dbg);
                if (ret != DW_DLE_NONE)
  800421341c:	83 7d a4 00          	cmpl   $0x0,-0x5c(%rbp)
  8004213420:	74 09                	je     800421342b <_dwarf_lineno_run_program+0x1f4>
                    goto prog_fail;
  8004213422:	90                   	nop

    return (DW_DLE_NONE);

prog_fail:

    return (ret);
  8004213423:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  8004213426:	e9 ba 03 00 00       	jmpq   80042137e5 <_dwarf_lineno_run_program+0x5ae>
                p++;
                ret = _dwarf_lineno_add_file(li, &p, NULL,
                    error, dbg);
                if (ret != DW_DLE_NONE)
                    goto prog_fail;
                break;
  800421342b:	eb 1a                	jmp    8004213447 <_dwarf_lineno_run_program+0x210>
            default:
                /* Unrecognized extened opcodes. */
                p += opsize;
  800421342d:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  8004213434:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004213438:	48 01 d0             	add    %rdx,%rax
  800421343b:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  8004213442:	e9 85 03 00 00       	jmpq   80042137cc <_dwarf_lineno_run_program+0x595>
  8004213447:	e9 80 03 00 00       	jmpq   80042137cc <_dwarf_lineno_run_program+0x595>
            }

        } else if (*p > 0 && *p < li->li_opbase) {
  800421344c:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004213453:	0f b6 00             	movzbl (%rax),%eax
  8004213456:	84 c0                	test   %al,%al
  8004213458:	0f 84 3c 02 00 00    	je     800421369a <_dwarf_lineno_run_program+0x463>
  800421345e:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004213465:	0f b6 10             	movzbl (%rax),%edx
  8004213468:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421346c:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004213470:	38 c2                	cmp    %al,%dl
  8004213472:	0f 83 22 02 00 00    	jae    800421369a <_dwarf_lineno_run_program+0x463>

            /*
             * Standard Opcodes.
             */

            switch (*p++) {
  8004213478:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800421347f:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004213483:	48 89 95 78 ff ff ff 	mov    %rdx,-0x88(%rbp)
  800421348a:	0f b6 00             	movzbl (%rax),%eax
  800421348d:	0f b6 c0             	movzbl %al,%eax
  8004213490:	83 f8 0c             	cmp    $0xc,%eax
  8004213493:	0f 87 fb 01 00 00    	ja     8004213694 <_dwarf_lineno_run_program+0x45d>
  8004213499:	89 c0                	mov    %eax,%eax
  800421349b:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042134a2:	00 
  80042134a3:	48 b8 40 83 21 04 80 	movabs $0x8004218340,%rax
  80042134aa:	00 00 00 
  80042134ad:	48 01 d0             	add    %rdx,%rax
  80042134b0:	48 8b 00             	mov    (%rax),%rax
  80042134b3:	ff e0                	jmpq   *%rax
            case DW_LNS_copy:
                APPEND_ROW;
  80042134b5:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042134bc:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80042134c0:	73 0a                	jae    80042134cc <_dwarf_lineno_run_program+0x295>
  80042134c2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042134c7:	e9 19 03 00 00       	jmpq   80042137e5 <_dwarf_lineno_run_program+0x5ae>
  80042134cc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042134d0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042134d4:	48 89 10             	mov    %rdx,(%rax)
  80042134d7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042134db:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  80042134e2:	00 
  80042134e3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042134e7:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042134eb:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80042134ef:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042134f3:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042134f7:	48 89 50 18          	mov    %rdx,0x18(%rax)
  80042134fb:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042134ff:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213503:	48 89 50 20          	mov    %rdx,0x20(%rax)
  8004213507:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421350b:	8b 55 c8             	mov    -0x38(%rbp),%edx
  800421350e:	89 50 28             	mov    %edx,0x28(%rax)
  8004213511:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213515:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004213518:	89 50 2c             	mov    %edx,0x2c(%rax)
  800421351b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421351f:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004213522:	89 50 30             	mov    %edx,0x30(%rax)
  8004213525:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213529:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8004213530:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004213534:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213538:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
                basic_block = 0;
  800421353f:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
                prologue_end = 0;
  8004213546:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
                epilogue_begin = 0;
  800421354d:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)
                break;
  8004213554:	e9 3c 01 00 00       	jmpq   8004213695 <_dwarf_lineno_run_program+0x45e>
            case DW_LNS_advance_pc:
                address += _dwarf_decode_uleb128(&p) *
  8004213559:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  8004213560:	48 89 c7             	mov    %rax,%rdi
  8004213563:	48 b8 fe f4 20 04 80 	movabs $0x800420f4fe,%rax
  800421356a:	00 00 00 
  800421356d:	ff d0                	callq  *%rax
                    li->li_minlen;
  800421356f:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004213573:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
                basic_block = 0;
                prologue_end = 0;
                epilogue_begin = 0;
                break;
            case DW_LNS_advance_pc:
                address += _dwarf_decode_uleb128(&p) *
  8004213577:	0f b6 d2             	movzbl %dl,%edx
  800421357a:	48 0f af c2          	imul   %rdx,%rax
  800421357e:	48 01 45 e8          	add    %rax,-0x18(%rbp)
                    li->li_minlen;
                break;
  8004213582:	e9 0e 01 00 00       	jmpq   8004213695 <_dwarf_lineno_run_program+0x45e>
            case DW_LNS_advance_line:
                line += _dwarf_decode_sleb128(&p);
  8004213587:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  800421358e:	48 89 c7             	mov    %rax,%rdi
  8004213591:	48 b8 6c f4 20 04 80 	movabs $0x800420f46c,%rax
  8004213598:	00 00 00 
  800421359b:	ff d0                	callq  *%rax
  800421359d:	48 01 45 d8          	add    %rax,-0x28(%rbp)
                break;
  80042135a1:	e9 ef 00 00 00       	jmpq   8004213695 <_dwarf_lineno_run_program+0x45e>
            case DW_LNS_set_file:
                file = _dwarf_decode_uleb128(&p);
  80042135a6:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  80042135ad:	48 89 c7             	mov    %rax,%rdi
  80042135b0:	48 b8 fe f4 20 04 80 	movabs $0x800420f4fe,%rax
  80042135b7:	00 00 00 
  80042135ba:	ff d0                	callq  *%rax
  80042135bc:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
                break;
  80042135c0:	e9 d0 00 00 00       	jmpq   8004213695 <_dwarf_lineno_run_program+0x45e>
            case DW_LNS_set_column:
                column = _dwarf_decode_uleb128(&p);
  80042135c5:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  80042135cc:	48 89 c7             	mov    %rax,%rdi
  80042135cf:	48 b8 fe f4 20 04 80 	movabs $0x800420f4fe,%rax
  80042135d6:	00 00 00 
  80042135d9:	ff d0                	callq  *%rax
  80042135db:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                break;
  80042135df:	e9 b1 00 00 00       	jmpq   8004213695 <_dwarf_lineno_run_program+0x45e>
            case DW_LNS_negate_stmt:
                is_stmt = !is_stmt;
  80042135e4:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  80042135e8:	0f 94 c0             	sete   %al
  80042135eb:	0f b6 c0             	movzbl %al,%eax
  80042135ee:	89 45 cc             	mov    %eax,-0x34(%rbp)
                break;
  80042135f1:	e9 9f 00 00 00       	jmpq   8004213695 <_dwarf_lineno_run_program+0x45e>
            case DW_LNS_set_basic_block:
                basic_block = 1;
  80042135f6:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%rbp)
                break;
  80042135fd:	e9 93 00 00 00       	jmpq   8004213695 <_dwarf_lineno_run_program+0x45e>
            case DW_LNS_const_add_pc:
                address += ADDRESS(255);
  8004213602:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213606:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  800421360a:	0f b6 c0             	movzbl %al,%eax
  800421360d:	ba ff 00 00 00       	mov    $0xff,%edx
  8004213612:	89 d1                	mov    %edx,%ecx
  8004213614:	29 c1                	sub    %eax,%ecx
  8004213616:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421361a:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  800421361e:	0f b6 d8             	movzbl %al,%ebx
  8004213621:	89 c8                	mov    %ecx,%eax
  8004213623:	99                   	cltd   
  8004213624:	f7 fb                	idiv   %ebx
  8004213626:	89 c2                	mov    %eax,%edx
  8004213628:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421362c:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  8004213630:	0f b6 c0             	movzbl %al,%eax
  8004213633:	0f af c2             	imul   %edx,%eax
  8004213636:	48 98                	cltq   
  8004213638:	48 01 45 e8          	add    %rax,-0x18(%rbp)
                break;
  800421363c:	eb 57                	jmp    8004213695 <_dwarf_lineno_run_program+0x45e>
            case DW_LNS_fixed_advance_pc:
                address += dbg->decode(&p, 2);
  800421363e:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  8004213645:	00 00 00 
  8004213648:	48 8b 00             	mov    (%rax),%rax
  800421364b:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421364f:	48 8d 95 78 ff ff ff 	lea    -0x88(%rbp),%rdx
  8004213656:	be 02 00 00 00       	mov    $0x2,%esi
  800421365b:	48 89 d7             	mov    %rdx,%rdi
  800421365e:	ff d0                	callq  *%rax
  8004213660:	48 01 45 e8          	add    %rax,-0x18(%rbp)
                break;
  8004213664:	eb 2f                	jmp    8004213695 <_dwarf_lineno_run_program+0x45e>
            case DW_LNS_set_prologue_end:
                prologue_end = 1;
  8004213666:	c7 45 b4 01 00 00 00 	movl   $0x1,-0x4c(%rbp)
                break;
  800421366d:	eb 26                	jmp    8004213695 <_dwarf_lineno_run_program+0x45e>
            case DW_LNS_set_epilogue_begin:
                epilogue_begin = 1;
  800421366f:	c7 45 b0 01 00 00 00 	movl   $0x1,-0x50(%rbp)
                break;
  8004213676:	eb 1d                	jmp    8004213695 <_dwarf_lineno_run_program+0x45e>
            case DW_LNS_set_isa:
                isa = _dwarf_decode_uleb128(&p);
  8004213678:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  800421367f:	48 89 c7             	mov    %rax,%rdi
  8004213682:	48 b8 fe f4 20 04 80 	movabs $0x800420f4fe,%rax
  8004213689:	00 00 00 
  800421368c:	ff d0                	callq  *%rax
  800421368e:	48 89 45 98          	mov    %rax,-0x68(%rbp)
                break;
  8004213692:	eb 01                	jmp    8004213695 <_dwarf_lineno_run_program+0x45e>
            default:
                /* Unrecognized extened opcodes. What to do? */
                break;
  8004213694:	90                   	nop
            }

        } else {
  8004213695:	e9 32 01 00 00       	jmpq   80042137cc <_dwarf_lineno_run_program+0x595>

            /*
             * Special Opcodes.
             */

            line += LINE(*p);
  800421369a:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421369e:	0f b6 40 1a          	movzbl 0x1a(%rax),%eax
  80042136a2:	0f be c8             	movsbl %al,%ecx
  80042136a5:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042136ac:	0f b6 00             	movzbl (%rax),%eax
  80042136af:	0f b6 d0             	movzbl %al,%edx
  80042136b2:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042136b6:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  80042136ba:	0f b6 c0             	movzbl %al,%eax
  80042136bd:	29 c2                	sub    %eax,%edx
  80042136bf:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042136c3:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  80042136c7:	0f b6 f0             	movzbl %al,%esi
  80042136ca:	89 d0                	mov    %edx,%eax
  80042136cc:	99                   	cltd   
  80042136cd:	f7 fe                	idiv   %esi
  80042136cf:	89 d0                	mov    %edx,%eax
  80042136d1:	01 c8                	add    %ecx,%eax
  80042136d3:	48 98                	cltq   
  80042136d5:	48 01 45 d8          	add    %rax,-0x28(%rbp)
            address += ADDRESS(*p);
  80042136d9:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042136e0:	0f b6 00             	movzbl (%rax),%eax
  80042136e3:	0f b6 d0             	movzbl %al,%edx
  80042136e6:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042136ea:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  80042136ee:	0f b6 c0             	movzbl %al,%eax
  80042136f1:	89 d1                	mov    %edx,%ecx
  80042136f3:	29 c1                	sub    %eax,%ecx
  80042136f5:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042136f9:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  80042136fd:	0f b6 d8             	movzbl %al,%ebx
  8004213700:	89 c8                	mov    %ecx,%eax
  8004213702:	99                   	cltd   
  8004213703:	f7 fb                	idiv   %ebx
  8004213705:	89 c2                	mov    %eax,%edx
  8004213707:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421370b:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  800421370f:	0f b6 c0             	movzbl %al,%eax
  8004213712:	0f af c2             	imul   %edx,%eax
  8004213715:	48 98                	cltq   
  8004213717:	48 01 45 e8          	add    %rax,-0x18(%rbp)
            APPEND_ROW;
  800421371b:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004213722:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004213726:	73 0a                	jae    8004213732 <_dwarf_lineno_run_program+0x4fb>
  8004213728:	b8 00 00 00 00       	mov    $0x0,%eax
  800421372d:	e9 b3 00 00 00       	jmpq   80042137e5 <_dwarf_lineno_run_program+0x5ae>
  8004213732:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213736:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421373a:	48 89 10             	mov    %rdx,(%rax)
  800421373d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213741:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  8004213748:	00 
  8004213749:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421374d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004213751:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8004213755:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213759:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800421375d:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004213761:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213765:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213769:	48 89 50 20          	mov    %rdx,0x20(%rax)
  800421376d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213771:	8b 55 c8             	mov    -0x38(%rbp),%edx
  8004213774:	89 50 28             	mov    %edx,0x28(%rax)
  8004213777:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421377b:	8b 55 cc             	mov    -0x34(%rbp),%edx
  800421377e:	89 50 2c             	mov    %edx,0x2c(%rax)
  8004213781:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213785:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004213788:	89 50 30             	mov    %edx,0x30(%rax)
  800421378b:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421378f:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8004213796:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800421379a:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421379e:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
            basic_block = 0;
  80042137a5:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
            prologue_end = 0;
  80042137ac:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
            epilogue_begin = 0;
  80042137b3:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)
            p++;
  80042137ba:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042137c1:	48 83 c0 01          	add    $0x1,%rax
  80042137c5:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
    RESET_REGISTERS;

    /*
     * Start line number program.
     */
    while (p < pe) {
  80042137cc:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042137d3:	48 3b 85 70 ff ff ff 	cmp    -0x90(%rbp),%rax
  80042137da:	0f 82 e2 fa ff ff    	jb     80042132c2 <_dwarf_lineno_run_program+0x8b>
            epilogue_begin = 0;
            p++;
        }
    }

    return (DW_DLE_NONE);
  80042137e0:	b8 00 00 00 00       	mov    $0x0,%eax

#undef  RESET_REGISTERS
#undef  APPEND_ROW
#undef  LINE
#undef  ADDRESS
}
  80042137e5:	48 81 c4 98 00 00 00 	add    $0x98,%rsp
  80042137ec:	5b                   	pop    %rbx
  80042137ed:	5d                   	pop    %rbp
  80042137ee:	c3                   	retq   

00000080042137ef <_dwarf_lineno_add_file>:

static int
_dwarf_lineno_add_file(Dwarf_LineInfo li, uint8_t **p, const char *compdir,
    Dwarf_Error *error, Dwarf_Debug dbg)
{
  80042137ef:	55                   	push   %rbp
  80042137f0:	48 89 e5             	mov    %rsp,%rbp
  80042137f3:	53                   	push   %rbx
  80042137f4:	48 83 ec 48          	sub    $0x48,%rsp
  80042137f8:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80042137fc:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004213800:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004213804:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  8004213808:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
    char *fname;
    //const char *dirname;
    uint8_t *src;
    int slen;

    src = *p;
  800421380c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213810:	48 8b 00             	mov    (%rax),%rax
  8004213813:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        DWARF_SET_ERROR(dbg, error, DW_DLE_MEMORY);
        return (DW_DLE_MEMORY);
    }
*/  
    //lf->lf_fullpath = NULL;
    fname = (char *) src;
  8004213817:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421381b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    src += strlen(fname) + 1;
  800421381f:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
  8004213823:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213827:	48 89 c7             	mov    %rax,%rdi
  800421382a:	48 b8 d6 e5 20 04 80 	movabs $0x800420e5d6,%rax
  8004213831:	00 00 00 
  8004213834:	ff d0                	callq  *%rax
  8004213836:	48 98                	cltq   
  8004213838:	48 83 c0 01          	add    $0x1,%rax
  800421383c:	48 01 d8             	add    %rbx,%rax
  800421383f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    _dwarf_decode_uleb128(&src);
  8004213843:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004213847:	48 89 c7             	mov    %rax,%rdi
  800421384a:	48 b8 fe f4 20 04 80 	movabs $0x800420f4fe,%rax
  8004213851:	00 00 00 
  8004213854:	ff d0                	callq  *%rax
            snprintf(lf->lf_fullpath, slen, "%s/%s", dirname,
                lf->lf_fname);
        }
    }
*/
    _dwarf_decode_uleb128(&src);
  8004213856:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  800421385a:	48 89 c7             	mov    %rax,%rdi
  800421385d:	48 b8 fe f4 20 04 80 	movabs $0x800420f4fe,%rax
  8004213864:	00 00 00 
  8004213867:	ff d0                	callq  *%rax
    _dwarf_decode_uleb128(&src);
  8004213869:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  800421386d:	48 89 c7             	mov    %rax,%rdi
  8004213870:	48 b8 fe f4 20 04 80 	movabs $0x800420f4fe,%rax
  8004213877:	00 00 00 
  800421387a:	ff d0                	callq  *%rax
    //STAILQ_INSERT_TAIL(&li->li_lflist, lf, lf_next);
    //li->li_lflen++;

    *p = src;
  800421387c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004213880:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213884:	48 89 10             	mov    %rdx,(%rax)

    return (DW_DLE_NONE);
  8004213887:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421388c:	48 83 c4 48          	add    $0x48,%rsp
  8004213890:	5b                   	pop    %rbx
  8004213891:	5d                   	pop    %rbp
  8004213892:	c3                   	retq   

0000008004213893 <_dwarf_lineno_init>:

int     
_dwarf_lineno_init(Dwarf_Die *die, uint64_t offset, Dwarf_LineInfo linfo, Dwarf_Addr pc, Dwarf_Error *error)
{   
  8004213893:	55                   	push   %rbp
  8004213894:	48 89 e5             	mov    %rsp,%rbp
  8004213897:	53                   	push   %rbx
  8004213898:	48 81 ec 08 01 00 00 	sub    $0x108,%rsp
  800421389f:	48 89 bd 18 ff ff ff 	mov    %rdi,-0xe8(%rbp)
  80042138a6:	48 89 b5 10 ff ff ff 	mov    %rsi,-0xf0(%rbp)
  80042138ad:	48 89 95 08 ff ff ff 	mov    %rdx,-0xf8(%rbp)
  80042138b4:	48 89 8d 00 ff ff ff 	mov    %rcx,-0x100(%rbp)
  80042138bb:	4c 89 85 f8 fe ff ff 	mov    %r8,-0x108(%rbp)
    Dwarf_Section myds = {.ds_name = ".debug_line"};
  80042138c2:	48 c7 45 90 00 00 00 	movq   $0x0,-0x70(%rbp)
  80042138c9:	00 
  80042138ca:	48 c7 45 98 00 00 00 	movq   $0x0,-0x68(%rbp)
  80042138d1:	00 
  80042138d2:	48 c7 45 a0 00 00 00 	movq   $0x0,-0x60(%rbp)
  80042138d9:	00 
  80042138da:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  80042138e1:	00 
  80042138e2:	48 b8 a8 83 21 04 80 	movabs $0x80042183a8,%rax
  80042138e9:	00 00 00 
  80042138ec:	48 89 45 90          	mov    %rax,-0x70(%rbp)
	Dwarf_Section *ds = &myds;
  80042138f0:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  80042138f4:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    //Dwarf_LineFile lf, tlf;
    uint64_t length, hdroff, endoff;
    uint8_t *p;
    int dwarf_size, i, ret;
            
    cu = die->cu_header;
  80042138f8:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80042138ff:	48 8b 80 60 03 00 00 	mov    0x360(%rax),%rax
  8004213906:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    assert(cu != NULL); 
  800421390a:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800421390f:	75 35                	jne    8004213946 <_dwarf_lineno_init+0xb3>
  8004213911:	48 b9 b4 83 21 04 80 	movabs $0x80042183b4,%rcx
  8004213918:	00 00 00 
  800421391b:	48 ba bf 83 21 04 80 	movabs $0x80042183bf,%rdx
  8004213922:	00 00 00 
  8004213925:	be 17 01 00 00       	mov    $0x117,%esi
  800421392a:	48 bf d4 83 21 04 80 	movabs $0x80042183d4,%rdi
  8004213931:	00 00 00 
  8004213934:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213939:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004213940:	00 00 00 
  8004213943:	41 ff d0             	callq  *%r8
    assert(dbg != NULL);
  8004213946:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  800421394d:	00 00 00 
  8004213950:	48 8b 00             	mov    (%rax),%rax
  8004213953:	48 85 c0             	test   %rax,%rax
  8004213956:	75 35                	jne    800421398d <_dwarf_lineno_init+0xfa>
  8004213958:	48 b9 eb 83 21 04 80 	movabs $0x80042183eb,%rcx
  800421395f:	00 00 00 
  8004213962:	48 ba bf 83 21 04 80 	movabs $0x80042183bf,%rdx
  8004213969:	00 00 00 
  800421396c:	be 18 01 00 00       	mov    $0x118,%esi
  8004213971:	48 bf d4 83 21 04 80 	movabs $0x80042183d4,%rdi
  8004213978:	00 00 00 
  800421397b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213980:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004213987:	00 00 00 
  800421398a:	41 ff d0             	callq  *%r8

    if ((_dwarf_find_section_enhanced(ds)) != 0)
  800421398d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213991:	48 89 c7             	mov    %rax,%rdi
  8004213994:	48 b8 8b 0c 21 04 80 	movabs $0x8004210c8b,%rax
  800421399b:	00 00 00 
  800421399e:	ff d0                	callq  *%rax
  80042139a0:	85 c0                	test   %eax,%eax
  80042139a2:	74 0a                	je     80042139ae <_dwarf_lineno_init+0x11b>
        return (DW_DLE_NONE);
  80042139a4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042139a9:	e9 4f 04 00 00       	jmpq   8004213dfd <_dwarf_lineno_init+0x56a>

	li = linfo;
  80042139ae:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  80042139b5:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
            break;
        }
    }
     */

    length = dbg->read(ds->ds_data, &offset, 4);
  80042139b9:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  80042139c0:	00 00 00 
  80042139c3:	48 8b 00             	mov    (%rax),%rax
  80042139c6:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042139ca:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042139ce:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80042139d2:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  80042139d9:	ba 04 00 00 00       	mov    $0x4,%edx
  80042139de:	48 89 cf             	mov    %rcx,%rdi
  80042139e1:	ff d0                	callq  *%rax
  80042139e3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if (length == 0xffffffff) {
  80042139e7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042139ec:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80042139f0:	75 37                	jne    8004213a29 <_dwarf_lineno_init+0x196>
        dwarf_size = 8;
  80042139f2:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%rbp)
        length = dbg->read(ds->ds_data, &offset, 8);
  80042139f9:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  8004213a00:	00 00 00 
  8004213a03:	48 8b 00             	mov    (%rax),%rax
  8004213a06:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213a0a:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213a0e:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004213a12:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004213a19:	ba 08 00 00 00       	mov    $0x8,%edx
  8004213a1e:	48 89 cf             	mov    %rcx,%rdi
  8004213a21:	ff d0                	callq  *%rax
  8004213a23:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004213a27:	eb 07                	jmp    8004213a30 <_dwarf_lineno_init+0x19d>
    } else
        dwarf_size = 4;
  8004213a29:	c7 45 e4 04 00 00 00 	movl   $0x4,-0x1c(%rbp)

    if (length > ds->ds_size - offset) {
  8004213a30:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213a34:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004213a38:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004213a3f:	48 29 c2             	sub    %rax,%rdx
  8004213a42:	48 89 d0             	mov    %rdx,%rax
  8004213a45:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004213a49:	73 0a                	jae    8004213a55 <_dwarf_lineno_init+0x1c2>
        DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_LINE_LENGTH_BAD);
        return (DW_DLE_DEBUG_LINE_LENGTH_BAD);
  8004213a4b:	b8 0f 00 00 00       	mov    $0xf,%eax
  8004213a50:	e9 a8 03 00 00       	jmpq   8004213dfd <_dwarf_lineno_init+0x56a>
    }
    /*
     * Read in line number program header.
     */
    li->li_length = length;
  8004213a55:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213a59:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213a5d:	48 89 10             	mov    %rdx,(%rax)
    endoff = offset + length;
  8004213a60:	48 8b 95 10 ff ff ff 	mov    -0xf0(%rbp),%rdx
  8004213a67:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213a6b:	48 01 d0             	add    %rdx,%rax
  8004213a6e:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    li->li_version = dbg->read(ds->ds_data, &offset, 2); /* FIXME: verify version */
  8004213a72:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  8004213a79:	00 00 00 
  8004213a7c:	48 8b 00             	mov    (%rax),%rax
  8004213a7f:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213a83:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213a87:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004213a8b:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004213a92:	ba 02 00 00 00       	mov    $0x2,%edx
  8004213a97:	48 89 cf             	mov    %rcx,%rdi
  8004213a9a:	ff d0                	callq  *%rax
  8004213a9c:	89 c2                	mov    %eax,%edx
  8004213a9e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213aa2:	66 89 50 08          	mov    %dx,0x8(%rax)
    li->li_hdrlen = dbg->read(ds->ds_data, &offset, dwarf_size);
  8004213aa6:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  8004213aad:	00 00 00 
  8004213ab0:	48 8b 00             	mov    (%rax),%rax
  8004213ab3:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213ab7:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213abb:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004213abf:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004213ac2:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004213ac9:	48 89 cf             	mov    %rcx,%rdi
  8004213acc:	ff d0                	callq  *%rax
  8004213ace:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004213ad2:	48 89 42 10          	mov    %rax,0x10(%rdx)
    hdroff = offset;
  8004213ad6:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004213add:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    li->li_minlen = dbg->read(ds->ds_data, &offset, 1);
  8004213ae1:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  8004213ae8:	00 00 00 
  8004213aeb:	48 8b 00             	mov    (%rax),%rax
  8004213aee:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213af2:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213af6:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004213afa:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004213b01:	ba 01 00 00 00       	mov    $0x1,%edx
  8004213b06:	48 89 cf             	mov    %rcx,%rdi
  8004213b09:	ff d0                	callq  *%rax
  8004213b0b:	89 c2                	mov    %eax,%edx
  8004213b0d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213b11:	88 50 18             	mov    %dl,0x18(%rax)
    li->li_defstmt = dbg->read(ds->ds_data, &offset, 1);
  8004213b14:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  8004213b1b:	00 00 00 
  8004213b1e:	48 8b 00             	mov    (%rax),%rax
  8004213b21:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213b25:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213b29:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004213b2d:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004213b34:	ba 01 00 00 00       	mov    $0x1,%edx
  8004213b39:	48 89 cf             	mov    %rcx,%rdi
  8004213b3c:	ff d0                	callq  *%rax
  8004213b3e:	89 c2                	mov    %eax,%edx
  8004213b40:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213b44:	88 50 19             	mov    %dl,0x19(%rax)
    li->li_lbase = dbg->read(ds->ds_data, &offset, 1);
  8004213b47:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  8004213b4e:	00 00 00 
  8004213b51:	48 8b 00             	mov    (%rax),%rax
  8004213b54:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213b58:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213b5c:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004213b60:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004213b67:	ba 01 00 00 00       	mov    $0x1,%edx
  8004213b6c:	48 89 cf             	mov    %rcx,%rdi
  8004213b6f:	ff d0                	callq  *%rax
  8004213b71:	89 c2                	mov    %eax,%edx
  8004213b73:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213b77:	88 50 1a             	mov    %dl,0x1a(%rax)
    li->li_lrange = dbg->read(ds->ds_data, &offset, 1);
  8004213b7a:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  8004213b81:	00 00 00 
  8004213b84:	48 8b 00             	mov    (%rax),%rax
  8004213b87:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213b8b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213b8f:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004213b93:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004213b9a:	ba 01 00 00 00       	mov    $0x1,%edx
  8004213b9f:	48 89 cf             	mov    %rcx,%rdi
  8004213ba2:	ff d0                	callq  *%rax
  8004213ba4:	89 c2                	mov    %eax,%edx
  8004213ba6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213baa:	88 50 1b             	mov    %dl,0x1b(%rax)
    li->li_opbase = dbg->read(ds->ds_data, &offset, 1);
  8004213bad:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  8004213bb4:	00 00 00 
  8004213bb7:	48 8b 00             	mov    (%rax),%rax
  8004213bba:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213bbe:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213bc2:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004213bc6:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004213bcd:	ba 01 00 00 00       	mov    $0x1,%edx
  8004213bd2:	48 89 cf             	mov    %rcx,%rdi
  8004213bd5:	ff d0                	callq  *%rax
  8004213bd7:	89 c2                	mov    %eax,%edx
  8004213bd9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213bdd:	88 50 1c             	mov    %dl,0x1c(%rax)
    //STAILQ_INIT(&li->li_lflist);
    //STAILQ_INIT(&li->li_lnlist);

    if ((int)li->li_hdrlen - 5 < li->li_opbase - 1) {
  8004213be0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213be4:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004213be8:	8d 50 fb             	lea    -0x5(%rax),%edx
  8004213beb:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213bef:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004213bf3:	0f b6 c0             	movzbl %al,%eax
  8004213bf6:	83 e8 01             	sub    $0x1,%eax
  8004213bf9:	39 c2                	cmp    %eax,%edx
  8004213bfb:	7d 0c                	jge    8004213c09 <_dwarf_lineno_init+0x376>
        ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  8004213bfd:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
        DWARF_SET_ERROR(dbg, error, ret);
        goto fail_cleanup;
  8004213c04:	e9 f1 01 00 00       	jmpq   8004213dfa <_dwarf_lineno_init+0x567>
    }

    li->li_oplen = global_std_op;
  8004213c09:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213c0d:	48 bb a0 75 49 04 80 	movabs $0x80044975a0,%rbx
  8004213c14:	00 00 00 
  8004213c17:	48 89 58 20          	mov    %rbx,0x20(%rax)

    /*
     * Read in std opcode arg length list. Note that the first
     * element is not used.
     */
    for (i = 1; i < li->li_opbase; i++)
  8004213c1b:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%rbp)
  8004213c22:	eb 41                	jmp    8004213c65 <_dwarf_lineno_init+0x3d2>
        li->li_oplen[i] = dbg->read(ds->ds_data, &offset, 1);
  8004213c24:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213c28:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004213c2c:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004213c2f:	48 98                	cltq   
  8004213c31:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  8004213c35:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  8004213c3c:	00 00 00 
  8004213c3f:	48 8b 00             	mov    (%rax),%rax
  8004213c42:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213c46:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213c4a:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004213c4e:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004213c55:	ba 01 00 00 00       	mov    $0x1,%edx
  8004213c5a:	48 89 cf             	mov    %rcx,%rdi
  8004213c5d:	ff d0                	callq  *%rax
  8004213c5f:	88 03                	mov    %al,(%rbx)

    /*
     * Read in std opcode arg length list. Note that the first
     * element is not used.
     */
    for (i = 1; i < li->li_opbase; i++)
  8004213c61:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
  8004213c65:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213c69:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004213c6d:	0f b6 c0             	movzbl %al,%eax
  8004213c70:	3b 45 e0             	cmp    -0x20(%rbp),%eax
  8004213c73:	7f af                	jg     8004213c24 <_dwarf_lineno_init+0x391>
        li->li_oplen[i] = dbg->read(ds->ds_data, &offset, 1);

    /*
     * Check how many strings in the include dir string array.
     */
    length = 0;
  8004213c75:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004213c7c:	00 
    p = ds->ds_data + offset;
  8004213c7d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213c81:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004213c85:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004213c8c:	48 01 d0             	add    %rdx,%rax
  8004213c8f:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
    while (*p != '\0') {
  8004213c96:	eb 1f                	jmp    8004213cb7 <_dwarf_lineno_init+0x424>
        while (*p++ != '\0')
  8004213c98:	90                   	nop
  8004213c99:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004213ca0:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004213ca4:	48 89 95 28 ff ff ff 	mov    %rdx,-0xd8(%rbp)
  8004213cab:	0f b6 00             	movzbl (%rax),%eax
  8004213cae:	84 c0                	test   %al,%al
  8004213cb0:	75 e7                	jne    8004213c99 <_dwarf_lineno_init+0x406>
            ;
        length++;
  8004213cb2:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
    /*
     * Check how many strings in the include dir string array.
     */
    length = 0;
    p = ds->ds_data + offset;
    while (*p != '\0') {
  8004213cb7:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004213cbe:	0f b6 00             	movzbl (%rax),%eax
  8004213cc1:	84 c0                	test   %al,%al
  8004213cc3:	75 d3                	jne    8004213c98 <_dwarf_lineno_init+0x405>
        while (*p++ != '\0')
            ;
        length++;
    }
    li->li_inclen = length;
  8004213cc5:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213cc9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213ccd:	48 89 50 30          	mov    %rdx,0x30(%rax)

    /* Sanity check. */
    if (p - ds->ds_data > (int) ds->ds_size) {
  8004213cd1:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004213cd8:	48 89 c2             	mov    %rax,%rdx
  8004213cdb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213cdf:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004213ce3:	48 29 c2             	sub    %rax,%rdx
  8004213ce6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213cea:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213cee:	48 98                	cltq   
  8004213cf0:	48 39 c2             	cmp    %rax,%rdx
  8004213cf3:	7e 0c                	jle    8004213d01 <_dwarf_lineno_init+0x46e>
        ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  8004213cf5:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
        DWARF_SET_ERROR(dbg, error, ret);
        goto fail_cleanup;
  8004213cfc:	e9 f9 00 00 00       	jmpq   8004213dfa <_dwarf_lineno_init+0x567>
        li->li_incdirs[i++] = (char *) p;
        while (*p++ != '\0')
            ;
    }
*/
    p++;
  8004213d01:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004213d08:	48 83 c0 01          	add    $0x1,%rax
  8004213d0c:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)

    /*
     * Process file list.
     */
    while (*p != '\0') {
  8004213d13:	eb 3c                	jmp    8004213d51 <_dwarf_lineno_init+0x4be>
        ret = _dwarf_lineno_add_file(li, &p, NULL, error, dbg);
  8004213d15:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  8004213d1c:	00 00 00 
  8004213d1f:	48 8b 08             	mov    (%rax),%rcx
  8004213d22:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  8004213d29:	48 8d b5 28 ff ff ff 	lea    -0xd8(%rbp),%rsi
  8004213d30:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213d34:	49 89 c8             	mov    %rcx,%r8
  8004213d37:	48 89 d1             	mov    %rdx,%rcx
  8004213d3a:	ba 00 00 00 00       	mov    $0x0,%edx
  8004213d3f:	48 89 c7             	mov    %rax,%rdi
  8004213d42:	48 b8 ef 37 21 04 80 	movabs $0x80042137ef,%rax
  8004213d49:	00 00 00 
  8004213d4c:	ff d0                	callq  *%rax
  8004213d4e:	89 45 dc             	mov    %eax,-0x24(%rbp)
    p++;

    /*
     * Process file list.
     */
    while (*p != '\0') {
  8004213d51:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004213d58:	0f b6 00             	movzbl (%rax),%eax
  8004213d5b:	84 c0                	test   %al,%al
  8004213d5d:	75 b6                	jne    8004213d15 <_dwarf_lineno_init+0x482>
        ret = _dwarf_lineno_add_file(li, &p, NULL, error, dbg);
		//p++;
    }

    p++;
  8004213d5f:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004213d66:	48 83 c0 01          	add    $0x1,%rax
  8004213d6a:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
    /* Sanity check. */
    if (p - ds->ds_data - hdroff != li->li_hdrlen) {
  8004213d71:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004213d78:	48 89 c2             	mov    %rax,%rdx
  8004213d7b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213d7f:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004213d83:	48 29 c2             	sub    %rax,%rdx
  8004213d86:	48 89 d0             	mov    %rdx,%rax
  8004213d89:	48 2b 45 b0          	sub    -0x50(%rbp),%rax
  8004213d8d:	48 89 c2             	mov    %rax,%rdx
  8004213d90:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213d94:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004213d98:	48 39 c2             	cmp    %rax,%rdx
  8004213d9b:	74 09                	je     8004213da6 <_dwarf_lineno_init+0x513>
        ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  8004213d9d:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
        DWARF_SET_ERROR(dbg, error, ret);
        goto fail_cleanup;
  8004213da4:	eb 54                	jmp    8004213dfa <_dwarf_lineno_init+0x567>
    }

    /*
     * Process line number program.
     */
    ret = _dwarf_lineno_run_program(cu, li, p, ds->ds_data + endoff, pc,
  8004213da6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213daa:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004213dae:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213db2:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  8004213db6:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  8004213dbd:	4c 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%r8
  8004213dc4:	48 8b bd 00 ff ff ff 	mov    -0x100(%rbp),%rdi
  8004213dcb:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004213dcf:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213dd3:	4d 89 c1             	mov    %r8,%r9
  8004213dd6:	49 89 f8             	mov    %rdi,%r8
  8004213dd9:	48 89 c7             	mov    %rax,%rdi
  8004213ddc:	48 b8 37 32 21 04 80 	movabs $0x8004213237,%rax
  8004213de3:	00 00 00 
  8004213de6:	ff d0                	callq  *%rax
  8004213de8:	89 45 dc             	mov    %eax,-0x24(%rbp)
        error);
    if (ret != DW_DLE_NONE)
  8004213deb:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004213def:	74 02                	je     8004213df3 <_dwarf_lineno_init+0x560>
        goto fail_cleanup;
  8004213df1:	eb 07                	jmp    8004213dfa <_dwarf_lineno_init+0x567>

    //cu->cu_lineinfo = li;

    return (DW_DLE_NONE);
  8004213df3:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213df8:	eb 03                	jmp    8004213dfd <_dwarf_lineno_init+0x56a>
fail_cleanup:

    /*if (li->li_oplen)
        free(li->li_oplen);*/

    return (ret);
  8004213dfa:	8b 45 dc             	mov    -0x24(%rbp),%eax
}
  8004213dfd:	48 81 c4 08 01 00 00 	add    $0x108,%rsp
  8004213e04:	5b                   	pop    %rbx
  8004213e05:	5d                   	pop    %rbp
  8004213e06:	c3                   	retq   

0000008004213e07 <dwarf_srclines>:

int
dwarf_srclines(Dwarf_Die *die, Dwarf_Line linebuf, Dwarf_Addr pc, Dwarf_Error *error)
{
  8004213e07:	55                   	push   %rbp
  8004213e08:	48 89 e5             	mov    %rsp,%rbp
  8004213e0b:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  8004213e12:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  8004213e19:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  8004213e20:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
  8004213e27:	48 89 8d 50 ff ff ff 	mov    %rcx,-0xb0(%rbp)
    _Dwarf_LineInfo li;
    Dwarf_Attribute *at;

	assert(die);
  8004213e2e:	48 83 bd 68 ff ff ff 	cmpq   $0x0,-0x98(%rbp)
  8004213e35:	00 
  8004213e36:	75 35                	jne    8004213e6d <dwarf_srclines+0x66>
  8004213e38:	48 b9 f7 83 21 04 80 	movabs $0x80042183f7,%rcx
  8004213e3f:	00 00 00 
  8004213e42:	48 ba bf 83 21 04 80 	movabs $0x80042183bf,%rdx
  8004213e49:	00 00 00 
  8004213e4c:	be ae 01 00 00       	mov    $0x1ae,%esi
  8004213e51:	48 bf d4 83 21 04 80 	movabs $0x80042183d4,%rdi
  8004213e58:	00 00 00 
  8004213e5b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213e60:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004213e67:	00 00 00 
  8004213e6a:	41 ff d0             	callq  *%r8
	assert(linebuf);
  8004213e6d:	48 83 bd 60 ff ff ff 	cmpq   $0x0,-0xa0(%rbp)
  8004213e74:	00 
  8004213e75:	75 35                	jne    8004213eac <dwarf_srclines+0xa5>
  8004213e77:	48 b9 fb 83 21 04 80 	movabs $0x80042183fb,%rcx
  8004213e7e:	00 00 00 
  8004213e81:	48 ba bf 83 21 04 80 	movabs $0x80042183bf,%rdx
  8004213e88:	00 00 00 
  8004213e8b:	be af 01 00 00       	mov    $0x1af,%esi
  8004213e90:	48 bf d4 83 21 04 80 	movabs $0x80042183d4,%rdi
  8004213e97:	00 00 00 
  8004213e9a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213e9f:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004213ea6:	00 00 00 
  8004213ea9:	41 ff d0             	callq  *%r8

	memset(&li, 0, sizeof(_Dwarf_LineInfo));
  8004213eac:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  8004213eb3:	ba 88 00 00 00       	mov    $0x88,%edx
  8004213eb8:	be 00 00 00 00       	mov    $0x0,%esi
  8004213ebd:	48 89 c7             	mov    %rax,%rdi
  8004213ec0:	48 b8 db e8 20 04 80 	movabs $0x800420e8db,%rax
  8004213ec7:	00 00 00 
  8004213eca:	ff d0                	callq  *%rax

    if ((at = _dwarf_attr_find(die, DW_AT_stmt_list)) == NULL) {
  8004213ecc:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004213ed3:	be 10 00 00 00       	mov    $0x10,%esi
  8004213ed8:	48 89 c7             	mov    %rax,%rdi
  8004213edb:	48 b8 10 08 21 04 80 	movabs $0x8004210810,%rax
  8004213ee2:	00 00 00 
  8004213ee5:	ff d0                	callq  *%rax
  8004213ee7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004213eeb:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004213ef0:	75 0a                	jne    8004213efc <dwarf_srclines+0xf5>
        DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
        return (DW_DLV_NO_ENTRY);
  8004213ef2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004213ef7:	e9 84 00 00 00       	jmpq   8004213f80 <dwarf_srclines+0x179>
    }

    if (_dwarf_lineno_init(die, at->u[0].u64, &li, pc, error) !=
  8004213efc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213f00:	48 8b 70 28          	mov    0x28(%rax),%rsi
  8004213f04:	48 8b bd 50 ff ff ff 	mov    -0xb0(%rbp),%rdi
  8004213f0b:	48 8b 8d 58 ff ff ff 	mov    -0xa8(%rbp),%rcx
  8004213f12:	48 8d 95 70 ff ff ff 	lea    -0x90(%rbp),%rdx
  8004213f19:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004213f20:	49 89 f8             	mov    %rdi,%r8
  8004213f23:	48 89 c7             	mov    %rax,%rdi
  8004213f26:	48 b8 93 38 21 04 80 	movabs $0x8004213893,%rax
  8004213f2d:	00 00 00 
  8004213f30:	ff d0                	callq  *%rax
  8004213f32:	85 c0                	test   %eax,%eax
  8004213f34:	74 07                	je     8004213f3d <dwarf_srclines+0x136>
        DW_DLE_NONE)
	{
          return (DW_DLV_ERROR);
  8004213f36:	b8 01 00 00 00       	mov    $0x1,%eax
  8004213f3b:	eb 43                	jmp    8004213f80 <dwarf_srclines+0x179>
	}
    *linebuf = li.li_line;
  8004213f3d:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004213f44:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004213f48:	48 89 10             	mov    %rdx,(%rax)
  8004213f4b:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004213f4f:	48 89 50 08          	mov    %rdx,0x8(%rax)
  8004213f53:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213f57:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8004213f5b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213f5f:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004213f63:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004213f67:	48 89 50 20          	mov    %rdx,0x20(%rax)
  8004213f6b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004213f6f:	48 89 50 28          	mov    %rdx,0x28(%rax)
  8004213f73:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213f77:	48 89 50 30          	mov    %rdx,0x30(%rax)

    return (DW_DLV_OK);
  8004213f7b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004213f80:	c9                   	leaveq 
  8004213f81:	c3                   	retq   

0000008004213f82 <_dwarf_find_section>:
uintptr_t
read_section_headers(uintptr_t, uintptr_t);

Dwarf_Section *
_dwarf_find_section(const char *name)
{
  8004213f82:	55                   	push   %rbp
  8004213f83:	48 89 e5             	mov    %rsp,%rbp
  8004213f86:	48 83 ec 20          	sub    $0x20,%rsp
  8004213f8a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    Dwarf_Section *ret=NULL;
  8004213f8e:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004213f95:	00 
    int i;

    for (i = 0; i < NDEBUG_SECT; i++) {
  8004213f96:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004213f9d:	eb 57                	jmp    8004213ff6 <_dwarf_find_section+0x74>
        if (!strcmp(section_info[i].ds_name, name)) {
  8004213f9f:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  8004213fa6:	00 00 00 
  8004213fa9:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004213fac:	48 63 d2             	movslq %edx,%rdx
  8004213faf:	48 c1 e2 05          	shl    $0x5,%rdx
  8004213fb3:	48 01 d0             	add    %rdx,%rax
  8004213fb6:	48 8b 00             	mov    (%rax),%rax
  8004213fb9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213fbd:	48 89 d6             	mov    %rdx,%rsi
  8004213fc0:	48 89 c7             	mov    %rax,%rdi
  8004213fc3:	48 b8 a4 e7 20 04 80 	movabs $0x800420e7a4,%rax
  8004213fca:	00 00 00 
  8004213fcd:	ff d0                	callq  *%rax
  8004213fcf:	85 c0                	test   %eax,%eax
  8004213fd1:	75 1f                	jne    8004213ff2 <_dwarf_find_section+0x70>
            ret = (section_info + i);
  8004213fd3:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004213fd6:	48 98                	cltq   
  8004213fd8:	48 c1 e0 05          	shl    $0x5,%rax
  8004213fdc:	48 89 c2             	mov    %rax,%rdx
  8004213fdf:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  8004213fe6:	00 00 00 
  8004213fe9:	48 01 d0             	add    %rdx,%rax
  8004213fec:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
            break;
  8004213ff0:	eb 0a                	jmp    8004213ffc <_dwarf_find_section+0x7a>
_dwarf_find_section(const char *name)
{
    Dwarf_Section *ret=NULL;
    int i;

    for (i = 0; i < NDEBUG_SECT; i++) {
  8004213ff2:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004213ff6:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004213ffa:	7e a3                	jle    8004213f9f <_dwarf_find_section+0x1d>
            ret = (section_info + i);
            break;
        }
    }

    return ret;
  8004213ffc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004214000:	c9                   	leaveq 
  8004214001:	c3                   	retq   

0000008004214002 <find_debug_sections>:

void find_debug_sections(uintptr_t elf) 
{
  8004214002:	55                   	push   %rbp
  8004214003:	48 89 e5             	mov    %rsp,%rbp
  8004214006:	48 83 ec 40          	sub    $0x40,%rsp
  800421400a:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
    Elf *ehdr = (Elf *)elf;
  800421400e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214012:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    uintptr_t debug_address = USTABDATA;
  8004214016:	48 c7 45 f8 00 00 20 	movq   $0x200000,-0x8(%rbp)
  800421401d:	00 
    Secthdr *sh = (Secthdr *)(((uint8_t *)ehdr + ehdr->e_shoff));
  800421401e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214022:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004214026:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421402a:	48 01 d0             	add    %rdx,%rax
  800421402d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    Secthdr *shstr_tab = sh + ehdr->e_shstrndx;
  8004214031:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214035:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  8004214039:	0f b7 c0             	movzwl %ax,%eax
  800421403c:	48 c1 e0 06          	shl    $0x6,%rax
  8004214040:	48 89 c2             	mov    %rax,%rdx
  8004214043:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214047:	48 01 d0             	add    %rdx,%rax
  800421404a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    Secthdr* esh = sh + ehdr->e_shnum;
  800421404e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214052:	0f b7 40 3c          	movzwl 0x3c(%rax),%eax
  8004214056:	0f b7 c0             	movzwl %ax,%eax
  8004214059:	48 c1 e0 06          	shl    $0x6,%rax
  800421405d:	48 89 c2             	mov    %rax,%rdx
  8004214060:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214064:	48 01 d0             	add    %rdx,%rax
  8004214067:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    for ( ; sh < esh; sh++) {
  800421406b:	e9 4b 02 00 00       	jmpq   80042142bb <find_debug_sections+0x2b9>
        char* name = (char*)((uint8_t*)elf + shstr_tab->sh_offset) + sh->sh_name;
  8004214070:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214074:	8b 00                	mov    (%rax),%eax
  8004214076:	89 c2                	mov    %eax,%edx
  8004214078:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421407c:	48 8b 48 18          	mov    0x18(%rax),%rcx
  8004214080:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214084:	48 01 c8             	add    %rcx,%rax
  8004214087:	48 01 d0             	add    %rdx,%rax
  800421408a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		if (!strcmp(name, ".debug_info")) {
  800421408e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214092:	48 be 03 84 21 04 80 	movabs $0x8004218403,%rsi
  8004214099:	00 00 00 
  800421409c:	48 89 c7             	mov    %rax,%rdi
  800421409f:	48 b8 a4 e7 20 04 80 	movabs $0x800420e7a4,%rax
  80042140a6:	00 00 00 
  80042140a9:	ff d0                	callq  *%rax
  80042140ab:	85 c0                	test   %eax,%eax
  80042140ad:	75 4b                	jne    80042140fa <find_debug_sections+0xf8>
            section_info[DEBUG_INFO].ds_data = (uint8_t*)debug_address;
  80042140af:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042140b3:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  80042140ba:	00 00 00 
  80042140bd:	48 89 50 08          	mov    %rdx,0x8(%rax)
			section_info[DEBUG_INFO].ds_addr = debug_address;
  80042140c1:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  80042140c8:	00 00 00 
  80042140cb:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042140cf:	48 89 50 10          	mov    %rdx,0x10(%rax)
			section_info[DEBUG_INFO].ds_size = sh->sh_size;
  80042140d3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042140d7:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042140db:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  80042140e2:	00 00 00 
  80042140e5:	48 89 50 18          	mov    %rdx,0x18(%rax)
            debug_address += sh->sh_size;
  80042140e9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042140ed:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042140f1:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  80042140f5:	e9 bc 01 00 00       	jmpq   80042142b6 <find_debug_sections+0x2b4>
        } else if (!strcmp(name, ".debug_abbrev")) {
  80042140fa:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042140fe:	48 be 0f 84 21 04 80 	movabs $0x800421840f,%rsi
  8004214105:	00 00 00 
  8004214108:	48 89 c7             	mov    %rax,%rdi
  800421410b:	48 b8 a4 e7 20 04 80 	movabs $0x800420e7a4,%rax
  8004214112:	00 00 00 
  8004214115:	ff d0                	callq  *%rax
  8004214117:	85 c0                	test   %eax,%eax
  8004214119:	75 4b                	jne    8004214166 <find_debug_sections+0x164>
            section_info[DEBUG_ABBREV].ds_data = (uint8_t*)debug_address;
  800421411b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421411f:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  8004214126:	00 00 00 
  8004214129:	48 89 50 28          	mov    %rdx,0x28(%rax)
			section_info[DEBUG_ABBREV].ds_addr = debug_address;
  800421412d:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  8004214134:	00 00 00 
  8004214137:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421413b:	48 89 50 30          	mov    %rdx,0x30(%rax)
			section_info[DEBUG_ABBREV].ds_size = sh->sh_size;
  800421413f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214143:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004214147:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  800421414e:	00 00 00 
  8004214151:	48 89 50 38          	mov    %rdx,0x38(%rax)
            debug_address += sh->sh_size;
  8004214155:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214159:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421415d:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  8004214161:	e9 50 01 00 00       	jmpq   80042142b6 <find_debug_sections+0x2b4>
        } else if (!strcmp(name, ".debug_line")){
  8004214166:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421416a:	48 be 27 84 21 04 80 	movabs $0x8004218427,%rsi
  8004214171:	00 00 00 
  8004214174:	48 89 c7             	mov    %rax,%rdi
  8004214177:	48 b8 a4 e7 20 04 80 	movabs $0x800420e7a4,%rax
  800421417e:	00 00 00 
  8004214181:	ff d0                	callq  *%rax
  8004214183:	85 c0                	test   %eax,%eax
  8004214185:	75 4b                	jne    80042141d2 <find_debug_sections+0x1d0>
            section_info[DEBUG_LINE].ds_data = (uint8_t*)debug_address;
  8004214187:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421418b:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  8004214192:	00 00 00 
  8004214195:	48 89 50 68          	mov    %rdx,0x68(%rax)
			section_info[DEBUG_LINE].ds_addr = debug_address;
  8004214199:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  80042141a0:	00 00 00 
  80042141a3:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042141a7:	48 89 50 70          	mov    %rdx,0x70(%rax)
			section_info[DEBUG_LINE].ds_size = sh->sh_size;
  80042141ab:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042141af:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042141b3:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  80042141ba:	00 00 00 
  80042141bd:	48 89 50 78          	mov    %rdx,0x78(%rax)
            debug_address += sh->sh_size;
  80042141c1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042141c5:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042141c9:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  80042141cd:	e9 e4 00 00 00       	jmpq   80042142b6 <find_debug_sections+0x2b4>
        } else if (!strcmp(name, ".eh_frame")){
  80042141d2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042141d6:	48 be 1d 84 21 04 80 	movabs $0x800421841d,%rsi
  80042141dd:	00 00 00 
  80042141e0:	48 89 c7             	mov    %rax,%rdi
  80042141e3:	48 b8 a4 e7 20 04 80 	movabs $0x800420e7a4,%rax
  80042141ea:	00 00 00 
  80042141ed:	ff d0                	callq  *%rax
  80042141ef:	85 c0                	test   %eax,%eax
  80042141f1:	75 53                	jne    8004214246 <find_debug_sections+0x244>
            section_info[DEBUG_FRAME].ds_data = (uint8_t*)sh->sh_addr;
  80042141f3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042141f7:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042141fb:	48 89 c2             	mov    %rax,%rdx
  80042141fe:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  8004214205:	00 00 00 
  8004214208:	48 89 50 48          	mov    %rdx,0x48(%rax)
			section_info[DEBUG_FRAME].ds_addr = sh->sh_addr;
  800421420c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214210:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004214214:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  800421421b:	00 00 00 
  800421421e:	48 89 50 50          	mov    %rdx,0x50(%rax)
			section_info[DEBUG_FRAME].ds_size = sh->sh_size;
  8004214222:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214226:	48 8b 50 20          	mov    0x20(%rax),%rdx
  800421422a:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  8004214231:	00 00 00 
  8004214234:	48 89 50 58          	mov    %rdx,0x58(%rax)
            debug_address += sh->sh_size;
  8004214238:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421423c:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004214240:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  8004214244:	eb 70                	jmp    80042142b6 <find_debug_sections+0x2b4>
        } else if (!strcmp(name, ".debug_str")) {
  8004214246:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421424a:	48 be 33 84 21 04 80 	movabs $0x8004218433,%rsi
  8004214251:	00 00 00 
  8004214254:	48 89 c7             	mov    %rax,%rdi
  8004214257:	48 b8 a4 e7 20 04 80 	movabs $0x800420e7a4,%rax
  800421425e:	00 00 00 
  8004214261:	ff d0                	callq  *%rax
  8004214263:	85 c0                	test   %eax,%eax
  8004214265:	75 4f                	jne    80042142b6 <find_debug_sections+0x2b4>
            section_info[DEBUG_STR].ds_data = (uint8_t*)debug_address;
  8004214267:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421426b:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  8004214272:	00 00 00 
  8004214275:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
			section_info[DEBUG_STR].ds_addr = debug_address;
  800421427c:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  8004214283:	00 00 00 
  8004214286:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421428a:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
			section_info[DEBUG_STR].ds_size = sh->sh_size;
  8004214291:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214295:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004214299:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  80042142a0:	00 00 00 
  80042142a3:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
            debug_address += sh->sh_size;
  80042142aa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042142ae:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042142b2:	48 01 45 f8          	add    %rax,-0x8(%rbp)
    Elf *ehdr = (Elf *)elf;
    uintptr_t debug_address = USTABDATA;
    Secthdr *sh = (Secthdr *)(((uint8_t *)ehdr + ehdr->e_shoff));
    Secthdr *shstr_tab = sh + ehdr->e_shstrndx;
    Secthdr* esh = sh + ehdr->e_shnum;
    for ( ; sh < esh; sh++) {
  80042142b6:	48 83 45 f0 40       	addq   $0x40,-0x10(%rbp)
  80042142bb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042142bf:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  80042142c3:	0f 82 a7 fd ff ff    	jb     8004214070 <find_debug_sections+0x6e>
			section_info[DEBUG_STR].ds_size = sh->sh_size;
            debug_address += sh->sh_size;
        }
    }

}
  80042142c9:	c9                   	leaveq 
  80042142ca:	c3                   	retq   

00000080042142cb <read_section_headers>:

uint64_t
read_section_headers(uintptr_t elfhdr, uintptr_t to_va)
{
  80042142cb:	55                   	push   %rbp
  80042142cc:	48 89 e5             	mov    %rsp,%rbp
  80042142cf:	48 81 ec 60 01 00 00 	sub    $0x160,%rsp
  80042142d6:	48 89 bd a8 fe ff ff 	mov    %rdi,-0x158(%rbp)
  80042142dd:	48 89 b5 a0 fe ff ff 	mov    %rsi,-0x160(%rbp)
    Secthdr* secthdr_ptr[20] = {0};
  80042142e4:	48 8d b5 c0 fe ff ff 	lea    -0x140(%rbp),%rsi
  80042142eb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042142f0:	ba 14 00 00 00       	mov    $0x14,%edx
  80042142f5:	48 89 f7             	mov    %rsi,%rdi
  80042142f8:	48 89 d1             	mov    %rdx,%rcx
  80042142fb:	f3 48 ab             	rep stos %rax,%es:(%rdi)
    char* kvbase = ROUNDUP((char*)to_va, SECTSIZE);
  80042142fe:	48 c7 45 e8 00 02 00 	movq   $0x200,-0x18(%rbp)
  8004214305:	00 
  8004214306:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421430a:	48 8b 95 a0 fe ff ff 	mov    -0x160(%rbp),%rdx
  8004214311:	48 01 d0             	add    %rdx,%rax
  8004214314:	48 83 e8 01          	sub    $0x1,%rax
  8004214318:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800421431c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214320:	ba 00 00 00 00       	mov    $0x0,%edx
  8004214325:	48 f7 75 e8          	divq   -0x18(%rbp)
  8004214329:	48 89 d0             	mov    %rdx,%rax
  800421432c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004214330:	48 29 c2             	sub    %rax,%rdx
  8004214333:	48 89 d0             	mov    %rdx,%rax
  8004214336:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    uint64_t kvoffset = 0;
  800421433a:	48 c7 85 b8 fe ff ff 	movq   $0x0,-0x148(%rbp)
  8004214341:	00 00 00 00 
	char *orig_secthdr = (char*)kvbase;
  8004214345:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214349:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    char * secthdr = NULL;
  800421434d:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  8004214354:	00 
    uint64_t offset;
    if (elfhdr == KELFHDR)
  8004214355:	48 b8 00 00 01 04 80 	movabs $0x8004010000,%rax
  800421435c:	00 00 00 
  800421435f:	48 39 85 a8 fe ff ff 	cmp    %rax,-0x158(%rbp)
  8004214366:	75 11                	jne    8004214379 <read_section_headers+0xae>
        offset = ((Elf*)elfhdr)->e_shoff;
  8004214368:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  800421436f:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004214373:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004214377:	eb 26                	jmp    800421439f <read_section_headers+0xd4>
    else
        offset = ((Elf*)elfhdr)->e_shoff + (elfhdr - KERNBASE);
  8004214379:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004214380:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004214384:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  800421438b:	48 01 c2             	add    %rax,%rdx
  800421438e:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  8004214395:	ff ff ff 
  8004214398:	48 01 d0             	add    %rdx,%rax
  800421439b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

    int numSectionHeaders = ((Elf*)elfhdr)->e_shnum;
  800421439f:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  80042143a6:	0f b7 40 3c          	movzwl 0x3c(%rax),%eax
  80042143aa:	0f b7 c0             	movzwl %ax,%eax
  80042143ad:	89 45 c4             	mov    %eax,-0x3c(%rbp)
	int sizeSections = ((Elf*)elfhdr)->e_shentsize;
  80042143b0:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  80042143b7:	0f b7 40 3a          	movzwl 0x3a(%rax),%eax
  80042143bb:	0f b7 c0             	movzwl %ax,%eax
  80042143be:	89 45 c0             	mov    %eax,-0x40(%rbp)
	char *nametab;
	int i;
	uint64_t temp;
	char *name;

	Elf *ehdr = (Elf *)elfhdr;
  80042143c1:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  80042143c8:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	Secthdr *sec_name;  

	readseg((uint64_t)orig_secthdr , numSectionHeaders * sizeSections,
  80042143cc:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  80042143cf:	0f af 45 c0          	imul   -0x40(%rbp),%eax
  80042143d3:	48 63 f0             	movslq %eax,%rsi
  80042143d6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042143da:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  80042143e1:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042143e5:	48 89 c7             	mov    %rax,%rdi
  80042143e8:	48 b8 0a 4a 21 04 80 	movabs $0x8004214a0a,%rax
  80042143ef:	00 00 00 
  80042143f2:	ff d0                	callq  *%rax
             offset, &kvoffset);
	secthdr = (char*)orig_secthdr + (offset - ROUNDDOWN(offset, SECTSIZE));
  80042143f4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042143f8:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  80042143fc:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004214400:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004214406:	48 89 c2             	mov    %rax,%rdx
  8004214409:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421440d:	48 29 d0             	sub    %rdx,%rax
  8004214410:	48 89 c2             	mov    %rax,%rdx
  8004214413:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214417:	48 01 d0             	add    %rdx,%rax
  800421441a:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	for (i = 0; i < numSectionHeaders; i++)
  800421441e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004214425:	eb 24                	jmp    800421444b <read_section_headers+0x180>
	{
		 secthdr_ptr[i] = (Secthdr*)(secthdr) + i;
  8004214427:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421442a:	48 98                	cltq   
  800421442c:	48 c1 e0 06          	shl    $0x6,%rax
  8004214430:	48 89 c2             	mov    %rax,%rdx
  8004214433:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214437:	48 01 c2             	add    %rax,%rdx
  800421443a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421443d:	48 98                	cltq   
  800421443f:	48 89 94 c5 c0 fe ff 	mov    %rdx,-0x140(%rbp,%rax,8)
  8004214446:	ff 
	Secthdr *sec_name;  

	readseg((uint64_t)orig_secthdr , numSectionHeaders * sizeSections,
             offset, &kvoffset);
	secthdr = (char*)orig_secthdr + (offset - ROUNDDOWN(offset, SECTSIZE));
	for (i = 0; i < numSectionHeaders; i++)
  8004214447:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  800421444b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421444e:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  8004214451:	7c d4                	jl     8004214427 <read_section_headers+0x15c>
	{
		 secthdr_ptr[i] = (Secthdr*)(secthdr) + i;
	}
	
	sec_name = secthdr_ptr[ehdr->e_shstrndx]; 
  8004214453:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214457:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  800421445b:	0f b7 c0             	movzwl %ax,%eax
  800421445e:	48 98                	cltq   
  8004214460:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214467:	ff 
  8004214468:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	temp = kvoffset;
  800421446c:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004214473:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
	readseg((uint64_t)((char *)kvbase + kvoffset), sec_name->sh_size,
  8004214477:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421447b:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421447f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004214483:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004214487:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  800421448e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214492:	48 01 c8             	add    %rcx,%rax
  8004214495:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  800421449c:	48 89 c7             	mov    %rax,%rdi
  800421449f:	48 b8 0a 4a 21 04 80 	movabs $0x8004214a0a,%rax
  80042144a6:	00 00 00 
  80042144a9:	ff d0                	callq  *%rax
            sec_name->sh_offset, &kvoffset);
	nametab = (char *)((char *)kvbase + temp) + OFFSET_CORRECT(sec_name->sh_offset);	
  80042144ab:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042144af:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042144b3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042144b7:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042144bb:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  80042144bf:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042144c3:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  80042144c9:	48 29 c2             	sub    %rax,%rdx
  80042144cc:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042144d0:	48 01 c2             	add    %rax,%rdx
  80042144d3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042144d7:	48 01 d0             	add    %rdx,%rax
  80042144da:	48 89 45 90          	mov    %rax,-0x70(%rbp)

    
	for (i = 0; i < numSectionHeaders; i++)
  80042144de:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  80042144e5:	e9 04 05 00 00       	jmpq   80042149ee <read_section_headers+0x723>
    {
		name = (char *)(nametab + secthdr_ptr[i]->sh_name);
  80042144ea:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042144ed:	48 98                	cltq   
  80042144ef:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042144f6:	ff 
  80042144f7:	8b 00                	mov    (%rax),%eax
  80042144f9:	89 c2                	mov    %eax,%edx
  80042144fb:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042144ff:	48 01 d0             	add    %rdx,%rax
  8004214502:	48 89 45 88          	mov    %rax,-0x78(%rbp)
        assert(kvoffset % SECTSIZE == 0);
  8004214506:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  800421450d:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004214512:	48 85 c0             	test   %rax,%rax
  8004214515:	74 35                	je     800421454c <read_section_headers+0x281>
  8004214517:	48 b9 3e 84 21 04 80 	movabs $0x800421843e,%rcx
  800421451e:	00 00 00 
  8004214521:	48 ba 57 84 21 04 80 	movabs $0x8004218457,%rdx
  8004214528:	00 00 00 
  800421452b:	be 87 00 00 00       	mov    $0x87,%esi
  8004214530:	48 bf 6c 84 21 04 80 	movabs $0x800421846c,%rdi
  8004214537:	00 00 00 
  800421453a:	b8 00 00 00 00       	mov    $0x0,%eax
  800421453f:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004214546:	00 00 00 
  8004214549:	41 ff d0             	callq  *%r8
        temp = kvoffset;
  800421454c:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004214553:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
#ifdef DWARF_DEBUG
        cprintf("SectName: %s\n", name);
#endif
		if (!strcmp(name, ".debug_info"))
  8004214557:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800421455b:	48 be 03 84 21 04 80 	movabs $0x8004218403,%rsi
  8004214562:	00 00 00 
  8004214565:	48 89 c7             	mov    %rax,%rdi
  8004214568:	48 b8 a4 e7 20 04 80 	movabs $0x800420e7a4,%rax
  800421456f:	00 00 00 
  8004214572:	ff d0                	callq  *%rax
  8004214574:	85 c0                	test   %eax,%eax
  8004214576:	0f 85 d8 00 00 00    	jne    8004214654 <read_section_headers+0x389>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
                    secthdr_ptr[i]->sh_offset, &kvoffset);	
  800421457c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421457f:	48 98                	cltq   
  8004214581:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214588:	ff 
#ifdef DWARF_DEBUG
        cprintf("SectName: %s\n", name);
#endif
		if (!strcmp(name, ".debug_info"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004214589:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421458d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214590:	48 98                	cltq   
  8004214592:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214599:	ff 
  800421459a:	48 8b 70 20          	mov    0x20(%rax),%rsi
  800421459e:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  80042145a5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042145a9:	48 01 c8             	add    %rcx,%rax
  80042145ac:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  80042145b3:	48 89 c7             	mov    %rax,%rdi
  80042145b6:	48 b8 0a 4a 21 04 80 	movabs $0x8004214a0a,%rax
  80042145bd:	00 00 00 
  80042145c0:	ff d0                	callq  *%rax
                    secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_INFO].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  80042145c2:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042145c5:	48 98                	cltq   
  80042145c7:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042145ce:	ff 
  80042145cf:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042145d3:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042145d6:	48 98                	cltq   
  80042145d8:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042145df:	ff 
  80042145e0:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042145e4:	48 89 45 80          	mov    %rax,-0x80(%rbp)
  80042145e8:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042145ec:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  80042145f2:	48 29 c2             	sub    %rax,%rdx
  80042145f5:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042145f9:	48 01 c2             	add    %rax,%rdx
  80042145fc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214600:	48 01 c2             	add    %rax,%rdx
  8004214603:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  800421460a:	00 00 00 
  800421460d:	48 89 50 08          	mov    %rdx,0x8(%rax)
			section_info[DEBUG_INFO].ds_addr = (uintptr_t)section_info[DEBUG_INFO].ds_data;
  8004214611:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  8004214618:	00 00 00 
  800421461b:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421461f:	48 89 c2             	mov    %rax,%rdx
  8004214622:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  8004214629:	00 00 00 
  800421462c:	48 89 50 10          	mov    %rdx,0x10(%rax)
			section_info[DEBUG_INFO].ds_size = secthdr_ptr[i]->sh_size;
  8004214630:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214633:	48 98                	cltq   
  8004214635:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421463c:	ff 
  800421463d:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004214641:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  8004214648:	00 00 00 
  800421464b:	48 89 50 18          	mov    %rdx,0x18(%rax)
  800421464f:	e9 96 03 00 00       	jmpq   80042149ea <read_section_headers+0x71f>
		}
		else if (!strcmp(name, ".debug_abbrev"))
  8004214654:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004214658:	48 be 0f 84 21 04 80 	movabs $0x800421840f,%rsi
  800421465f:	00 00 00 
  8004214662:	48 89 c7             	mov    %rax,%rdi
  8004214665:	48 b8 a4 e7 20 04 80 	movabs $0x800420e7a4,%rax
  800421466c:	00 00 00 
  800421466f:	ff d0                	callq  *%rax
  8004214671:	85 c0                	test   %eax,%eax
  8004214673:	0f 85 de 00 00 00    	jne    8004214757 <read_section_headers+0x48c>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
                    secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004214679:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421467c:	48 98                	cltq   
  800421467e:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214685:	ff 
			section_info[DEBUG_INFO].ds_addr = (uintptr_t)section_info[DEBUG_INFO].ds_data;
			section_info[DEBUG_INFO].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if (!strcmp(name, ".debug_abbrev"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004214686:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421468a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421468d:	48 98                	cltq   
  800421468f:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214696:	ff 
  8004214697:	48 8b 70 20          	mov    0x20(%rax),%rsi
  800421469b:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  80042146a2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042146a6:	48 01 c8             	add    %rcx,%rax
  80042146a9:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  80042146b0:	48 89 c7             	mov    %rax,%rdi
  80042146b3:	48 b8 0a 4a 21 04 80 	movabs $0x8004214a0a,%rax
  80042146ba:	00 00 00 
  80042146bd:	ff d0                	callq  *%rax
                    secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_ABBREV].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  80042146bf:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042146c2:	48 98                	cltq   
  80042146c4:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042146cb:	ff 
  80042146cc:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042146d0:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042146d3:	48 98                	cltq   
  80042146d5:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042146dc:	ff 
  80042146dd:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042146e1:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  80042146e8:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042146ef:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  80042146f5:	48 29 c2             	sub    %rax,%rdx
  80042146f8:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042146fc:	48 01 c2             	add    %rax,%rdx
  80042146ff:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214703:	48 01 c2             	add    %rax,%rdx
  8004214706:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  800421470d:	00 00 00 
  8004214710:	48 89 50 28          	mov    %rdx,0x28(%rax)
			section_info[DEBUG_ABBREV].ds_addr = (uintptr_t)section_info[DEBUG_ABBREV].ds_data;
  8004214714:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  800421471b:	00 00 00 
  800421471e:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004214722:	48 89 c2             	mov    %rax,%rdx
  8004214725:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  800421472c:	00 00 00 
  800421472f:	48 89 50 30          	mov    %rdx,0x30(%rax)
			section_info[DEBUG_ABBREV].ds_size = secthdr_ptr[i]->sh_size;
  8004214733:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214736:	48 98                	cltq   
  8004214738:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421473f:	ff 
  8004214740:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004214744:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  800421474b:	00 00 00 
  800421474e:	48 89 50 38          	mov    %rdx,0x38(%rax)
  8004214752:	e9 93 02 00 00       	jmpq   80042149ea <read_section_headers+0x71f>
		}
		else if (!strcmp(name, ".debug_line"))
  8004214757:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800421475b:	48 be 27 84 21 04 80 	movabs $0x8004218427,%rsi
  8004214762:	00 00 00 
  8004214765:	48 89 c7             	mov    %rax,%rdi
  8004214768:	48 b8 a4 e7 20 04 80 	movabs $0x800420e7a4,%rax
  800421476f:	00 00 00 
  8004214772:	ff d0                	callq  *%rax
  8004214774:	85 c0                	test   %eax,%eax
  8004214776:	0f 85 de 00 00 00    	jne    800421485a <read_section_headers+0x58f>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
                    secthdr_ptr[i]->sh_offset, &kvoffset);	
  800421477c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421477f:	48 98                	cltq   
  8004214781:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214788:	ff 
			section_info[DEBUG_ABBREV].ds_addr = (uintptr_t)section_info[DEBUG_ABBREV].ds_data;
			section_info[DEBUG_ABBREV].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if (!strcmp(name, ".debug_line"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004214789:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421478d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214790:	48 98                	cltq   
  8004214792:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214799:	ff 
  800421479a:	48 8b 70 20          	mov    0x20(%rax),%rsi
  800421479e:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  80042147a5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042147a9:	48 01 c8             	add    %rcx,%rax
  80042147ac:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  80042147b3:	48 89 c7             	mov    %rax,%rdi
  80042147b6:	48 b8 0a 4a 21 04 80 	movabs $0x8004214a0a,%rax
  80042147bd:	00 00 00 
  80042147c0:	ff d0                	callq  *%rax
                    secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_LINE].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  80042147c2:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042147c5:	48 98                	cltq   
  80042147c7:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042147ce:	ff 
  80042147cf:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042147d3:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042147d6:	48 98                	cltq   
  80042147d8:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042147df:	ff 
  80042147e0:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042147e4:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
  80042147eb:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80042147f2:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  80042147f8:	48 29 c2             	sub    %rax,%rdx
  80042147fb:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042147ff:	48 01 c2             	add    %rax,%rdx
  8004214802:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214806:	48 01 c2             	add    %rax,%rdx
  8004214809:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  8004214810:	00 00 00 
  8004214813:	48 89 50 68          	mov    %rdx,0x68(%rax)
			section_info[DEBUG_LINE].ds_addr = (uintptr_t)section_info[DEBUG_LINE].ds_data;
  8004214817:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  800421481e:	00 00 00 
  8004214821:	48 8b 40 68          	mov    0x68(%rax),%rax
  8004214825:	48 89 c2             	mov    %rax,%rdx
  8004214828:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  800421482f:	00 00 00 
  8004214832:	48 89 50 70          	mov    %rdx,0x70(%rax)
			section_info[DEBUG_LINE].ds_size = secthdr_ptr[i]->sh_size;
  8004214836:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214839:	48 98                	cltq   
  800421483b:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214842:	ff 
  8004214843:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004214847:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  800421484e:	00 00 00 
  8004214851:	48 89 50 78          	mov    %rdx,0x78(%rax)
  8004214855:	e9 90 01 00 00       	jmpq   80042149ea <read_section_headers+0x71f>
		}
		else if (!strcmp(name, ".eh_frame"))
  800421485a:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800421485e:	48 be 1d 84 21 04 80 	movabs $0x800421841d,%rsi
  8004214865:	00 00 00 
  8004214868:	48 89 c7             	mov    %rax,%rdi
  800421486b:	48 b8 a4 e7 20 04 80 	movabs $0x800420e7a4,%rax
  8004214872:	00 00 00 
  8004214875:	ff d0                	callq  *%rax
  8004214877:	85 c0                	test   %eax,%eax
  8004214879:	75 65                	jne    80042148e0 <read_section_headers+0x615>
		{
			section_info[DEBUG_FRAME].ds_data = (uint8_t *)secthdr_ptr[i]->sh_addr;
  800421487b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421487e:	48 98                	cltq   
  8004214880:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214887:	ff 
  8004214888:	48 8b 40 10          	mov    0x10(%rax),%rax
  800421488c:	48 89 c2             	mov    %rax,%rdx
  800421488f:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  8004214896:	00 00 00 
  8004214899:	48 89 50 48          	mov    %rdx,0x48(%rax)
			section_info[DEBUG_FRAME].ds_addr = (uintptr_t)section_info[DEBUG_FRAME].ds_data;
  800421489d:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  80042148a4:	00 00 00 
  80042148a7:	48 8b 40 48          	mov    0x48(%rax),%rax
  80042148ab:	48 89 c2             	mov    %rax,%rdx
  80042148ae:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  80042148b5:	00 00 00 
  80042148b8:	48 89 50 50          	mov    %rdx,0x50(%rax)
			section_info[DEBUG_FRAME].ds_size = secthdr_ptr[i]->sh_size;
  80042148bc:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042148bf:	48 98                	cltq   
  80042148c1:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042148c8:	ff 
  80042148c9:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042148cd:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  80042148d4:	00 00 00 
  80042148d7:	48 89 50 58          	mov    %rdx,0x58(%rax)
  80042148db:	e9 0a 01 00 00       	jmpq   80042149ea <read_section_headers+0x71f>
		}
		else if (!strcmp(name, ".debug_str"))
  80042148e0:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042148e4:	48 be 33 84 21 04 80 	movabs $0x8004218433,%rsi
  80042148eb:	00 00 00 
  80042148ee:	48 89 c7             	mov    %rax,%rdi
  80042148f1:	48 b8 a4 e7 20 04 80 	movabs $0x800420e7a4,%rax
  80042148f8:	00 00 00 
  80042148fb:	ff d0                	callq  *%rax
  80042148fd:	85 c0                	test   %eax,%eax
  80042148ff:	0f 85 e5 00 00 00    	jne    80042149ea <read_section_headers+0x71f>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
                    secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004214905:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214908:	48 98                	cltq   
  800421490a:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214911:	ff 
			section_info[DEBUG_FRAME].ds_addr = (uintptr_t)section_info[DEBUG_FRAME].ds_data;
			section_info[DEBUG_FRAME].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if (!strcmp(name, ".debug_str"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004214912:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214916:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214919:	48 98                	cltq   
  800421491b:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214922:	ff 
  8004214923:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004214927:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  800421492e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214932:	48 01 c8             	add    %rcx,%rax
  8004214935:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  800421493c:	48 89 c7             	mov    %rax,%rdi
  800421493f:	48 b8 0a 4a 21 04 80 	movabs $0x8004214a0a,%rax
  8004214946:	00 00 00 
  8004214949:	ff d0                	callq  *%rax
                    secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_STR].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  800421494b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421494e:	48 98                	cltq   
  8004214950:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214957:	ff 
  8004214958:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421495c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421495f:	48 98                	cltq   
  8004214961:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214968:	ff 
  8004214969:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421496d:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
  8004214974:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421497b:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004214981:	48 29 c2             	sub    %rax,%rdx
  8004214984:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004214988:	48 01 c2             	add    %rax,%rdx
  800421498b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421498f:	48 01 c2             	add    %rax,%rdx
  8004214992:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  8004214999:	00 00 00 
  800421499c:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
			section_info[DEBUG_STR].ds_addr = (uintptr_t)section_info[DEBUG_STR].ds_data;
  80042149a3:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  80042149aa:	00 00 00 
  80042149ad:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  80042149b4:	48 89 c2             	mov    %rax,%rdx
  80042149b7:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  80042149be:	00 00 00 
  80042149c1:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
			section_info[DEBUG_STR].ds_size = secthdr_ptr[i]->sh_size;
  80042149c8:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042149cb:	48 98                	cltq   
  80042149cd:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042149d4:	ff 
  80042149d5:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042149d9:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  80042149e0:	00 00 00 
  80042149e3:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
	readseg((uint64_t)((char *)kvbase + kvoffset), sec_name->sh_size,
            sec_name->sh_offset, &kvoffset);
	nametab = (char *)((char *)kvbase + temp) + OFFSET_CORRECT(sec_name->sh_offset);	

    
	for (i = 0; i < numSectionHeaders; i++)
  80042149ea:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  80042149ee:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042149f1:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  80042149f4:	0f 8c f0 fa ff ff    	jl     80042144ea <read_section_headers+0x21f>
			section_info[DEBUG_STR].ds_addr = (uintptr_t)section_info[DEBUG_STR].ds_data;
			section_info[DEBUG_STR].ds_size = secthdr_ptr[i]->sh_size;
		}
    }
	
    return ((uintptr_t)kvbase + kvoffset);
  80042149fa:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042149fe:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004214a05:	48 01 d0             	add    %rdx,%rax
}
  8004214a08:	c9                   	leaveq 
  8004214a09:	c3                   	retq   

0000008004214a0a <readseg>:

// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.
// Might copy more than asked
void
readseg(uint64_t pa, uint64_t count, uint64_t offset, uint64_t* kvoffset)
{
  8004214a0a:	55                   	push   %rbp
  8004214a0b:	48 89 e5             	mov    %rsp,%rbp
  8004214a0e:	48 83 ec 30          	sub    $0x30,%rsp
  8004214a12:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004214a16:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004214a1a:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004214a1e:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
	uint64_t end_pa;
	uint64_t orgoff = offset;
  8004214a22:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214a26:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	end_pa = pa + count;
  8004214a2a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214a2e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214a32:	48 01 d0             	add    %rdx,%rax
  8004214a35:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	assert(pa % SECTSIZE == 0);	
  8004214a39:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214a3d:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004214a42:	48 85 c0             	test   %rax,%rax
  8004214a45:	74 35                	je     8004214a7c <readseg+0x72>
  8004214a47:	48 b9 7a 84 21 04 80 	movabs $0x800421847a,%rcx
  8004214a4e:	00 00 00 
  8004214a51:	48 ba 57 84 21 04 80 	movabs $0x8004218457,%rdx
  8004214a58:	00 00 00 
  8004214a5b:	be c1 00 00 00       	mov    $0xc1,%esi
  8004214a60:	48 bf 6c 84 21 04 80 	movabs $0x800421846c,%rdi
  8004214a67:	00 00 00 
  8004214a6a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214a6f:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004214a76:	00 00 00 
  8004214a79:	41 ff d0             	callq  *%r8
	// round down to sector boundary
	pa &= ~(SECTSIZE - 1);
  8004214a7c:	48 81 65 e8 00 fe ff 	andq   $0xfffffffffffffe00,-0x18(%rbp)
  8004214a83:	ff 

	// translate from bytes to sectors, and kernel starts at sector 1
	offset = (offset / SECTSIZE) + 1;
  8004214a84:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214a88:	48 c1 e8 09          	shr    $0x9,%rax
  8004214a8c:	48 83 c0 01          	add    $0x1,%rax
  8004214a90:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

	// If this is too slow, we could read lots of sectors at a time.
	// We'd write more to memory than asked, but it doesn't matter --
	// we load in increasing order.
	while (pa < end_pa) {
  8004214a94:	eb 3c                	jmp    8004214ad2 <readseg+0xc8>
		readsect((uint8_t*) pa, offset);
  8004214a96:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214a9a:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004214a9e:	48 89 d6             	mov    %rdx,%rsi
  8004214aa1:	48 89 c7             	mov    %rax,%rdi
  8004214aa4:	48 b8 9a 4b 21 04 80 	movabs $0x8004214b9a,%rax
  8004214aab:	00 00 00 
  8004214aae:	ff d0                	callq  *%rax
		pa += SECTSIZE;
  8004214ab0:	48 81 45 e8 00 02 00 	addq   $0x200,-0x18(%rbp)
  8004214ab7:	00 
		*kvoffset += SECTSIZE;
  8004214ab8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214abc:	48 8b 00             	mov    (%rax),%rax
  8004214abf:	48 8d 90 00 02 00 00 	lea    0x200(%rax),%rdx
  8004214ac6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214aca:	48 89 10             	mov    %rdx,(%rax)
		offset++;
  8004214acd:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
	offset = (offset / SECTSIZE) + 1;

	// If this is too slow, we could read lots of sectors at a time.
	// We'd write more to memory than asked, but it doesn't matter --
	// we load in increasing order.
	while (pa < end_pa) {
  8004214ad2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214ad6:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8004214ada:	72 ba                	jb     8004214a96 <readseg+0x8c>
		pa += SECTSIZE;
		*kvoffset += SECTSIZE;
		offset++;
	}

	if (((orgoff % SECTSIZE) + count) > SECTSIZE)
  8004214adc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214ae0:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004214ae5:	48 89 c2             	mov    %rax,%rdx
  8004214ae8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214aec:	48 01 d0             	add    %rdx,%rax
  8004214aef:	48 3d 00 02 00 00    	cmp    $0x200,%rax
  8004214af5:	76 2f                	jbe    8004214b26 <readseg+0x11c>
	{
		readsect((uint8_t*) pa, offset);
  8004214af7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214afb:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004214aff:	48 89 d6             	mov    %rdx,%rsi
  8004214b02:	48 89 c7             	mov    %rax,%rdi
  8004214b05:	48 b8 9a 4b 21 04 80 	movabs $0x8004214b9a,%rax
  8004214b0c:	00 00 00 
  8004214b0f:	ff d0                	callq  *%rax
		*kvoffset += SECTSIZE;
  8004214b11:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214b15:	48 8b 00             	mov    (%rax),%rax
  8004214b18:	48 8d 90 00 02 00 00 	lea    0x200(%rax),%rdx
  8004214b1f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214b23:	48 89 10             	mov    %rdx,(%rax)
	}
	assert(*kvoffset % SECTSIZE == 0);
  8004214b26:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214b2a:	48 8b 00             	mov    (%rax),%rax
  8004214b2d:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004214b32:	48 85 c0             	test   %rax,%rax
  8004214b35:	74 35                	je     8004214b6c <readseg+0x162>
  8004214b37:	48 b9 8d 84 21 04 80 	movabs $0x800421848d,%rcx
  8004214b3e:	00 00 00 
  8004214b41:	48 ba 57 84 21 04 80 	movabs $0x8004218457,%rdx
  8004214b48:	00 00 00 
  8004214b4b:	be d7 00 00 00       	mov    $0xd7,%esi
  8004214b50:	48 bf 6c 84 21 04 80 	movabs $0x800421846c,%rdi
  8004214b57:	00 00 00 
  8004214b5a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214b5f:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004214b66:	00 00 00 
  8004214b69:	41 ff d0             	callq  *%r8
}
  8004214b6c:	c9                   	leaveq 
  8004214b6d:	c3                   	retq   

0000008004214b6e <waitdisk>:

void
waitdisk(void)
{
  8004214b6e:	55                   	push   %rbp
  8004214b6f:	48 89 e5             	mov    %rsp,%rbp
  8004214b72:	48 83 ec 10          	sub    $0x10,%rsp
	// wait for disk reaady
	while ((inb(0x1F7) & 0xC0) != 0x40)
  8004214b76:	90                   	nop
  8004214b77:	c7 45 fc f7 01 00 00 	movl   $0x1f7,-0x4(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004214b7e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004214b81:	89 c2                	mov    %eax,%edx
  8004214b83:	ec                   	in     (%dx),%al
  8004214b84:	88 45 fb             	mov    %al,-0x5(%rbp)
	return data;
  8004214b87:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004214b8b:	0f b6 c0             	movzbl %al,%eax
  8004214b8e:	25 c0 00 00 00       	and    $0xc0,%eax
  8004214b93:	83 f8 40             	cmp    $0x40,%eax
  8004214b96:	75 df                	jne    8004214b77 <waitdisk+0x9>
		/* do nothing */;
}
  8004214b98:	c9                   	leaveq 
  8004214b99:	c3                   	retq   

0000008004214b9a <readsect>:

void
readsect(void *dst, uint64_t offset)
{
  8004214b9a:	55                   	push   %rbp
  8004214b9b:	48 89 e5             	mov    %rsp,%rbp
  8004214b9e:	48 83 ec 60          	sub    $0x60,%rsp
  8004214ba2:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8004214ba6:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
	// wait for disk to be ready
	waitdisk();
  8004214baa:	48 b8 6e 4b 21 04 80 	movabs $0x8004214b6e,%rax
  8004214bb1:	00 00 00 
  8004214bb4:	ff d0                	callq  *%rax
  8004214bb6:	c7 45 fc f2 01 00 00 	movl   $0x1f2,-0x4(%rbp)
  8004214bbd:	c6 45 fb 01          	movb   $0x1,-0x5(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004214bc1:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004214bc5:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004214bc8:	ee                   	out    %al,(%dx)

	outb(0x1F2, 1);		// count = 1
	outb(0x1F3, offset);
  8004214bc9:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004214bcd:	0f b6 c0             	movzbl %al,%eax
  8004214bd0:	c7 45 f4 f3 01 00 00 	movl   $0x1f3,-0xc(%rbp)
  8004214bd7:	88 45 f3             	mov    %al,-0xd(%rbp)
  8004214bda:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004214bde:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004214be1:	ee                   	out    %al,(%dx)
	outb(0x1F4, offset >> 8);
  8004214be2:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004214be6:	48 c1 e8 08          	shr    $0x8,%rax
  8004214bea:	0f b6 c0             	movzbl %al,%eax
  8004214bed:	c7 45 ec f4 01 00 00 	movl   $0x1f4,-0x14(%rbp)
  8004214bf4:	88 45 eb             	mov    %al,-0x15(%rbp)
  8004214bf7:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004214bfb:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004214bfe:	ee                   	out    %al,(%dx)
	outb(0x1F5, offset >> 16);
  8004214bff:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004214c03:	48 c1 e8 10          	shr    $0x10,%rax
  8004214c07:	0f b6 c0             	movzbl %al,%eax
  8004214c0a:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%rbp)
  8004214c11:	88 45 e3             	mov    %al,-0x1d(%rbp)
  8004214c14:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004214c18:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004214c1b:	ee                   	out    %al,(%dx)
	outb(0x1F6, (offset >> 24) | 0xE0);
  8004214c1c:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004214c20:	48 c1 e8 18          	shr    $0x18,%rax
  8004214c24:	83 c8 e0             	or     $0xffffffe0,%eax
  8004214c27:	0f b6 c0             	movzbl %al,%eax
  8004214c2a:	c7 45 dc f6 01 00 00 	movl   $0x1f6,-0x24(%rbp)
  8004214c31:	88 45 db             	mov    %al,-0x25(%rbp)
  8004214c34:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004214c38:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004214c3b:	ee                   	out    %al,(%dx)
  8004214c3c:	c7 45 d4 f7 01 00 00 	movl   $0x1f7,-0x2c(%rbp)
  8004214c43:	c6 45 d3 20          	movb   $0x20,-0x2d(%rbp)
  8004214c47:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004214c4b:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004214c4e:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x20);	// cmd 0x20 - read sectors

	// wait for disk to be ready
	waitdisk();
  8004214c4f:	48 b8 6e 4b 21 04 80 	movabs $0x8004214b6e,%rax
  8004214c56:	00 00 00 
  8004214c59:	ff d0                	callq  *%rax
  8004214c5b:	c7 45 cc f0 01 00 00 	movl   $0x1f0,-0x34(%rbp)
  8004214c62:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004214c66:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004214c6a:	c7 45 bc 80 00 00 00 	movl   $0x80,-0x44(%rbp)
}

static __inline void
insl(int port, void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\tinsl"			:
  8004214c71:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004214c74:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8004214c78:	8b 45 bc             	mov    -0x44(%rbp),%eax
  8004214c7b:	48 89 ce             	mov    %rcx,%rsi
  8004214c7e:	48 89 f7             	mov    %rsi,%rdi
  8004214c81:	89 c1                	mov    %eax,%ecx
  8004214c83:	fc                   	cld    
  8004214c84:	f2 6d                	repnz insl (%dx),%es:(%rdi)
  8004214c86:	89 c8                	mov    %ecx,%eax
  8004214c88:	48 89 fe             	mov    %rdi,%rsi
  8004214c8b:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004214c8f:	89 45 bc             	mov    %eax,-0x44(%rbp)

	// read a sector
	insl(0x1F0, dst, SECTSIZE/4);
}
  8004214c92:	c9                   	leaveq 
  8004214c93:	c3                   	retq   
  8004214c94:	0f 1f 40 00          	nopl   0x0(%rax)

0000008004214c98 <mpentry_start>:
.set pml4, pml4phys

.code16           
.globl mpentry_start
mpentry_start:
	cli
  8004214c98:	fa                   	cli    
	xorw    %ax, %ax
  8004214c99:	31 c0                	xor    %eax,%eax
	movw    %ax, %ds
  8004214c9b:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  8004214c9d:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  8004214c9f:	8e d0                	mov    %eax,%ss
	
	
	lgdt    MPBOOTPHYS(gdt32desc)   // load 32 bit global descritor table
  8004214ca1:	0f 01 16             	lgdt   (%rsi)
  8004214ca4:	e0 70                	loopne 8004214d16 <start64+0x10>
	movl    %cr0, %eax
  8004214ca6:	0f 20 c0             	mov    %cr0,%rax
	orl     $CR0_PE, %eax
  8004214ca9:	66 83 c8 01          	or     $0x1,%ax
	movl    %eax, %cr0
  8004214cad:	0f 22 c0             	mov    %rax,%cr0
	ljmp	$(PROT_MODE_CSEG),$(MPBOOTPHYS(start32))
  8004214cb0:	ea                   	(bad)  
  8004214cb1:	1d 70 08 00 66       	sbb    $0x66000870,%eax

0000008004214cb5 <start32>:

.code32
start32:
	
	movw    $(PROT_MODE_DSEG), %ax
  8004214cb5:	66 b8 10 00          	mov    $0x10,%ax
	movw    %ax, %ds
  8004214cb9:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  8004214cbb:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  8004214cbd:	8e d0                	mov    %eax,%ss
	movw    $0, %ax
  8004214cbf:	66 b8 00 00          	mov    $0x0,%ax
	movw    %ax, %fs
  8004214cc3:	8e e0                	mov    %eax,%fs
	movw    %ax, %gs
  8004214cc5:	8e e8                	mov    %eax,%gs

	movl $CR4_PAE,%eax
  8004214cc7:	b8 20 00 00 00       	mov    $0x20,%eax
	movl %eax,%cr4
  8004214ccc:	0f 22 e0             	mov    %rax,%cr4
	
	lgdt    MPBOOTPHYS(gdtdesc)
  8004214ccf:	0f 01 15 c0 70 00 00 	lgdt   0x70c0(%rip)        # 800421bd96 <bootstack+0xd96>
	movl    %cr0, %eax
  8004214cd6:	0f 20 c0             	mov    %cr0,%rax
	orl     $CR0_PE, %eax
  8004214cd9:	83 c8 01             	or     $0x1,%eax
	movl    %eax, %cr0
  8004214cdc:	0f 22 c0             	mov    %rax,%cr0
	
	# Set up initial page table. We cannot use kern_pgdir yet because
	# we are still running at a low EIP.
	movl    $pml4, %eax
  8004214cdf:	b8 00 20 10 00       	mov    $0x102000,%eax
	movl    %eax, %cr3
  8004214ce4:	0f 22 d8             	mov    %rax,%cr3
	
	# enable the long mode in MSR
	movl $EFER_MSR,%ecx
  8004214ce7:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
	rdmsr
  8004214cec:	0f 32                	rdmsr  
	btsl $EFER_LME,%eax
  8004214cee:	0f ba e8 08          	bts    $0x8,%eax
	wrmsr
  8004214cf2:	0f 30                	wrmsr  
	
	# Turn on paging.
	movl    %cr0, %eax
  8004214cf4:	0f 20 c0             	mov    %cr0,%rax
	orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
  8004214cf7:	0d 01 00 01 80       	or     $0x80010001,%eax
	movl    %eax, %cr0
  8004214cfc:	0f 22 c0             	mov    %rax,%cr0
	

	ljmpl   $(LONG_MODE_CSEG), $(MPBOOTPHYS(start64))
  8004214cff:	ea                   	(bad)  
  8004214d00:	6e                   	outsb  %ds:(%rsi),(%dx)
  8004214d01:	70 00                	jo     8004214d03 <start32+0x4e>
  8004214d03:	00 08                	add    %cl,(%rax)
	...

0000008004214d06 <start64>:

.code64
start64:
	movw    $(LONG_MODE_DSEG), %ax
  8004214d06:	66 b8 10 00          	mov    $0x10,%ax
	movw    %ax, %ds
  8004214d0a:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  8004214d0c:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  8004214d0e:	8e d0                	mov    %eax,%ss
	movw    $0, %ax
  8004214d10:	66 b8 00 00          	mov    $0x0,%ax
	movw    %ax, %fs
  8004214d14:	8e e0                	mov    %eax,%fs
	movw    %ax, %gs
  8004214d16:	8e e8                	mov    %eax,%gs

	# Switch to the per-cpu stack allocated in boot_aps()
	movabs    mpentry_kstack, %rax
  8004214d18:	48 a1 98 67 49 04 80 	movabs 0x8004496798,%rax
  8004214d1f:	00 00 00 
	movq    %rax,%rsp
  8004214d22:	48 89 c4             	mov    %rax,%rsp
	movq    $0x0, %rbp       # nuke frame pointer
  8004214d25:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp

	# Call mp_main().  (Exercise for the reader: why the indirect call?)
	movabs    $mp_main, %rax
  8004214d2c:	48 b8 e8 03 20 04 80 	movabs $0x80042003e8,%rax
  8004214d33:	00 00 00 
	call    *%rax
  8004214d36:	ff d0                	callq  *%rax

0000008004214d38 <spin>:

	# If mp_main returns (it shouldn't), loop.
spin:
	jmp     spin
  8004214d38:	eb fe                	jmp    8004214d38 <spin>
  8004214d3a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000008004214d40 <gdt>:
	...
  8004214d48:	ff                   	(bad)  
  8004214d49:	ff 00                	incl   (%rax)
  8004214d4b:	00 00                	add    %al,(%rax)
  8004214d4d:	9a                   	(bad)  
  8004214d4e:	af                   	scas   %es:(%rdi),%eax
  8004214d4f:	00 ff                	add    %bh,%bh
  8004214d51:	ff 00                	incl   (%rax)
  8004214d53:	00 00                	add    %al,(%rax)
  8004214d55:	92                   	xchg   %eax,%edx
  8004214d56:	af                   	scas   %es:(%rdi),%eax
	...

0000008004214d58 <gdtdesc>:
  8004214d58:	17                   	(bad)  
  8004214d59:	00 a8 70 00 00 66    	add    %ch,0x66000070(%rax)
  8004214d5f:	90                   	nop

0000008004214d60 <gdt32>:
	...
  8004214d68:	ff                   	(bad)  
  8004214d69:	ff 00                	incl   (%rax)
  8004214d6b:	00 00                	add    %al,(%rax)
  8004214d6d:	9a                   	(bad)  
  8004214d6e:	cf                   	iret   
  8004214d6f:	00 ff                	add    %bh,%bh
  8004214d71:	ff 00                	incl   (%rax)
  8004214d73:	00 00                	add    %al,(%rax)
  8004214d75:	92                   	xchg   %eax,%edx
  8004214d76:	cf                   	iret   
	...

0000008004214d78 <gdt32desc>:
  8004214d78:	17                   	(bad)  
  8004214d79:	00 c8                	add    %cl,%al
  8004214d7b:	70 00                	jo     8004214d7d <gdt32desc+0x5>
	...

0000008004214d7e <mpentry_end>:
	.long   MPBOOTPHYS(gdt32)			# address gdt


.globl mpentry_end
mpentry_end:
	nop
  8004214d7e:	90                   	nop

0000008004214d7f <sum>:
#define MPIOINTR  0x03  // One per bus interrupt source
#define MPLINTR   0x04  // One per system interrupt source

static uint8_t
sum(void *addr, int len)
{
  8004214d7f:	55                   	push   %rbp
  8004214d80:	48 89 e5             	mov    %rsp,%rbp
  8004214d83:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004214d87:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004214d8b:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	int i, sum;

	sum = 0;
  8004214d8e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	for (i = 0; i < len; i++)
  8004214d95:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004214d9c:	eb 1a                	jmp    8004214db8 <sum+0x39>
		sum += ((uint8_t *)addr)[i];
  8004214d9e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004214da1:	48 63 d0             	movslq %eax,%rdx
  8004214da4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214da8:	48 01 d0             	add    %rdx,%rax
  8004214dab:	0f b6 00             	movzbl (%rax),%eax
  8004214dae:	0f b6 c0             	movzbl %al,%eax
  8004214db1:	01 45 f8             	add    %eax,-0x8(%rbp)
sum(void *addr, int len)
{
	int i, sum;

	sum = 0;
	for (i = 0; i < len; i++)
  8004214db4:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004214db8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004214dbb:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  8004214dbe:	7c de                	jl     8004214d9e <sum+0x1f>
		sum += ((uint8_t *)addr)[i];
	return sum;
  8004214dc0:	8b 45 f8             	mov    -0x8(%rbp),%eax
}
  8004214dc3:	c9                   	leaveq 
  8004214dc4:	c3                   	retq   

0000008004214dc5 <mpsearch1>:

// Look for an MP structure in the len bytes at physical address addr.
static struct mp *
mpsearch1(physaddr_t a, int len)
{
  8004214dc5:	55                   	push   %rbp
  8004214dc6:	48 89 e5             	mov    %rsp,%rbp
  8004214dc9:	48 83 ec 40          	sub    $0x40,%rsp
  8004214dcd:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004214dd1:	89 75 c4             	mov    %esi,-0x3c(%rbp)
	struct mp *mp = KADDR(a), *end = KADDR(a + len);
  8004214dd4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214dd8:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004214ddc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214de0:	48 c1 e8 0c          	shr    $0xc,%rax
  8004214de4:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004214de7:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004214dea:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  8004214df1:	00 00 00 
  8004214df4:	48 8b 00             	mov    (%rax),%rax
  8004214df7:	48 39 c2             	cmp    %rax,%rdx
  8004214dfa:	72 32                	jb     8004214e2e <mpsearch1+0x69>
  8004214dfc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214e00:	48 89 c1             	mov    %rax,%rcx
  8004214e03:	48 ba a8 84 21 04 80 	movabs $0x80042184a8,%rdx
  8004214e0a:	00 00 00 
  8004214e0d:	be 57 00 00 00       	mov    $0x57,%esi
  8004214e12:	48 bf cb 84 21 04 80 	movabs $0x80042184cb,%rdi
  8004214e19:	00 00 00 
  8004214e1c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214e21:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004214e28:	00 00 00 
  8004214e2b:	41 ff d0             	callq  *%r8
  8004214e2e:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004214e35:	00 00 00 
  8004214e38:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214e3c:	48 01 d0             	add    %rdx,%rax
  8004214e3f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004214e43:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004214e46:	48 63 d0             	movslq %eax,%rdx
  8004214e49:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214e4d:	48 01 d0             	add    %rdx,%rax
  8004214e50:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004214e54:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214e58:	48 c1 e8 0c          	shr    $0xc,%rax
  8004214e5c:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004214e5f:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004214e62:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  8004214e69:	00 00 00 
  8004214e6c:	48 8b 00             	mov    (%rax),%rax
  8004214e6f:	48 39 c2             	cmp    %rax,%rdx
  8004214e72:	72 32                	jb     8004214ea6 <mpsearch1+0xe1>
  8004214e74:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214e78:	48 89 c1             	mov    %rax,%rcx
  8004214e7b:	48 ba a8 84 21 04 80 	movabs $0x80042184a8,%rdx
  8004214e82:	00 00 00 
  8004214e85:	be 57 00 00 00       	mov    $0x57,%esi
  8004214e8a:	48 bf cb 84 21 04 80 	movabs $0x80042184cb,%rdi
  8004214e91:	00 00 00 
  8004214e94:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214e99:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004214ea0:	00 00 00 
  8004214ea3:	41 ff d0             	callq  *%r8
  8004214ea6:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004214ead:	00 00 00 
  8004214eb0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214eb4:	48 01 d0             	add    %rdx,%rax
  8004214eb7:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

	for (; mp < end; mp++)
  8004214ebb:	eb 4d                	jmp    8004214f0a <mpsearch1+0x145>
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
  8004214ebd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214ec1:	ba 04 00 00 00       	mov    $0x4,%edx
  8004214ec6:	48 be db 84 21 04 80 	movabs $0x80042184db,%rsi
  8004214ecd:	00 00 00 
  8004214ed0:	48 89 c7             	mov    %rax,%rdi
  8004214ed3:	48 b8 b1 ea 20 04 80 	movabs $0x800420eab1,%rax
  8004214eda:	00 00 00 
  8004214edd:	ff d0                	callq  *%rax
  8004214edf:	85 c0                	test   %eax,%eax
  8004214ee1:	75 22                	jne    8004214f05 <mpsearch1+0x140>
		    sum(mp, sizeof(*mp)) == 0)
  8004214ee3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214ee7:	be 10 00 00 00       	mov    $0x10,%esi
  8004214eec:	48 89 c7             	mov    %rax,%rdi
  8004214eef:	48 b8 7f 4d 21 04 80 	movabs $0x8004214d7f,%rax
  8004214ef6:	00 00 00 
  8004214ef9:	ff d0                	callq  *%rax
mpsearch1(physaddr_t a, int len)
{
	struct mp *mp = KADDR(a), *end = KADDR(a + len);

	for (; mp < end; mp++)
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
  8004214efb:	84 c0                	test   %al,%al
  8004214efd:	75 06                	jne    8004214f05 <mpsearch1+0x140>
		    sum(mp, sizeof(*mp)) == 0)
			return mp;
  8004214eff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214f03:	eb 14                	jmp    8004214f19 <mpsearch1+0x154>
static struct mp *
mpsearch1(physaddr_t a, int len)
{
	struct mp *mp = KADDR(a), *end = KADDR(a + len);

	for (; mp < end; mp++)
  8004214f05:	48 83 45 f8 10       	addq   $0x10,-0x8(%rbp)
  8004214f0a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214f0e:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004214f12:	72 a9                	jb     8004214ebd <mpsearch1+0xf8>
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
		    sum(mp, sizeof(*mp)) == 0)
			return mp;
	return NULL;
  8004214f14:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004214f19:	c9                   	leaveq 
  8004214f1a:	c3                   	retq   

0000008004214f1b <mpsearch>:
// 1) in the first KB of the EBDA;
// 2) if there is no EBDA, in the last KB of system base memory;
// 3) in the BIOS ROM between 0xE0000 and 0xFFFFF.
static struct mp *
mpsearch(void)
{
  8004214f1b:	55                   	push   %rbp
  8004214f1c:	48 89 e5             	mov    %rsp,%rbp
  8004214f1f:	48 83 ec 30          	sub    $0x30,%rsp
	struct mp *mp;

	//static_assert(sizeof(*mp) == 32);

	// The BIOS data area lives in 16-bit segment 0x40.
	bda = (uint8_t *) KADDR(0x40 << 4);
  8004214f23:	48 c7 45 f8 00 04 00 	movq   $0x400,-0x8(%rbp)
  8004214f2a:	00 
  8004214f2b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214f2f:	48 c1 e8 0c          	shr    $0xc,%rax
  8004214f33:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004214f36:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004214f39:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  8004214f40:	00 00 00 
  8004214f43:	48 8b 00             	mov    (%rax),%rax
  8004214f46:	48 39 c2             	cmp    %rax,%rdx
  8004214f49:	72 32                	jb     8004214f7d <mpsearch+0x62>
  8004214f4b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214f4f:	48 89 c1             	mov    %rax,%rcx
  8004214f52:	48 ba a8 84 21 04 80 	movabs $0x80042184a8,%rdx
  8004214f59:	00 00 00 
  8004214f5c:	be 6f 00 00 00       	mov    $0x6f,%esi
  8004214f61:	48 bf cb 84 21 04 80 	movabs $0x80042184cb,%rdi
  8004214f68:	00 00 00 
  8004214f6b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214f70:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004214f77:	00 00 00 
  8004214f7a:	41 ff d0             	callq  *%r8
  8004214f7d:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004214f84:	00 00 00 
  8004214f87:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214f8b:	48 01 d0             	add    %rdx,%rax
  8004214f8e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	// [MP 4] The 16-bit segment of the EBDA is in the two bytes
	// starting at byte 0x0E of the BDA.  0 if not present.
	if ((p = *(uint16_t *) (bda + 0x0E))) {
  8004214f92:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214f96:	48 83 c0 0e          	add    $0xe,%rax
  8004214f9a:	0f b7 00             	movzwl (%rax),%eax
  8004214f9d:	0f b7 c0             	movzwl %ax,%eax
  8004214fa0:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  8004214fa3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004214fa7:	74 2c                	je     8004214fd5 <mpsearch+0xba>
		p <<= 4;	// Translate from segment to PA
  8004214fa9:	c1 65 e4 04          	shll   $0x4,-0x1c(%rbp)
		if ((mp = mpsearch1(p, 1024)))
  8004214fad:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004214fb0:	be 00 04 00 00       	mov    $0x400,%esi
  8004214fb5:	48 89 c7             	mov    %rax,%rdi
  8004214fb8:	48 b8 c5 4d 21 04 80 	movabs $0x8004214dc5,%rax
  8004214fbf:	00 00 00 
  8004214fc2:	ff d0                	callq  *%rax
  8004214fc4:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004214fc8:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004214fcd:	74 49                	je     8004215018 <mpsearch+0xfd>
			return mp;
  8004214fcf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214fd3:	eb 59                	jmp    800421502e <mpsearch+0x113>
	} else {
		// The size of base memory, in KB is in the two bytes
		// starting at 0x13 of the BDA.
		p = *(uint16_t *) (bda + 0x13) * 1024;
  8004214fd5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214fd9:	48 83 c0 13          	add    $0x13,%rax
  8004214fdd:	0f b7 00             	movzwl (%rax),%eax
  8004214fe0:	0f b7 c0             	movzwl %ax,%eax
  8004214fe3:	c1 e0 0a             	shl    $0xa,%eax
  8004214fe6:	89 45 e4             	mov    %eax,-0x1c(%rbp)
		if ((mp = mpsearch1(p - 1024, 1024)))
  8004214fe9:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004214fec:	2d 00 04 00 00       	sub    $0x400,%eax
  8004214ff1:	89 c0                	mov    %eax,%eax
  8004214ff3:	be 00 04 00 00       	mov    $0x400,%esi
  8004214ff8:	48 89 c7             	mov    %rax,%rdi
  8004214ffb:	48 b8 c5 4d 21 04 80 	movabs $0x8004214dc5,%rax
  8004215002:	00 00 00 
  8004215005:	ff d0                	callq  *%rax
  8004215007:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800421500b:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004215010:	74 06                	je     8004215018 <mpsearch+0xfd>
			return mp;
  8004215012:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215016:	eb 16                	jmp    800421502e <mpsearch+0x113>
	}
	return mpsearch1(0xF0000, 0x10000);
  8004215018:	be 00 00 01 00       	mov    $0x10000,%esi
  800421501d:	bf 00 00 0f 00       	mov    $0xf0000,%edi
  8004215022:	48 b8 c5 4d 21 04 80 	movabs $0x8004214dc5,%rax
  8004215029:	00 00 00 
  800421502c:	ff d0                	callq  *%rax
}
  800421502e:	c9                   	leaveq 
  800421502f:	c3                   	retq   

0000008004215030 <mpconfig>:
// Search for an MP configuration table.  For now, don't accept the
// default configurations (physaddr == 0).
// Check for the correct signature, checksum, and version.
static struct mpconf *
mpconfig(struct mp **pmp)
{
  8004215030:	55                   	push   %rbp
  8004215031:	48 89 e5             	mov    %rsp,%rbp
  8004215034:	48 83 ec 30          	sub    $0x30,%rsp
  8004215038:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	struct mpconf *conf;
	struct mp *mp;

	if ((mp = mpsearch()) == 0)
  800421503c:	48 b8 1b 4f 21 04 80 	movabs $0x8004214f1b,%rax
  8004215043:	00 00 00 
  8004215046:	ff d0                	callq  *%rax
  8004215048:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421504c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004215051:	75 0a                	jne    800421505d <mpconfig+0x2d>
		return NULL;
  8004215053:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215058:	e9 f6 01 00 00       	jmpq   8004215253 <mpconfig+0x223>
	if (mp->physaddr == 0 || mp->type != 0) {
  800421505d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215061:	8b 40 04             	mov    0x4(%rax),%eax
  8004215064:	85 c0                	test   %eax,%eax
  8004215066:	74 0c                	je     8004215074 <mpconfig+0x44>
  8004215068:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421506c:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  8004215070:	84 c0                	test   %al,%al
  8004215072:	74 25                	je     8004215099 <mpconfig+0x69>
		cprintf("SMP: Default configurations not implemented\n");
  8004215074:	48 bf e0 84 21 04 80 	movabs $0x80042184e0,%rdi
  800421507b:	00 00 00 
  800421507e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215083:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  800421508a:	00 00 00 
  800421508d:	ff d2                	callq  *%rdx
		return NULL;
  800421508f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215094:	e9 ba 01 00 00       	jmpq   8004215253 <mpconfig+0x223>
	}
	conf = (struct mpconf *) KADDR(mp->physaddr);
  8004215099:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421509d:	8b 40 04             	mov    0x4(%rax),%eax
  80042150a0:	89 c0                	mov    %eax,%eax
  80042150a2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042150a6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042150aa:	48 c1 e8 0c          	shr    $0xc,%rax
  80042150ae:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80042150b1:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042150b4:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  80042150bb:	00 00 00 
  80042150be:	48 8b 00             	mov    (%rax),%rax
  80042150c1:	48 39 c2             	cmp    %rax,%rdx
  80042150c4:	72 32                	jb     80042150f8 <mpconfig+0xc8>
  80042150c6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042150ca:	48 89 c1             	mov    %rax,%rcx
  80042150cd:	48 ba a8 84 21 04 80 	movabs $0x80042184a8,%rdx
  80042150d4:	00 00 00 
  80042150d7:	be 90 00 00 00       	mov    $0x90,%esi
  80042150dc:	48 bf cb 84 21 04 80 	movabs $0x80042184cb,%rdi
  80042150e3:	00 00 00 
  80042150e6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042150eb:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042150f2:	00 00 00 
  80042150f5:	41 ff d0             	callq  *%r8
  80042150f8:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042150ff:	00 00 00 
  8004215102:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215106:	48 01 d0             	add    %rdx,%rax
  8004215109:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if (memcmp(conf, "PCMP", 4) != 0) {
  800421510d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215111:	ba 04 00 00 00       	mov    $0x4,%edx
  8004215116:	48 be 0d 85 21 04 80 	movabs $0x800421850d,%rsi
  800421511d:	00 00 00 
  8004215120:	48 89 c7             	mov    %rax,%rdi
  8004215123:	48 b8 b1 ea 20 04 80 	movabs $0x800420eab1,%rax
  800421512a:	00 00 00 
  800421512d:	ff d0                	callq  *%rax
  800421512f:	85 c0                	test   %eax,%eax
  8004215131:	74 25                	je     8004215158 <mpconfig+0x128>
		cprintf("SMP: Incorrect MP configuration table signature\n");
  8004215133:	48 bf 18 85 21 04 80 	movabs $0x8004218518,%rdi
  800421513a:	00 00 00 
  800421513d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215142:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  8004215149:	00 00 00 
  800421514c:	ff d2                	callq  *%rdx
		return NULL;
  800421514e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215153:	e9 fb 00 00 00       	jmpq   8004215253 <mpconfig+0x223>
	}
	if (sum(conf, conf->length) != 0) {
  8004215158:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421515c:	0f b7 40 04          	movzwl 0x4(%rax),%eax
  8004215160:	0f b7 d0             	movzwl %ax,%edx
  8004215163:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215167:	89 d6                	mov    %edx,%esi
  8004215169:	48 89 c7             	mov    %rax,%rdi
  800421516c:	48 b8 7f 4d 21 04 80 	movabs $0x8004214d7f,%rax
  8004215173:	00 00 00 
  8004215176:	ff d0                	callq  *%rax
  8004215178:	84 c0                	test   %al,%al
  800421517a:	74 25                	je     80042151a1 <mpconfig+0x171>
		cprintf("SMP: Bad MP configuration checksum\n");
  800421517c:	48 bf 50 85 21 04 80 	movabs $0x8004218550,%rdi
  8004215183:	00 00 00 
  8004215186:	b8 00 00 00 00       	mov    $0x0,%eax
  800421518b:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  8004215192:	00 00 00 
  8004215195:	ff d2                	callq  *%rdx
		return NULL;
  8004215197:	b8 00 00 00 00       	mov    $0x0,%eax
  800421519c:	e9 b2 00 00 00       	jmpq   8004215253 <mpconfig+0x223>
	}
	if (conf->version != 1 && conf->version != 4) {
  80042151a1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042151a5:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  80042151a9:	3c 01                	cmp    $0x1,%al
  80042151ab:	74 3b                	je     80042151e8 <mpconfig+0x1b8>
  80042151ad:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042151b1:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  80042151b5:	3c 04                	cmp    $0x4,%al
  80042151b7:	74 2f                	je     80042151e8 <mpconfig+0x1b8>
		cprintf("SMP: Unsupported MP version %d\n", conf->version);
  80042151b9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042151bd:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  80042151c1:	0f b6 c0             	movzbl %al,%eax
  80042151c4:	89 c6                	mov    %eax,%esi
  80042151c6:	48 bf 78 85 21 04 80 	movabs $0x8004218578,%rdi
  80042151cd:	00 00 00 
  80042151d0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042151d5:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  80042151dc:	00 00 00 
  80042151df:	ff d2                	callq  *%rdx
		return NULL;
  80042151e1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042151e6:	eb 6b                	jmp    8004215253 <mpconfig+0x223>
	}
	if (sum((uint8_t *)conf + conf->length, conf->xlength) != conf->xchecksum) {
  80042151e8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042151ec:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80042151f0:	0f b7 c0             	movzwl %ax,%eax
  80042151f3:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042151f7:	0f b7 52 04          	movzwl 0x4(%rdx),%edx
  80042151fb:	0f b7 ca             	movzwl %dx,%ecx
  80042151fe:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004215202:	48 01 ca             	add    %rcx,%rdx
  8004215205:	89 c6                	mov    %eax,%esi
  8004215207:	48 89 d7             	mov    %rdx,%rdi
  800421520a:	48 b8 7f 4d 21 04 80 	movabs $0x8004214d7f,%rax
  8004215211:	00 00 00 
  8004215214:	ff d0                	callq  *%rax
  8004215216:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421521a:	0f b6 52 2a          	movzbl 0x2a(%rdx),%edx
  800421521e:	38 d0                	cmp    %dl,%al
  8004215220:	74 22                	je     8004215244 <mpconfig+0x214>
		cprintf("SMP: Bad MP configuration extended checksum\n");
  8004215222:	48 bf 98 85 21 04 80 	movabs $0x8004218598,%rdi
  8004215229:	00 00 00 
  800421522c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215231:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  8004215238:	00 00 00 
  800421523b:	ff d2                	callq  *%rdx
		return NULL;
  800421523d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215242:	eb 0f                	jmp    8004215253 <mpconfig+0x223>
	}
	*pmp = mp;
  8004215244:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215248:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421524c:	48 89 10             	mov    %rdx,(%rax)
	return conf;
  800421524f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
}
  8004215253:	c9                   	leaveq 
  8004215254:	c3                   	retq   

0000008004215255 <mp_init>:

void
mp_init(void)
{
  8004215255:	55                   	push   %rbp
  8004215256:	48 89 e5             	mov    %rsp,%rbp
  8004215259:	53                   	push   %rbx
  800421525a:	48 83 ec 48          	sub    $0x48,%rsp
	struct mpconf *conf;
	struct mpproc *proc;
	uint8_t *p;
	unsigned int i;

	bootcpu = &cpus[0];
  800421525e:	48 b8 e0 83 49 04 80 	movabs $0x80044983e0,%rax
  8004215265:	00 00 00 
  8004215268:	48 bb 20 80 49 04 80 	movabs $0x8004498020,%rbx
  800421526f:	00 00 00 
  8004215272:	48 89 18             	mov    %rbx,(%rax)
	if ((conf = mpconfig(&mp)) == 0)
  8004215275:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
  8004215279:	48 89 c7             	mov    %rax,%rdi
  800421527c:	48 b8 30 50 21 04 80 	movabs $0x8004215030,%rax
  8004215283:	00 00 00 
  8004215286:	ff d0                	callq  *%rax
  8004215288:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800421528c:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004215291:	75 05                	jne    8004215298 <mp_init+0x43>
		return;
  8004215293:	e9 b5 02 00 00       	jmpq   800421554d <mp_init+0x2f8>
	ismp = 1;
  8004215298:	48 b8 00 80 49 04 80 	movabs $0x8004498000,%rax
  800421529f:	00 00 00 
  80042152a2:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
	lapicaddr = conf->lapicaddr;
  80042152a8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042152ac:	8b 40 24             	mov    0x24(%rax),%eax
  80042152af:	89 c2                	mov    %eax,%edx
  80042152b1:	48 b8 00 90 51 04 80 	movabs $0x8004519000,%rax
  80042152b8:	00 00 00 
  80042152bb:	48 89 10             	mov    %rdx,(%rax)

	for (p = conf->entries, i = 0; i < conf->entry; i++) {
  80042152be:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042152c2:	48 83 c0 2c          	add    $0x2c,%rax
  80042152c6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  80042152ca:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
  80042152d1:	e9 5c 01 00 00       	jmpq   8004215432 <mp_init+0x1dd>
		switch (*p) {
  80042152d6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042152da:	0f b6 00             	movzbl (%rax),%eax
  80042152dd:	0f b6 c0             	movzbl %al,%eax
  80042152e0:	85 c0                	test   %eax,%eax
  80042152e2:	74 16                	je     80042152fa <mp_init+0xa5>
  80042152e4:	85 c0                	test   %eax,%eax
  80042152e6:	0f 88 fd 00 00 00    	js     80042153e9 <mp_init+0x194>
  80042152ec:	83 f8 04             	cmp    $0x4,%eax
  80042152ef:	0f 8f f4 00 00 00    	jg     80042153e9 <mp_init+0x194>
  80042152f5:	e9 e8 00 00 00       	jmpq   80042153e2 <mp_init+0x18d>
		case MPPROC:
			proc = (struct mpproc *)p;
  80042152fa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042152fe:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			if (proc->flags & MPPROC_BOOT)
  8004215302:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215306:	0f b6 40 03          	movzbl 0x3(%rax),%eax
  800421530a:	0f b6 c0             	movzbl %al,%eax
  800421530d:	83 e0 02             	and    $0x2,%eax
  8004215310:	85 c0                	test   %eax,%eax
  8004215312:	74 36                	je     800421534a <mp_init+0xf5>
				bootcpu = &cpus[ncpu];
  8004215314:	48 b8 e8 83 49 04 80 	movabs $0x80044983e8,%rax
  800421531b:	00 00 00 
  800421531e:	8b 00                	mov    (%rax),%eax
  8004215320:	48 98                	cltq   
  8004215322:	48 c1 e0 03          	shl    $0x3,%rax
  8004215326:	48 89 c2             	mov    %rax,%rdx
  8004215329:	48 c1 e2 04          	shl    $0x4,%rdx
  800421532d:	48 29 c2             	sub    %rax,%rdx
  8004215330:	48 b8 20 80 49 04 80 	movabs $0x8004498020,%rax
  8004215337:	00 00 00 
  800421533a:	48 01 c2             	add    %rax,%rdx
  800421533d:	48 b8 e0 83 49 04 80 	movabs $0x80044983e0,%rax
  8004215344:	00 00 00 
  8004215347:	48 89 10             	mov    %rdx,(%rax)
			if (ncpu < NCPU) {
  800421534a:	48 b8 e8 83 49 04 80 	movabs $0x80044983e8,%rax
  8004215351:	00 00 00 
  8004215354:	8b 00                	mov    (%rax),%eax
  8004215356:	83 f8 07             	cmp    $0x7,%eax
  8004215359:	7f 58                	jg     80042153b3 <mp_init+0x15e>
				cpus[ncpu].cpu_id = ncpu;
  800421535b:	48 b8 e8 83 49 04 80 	movabs $0x80044983e8,%rax
  8004215362:	00 00 00 
  8004215365:	8b 10                	mov    (%rax),%edx
  8004215367:	48 b8 e8 83 49 04 80 	movabs $0x80044983e8,%rax
  800421536e:	00 00 00 
  8004215371:	8b 00                	mov    (%rax),%eax
  8004215373:	89 c1                	mov    %eax,%ecx
  8004215375:	48 be 20 80 49 04 80 	movabs $0x8004498020,%rsi
  800421537c:	00 00 00 
  800421537f:	48 63 c2             	movslq %edx,%rax
  8004215382:	48 c1 e0 03          	shl    $0x3,%rax
  8004215386:	48 89 c2             	mov    %rax,%rdx
  8004215389:	48 c1 e2 04          	shl    $0x4,%rdx
  800421538d:	48 29 c2             	sub    %rax,%rdx
  8004215390:	48 8d 04 16          	lea    (%rsi,%rdx,1),%rax
  8004215394:	88 08                	mov    %cl,(%rax)
				ncpu++;
  8004215396:	48 b8 e8 83 49 04 80 	movabs $0x80044983e8,%rax
  800421539d:	00 00 00 
  80042153a0:	8b 00                	mov    (%rax),%eax
  80042153a2:	8d 50 01             	lea    0x1(%rax),%edx
  80042153a5:	48 b8 e8 83 49 04 80 	movabs $0x80044983e8,%rax
  80042153ac:	00 00 00 
  80042153af:	89 10                	mov    %edx,(%rax)
  80042153b1:	eb 28                	jmp    80042153db <mp_init+0x186>
			} else {
				cprintf("SMP: too many CPUs, CPU %d disabled\n",
					proc->apicid);
  80042153b3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042153b7:	0f b6 40 01          	movzbl 0x1(%rax),%eax
				bootcpu = &cpus[ncpu];
			if (ncpu < NCPU) {
				cpus[ncpu].cpu_id = ncpu;
				ncpu++;
			} else {
				cprintf("SMP: too many CPUs, CPU %d disabled\n",
  80042153bb:	0f b6 c0             	movzbl %al,%eax
  80042153be:	89 c6                	mov    %eax,%esi
  80042153c0:	48 bf c8 85 21 04 80 	movabs $0x80042185c8,%rdi
  80042153c7:	00 00 00 
  80042153ca:	b8 00 00 00 00       	mov    $0x0,%eax
  80042153cf:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  80042153d6:	00 00 00 
  80042153d9:	ff d2                	callq  *%rdx
					proc->apicid);
			}
			p += sizeof(struct mpproc);
  80042153db:	48 83 45 e8 14       	addq   $0x14,-0x18(%rbp)
			continue;
  80042153e0:	eb 4c                	jmp    800421542e <mp_init+0x1d9>
		case MPBUS:
		case MPIOAPIC:
		case MPIOINTR:
		case MPLINTR:
			p += 8;
  80042153e2:	48 83 45 e8 08       	addq   $0x8,-0x18(%rbp)
			continue;
  80042153e7:	eb 45                	jmp    800421542e <mp_init+0x1d9>
		default:
			cprintf("mpinit: unknown config type %x\n", *p);
  80042153e9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042153ed:	0f b6 00             	movzbl (%rax),%eax
  80042153f0:	0f b6 c0             	movzbl %al,%eax
  80042153f3:	89 c6                	mov    %eax,%esi
  80042153f5:	48 bf f0 85 21 04 80 	movabs $0x80042185f0,%rdi
  80042153fc:	00 00 00 
  80042153ff:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215404:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  800421540b:	00 00 00 
  800421540e:	ff d2                	callq  *%rdx
			ismp = 0;
  8004215410:	48 b8 00 80 49 04 80 	movabs $0x8004498000,%rax
  8004215417:	00 00 00 
  800421541a:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
			i = conf->entry;
  8004215420:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215424:	0f b7 40 22          	movzwl 0x22(%rax),%eax
  8004215428:	0f b7 c0             	movzwl %ax,%eax
  800421542b:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	if ((conf = mpconfig(&mp)) == 0)
		return;
	ismp = 1;
	lapicaddr = conf->lapicaddr;

	for (p = conf->entries, i = 0; i < conf->entry; i++) {
  800421542e:	83 45 e4 01          	addl   $0x1,-0x1c(%rbp)
  8004215432:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215436:	0f b7 40 22          	movzwl 0x22(%rax),%eax
  800421543a:	0f b7 c0             	movzwl %ax,%eax
  800421543d:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  8004215440:	0f 87 90 fe ff ff    	ja     80042152d6 <mp_init+0x81>
			ismp = 0;
			i = conf->entry;
		}
	}

	bootcpu->cpu_status = CPU_STARTED;
  8004215446:	48 b8 e0 83 49 04 80 	movabs $0x80044983e0,%rax
  800421544d:	00 00 00 
  8004215450:	48 8b 00             	mov    (%rax),%rax
  8004215453:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%rax)
	if (!ismp) {
  800421545a:	48 b8 00 80 49 04 80 	movabs $0x8004498000,%rax
  8004215461:	00 00 00 
  8004215464:	8b 00                	mov    (%rax),%eax
  8004215466:	85 c0                	test   %eax,%eax
  8004215468:	75 41                	jne    80042154ab <mp_init+0x256>
		// Didn't like what we found; fall back to no MP.
		ncpu = 1;
  800421546a:	48 b8 e8 83 49 04 80 	movabs $0x80044983e8,%rax
  8004215471:	00 00 00 
  8004215474:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
		lapicaddr = 0;
  800421547a:	48 b8 00 90 51 04 80 	movabs $0x8004519000,%rax
  8004215481:	00 00 00 
  8004215484:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		cprintf("SMP: configuration not found, SMP disabled\n");
  800421548b:	48 bf 10 86 21 04 80 	movabs $0x8004218610,%rdi
  8004215492:	00 00 00 
  8004215495:	b8 00 00 00 00       	mov    $0x0,%eax
  800421549a:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  80042154a1:	00 00 00 
  80042154a4:	ff d2                	callq  *%rdx
		return;
  80042154a6:	e9 a2 00 00 00       	jmpq   800421554d <mp_init+0x2f8>
	}
	cprintf("SMP: CPU %d found %d CPU(s)\n", bootcpu->cpu_id,  ncpu);
  80042154ab:	48 b8 e8 83 49 04 80 	movabs $0x80044983e8,%rax
  80042154b2:	00 00 00 
  80042154b5:	8b 10                	mov    (%rax),%edx
  80042154b7:	48 b8 e0 83 49 04 80 	movabs $0x80044983e0,%rax
  80042154be:	00 00 00 
  80042154c1:	48 8b 00             	mov    (%rax),%rax
  80042154c4:	0f b6 00             	movzbl (%rax),%eax
  80042154c7:	0f b6 c0             	movzbl %al,%eax
  80042154ca:	89 c6                	mov    %eax,%esi
  80042154cc:	48 bf 3c 86 21 04 80 	movabs $0x800421863c,%rdi
  80042154d3:	00 00 00 
  80042154d6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042154db:	48 b9 7a 8a 20 04 80 	movabs $0x8004208a7a,%rcx
  80042154e2:	00 00 00 
  80042154e5:	ff d1                	callq  *%rcx

	if (mp->imcrp) {
  80042154e7:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042154eb:	0f b6 40 0c          	movzbl 0xc(%rax),%eax
  80042154ef:	84 c0                	test   %al,%al
  80042154f1:	74 5a                	je     800421554d <mp_init+0x2f8>
		// [MP 3.2.6.1] If the hardware implements PIC mode,
		// switch to getting interrupts from the LAPIC.
		cprintf("SMP: Setting IMCR to switch from PIC mode to symmetric I/O mode\n");
  80042154f3:	48 bf 60 86 21 04 80 	movabs $0x8004218660,%rdi
  80042154fa:	00 00 00 
  80042154fd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215502:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  8004215509:	00 00 00 
  800421550c:	ff d2                	callq  *%rdx
  800421550e:	c7 45 cc 22 00 00 00 	movl   $0x22,-0x34(%rbp)
  8004215515:	c6 45 cb 70          	movb   $0x70,-0x35(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004215519:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  800421551d:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004215520:	ee                   	out    %al,(%dx)
  8004215521:	c7 45 c4 23 00 00 00 	movl   $0x23,-0x3c(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004215528:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800421552b:	89 c2                	mov    %eax,%edx
  800421552d:	ec                   	in     (%dx),%al
  800421552e:	88 45 c3             	mov    %al,-0x3d(%rbp)
	return data;
  8004215531:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
		outb(0x22, 0x70);   // Select IMCR
		outb(0x23, inb(0x23) | 1);  // Mask external interrupts.
  8004215535:	83 c8 01             	or     $0x1,%eax
  8004215538:	0f b6 c0             	movzbl %al,%eax
  800421553b:	c7 45 bc 23 00 00 00 	movl   $0x23,-0x44(%rbp)
  8004215542:	88 45 bb             	mov    %al,-0x45(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004215545:	0f b6 45 bb          	movzbl -0x45(%rbp),%eax
  8004215549:	8b 55 bc             	mov    -0x44(%rbp),%edx
  800421554c:	ee                   	out    %al,(%dx)
	}
}
  800421554d:	48 83 c4 48          	add    $0x48,%rsp
  8004215551:	5b                   	pop    %rbx
  8004215552:	5d                   	pop    %rbp
  8004215553:	c3                   	retq   

0000008004215554 <lapicw>:
physaddr_t lapicaddr;        // Initialized in mpconfig.c
volatile uint32_t *lapic;

static void
lapicw(int index, int value)
{
  8004215554:	55                   	push   %rbp
  8004215555:	48 89 e5             	mov    %rsp,%rbp
  8004215558:	48 83 ec 08          	sub    $0x8,%rsp
  800421555c:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800421555f:	89 75 f8             	mov    %esi,-0x8(%rbp)
	lapic[index] = value;
  8004215562:	48 b8 08 90 51 04 80 	movabs $0x8004519008,%rax
  8004215569:	00 00 00 
  800421556c:	48 8b 00             	mov    (%rax),%rax
  800421556f:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004215572:	48 63 d2             	movslq %edx,%rdx
  8004215575:	48 c1 e2 02          	shl    $0x2,%rdx
  8004215579:	48 01 c2             	add    %rax,%rdx
  800421557c:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421557f:	89 02                	mov    %eax,(%rdx)
	lapic[ID];  // wait for write to finish, by reading
  8004215581:	48 b8 08 90 51 04 80 	movabs $0x8004519008,%rax
  8004215588:	00 00 00 
  800421558b:	48 8b 00             	mov    (%rax),%rax
  800421558e:	48 83 c0 20          	add    $0x20,%rax
  8004215592:	8b 00                	mov    (%rax),%eax
}
  8004215594:	c9                   	leaveq 
  8004215595:	c3                   	retq   

0000008004215596 <lapic_init>:

void
lapic_init(void)
{
  8004215596:	55                   	push   %rbp
  8004215597:	48 89 e5             	mov    %rsp,%rbp
	if (!lapicaddr)
  800421559a:	48 b8 00 90 51 04 80 	movabs $0x8004519000,%rax
  80042155a1:	00 00 00 
  80042155a4:	48 8b 00             	mov    (%rax),%rax
  80042155a7:	48 85 c0             	test   %rax,%rax
  80042155aa:	75 05                	jne    80042155b1 <lapic_init+0x1b>
		return;
  80042155ac:	e9 da 01 00 00       	jmpq   800421578b <lapic_init+0x1f5>

	// lapicaddr is the physical address of the LAPIC's 4K MMIO
	// region.  Map it in to virtual memory so we can access it.
	lapic = mmio_map_region(lapicaddr, 4096);
  80042155b1:	48 b8 00 90 51 04 80 	movabs $0x8004519000,%rax
  80042155b8:	00 00 00 
  80042155bb:	48 8b 00             	mov    (%rax),%rax
  80042155be:	be 00 10 00 00       	mov    $0x1000,%esi
  80042155c3:	48 89 c7             	mov    %rax,%rdi
  80042155c6:	48 b8 d3 35 20 04 80 	movabs $0x80042035d3,%rax
  80042155cd:	00 00 00 
  80042155d0:	ff d0                	callq  *%rax
  80042155d2:	48 ba 08 90 51 04 80 	movabs $0x8004519008,%rdx
  80042155d9:	00 00 00 
  80042155dc:	48 89 02             	mov    %rax,(%rdx)

	// Enable local APIC; set spurious interrupt vector.
	lapicw(SVR, ENABLE | (IRQ_OFFSET + IRQ_SPURIOUS));
  80042155df:	be 27 01 00 00       	mov    $0x127,%esi
  80042155e4:	bf 3c 00 00 00       	mov    $0x3c,%edi
  80042155e9:	48 b8 54 55 21 04 80 	movabs $0x8004215554,%rax
  80042155f0:	00 00 00 
  80042155f3:	ff d0                	callq  *%rax

	// The timer repeatedly counts down at bus frequency
	// from lapic[TICR] and then issues an interrupt.  
	// If we cared more about precise timekeeping,
	// TICR would be calibrated using an external time source.
	lapicw(TDCR, X1);
  80042155f5:	be 0b 00 00 00       	mov    $0xb,%esi
  80042155fa:	bf f8 00 00 00       	mov    $0xf8,%edi
  80042155ff:	48 b8 54 55 21 04 80 	movabs $0x8004215554,%rax
  8004215606:	00 00 00 
  8004215609:	ff d0                	callq  *%rax
	lapicw(TIMER, PERIODIC | (IRQ_OFFSET + IRQ_TIMER));
  800421560b:	be 20 00 02 00       	mov    $0x20020,%esi
  8004215610:	bf c8 00 00 00       	mov    $0xc8,%edi
  8004215615:	48 b8 54 55 21 04 80 	movabs $0x8004215554,%rax
  800421561c:	00 00 00 
  800421561f:	ff d0                	callq  *%rax
	lapicw(TICR, 10000000); 
  8004215621:	be 80 96 98 00       	mov    $0x989680,%esi
  8004215626:	bf e0 00 00 00       	mov    $0xe0,%edi
  800421562b:	48 b8 54 55 21 04 80 	movabs $0x8004215554,%rax
  8004215632:	00 00 00 
  8004215635:	ff d0                	callq  *%rax
	//
	// According to Intel MP Specification, the BIOS should initialize
	// BSP's local APIC in Virtual Wire Mode, in which 8259A's
	// INTR is virtually connected to BSP's LINTIN0. In this mode,
	// we do not need to program the IOAPIC.
	if (thiscpu != bootcpu)
  8004215637:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  800421563e:	00 00 00 
  8004215641:	ff d0                	callq  *%rax
  8004215643:	48 98                	cltq   
  8004215645:	48 c1 e0 03          	shl    $0x3,%rax
  8004215649:	48 89 c2             	mov    %rax,%rdx
  800421564c:	48 c1 e2 04          	shl    $0x4,%rdx
  8004215650:	48 29 c2             	sub    %rax,%rdx
  8004215653:	48 b8 20 80 49 04 80 	movabs $0x8004498020,%rax
  800421565a:	00 00 00 
  800421565d:	48 01 c2             	add    %rax,%rdx
  8004215660:	48 b8 e0 83 49 04 80 	movabs $0x80044983e0,%rax
  8004215667:	00 00 00 
  800421566a:	48 8b 00             	mov    (%rax),%rax
  800421566d:	48 39 c2             	cmp    %rax,%rdx
  8004215670:	74 16                	je     8004215688 <lapic_init+0xf2>
		lapicw(LINT0, MASKED);
  8004215672:	be 00 00 01 00       	mov    $0x10000,%esi
  8004215677:	bf d4 00 00 00       	mov    $0xd4,%edi
  800421567c:	48 b8 54 55 21 04 80 	movabs $0x8004215554,%rax
  8004215683:	00 00 00 
  8004215686:	ff d0                	callq  *%rax

	// Disable NMI (LINT1) on all CPUs
	lapicw(LINT1, MASKED);
  8004215688:	be 00 00 01 00       	mov    $0x10000,%esi
  800421568d:	bf d8 00 00 00       	mov    $0xd8,%edi
  8004215692:	48 b8 54 55 21 04 80 	movabs $0x8004215554,%rax
  8004215699:	00 00 00 
  800421569c:	ff d0                	callq  *%rax

	// Disable performance counter overflow interrupts
	// on machines that provide that interrupt entry.
	if (((lapic[VER]>>16) & 0xFF) >= 4)
  800421569e:	48 b8 08 90 51 04 80 	movabs $0x8004519008,%rax
  80042156a5:	00 00 00 
  80042156a8:	48 8b 00             	mov    (%rax),%rax
  80042156ab:	48 83 c0 30          	add    $0x30,%rax
  80042156af:	8b 00                	mov    (%rax),%eax
  80042156b1:	c1 e8 10             	shr    $0x10,%eax
  80042156b4:	0f b6 c0             	movzbl %al,%eax
  80042156b7:	83 f8 03             	cmp    $0x3,%eax
  80042156ba:	76 16                	jbe    80042156d2 <lapic_init+0x13c>
		lapicw(PCINT, MASKED);
  80042156bc:	be 00 00 01 00       	mov    $0x10000,%esi
  80042156c1:	bf d0 00 00 00       	mov    $0xd0,%edi
  80042156c6:	48 b8 54 55 21 04 80 	movabs $0x8004215554,%rax
  80042156cd:	00 00 00 
  80042156d0:	ff d0                	callq  *%rax

	// Map error interrupt to IRQ_ERROR.
	lapicw(ERROR, IRQ_OFFSET + IRQ_ERROR);
  80042156d2:	be 33 00 00 00       	mov    $0x33,%esi
  80042156d7:	bf dc 00 00 00       	mov    $0xdc,%edi
  80042156dc:	48 b8 54 55 21 04 80 	movabs $0x8004215554,%rax
  80042156e3:	00 00 00 
  80042156e6:	ff d0                	callq  *%rax

	// Clear error status register (requires back-to-back writes).
	lapicw(ESR, 0);
  80042156e8:	be 00 00 00 00       	mov    $0x0,%esi
  80042156ed:	bf a0 00 00 00       	mov    $0xa0,%edi
  80042156f2:	48 b8 54 55 21 04 80 	movabs $0x8004215554,%rax
  80042156f9:	00 00 00 
  80042156fc:	ff d0                	callq  *%rax
	lapicw(ESR, 0);
  80042156fe:	be 00 00 00 00       	mov    $0x0,%esi
  8004215703:	bf a0 00 00 00       	mov    $0xa0,%edi
  8004215708:	48 b8 54 55 21 04 80 	movabs $0x8004215554,%rax
  800421570f:	00 00 00 
  8004215712:	ff d0                	callq  *%rax

	// Ack any outstanding interrupts.
	lapicw(EOI, 0);
  8004215714:	be 00 00 00 00       	mov    $0x0,%esi
  8004215719:	bf 2c 00 00 00       	mov    $0x2c,%edi
  800421571e:	48 b8 54 55 21 04 80 	movabs $0x8004215554,%rax
  8004215725:	00 00 00 
  8004215728:	ff d0                	callq  *%rax

	// Send an Init Level De-Assert to synchronize arbitration ID's.
	lapicw(ICRHI, 0);
  800421572a:	be 00 00 00 00       	mov    $0x0,%esi
  800421572f:	bf c4 00 00 00       	mov    $0xc4,%edi
  8004215734:	48 b8 54 55 21 04 80 	movabs $0x8004215554,%rax
  800421573b:	00 00 00 
  800421573e:	ff d0                	callq  *%rax
	lapicw(ICRLO, BCAST | INIT | LEVEL);
  8004215740:	be 00 85 08 00       	mov    $0x88500,%esi
  8004215745:	bf c0 00 00 00       	mov    $0xc0,%edi
  800421574a:	48 b8 54 55 21 04 80 	movabs $0x8004215554,%rax
  8004215751:	00 00 00 
  8004215754:	ff d0                	callq  *%rax
	while (lapic[ICRLO] & DELIVS)
  8004215756:	90                   	nop
  8004215757:	48 b8 08 90 51 04 80 	movabs $0x8004519008,%rax
  800421575e:	00 00 00 
  8004215761:	48 8b 00             	mov    (%rax),%rax
  8004215764:	48 05 00 03 00 00    	add    $0x300,%rax
  800421576a:	8b 00                	mov    (%rax),%eax
  800421576c:	25 00 10 00 00       	and    $0x1000,%eax
  8004215771:	85 c0                	test   %eax,%eax
  8004215773:	75 e2                	jne    8004215757 <lapic_init+0x1c1>
		;

	// Enable interrupts on the APIC (but not on the processor).
	lapicw(TPR, 0);
  8004215775:	be 00 00 00 00       	mov    $0x0,%esi
  800421577a:	bf 20 00 00 00       	mov    $0x20,%edi
  800421577f:	48 b8 54 55 21 04 80 	movabs $0x8004215554,%rax
  8004215786:	00 00 00 
  8004215789:	ff d0                	callq  *%rax
}
  800421578b:	5d                   	pop    %rbp
  800421578c:	c3                   	retq   

000000800421578d <cpunum>:

int
cpunum(void)
{
  800421578d:	55                   	push   %rbp
  800421578e:	48 89 e5             	mov    %rsp,%rbp
	if (lapic)
  8004215791:	48 b8 08 90 51 04 80 	movabs $0x8004519008,%rax
  8004215798:	00 00 00 
  800421579b:	48 8b 00             	mov    (%rax),%rax
  800421579e:	48 85 c0             	test   %rax,%rax
  80042157a1:	74 18                	je     80042157bb <cpunum+0x2e>
		return lapic[ID] >> 24;
  80042157a3:	48 b8 08 90 51 04 80 	movabs $0x8004519008,%rax
  80042157aa:	00 00 00 
  80042157ad:	48 8b 00             	mov    (%rax),%rax
  80042157b0:	48 83 c0 20          	add    $0x20,%rax
  80042157b4:	8b 00                	mov    (%rax),%eax
  80042157b6:	c1 e8 18             	shr    $0x18,%eax
  80042157b9:	eb 05                	jmp    80042157c0 <cpunum+0x33>
	return 0;
  80042157bb:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042157c0:	5d                   	pop    %rbp
  80042157c1:	c3                   	retq   

00000080042157c2 <lapic_eoi>:

// Acknowledge interrupt.
void
lapic_eoi(void)
{
  80042157c2:	55                   	push   %rbp
  80042157c3:	48 89 e5             	mov    %rsp,%rbp
	if (lapic)
  80042157c6:	48 b8 08 90 51 04 80 	movabs $0x8004519008,%rax
  80042157cd:	00 00 00 
  80042157d0:	48 8b 00             	mov    (%rax),%rax
  80042157d3:	48 85 c0             	test   %rax,%rax
  80042157d6:	74 16                	je     80042157ee <lapic_eoi+0x2c>
		lapicw(EOI, 0);
  80042157d8:	be 00 00 00 00       	mov    $0x0,%esi
  80042157dd:	bf 2c 00 00 00       	mov    $0x2c,%edi
  80042157e2:	48 b8 54 55 21 04 80 	movabs $0x8004215554,%rax
  80042157e9:	00 00 00 
  80042157ec:	ff d0                	callq  *%rax
}
  80042157ee:	5d                   	pop    %rbp
  80042157ef:	c3                   	retq   

00000080042157f0 <microdelay>:

// Spin for a given number of microseconds.
// On real hardware would want to tune this dynamically.
static void
microdelay(int us)
{
  80042157f0:	55                   	push   %rbp
  80042157f1:	48 89 e5             	mov    %rsp,%rbp
  80042157f4:	48 83 ec 04          	sub    $0x4,%rsp
  80042157f8:	89 7d fc             	mov    %edi,-0x4(%rbp)
}
  80042157fb:	c9                   	leaveq 
  80042157fc:	c3                   	retq   

00000080042157fd <lapic_startap>:

// Start additional processor running entry code at addr.
// See Appendix B of MultiProcessor Specification.
void
lapic_startap(uint8_t apicid, uint32_t addr)
{
  80042157fd:	55                   	push   %rbp
  80042157fe:	48 89 e5             	mov    %rsp,%rbp
  8004215801:	48 83 ec 40          	sub    $0x40,%rsp
  8004215805:	89 f8                	mov    %edi,%eax
  8004215807:	89 75 c8             	mov    %esi,-0x38(%rbp)
  800421580a:	88 45 cc             	mov    %al,-0x34(%rbp)
  800421580d:	c7 45 dc 70 00 00 00 	movl   $0x70,-0x24(%rbp)
  8004215814:	c6 45 db 0f          	movb   $0xf,-0x25(%rbp)
  8004215818:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  800421581c:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800421581f:	ee                   	out    %al,(%dx)
  8004215820:	c7 45 d4 71 00 00 00 	movl   $0x71,-0x2c(%rbp)
  8004215827:	c6 45 d3 0a          	movb   $0xa,-0x2d(%rbp)
  800421582b:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  800421582f:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004215832:	ee                   	out    %al,(%dx)
	// "The BSP must initialize CMOS shutdown code to 0AH
	// and the warm reset vector (DWORD based at 40:67) to point at
	// the AP startup code prior to the [universal startup algorithm]."
	outb(IO_RTC, 0xF);  // offset 0xF is shutdown code
	outb(IO_RTC+1, 0x0A);
	wrv = (uint16_t *)KADDR((0x40 << 4 | 0x67));  // Warm reset vector
  8004215833:	48 c7 45 f0 67 04 00 	movq   $0x467,-0x10(%rbp)
  800421583a:	00 
  800421583b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421583f:	48 c1 e8 0c          	shr    $0xc,%rax
  8004215843:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004215846:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004215849:	48 b8 b0 67 49 04 80 	movabs $0x80044967b0,%rax
  8004215850:	00 00 00 
  8004215853:	48 8b 00             	mov    (%rax),%rax
  8004215856:	48 39 c2             	cmp    %rax,%rdx
  8004215859:	72 32                	jb     800421588d <lapic_startap+0x90>
  800421585b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421585f:	48 89 c1             	mov    %rax,%rcx
  8004215862:	48 ba a8 86 21 04 80 	movabs $0x80042186a8,%rdx
  8004215869:	00 00 00 
  800421586c:	be 98 00 00 00       	mov    $0x98,%esi
  8004215871:	48 bf cb 86 21 04 80 	movabs $0x80042186cb,%rdi
  8004215878:	00 00 00 
  800421587b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215880:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004215887:	00 00 00 
  800421588a:	41 ff d0             	callq  *%r8
  800421588d:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004215894:	00 00 00 
  8004215897:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421589b:	48 01 d0             	add    %rdx,%rax
  800421589e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	wrv[0] = 0;
  80042158a2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042158a6:	66 c7 00 00 00       	movw   $0x0,(%rax)
	wrv[1] = addr >> 4;
  80042158ab:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042158af:	48 8d 50 02          	lea    0x2(%rax),%rdx
  80042158b3:	8b 45 c8             	mov    -0x38(%rbp),%eax
  80042158b6:	c1 e8 04             	shr    $0x4,%eax
  80042158b9:	66 89 02             	mov    %ax,(%rdx)

	// "Universal startup algorithm."
	// Send INIT (level-triggered) interrupt to reset other CPU.
	lapicw(ICRHI, apicid << 24);
  80042158bc:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  80042158c0:	c1 e0 18             	shl    $0x18,%eax
  80042158c3:	89 c6                	mov    %eax,%esi
  80042158c5:	bf c4 00 00 00       	mov    $0xc4,%edi
  80042158ca:	48 b8 54 55 21 04 80 	movabs $0x8004215554,%rax
  80042158d1:	00 00 00 
  80042158d4:	ff d0                	callq  *%rax
	lapicw(ICRLO, INIT | LEVEL | ASSERT);
  80042158d6:	be 00 c5 00 00       	mov    $0xc500,%esi
  80042158db:	bf c0 00 00 00       	mov    $0xc0,%edi
  80042158e0:	48 b8 54 55 21 04 80 	movabs $0x8004215554,%rax
  80042158e7:	00 00 00 
  80042158ea:	ff d0                	callq  *%rax
	microdelay(200);
  80042158ec:	bf c8 00 00 00       	mov    $0xc8,%edi
  80042158f1:	48 b8 f0 57 21 04 80 	movabs $0x80042157f0,%rax
  80042158f8:	00 00 00 
  80042158fb:	ff d0                	callq  *%rax
	lapicw(ICRLO, INIT | LEVEL);
  80042158fd:	be 00 85 00 00       	mov    $0x8500,%esi
  8004215902:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004215907:	48 b8 54 55 21 04 80 	movabs $0x8004215554,%rax
  800421590e:	00 00 00 
  8004215911:	ff d0                	callq  *%rax
	microdelay(100);    // should be 10ms, but too slow in Bochs!
  8004215913:	bf 64 00 00 00       	mov    $0x64,%edi
  8004215918:	48 b8 f0 57 21 04 80 	movabs $0x80042157f0,%rax
  800421591f:	00 00 00 
  8004215922:	ff d0                	callq  *%rax
	// Send startup IPI (twice!) to enter code.
	// Regular hardware is supposed to only accept a STARTUP
	// when it is in the halted state due to an INIT.  So the second
	// should be ignored, but it is part of the official Intel algorithm.
	// Bochs complains about the second one.  Too bad for Bochs.
	for (i = 0; i < 2; i++) {
  8004215924:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800421592b:	eb 4b                	jmp    8004215978 <lapic_startap+0x17b>
		lapicw(ICRHI, apicid << 24);
  800421592d:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004215931:	c1 e0 18             	shl    $0x18,%eax
  8004215934:	89 c6                	mov    %eax,%esi
  8004215936:	bf c4 00 00 00       	mov    $0xc4,%edi
  800421593b:	48 b8 54 55 21 04 80 	movabs $0x8004215554,%rax
  8004215942:	00 00 00 
  8004215945:	ff d0                	callq  *%rax
		lapicw(ICRLO, STARTUP | (addr >> 12));
  8004215947:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800421594a:	c1 e8 0c             	shr    $0xc,%eax
  800421594d:	80 cc 06             	or     $0x6,%ah
  8004215950:	89 c6                	mov    %eax,%esi
  8004215952:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004215957:	48 b8 54 55 21 04 80 	movabs $0x8004215554,%rax
  800421595e:	00 00 00 
  8004215961:	ff d0                	callq  *%rax
		microdelay(200);
  8004215963:	bf c8 00 00 00       	mov    $0xc8,%edi
  8004215968:	48 b8 f0 57 21 04 80 	movabs $0x80042157f0,%rax
  800421596f:	00 00 00 
  8004215972:	ff d0                	callq  *%rax
	// Send startup IPI (twice!) to enter code.
	// Regular hardware is supposed to only accept a STARTUP
	// when it is in the halted state due to an INIT.  So the second
	// should be ignored, but it is part of the official Intel algorithm.
	// Bochs complains about the second one.  Too bad for Bochs.
	for (i = 0; i < 2; i++) {
  8004215974:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004215978:	83 7d fc 01          	cmpl   $0x1,-0x4(%rbp)
  800421597c:	7e af                	jle    800421592d <lapic_startap+0x130>
		lapicw(ICRHI, apicid << 24);
		lapicw(ICRLO, STARTUP | (addr >> 12));
		microdelay(200);
	}
}
  800421597e:	c9                   	leaveq 
  800421597f:	c3                   	retq   

0000008004215980 <lapic_ipi>:

void
lapic_ipi(int vector)
{
  8004215980:	55                   	push   %rbp
  8004215981:	48 89 e5             	mov    %rsp,%rbp
  8004215984:	48 83 ec 08          	sub    $0x8,%rsp
  8004215988:	89 7d fc             	mov    %edi,-0x4(%rbp)
	lapicw(ICRLO, OTHERS | FIXED | vector);
  800421598b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421598e:	0d 00 00 0c 00       	or     $0xc0000,%eax
  8004215993:	89 c6                	mov    %eax,%esi
  8004215995:	bf c0 00 00 00       	mov    $0xc0,%edi
  800421599a:	48 b8 54 55 21 04 80 	movabs $0x8004215554,%rax
  80042159a1:	00 00 00 
  80042159a4:	ff d0                	callq  *%rax
	while (lapic[ICRLO] & DELIVS)
  80042159a6:	90                   	nop
  80042159a7:	48 b8 08 90 51 04 80 	movabs $0x8004519008,%rax
  80042159ae:	00 00 00 
  80042159b1:	48 8b 00             	mov    (%rax),%rax
  80042159b4:	48 05 00 03 00 00    	add    $0x300,%rax
  80042159ba:	8b 00                	mov    (%rax),%eax
  80042159bc:	25 00 10 00 00       	and    $0x1000,%eax
  80042159c1:	85 c0                	test   %eax,%eax
  80042159c3:	75 e2                	jne    80042159a7 <lapic_ipi+0x27>
		;
}
  80042159c5:	c9                   	leaveq 
  80042159c6:	c3                   	retq   

00000080042159c7 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  80042159c7:	55                   	push   %rbp
  80042159c8:	48 89 e5             	mov    %rsp,%rbp
  80042159cb:	48 83 ec 1c          	sub    $0x1c,%rsp
  80042159cf:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042159d3:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  80042159d6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042159da:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042159dd:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042159e1:	f0 87 02             	lock xchg %eax,(%rdx)
  80042159e4:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  80042159e7:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80042159ea:	c9                   	leaveq 
  80042159eb:	c3                   	retq   

00000080042159ec <get_caller_pcs>:

#ifdef DEBUG_SPINLOCK
// Record the current call stack in pcs[] by following the %ebp chain.
static void
get_caller_pcs(uint64_t pcs[])
{
  80042159ec:	55                   	push   %rbp
  80042159ed:	48 89 e5             	mov    %rsp,%rbp
  80042159f0:	48 83 ec 28          	sub    $0x28,%rsp
  80042159f4:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)

static __inline uint64_t
read_rbp(void)
{
        uint64_t rbp;
        __asm __volatile("movq %%rbp,%0" : "=r" (rbp)::"cc","memory");
  80042159f8:	48 89 e8             	mov    %rbp,%rax
  80042159fb:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        return rbp;
  80042159ff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
	uint64_t *rbp;
	int i;

	rbp = (uint64_t *)read_rbp();
  8004215a03:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for (i = 0; i < 10; i++){
  8004215a07:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004215a0e:	eb 45                	jmp    8004215a55 <get_caller_pcs+0x69>
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
  8004215a10:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004215a15:	74 44                	je     8004215a5b <get_caller_pcs+0x6f>
  8004215a17:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004215a1e:	00 00 00 
  8004215a21:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004215a25:	76 34                	jbe    8004215a5b <get_caller_pcs+0x6f>
			break;
		pcs[i] = rbp[1];          // saved %rip
  8004215a27:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215a2a:	48 98                	cltq   
  8004215a2c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004215a33:	00 
  8004215a34:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215a38:	48 01 c2             	add    %rax,%rdx
  8004215a3b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215a3f:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004215a43:	48 89 02             	mov    %rax,(%rdx)
		rbp = (uint64_t *)rbp[0]; // saved %rbp
  8004215a46:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215a4a:	48 8b 00             	mov    (%rax),%rax
  8004215a4d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
{
	uint64_t *rbp;
	int i;

	rbp = (uint64_t *)read_rbp();
	for (i = 0; i < 10; i++){
  8004215a51:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004215a55:	83 7d f4 09          	cmpl   $0x9,-0xc(%rbp)
  8004215a59:	7e b5                	jle    8004215a10 <get_caller_pcs+0x24>
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
			break;
		pcs[i] = rbp[1];          // saved %rip
		rbp = (uint64_t *)rbp[0]; // saved %rbp
	}
	for (; i < 10; i++)
  8004215a5b:	eb 1f                	jmp    8004215a7c <get_caller_pcs+0x90>
		pcs[i] = 0;
  8004215a5d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215a60:	48 98                	cltq   
  8004215a62:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004215a69:	00 
  8004215a6a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215a6e:	48 01 d0             	add    %rdx,%rax
  8004215a71:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
			break;
		pcs[i] = rbp[1];          // saved %rip
		rbp = (uint64_t *)rbp[0]; // saved %rbp
	}
	for (; i < 10; i++)
  8004215a78:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004215a7c:	83 7d f4 09          	cmpl   $0x9,-0xc(%rbp)
  8004215a80:	7e db                	jle    8004215a5d <get_caller_pcs+0x71>
		pcs[i] = 0;
}
  8004215a82:	c9                   	leaveq 
  8004215a83:	c3                   	retq   

0000008004215a84 <holding>:

// Check whether this CPU is holding the lock.
static int
holding(struct spinlock *lock)
{
  8004215a84:	55                   	push   %rbp
  8004215a85:	48 89 e5             	mov    %rsp,%rbp
  8004215a88:	53                   	push   %rbx
  8004215a89:	48 83 ec 18          	sub    $0x18,%rsp
  8004215a8d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return lock->locked && lock->cpu == thiscpu;
  8004215a91:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215a95:	8b 00                	mov    (%rax),%eax
  8004215a97:	85 c0                	test   %eax,%eax
  8004215a99:	74 3d                	je     8004215ad8 <holding+0x54>
  8004215a9b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215a9f:	48 8b 58 10          	mov    0x10(%rax),%rbx
  8004215aa3:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  8004215aaa:	00 00 00 
  8004215aad:	ff d0                	callq  *%rax
  8004215aaf:	48 98                	cltq   
  8004215ab1:	48 c1 e0 03          	shl    $0x3,%rax
  8004215ab5:	48 89 c2             	mov    %rax,%rdx
  8004215ab8:	48 c1 e2 04          	shl    $0x4,%rdx
  8004215abc:	48 29 c2             	sub    %rax,%rdx
  8004215abf:	48 b8 20 80 49 04 80 	movabs $0x8004498020,%rax
  8004215ac6:	00 00 00 
  8004215ac9:	48 01 d0             	add    %rdx,%rax
  8004215acc:	48 39 c3             	cmp    %rax,%rbx
  8004215acf:	75 07                	jne    8004215ad8 <holding+0x54>
  8004215ad1:	b8 01 00 00 00       	mov    $0x1,%eax
  8004215ad6:	eb 05                	jmp    8004215add <holding+0x59>
  8004215ad8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004215add:	48 83 c4 18          	add    $0x18,%rsp
  8004215ae1:	5b                   	pop    %rbx
  8004215ae2:	5d                   	pop    %rbp
  8004215ae3:	c3                   	retq   

0000008004215ae4 <__spin_initlock>:
#endif

void
__spin_initlock(struct spinlock *lk, char *name)
{
  8004215ae4:	55                   	push   %rbp
  8004215ae5:	48 89 e5             	mov    %rsp,%rbp
  8004215ae8:	48 83 ec 10          	sub    $0x10,%rsp
  8004215aec:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004215af0:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	lk->locked = 0;
  8004215af4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215af8:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
#ifdef DEBUG_SPINLOCK
	lk->name = name;
  8004215afe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215b02:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004215b06:	48 89 50 08          	mov    %rdx,0x8(%rax)
	lk->cpu = 0;
  8004215b0a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215b0e:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  8004215b15:	00 
#endif
}
  8004215b16:	c9                   	leaveq 
  8004215b17:	c3                   	retq   

0000008004215b18 <spin_lock>:
// Loops (spins) until the lock is acquired.
// Holding a lock for a long time may cause
// other CPUs to waste time spinning to acquire it.
void
spin_lock(struct spinlock *lk)
{
  8004215b18:	55                   	push   %rbp
  8004215b19:	48 89 e5             	mov    %rsp,%rbp
  8004215b1c:	53                   	push   %rbx
  8004215b1d:	48 83 ec 18          	sub    $0x18,%rsp
  8004215b21:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
#ifdef DEBUG_SPINLOCK
	if (holding(lk))
  8004215b25:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215b29:	48 89 c7             	mov    %rax,%rdi
  8004215b2c:	48 b8 84 5a 21 04 80 	movabs $0x8004215a84,%rax
  8004215b33:	00 00 00 
  8004215b36:	ff d0                	callq  *%rax
  8004215b38:	85 c0                	test   %eax,%eax
  8004215b3a:	74 44                	je     8004215b80 <spin_lock+0x68>
		panic("CPU %d cannot acquire %s: already holding", cpunum(), lk->name);
  8004215b3c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215b40:	48 8b 58 08          	mov    0x8(%rax),%rbx
  8004215b44:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  8004215b4b:	00 00 00 
  8004215b4e:	ff d0                	callq  *%rax
  8004215b50:	49 89 d8             	mov    %rbx,%r8
  8004215b53:	89 c1                	mov    %eax,%ecx
  8004215b55:	48 ba e8 86 21 04 80 	movabs $0x80042186e8,%rdx
  8004215b5c:	00 00 00 
  8004215b5f:	be 41 00 00 00       	mov    $0x41,%esi
  8004215b64:	48 bf 12 87 21 04 80 	movabs $0x8004218712,%rdi
  8004215b6b:	00 00 00 
  8004215b6e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215b73:	49 b9 ae 04 20 04 80 	movabs $0x80042004ae,%r9
  8004215b7a:	00 00 00 
  8004215b7d:	41 ff d1             	callq  *%r9
#endif

	// The xchg is atomic.
	// It also serializes, so that reads after acquire are not
	// reordered before it. 
	while (xchg(&lk->locked, 1) != 0)
  8004215b80:	eb 02                	jmp    8004215b84 <spin_lock+0x6c>
		asm volatile ("pause");
  8004215b82:	f3 90                	pause  
#endif

	// The xchg is atomic.
	// It also serializes, so that reads after acquire are not
	// reordered before it. 
	while (xchg(&lk->locked, 1) != 0)
  8004215b84:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215b88:	be 01 00 00 00       	mov    $0x1,%esi
  8004215b8d:	48 89 c7             	mov    %rax,%rdi
  8004215b90:	48 b8 c7 59 21 04 80 	movabs $0x80042159c7,%rax
  8004215b97:	00 00 00 
  8004215b9a:	ff d0                	callq  *%rax
  8004215b9c:	85 c0                	test   %eax,%eax
  8004215b9e:	75 e2                	jne    8004215b82 <spin_lock+0x6a>
		asm volatile ("pause");

	// Record info about lock acquisition for debugging.
#ifdef DEBUG_SPINLOCK
	lk->cpu = thiscpu;
  8004215ba0:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  8004215ba7:	00 00 00 
  8004215baa:	ff d0                	callq  *%rax
  8004215bac:	48 98                	cltq   
  8004215bae:	48 c1 e0 03          	shl    $0x3,%rax
  8004215bb2:	48 89 c2             	mov    %rax,%rdx
  8004215bb5:	48 c1 e2 04          	shl    $0x4,%rdx
  8004215bb9:	48 29 c2             	sub    %rax,%rdx
  8004215bbc:	48 b8 20 80 49 04 80 	movabs $0x8004498020,%rax
  8004215bc3:	00 00 00 
  8004215bc6:	48 01 c2             	add    %rax,%rdx
  8004215bc9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215bcd:	48 89 50 10          	mov    %rdx,0x10(%rax)
	get_caller_pcs(lk->pcs);
  8004215bd1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215bd5:	48 83 c0 18          	add    $0x18,%rax
  8004215bd9:	48 89 c7             	mov    %rax,%rdi
  8004215bdc:	48 b8 ec 59 21 04 80 	movabs $0x80042159ec,%rax
  8004215be3:	00 00 00 
  8004215be6:	ff d0                	callq  *%rax
#endif
}
  8004215be8:	48 83 c4 18          	add    $0x18,%rsp
  8004215bec:	5b                   	pop    %rbx
  8004215bed:	5d                   	pop    %rbp
  8004215bee:	c3                   	retq   

0000008004215bef <spin_unlock>:

// Release the lock.
void
spin_unlock(struct spinlock *lk)
{
  8004215bef:	55                   	push   %rbp
  8004215bf0:	48 89 e5             	mov    %rsp,%rbp
  8004215bf3:	41 54                	push   %r12
  8004215bf5:	53                   	push   %rbx
  8004215bf6:	48 81 ec 20 05 00 00 	sub    $0x520,%rsp
  8004215bfd:	48 89 bd d8 fa ff ff 	mov    %rdi,-0x528(%rbp)
#ifdef DEBUG_SPINLOCK
	if (!holding(lk)) {
  8004215c04:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004215c0b:	48 89 c7             	mov    %rax,%rdi
  8004215c0e:	48 b8 84 5a 21 04 80 	movabs $0x8004215a84,%rax
  8004215c15:	00 00 00 
  8004215c18:	ff d0                	callq  *%rax
  8004215c1a:	85 c0                	test   %eax,%eax
  8004215c1c:	0f 85 d2 01 00 00    	jne    8004215df4 <spin_unlock+0x205>
		int i;
		uint32_t pcs[10];
		// Nab the acquiring EIP chain before it gets released
		memmove(pcs, lk->pcs, sizeof pcs);
  8004215c22:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004215c29:	48 8d 48 18          	lea    0x18(%rax),%rcx
  8004215c2d:	48 8d 85 e0 fa ff ff 	lea    -0x520(%rbp),%rax
  8004215c34:	ba 28 00 00 00       	mov    $0x28,%edx
  8004215c39:	48 89 ce             	mov    %rcx,%rsi
  8004215c3c:	48 89 c7             	mov    %rax,%rdi
  8004215c3f:	48 b8 66 e9 20 04 80 	movabs $0x800420e966,%rax
  8004215c46:	00 00 00 
  8004215c49:	ff d0                	callq  *%rax
		if (!lk->cpu) 
  8004215c4b:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004215c52:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004215c56:	48 85 c0             	test   %rax,%rax
  8004215c59:	75 39                	jne    8004215c94 <spin_unlock+0xa5>
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
  8004215c5b:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004215c62:	48 8b 58 08          	mov    0x8(%rax),%rbx
  8004215c66:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  8004215c6d:	00 00 00 
  8004215c70:	ff d0                	callq  *%rax
  8004215c72:	48 89 da             	mov    %rbx,%rdx
  8004215c75:	89 c6                	mov    %eax,%esi
  8004215c77:	48 bf 28 87 21 04 80 	movabs $0x8004218728,%rdi
  8004215c7e:	00 00 00 
  8004215c81:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215c86:	48 b9 7a 8a 20 04 80 	movabs $0x8004208a7a,%rcx
  8004215c8d:	00 00 00 
  8004215c90:	ff d1                	callq  *%rcx
  8004215c92:	eb 4d                	jmp    8004215ce1 <spin_unlock+0xf2>
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
  8004215c94:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004215c9b:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004215c9f:	0f b6 00             	movzbl (%rax),%eax
		memmove(pcs, lk->pcs, sizeof pcs);
		if (!lk->cpu) 
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
  8004215ca2:	44 0f b6 e0          	movzbl %al,%r12d
  8004215ca6:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004215cad:	48 8b 58 08          	mov    0x8(%rax),%rbx
  8004215cb1:	48 b8 8d 57 21 04 80 	movabs $0x800421578d,%rax
  8004215cb8:	00 00 00 
  8004215cbb:	ff d0                	callq  *%rax
  8004215cbd:	44 89 e1             	mov    %r12d,%ecx
  8004215cc0:	48 89 da             	mov    %rbx,%rdx
  8004215cc3:	89 c6                	mov    %eax,%esi
  8004215cc5:	48 bf 68 87 21 04 80 	movabs $0x8004218768,%rdi
  8004215ccc:	00 00 00 
  8004215ccf:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215cd4:	49 b8 7a 8a 20 04 80 	movabs $0x8004208a7a,%r8
  8004215cdb:	00 00 00 
  8004215cde:	41 ff d0             	callq  *%r8
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
  8004215ce1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004215ce8:	e9 c3 00 00 00       	jmpq   8004215db0 <spin_unlock+0x1c1>
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
  8004215ced:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004215cf0:	48 98                	cltq   
  8004215cf2:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  8004215cf9:	89 c0                	mov    %eax,%eax
  8004215cfb:	48 8d 95 10 fb ff ff 	lea    -0x4f0(%rbp),%rdx
  8004215d02:	48 89 d6             	mov    %rdx,%rsi
  8004215d05:	48 89 c7             	mov    %rax,%rdi
  8004215d08:	48 b8 50 d3 20 04 80 	movabs $0x800420d350,%rax
  8004215d0f:	00 00 00 
  8004215d12:	ff d0                	callq  *%rax
  8004215d14:	85 c0                	test   %eax,%eax
  8004215d16:	78 6b                	js     8004215d83 <spin_unlock+0x194>
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
  8004215d18:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004215d1b:	48 98                	cltq   
  8004215d1d:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
  8004215d24:	89 c2                	mov    %eax,%edx
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
  8004215d26:	48 8b 85 30 fb ff ff 	mov    -0x4d0(%rbp),%rax
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
  8004215d2d:	48 29 c2             	sub    %rax,%rdx
  8004215d30:	49 89 d0             	mov    %rdx,%r8
  8004215d33:	48 8b bd 20 fb ff ff 	mov    -0x4e0(%rbp),%rdi
  8004215d3a:	8b b5 28 fb ff ff    	mov    -0x4d8(%rbp),%esi
  8004215d40:	8b 8d 18 fb ff ff    	mov    -0x4e8(%rbp),%ecx
  8004215d46:	48 8b 95 10 fb ff ff 	mov    -0x4f0(%rbp),%rdx
  8004215d4d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004215d50:	48 98                	cltq   
  8004215d52:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  8004215d59:	4c 89 04 24          	mov    %r8,(%rsp)
  8004215d5d:	49 89 f9             	mov    %rdi,%r9
  8004215d60:	41 89 f0             	mov    %esi,%r8d
  8004215d63:	89 c6                	mov    %eax,%esi
  8004215d65:	48 bf 9e 87 21 04 80 	movabs $0x800421879e,%rdi
  8004215d6c:	00 00 00 
  8004215d6f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215d74:	49 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%r10
  8004215d7b:	00 00 00 
  8004215d7e:	41 ff d2             	callq  *%r10
  8004215d81:	eb 29                	jmp    8004215dac <spin_unlock+0x1bd>
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
			else
				cprintf("  %08x\n", pcs[i]);
  8004215d83:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004215d86:	48 98                	cltq   
  8004215d88:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  8004215d8f:	89 c6                	mov    %eax,%esi
  8004215d91:	48 bf b5 87 21 04 80 	movabs $0x80042187b5,%rdi
  8004215d98:	00 00 00 
  8004215d9b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215da0:	48 ba 7a 8a 20 04 80 	movabs $0x8004208a7a,%rdx
  8004215da7:	00 00 00 
  8004215daa:	ff d2                	callq  *%rdx
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
  8004215dac:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004215db0:	83 7d ec 09          	cmpl   $0x9,-0x14(%rbp)
  8004215db4:	7f 14                	jg     8004215dca <spin_unlock+0x1db>
  8004215db6:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004215db9:	48 98                	cltq   
  8004215dbb:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  8004215dc2:	85 c0                	test   %eax,%eax
  8004215dc4:	0f 85 23 ff ff ff    	jne    8004215ced <spin_unlock+0xfe>
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
			else
				cprintf("  %08x\n", pcs[i]);
		}
		panic("spin_unlock");
  8004215dca:	48 ba bd 87 21 04 80 	movabs $0x80042187bd,%rdx
  8004215dd1:	00 00 00 
  8004215dd4:	be 6b 00 00 00       	mov    $0x6b,%esi
  8004215dd9:	48 bf 12 87 21 04 80 	movabs $0x8004218712,%rdi
  8004215de0:	00 00 00 
  8004215de3:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215de8:	48 b9 ae 04 20 04 80 	movabs $0x80042004ae,%rcx
  8004215def:	00 00 00 
  8004215df2:	ff d1                	callq  *%rcx
	}

	lk->pcs[0] = 0;
  8004215df4:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004215dfb:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  8004215e02:	00 
	lk->cpu = 0;
  8004215e03:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004215e0a:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  8004215e11:	00 
	// But the 2007 Intel 64 Architecture Memory Ordering White
	// Paper says that Intel 64 and IA-32 will not move a load
	// after a store. So lock->locked = 0 would work here.
	// The xchg being asm volatile ensures gcc emits it after
	// the above assignments (and after the critical section).
	xchg(&lk->locked, 0);
  8004215e12:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004215e19:	be 00 00 00 00       	mov    $0x0,%esi
  8004215e1e:	48 89 c7             	mov    %rax,%rdi
  8004215e21:	48 b8 c7 59 21 04 80 	movabs $0x80042159c7,%rax
  8004215e28:	00 00 00 
  8004215e2b:	ff d0                	callq  *%rax
}
  8004215e2d:	48 81 c4 20 05 00 00 	add    $0x520,%rsp
  8004215e34:	5b                   	pop    %rbx
  8004215e35:	41 5c                	pop    %r12
  8004215e37:	5d                   	pop    %rbp
  8004215e38:	c3                   	retq   
